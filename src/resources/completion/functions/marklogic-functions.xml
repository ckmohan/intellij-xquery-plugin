<functions base="http://developer.marklogic.com:8040/5.0doc/">
	<function name="get-database-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:get-database-ids">
		<summary>This function returns all the database IDs from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:get-database-ids($config)
  (: returns the IDs of all the databases :)

</example>
	</function>
	<function name="get-host-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:get-host-ids">
		<summary>This function returns all the host IDs from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:get-host-ids($config)
  (: returns the IDs of all the hosts :)

</example>
	</function>
	<function name="get-group-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:get-group-ids">
		<summary>This function returns all the group IDs from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:get-group-ids($config)
  (: returns the IDs of all the groups :)

</example>
	</function>
	<function name="get-forest-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:get-forest-ids">
		<summary>This function returns all the forest IDs from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:get-forest-ids($config)
  (: returns the IDs of all the forests :)

</example>
	</function>
	<function name="get-appserver-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:get-appserver-ids">
		<summary>This function returns all the appserver IDs from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:get-appserver-ids($config)
  (: returns the IDs of all the appservers :)

</example>
	</function>
	<function name="get-configuration" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="actions" hidden="false" fullname="admin:get-configuration">
		<summary>Loads the admin configuration into memory for use by other functions in the Admin module.</summary>
		<return>element(configuration)</return>
		<usage>The configuration is loaded into memory only as it is needed, so it might not contain the entire configuration at any given moment. It loads only the parts of the configuration that are needed at the time they are needed to perform other Admin module operations that specified in the XQuery request. Therefore, if you execute the function without calling any other Admin module functions, it will return the empty sequence (because it never needed any of the config information to perform any of the Admin module operations).</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/admin-module-read</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

   let $config := admin:get-configuration()
   return
   admin:database-get-range-element-indexes($config,
                           xdmp:database("Documents") )

  =&gt; The xml for any element range indexes in the "Documents"
     database, for example:
   &lt;range-element-index xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	                xmlns="http://marklogic.com/xdmp/database"&gt;
      &lt;scalar-type&gt;date&lt;/scalar-type&gt;
      &lt;collation/&gt;
      &lt;namespace-uri&gt;mynamespace&lt;/namespace-uri&gt;
      &lt;localname&gt;myelementname&lt;/localname&gt;
      &lt;range-value-positions&gt;false&lt;/range-value-positions&gt;
   &lt;/range-element-index&gt;

</example>
	</function>
	<function name="save-configuration-without-restart" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="actions" hidden="false" fullname="admin:save-configuration-without-restart">
		<summary>This function saves a configuration specification to the cluster configuration files, without restarting MarkLogic Server. If you use this function to save any changes that require a server restart ("cold" changes such as App Server port assignment changes), then the changes will not take effect until the next time MarkLogic Server restarts (although they will be saved in the configuration). If you want MarkLogic Server to automatically restart when needed, use
			<code>admin:save-configuration</code>instead.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<usage>The return value is a list of the host IDs that need to be restarted in order for the changes to take effect.</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/admin-module-write</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $spec := admin:forest-set-enabled($config,
    xdmp:forest("myForest"), fn:true() )
  return
  admin:save-configuration-without-restart($spec)

</example>
	</function>
	<function name="save-configuration" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="actions" hidden="false" fullname="admin:save-configuration">
		<summary>This function saves a configuration specification to the cluster configuration files. It restarts MarkLogic Server for "cold" administrative tasks only (for example, for App Server port assignment changes). If you do not want those "cold" administrative tasks to automatically restart MarkLogic Server, use
			<code>admin:save-configuration-without-restart</code>instead.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/admin-module-write</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $spec := admin:forest-set-enabled($config,
    xdmp:forest("myForest"), fn:true() )
  return
  admin:save-configuration($spec)

</example>
	</function>
	<function name="restart-hosts" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="actions" hidden="false" fullname="admin:restart-hosts">
		<summary>This function restarts MarkLogic Server for the specified hosts.</summary>
		<params>
			<param name="hosts" type="xs:unsignedLong*" optional="false">The host ID(s) for the host(s) you want to restart. For example,
				<code>xdmp:host()</code>returns the ID for the current host.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
(:
  This query restarts all hosts in the cluster.  Note that
  it will restart the host in which the query is run, too.
:)
xquery version "1.0-ml";

import module namespace admin = "http://marklogic.com/xdmp/admin"
at "/MarkLogic/admin.xqy";
declare namespace host="http://marklogic.com/xdmp/status/host";

let $hostids :=
   for $id in xdmp:host-status(xdmp:host())
                               /host:hosts//host:host/host:host-id
   return fn:data($id)
return
admin:restart-hosts($hostids)

</example>
	</function>
	<function name="database-delete" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete">
		<summary>This function deletes the configuration from the specified database(s). It does not delete the configuration or data for any forests attached to the deleted database(s).</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-ids" type="xs:unsignedLong*" optional="false">The id(s) for the specified database(s) (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any database whose ID you pass into this function must not have any appservers targeting it when the transaction begins, otherwise an exception is thrown. If you need to delete the database, make sure no appserver targets the database in a separate transaction before calling this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-delete($config, admin:database-get-id($config, "foo"))

  =&gt; The new configuration with the specified databases removed.
     Use admin:save-configuration to save these changes.

</example>
	</function>
	<function name="database-create" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-create">
		<summary>This function creates a new database specification.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-name" type="xs:string" optional="false">The name the database to create. The name must not be used by any other database in the cluster.</param>
			<param name="security-db" type="xs:unsignedLong" optional="false">The ID of the security database (for example,
				<code>xdmp:database("Security")</code>used by this database.</param>
			<param name="schema-db" type="xs:unsignedLong" optional="false">The ID of the schemas database (for example,
				<code>xdmp:database("Schemas")</code>used by this database.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-create($config, "myNewDatabase",
        xdmp:database("Security"), xdmp:database("Schemas"))

</example>
	</function>
	<function name="database-copy" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-copy">
		<summary>This function creates a new database specification with the same settings as the database with the specified ID. The new database configuration will have the specified name.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database to copy (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="database-name" type="xs:string" optional="false">The name of the new database to create.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-copy($config, xdmp:database("myOldDatabase"),
                    "myNewDatabase")

   =&gt; Creates a configuration with a new database specification
      having the same settings as the database named "myOldDatabase".

</example>
	</function>
	<function name="database-detach-forest" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-detach-forest">
		<summary>This function detaches the specified forest from the specified database.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
        at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-detach-forest($config, xdmp:database("myDatabase"),
      xdmp:forest("myForest") )

</example>
	</function>
	<function name="database-attach-forest" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-attach-forest">
		<summary>This function attaches the specified forest to the specified database.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any forest whose ID you pass into this function must exist when the transaction begins, otherwise an exception is thrown. If you need to create the forest, do so in a separate transaction before using them in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
        at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-attach-forest($config, xdmp:database("myDatabase"),
      xdmp:forest("myForest") )

</example>
	</function>
	<function name="database-get-backups" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-backups">
		<summary>This function returns the scheduled backups for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("mydatabase")</code>).</param>
		</params>
		<return>element(db:database-backup)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-backups($config, xdmp:database("mydatabase") )
  (: returns the scheduled backups for the database :)

</example>
	</function>
	<function name="database-weekly-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-weekly-backup">
		<summary>This function constructs a weekly scheduled backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory where the backup will be saved to.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The how many weeks between each backup.</param>
			<param name="days" type="xs:string+" optional="false">The day(s) of the week. Must be a sequence of zero or more of
				<code>monday</code>,
				<code>tuesday</code>,
				<code>wednesday</code>,
				<code>thusday</code>,
				<code>friday</code>,
				<code>saturday</code>,
				<code>sunday</code>.</param>
			<param name="start-time" type="xs:time" optional="false">A time for the scheduled backup to start.</param>
			<param name="max-backups" type="xs:unsignedLong" optional="false">The maximum number of backups to keep in the backup directory.</param>
			<param name="backup-security-db" type="xs:boolean" optional="false">Whether to backup the security database alongside the current backup.</param>
			<param name="backup-schemas-db" type="xs:boolean" optional="false">Whether to backup the schemas database alongside the current backup.</param>
			<param name="backup-triggers-db" type="xs:boolean" optional="false">Whether to backup the triggers database alongside the current backup.</param>
			<param name="include-replicas" type="xs:boolean" optional="true">If set to
				<code>false</code>, do not include the replicas in the backup. The default is
				<code>true</code>, which means to include all replicas in the backup.</param>
			<param name="journal-archiving" type="xs:boolean" optional="true">Whether or not to enable journal archiving. Defaults to
				<code>false</code>.</param>
			<param name="journal-archive-path" type="xs:string" optional="true">Path for where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 900.</param>
		</params>
		<return>element(db:database-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:database-weekly-backup("/backup-dir", 2, "monday",
        xs:time("09:45:00"),10,true(),true(),true())
  (: returns the weekly backup specification :)

</example>
    <example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:database-weekly-backup("/backup-dir", 2, "monday",
        xs:time("09:45:00"),10,true(),true(),true(),false(),true(),(),500)
  (: returns the weekly backup specification :)

</example>
	</function>
	<function name="database-monthly-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-monthly-backup">
		<summary>This function constructs a monthly scheduled backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory where the backup will be saved to.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The number of months to elapse between each backup.</param>
			<param name="backup-month-day" type="xs:unsignedLong" optional="false">The day of the month the backup will happen (between 1 and 31)</param>
			<param name="start-time" type="xs:time" optional="false">A time for the scheduled backup to start.</param>
			<param name="max-backups" type="xs:unsignedLong" optional="false">The maximum number of backups to keep in the backup directory.</param>
			<param name="backup-security-db" type="xs:boolean" optional="false">Whether to backup the security database alongside the current backup.</param>
			<param name="backup-schemas-db" type="xs:boolean" optional="false">Whether to backup the schemas database alongside the current backup.</param>
			<param name="backup-triggers-db" type="xs:boolean" optional="false">Whether to backup the triggers database alongside the current backup.</param>
			<param name="include-replicas" type="xs:boolean" optional="true">If set to
				<code>false</code>, do not include the replicas in the backup. The default is
				<code>true</code>, which means to include all replicas in the backup.</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether or not to enable journal archiving. Defaults to
				<code>false</code>.</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path for where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong?" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 900.</param>
		</params>
		<return>element(db:database-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:database-monthly-backup("/backup-dir", 2, 1,
        xs:time("09:45:00"),10,true(),true(),true())
  (: returns the monthly backup specification :)

</example>
    <example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:database-monthly-backup("/backup-dir", 2, 1,
        xs:time("09:45:00"),10,true(),true(),true(),false(),true(),(),500)
  (: returns the monthly  backup specification :)

</example>
	</function>
	<function name="database-one-time-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-one-time-backup">
		<summary>This function constructs a one-time backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory where the backup will be saved to.</param>
			<param name="start" type="xs:dateTime" optional="false">The starting dateTime of the scheduled backup.</param>
			<param name="max-backups" type="xs:unsignedLong" optional="false">The maximum number of backups to keep in the backup directory.</param>
			<param name="backup-security-db" type="xs:boolean" optional="false">Whether to backup the security database alongside the current backup.</param>
			<param name="backup-schemas-db" type="xs:boolean" optional="false">Whether to backup the schemas database alongside the current backup.</param>
			<param name="backup-triggers-db" type="xs:boolean" optional="false">Whether to backup the triggers database alongside the current backup.</param>
			<param name="include-replicas" type="xs:boolean" optional="true">If set to
				<code>false</code>, do not include the replicas in the backup. The default is
				<code>true</code>, which means to include all replicas in the backup.</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether or not to enable journal archiving. Defaults to
				<code>false</code>.</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path for where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong?" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 900.</param>
		</params>
		<return>element(db:database-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:database-one-time-backup("/backup-dir",
        xs:dateTime("2008-02-14T09:45:00"),10,true(),true(),true())
  (: returns the one-time backup :)

</example>
    <example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:database-one-time-backup("/backup-dir",
        xs:dateTime("2008-02-14T09:45:00"),10,true(),true(),true(),false(),true(),(),500)
  (: returns the one-time backup :)

</example>
	</function>
	<function name="database-add-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-backup">
		<summary>This function adds scheduled backup specifications for a database to a configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("mydatabase")</code>).</param>
			<param name="backups" type="element(db:database-backup)*" optional="false">The scheduled backup specification(s), typically the result of an
				<code>admin:database-one-time-backup</code>or an
				<code>admin:database-monthly-backup</code>or an
				<code>admin:database-weekly-backup</code>call</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $database := xdmp:database("mydatabase")
  let $backup := admin:database-one-time-backup("/backup-dir",
        xs:dateTime("2008-02-14T09:45:00"),10,true(),true(),true())
  return
  admin:database-add-backup($config, $database, $backup)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-backup">
		<summary>This function deletes scheduled backup specifications for a database from a configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("mydatabase")</code>).</param>
			<param name="backups" type="element(db:database-backup)*" optional="false">The scheduled backup(s) to delete. Typically, the result of an
				<code>admin:database-get-backups</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config  := admin:get-configuration()
  let $dbid  := xdmp:database("Documents")
  let $backups := admin:database-get-backups($config, $database)[1 to 3]
  return
  admin:database-delete-backup($config, $dbid, $backups)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-merge-blackouts" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-merge-blackouts">
		<summary>This function returns the merge blackouts specification for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:merge-blackout)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-merge-blackouts($config, xdmp:database("myDatabase") )
  (: returns the merge-blackouts specification for the database :)

</example>
	</function>
	<function name="database-recurring-merge-blackout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-recurring-merge-blackout">
		<summary>This function constructs a merge-blackout specification.</summary>
		<params>
			<param name="limit" type="xs:unsignedInt" optional="false">The maximum number of megabytes for a merge.</param>
			<param name="merge-priority" type="xs:string" optional="false">The CPU scheduler priority for merges. Must be one of
				<code>normal</code>or
				<code>lower</code>.</param>
			<param name="days" type="xs:string+" optional="false">The day(s) of the week. Must be a sequence of zero or more of
				<code>monday</code>,
				<code>tuesday</code>,
				<code>wednesday</code>,
				<code>thusday</code>,
				<code>friday</code>,
				<code>saturday</code>,
				<code>sunday</code>.</param>
			<param name="start-time" type="xs:time?" optional="false">A time for the merge blackout to start.</param>
			<param name="end-time" type="xs:time?" optional="false">A time for the merge blackout to end.</param>
			<param name="duration" type="xs:duration?" optional="false">The amount of time for the blackout to last.</param>
		</params>
		<return>element(db:merge-blackout)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-recurring-merge-blackout(500, "lower", "monday",
        xs:time("09:45:00"), xs:time("11:45:00"), () )
  (: returns the merge-blackout specification :)

</example>
	</function>
	<function name="database-one-time-merge-blackout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-one-time-merge-blackout">
		<summary>This function constructs a one-time merge-blackout specification.</summary>
		<params>
			<param name="limit" type="xs:unsignedInt" optional="false">The maximum number of megabytes for a merge.</param>
			<param name="merge-priority" type="xs:string" optional="false">The CPU scheduler priority for merges. Must be one of
				<code>normal</code>or
				<code>lower</code>.</param>
			<param name="start" type="xs:dateTime" optional="false">The starting dateTime of the merge blackout.</param>
			<param name="end" type="xs:dateTime?" optional="false">The ending dateTime of the merge blackout.</param>
			<param name="duration" type="xs:duration?" optional="false">The amount of time for the blackout to last.</param>
		</params>
		<return>element(db:merge-blackout)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-one-time-merge-blackout(500, "lower",
        xs:dateTime("2008-02-14T09:45:00"),
        (), xs:dayTimeDuration("PT3H") )
  (: returns the one-time merge-blackout specification :)

</example>
	</function>
	<function name="database-add-merge-blackout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-merge-blackout">
		<summary>This function adds a merge blackout specification for a database to a configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="merge-blackouts" type="element(db:merge-blackout)*" optional="false">The merge blackout specification(s), typically the result of an
				<code>admin:database-one-time-merge-blackout</code>or an
				<code>admin:database-recurring-merge-blackout</code>call</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $mergespec := admin:database-one-time-merge-blackout(500, "lower",
        xs:dateTime("2008-02-14T09:45:00"),
        (), xs:dayTimeDuration("PT3H") )
  return
  admin:database-add-merge-blackout($config, $dbid, $mergespec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-merge-blackout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-merge-blackout">
		<summary>This function deletes a merge blackout specification for a database from a configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="blackouts" type="element(db:merge-blackout)*" optional="false">The merge blackout(s) to delete. Typically, the result of an
				<code>admin:database-get-merge-blackouts</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $mergespec := admin:database-get-merge-blackouts($config,
        $dbid )
  return
  admin:database-delete-merge-blackout($config, $dbid, $mergespec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-fragment-roots" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fragment-roots">
		<summary>This function returns the fragment roots specification for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:fragment-root)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fragment-roots($config, xdmp:database("myDatabase") )
  (: returns the fragments root specifications for the database :)

</example>
	</function>
	<function name="database-fragment-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-fragment-root">
		<summary>This function constructs a fragment root specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI. Specify an empty string if the element is in no namespace.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
		</params>
		<return>element(db:fragment-root)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $namespace := "my/namespace"
  let $localname := "some-element-name"
  return
  admin:database-fragment-root($namespace, $localname )
  (: returns the fragments root specification :)

</example>
	</function>
	<function name="database-add-fragment-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-fragment-root">
		<summary>This function adds the specified fragment root to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="fragment-roots" type="element(db:fragment-root)*" optional="false">A fragment root specification, typically the result of an
				<code>admin:database-fragment-root</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $fragspec := admin:database-fragment-root("my/namespace", "element-name")
  return
  admin:database-add-fragment-root($config, $dbid, $fragspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-fragment-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-fragment-root">
		<summary>This function deletes the specified fragment root in the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="fragment-roots" type="element(db:fragment-root)*" optional="false">A fragment root specification, typically the result of an
				<code>admin:database-fragment-root</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $fragspec := admin:database-fragment-root("my/namespace", "element-name")
  return
  admin:database-delete-fragment-root($config, $dbid, $fragspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-fragment-parents" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fragment-parents">
		<summary>This function returns the fragment parents specification for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:fragment-parent)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fragment-parents($config, xdmp:database("myDatabase") )
  (: returns the fragments parent specifications for the database :)

</example>
	</function>
	<function name="database-fragment-parent" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-fragment-parent">
		<summary>This function constructs a fragment parent specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI. Specify an empty string if the element is in no namespace.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
		</params>
		<return>element(db:fragment-parent)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $namespace := "my/namespace"
  let $localname := "some-element-name"
  return
  admin:database-fragment-parent($namespace, $localname )
  (: returns the fragments parent specification :)

</example>
	</function>
	<function name="database-add-fragment-parent" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-fragment-parent">
		<summary>This function adds the specified fragment parent to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="fragment-parents" type="element(db:fragment-parent)*" optional="false">A fragment parent specification, typically the result of an
				<code>admin:database-fragment-parent</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $fragspec := admin:database-fragment-parent("my/namespace", "element-name")
  return
  admin:database-add-fragment-parent($config, $dbid, $fragspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-fragment-parent" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-fragment-parent">
		<summary>This function deletes the specified fragment parent in the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="fragment-parents" type="element(db:fragment-parent)*" optional="false">A fragment parent specification, typically the result of an
				<code>admin:database-fragment-parent</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $fragspec := admin:database-fragment-parent("my/namespace", "element-name")
  return
  admin:database-delete-fragment-parent($config, $dbid, $fragspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-range-element-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-range-element-index">
		<summary>This function constructs a range element index specification.</summary>
		<params>
			<param name="scalar-type" type="xs:string" optional="false">A valid type for the range index. Must be one of:
				<code>int</code>,
				<code>unsignedInt</code>,
				<code>long</code>,
				<code>unsignedLong</code>,
				<code>float</code>,
				<code>double</code>,
				<code>decimal</code>,
				<code>dateTime</code>,
				<code>time</code>,
				<code>date</code>,
				<code>gYearMonth</code>,
				<code>gYear</code>,
				<code>gMonth</code>,
				<code>gDay</code>,
				<code>yearMonthDuration</code>,
				<code>dayTimeDuration</code>,
				<code>string</code>,
				<code>anyURI</code>, or
				<code>point</code>.</param>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
			<param name="collation" type="xs:string" optional="false">The collation URI (for example,
				<code>http://marklogic.com/collation/</code>). The collation is only needed for string and anyURI indexes; for other indexes, specify the empty string ("") for this parameter.</param>
			<param name="range-value-positions" type="xs:boolean" optional="false">A boolean specifying whether to maintain value postions in this index (used with co-occurrences).</param>
		</params>
		<return>element(db:range-element-index)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-range-element-index("string", "/my/namespace",
                "elementname", "http://marklogic.com/collation/",
	       fn:false() )
  (: returns the range element index specification :)

</example>
	</function>
	<function name="database-range-field-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-range-field-index">
		<summary>This function constructs a range field index specification.</summary>
		<params>
			<param name="scalar-type" type="xs:string" optional="false">A valid type for the range index. Must be one of:
				<code>int</code>,
				<code>unsignedInt</code>,
				<code>long</code>,
				<code>unsignedLong</code>,
				<code>float</code>,
				<code>double</code>,
				<code>decimal</code>,
				<code>dateTime</code>,
				<code>time</code>,
				<code>date</code>,
				<code>gYearMonth</code>,
				<code>gYear</code>,
				<code>gMonth</code>,
				<code>gDay</code>,
				<code>yearMonthDuration</code>,
				<code>dayTimeDuration</code>,
				<code>string</code>,
				<code>anyURI</code>, or
				<code>point</code>.</param>
			<param name="fieldname" type="xs:string" optional="false">The name for the field.</param>
			<param name="collation" type="xs:string" optional="false">The collation URI (for example,
				<code>http://marklogic.com/collation/</code>). The collation is only needed for string and anyURI indexes; for other indexes, specify the empty string ("") for this parameter.</param>
			<param name="range-value-positions" type="xs:boolean" optional="false">A boolean specifying whether to maintain value postions in this index (used with co-occurrences).</param>
		</params>
		<return>element(db:range-field-index)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-range-field-index("string", "fieldname",
                "http://marklogic.com/collation/",
	       fn:false() )
  (: returns the range field index specification :)

</example>
	</function>
	<function name="database-get-range-element-indexes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-range-element-indexes">
		<summary>This function returns the range element indexes specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:range-element-index)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-range-element-indexes($config, xdmp:database("myDatabase") )
  (: returns the range index specifications for the database :)

</example>
	</function>
	<function name="database-get-range-field-indexes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-range-field-indexes">
		<summary>This function returns the range field indexes specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:range-field-index)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-range-field-indexes($config, xdmp:database("myDatabase") )
  (: returns the range field index specifications for the database :)

</example>
	</function>
	<function name="database-add-range-element-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-range-element-index">
		<summary>This function adds a range element index to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="range-indexes" type="element(db:range-element-index)*" optional="false">An element range index specification, typically the result of an
				<code>admin:database-range-element-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $rangespec := admin:database-range-element-index("string", "/my/namespace",
                "elementname", "http://marklogic.com/collation/",
	       fn:false() )
  return
  admin:database-add-range-element-index($config, $dbid, $rangespec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-add-range-field-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-range-field-index">
		<summary>This function adds a range field index to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="range-indexes" type="element(db:range-field-index)*" optional="false">An field range index specification, typically the result of an
				<code>admin:database-range-field-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $rangespec := admin:database-range-field-index("string",
                "fieldname", "http://marklogic.com/collation/",
	       fn:false() )
  return
  admin:database-add-range-field-index($config, $dbid, $rangespec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-range-element-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-range-element-index">
		<summary>This function deletes a range element index for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="range-indexes" type="element(db:range-element-index)*" optional="false">An element range index specification, typically the result of an
				<code>admin:database-range-element-index</code>call.</param>
		</params>
		<usage>Note that the index specification to delete must exist in the configuration exactly as specified, even if the specification includes multiple QNames. If you have a range index configuration that specifies multiple QNames in a single entry, then if you want to delete the index for only one of the QNames, you must first delete the range index specification with multiple QNames and then add the indexes that you do not want to delete. To see the specifications as they are stored in the configuration, use
			<code>admin:database-get-range-element-index</code>.</usage>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $rangespec := admin:database-range-element-index("string", "/my/namespace",
                "elementname", "http://marklogic.com/collation/",
	       fn:false() )
  return
  admin:database-delete-range-element-index($config, $dbid, $rangespec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-range-field-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-range-field-index">
		<summary>This function deletes a range field index for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="range-indexes" type="element(db:range-field-index)*" optional="false">A field range index specification, typically the result of an
				<code>admin:database-range-field-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $rangespec := admin:database-range-field-index("string",
                "fieldname", "http://marklogic.com/collation/",
	       fn:false() )
  return
  admin:database-delete-range-field-index($config, $dbid, $rangespec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-range-element-attribute-indexes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-range-element-attribute-indexes">
		<summary>This function returns the range element attribute indexes specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:range-element-attribute-index)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-range-element-attribute-indexes($config,
        xdmp:database("myDatabase") )
  (: returns the range element attribute index specifications for the database :)

</example>
	</function>
	<function name="database-range-element-attribute-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-range-element-attribute-index">
		<summary>This function constructs a range element attribute index specification.</summary>
		<params>
			<param name="scalar-type" type="xs:string" optional="false">A valid type for the range index. Must be one of:
				<code>int</code>,
				<code>unsignedInt</code>,
				<code>long</code>,
				<code>unsignedLong</code>,
				<code>float</code>,
				<code>double</code>,
				<code>decimal</code>,
				<code>dateTime</code>,
				<code>time</code>,
				<code>date</code>,
				<code>gYearMonth</code>,
				<code>gYear</code>,
				<code>gMonth</code>,
				<code>gDay</code>,
				<code>yearMonthDuration</code>,
				<code>dayTimeDuration</code>,
				<code>string</code>,
				<code>anyURI</code>, or
				<code>point</code>.</param>
			<param name="parent-namespace" type="xs:string?" optional="false">The namespace of the parent element for the attribute.</param>
			<param name="parent-localname" type="xs:string" optional="false">The local name of the parent element for the attribute.</param>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
			<param name="collation" type="xs:string" optional="false">The collation URI (for example,
				<code>http://marklogic.com/collation/</code>. The collation is only needed for string and anyURI indexes; for other indexes, specify the empty string ("") for this parameter.</param>
			<param name="range-value-positions" type="xs:boolean" optional="false">A boolean specifying whether to maintain value postions in this index (used with co-occurrences).</param>
		</params>
		<return>element(db:range-element-attribute-index)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-range-element-attribute-index("string", "/my/namespace",
        "elementname", "", "myAtribute", "http://marklogic.com/collation/",
	fn:false() )
  (: returns the range element attribute-index specification :)

</example>
	</function>
	<function name="database-add-range-element-attribute-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-range-element-attribute-index">
		<summary>This function adds a range element attribute index to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="attribute-indexes" type="element(db:range-element-attribute-index)*" optional="false">An element attribute range index specification, typically the result of an
				<code>admin:database-range-element-attribute-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $rangespec := admin:database-range-element-attribute-index("string",
       "/my/namespace", "elementname", "", "myAttribute",
       "http://marklogic.com/collation/", fn:false() )
  return
  admin:database-add-range-element-attribute-index($config, $dbid, $rangespec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-range-element-attribute-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-range-element-attribute-index">
		<summary>This function deletes a range element attribute index for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="attribute-indexes" type="element(db:range-element-attribute-index)*" optional="false">An element attribute range index specification, typically the result of an
				<code>admin:database-range-element-attribute-index</code>call.</param>
		</params>
		<usage>Note that the index specification to delete must exist in the configuration exactly as specified, even if the specification includes multiple QNames. If you have a range index configuration that specifies multiple QNames in a single entry, then if you want to delete the index for only one of the QNames, you must first delete the range index specification with multiple QNames and then add the indexes that you do not want to delete. To see the specifications as they are stored in the configuration, use
			<code>admin:database-get-range-element-attribute-index</code>.</usage>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $rangespec := admin:database-range-element-attribute-index("string",
      "/my/namespace", "elementname", "", "myAttribute",
      "http://marklogic.com/collation/", fn:false() )
  return
  admin:database-delete-range-element-attribute-index($config, $dbid, $rangespec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-element-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-element-word-lexicon">
		<summary>This function constructs an element word lexicon specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
			<param name="collation" type="xs:string" optional="false">The collation URI (for example,
				<code>http://marklogic.com/collation/</code>).</param>
		</params>
		<return>element(db:element-word-lexicon)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-element-word-lexicon("my/namepsace", "elementname",
	"http://marklogic.com/collation/" )
  (: returns the element word lexicon specification :)

</example>
	</function>
	<function name="database-get-element-word-lexicons" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-element-word-lexicons">
		<summary>This function returns the element word lexicons specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:element-word-lexicon)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-element-word-lexicons($config, xdmp:database("myDatabase") )
  (: returns the element word lexicon specifications for the database :)

</example>
	</function>
	<function name="database-add-element-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-element-word-lexicon">
		<summary>This function adds an element word lexicon to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="element-word-lexicons" type="element(db:element-word-lexicon)*" optional="false">An element word lexicon specification, typically the result of an
				<code>admin:database-element-word-lexicon</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $lexspec := admin:database-element-word-lexicon("my/namepsace",
     "elementname", "http://marklogic.com/collation/" )
  return
  admin:database-add-element-word-lexicon($config, $dbid, $lexspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-element-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-element-word-lexicon">
		<summary>This function deletes an element word lexicon for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="element-word-lexicons" type="element(db:element-word-lexicon)*" optional="false">An element word lexicon specification, typically the result of an
				<code>admin:database-element-word-lexicon</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $lexspec := admin:database-element-word-lexicon("my/namepsace",
     "elementname", "http://marklogic.com/collation/" )
  return
  admin:database-delete-element-word-lexicon($config, $dbid, $lexspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-element-attribute-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-element-attribute-word-lexicon">
		<summary>This function constructs an element attribute word lexicon specification.</summary>
		<params>
			<param name="parent-namespace" type="xs:string?" optional="false">The namespace of the parent element for the attribute.</param>
			<param name="parent-localname" type="xs:string" optional="false">The local name of the parent element for the attribute.</param>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
			<param name="collation" type="xs:string" optional="false">The collation URI (for example,
				<code>http://marklogic.com/collation/</code>.</param>
		</params>
		<return>element(db:element-attribute-word-lexicon)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-element-attribute-word-lexicon("my/namepsace", "elementname",
	"", "myAttribute", "http://marklogic.com/collation/" )
  (: returns the element attribute word lexicon specification :)

</example>
	</function>
	<function name="database-get-element-attribute-word-lexicons" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-element-attribute-word-lexicons">
		<summary>This function returns the element attribute word lexicons specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:element-attribute-word-lexicon)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-element-attribute-word-lexicons($config,
        xdmp:database("myDatabase") )
  (: returns the element attribute word lexicon specifications for the database :)

</example>
	</function>
	<function name="database-add-element-attribute-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-element-attribute-word-lexicon">
		<summary>This function adds an element attribute word lexicon to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="element-attribute-word-lexicons" type="element(db:element-attribute-word-lexicon)*" optional="false">An element word lexicon specification, typically the result of an
				<code>admin:database-element-word-lexicon</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $lexspec := admin:database-element-attribute-word-lexicon("my/namepsace",
     "elementname", "", "myAttribute", "http://marklogic.com/collation/" )
  return
  admin:database-add-element-attribute-word-lexicon($config, $dbid, $lexspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-element-attribute-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-element-attribute-word-lexicon">
		<summary>This function deletes an element attribute word lexicon for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="lexicons" type="element(db:element-attribute-word-lexicon)*" optional="false">An element attribute word lexicon specification, typically the result of an
				<code>admin:database-element-attribute-word-lexicon</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $lexspec := admin:database-element-attribute-word-lexicon("my/namepsace",
     "elementname", "", "myAttribute", "http://marklogic.com/collation/" )
  return
  admin:database-delete-element-attribute-word-lexicon($config, $dbid, $lexspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-phrase-through" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-phrase-through">
		<summary>This function constructs a phrase through specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
		</params>
		<return>element(db:phrase-through)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-phrase-through("my/namepsace", "elementname" )
  (: returns the phrase through specification :)

</example>
	</function>
	<function name="database-get-phrase-throughs" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-phrase-throughs">
		<summary>This function returns the phrase throughs specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:phrase-through)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-phrase-throughs($config,
        xdmp:database("myDatabase") )
  (: returns the phrase through specifications for the database :)

</example>
	</function>
	<function name="database-add-phrase-through" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-phrase-through">
		<summary>This function adds a phrase through to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="phrase-throughs" type="element(db:phrase-through)*" optional="false">A phrase through specification, typically the result of an
				<code>admin:database-phrase-through</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $ptspec := admin:database-phrase-through("my/namepsace",
     "elementname" )
  return
  admin:database-add-phrase-through($config, $dbid, $ptspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-phrase-through" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-phrase-through">
		<summary>This function deletes a phrase through for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="phrase-throughs" type="element(db:phrase-through)*" optional="false">A phrase through specification, typically the result of an
				<code>admin:database-phrase-through</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $ptspec := admin:database-phrase-through("my/namepsace",
     "elementname" )
  return
  admin:database-delete-phrase-through($config, $dbid, $ptspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-phrase-around" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-phrase-around">
		<summary>This function constructs a phrase through specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
		</params>
		<return>element(db:phrase-around)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-phrase-around("my/namepsace", "elementname" )
  (: returns the phrase around specification :)

</example>
	</function>
	<function name="database-get-phrase-arounds" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-phrase-arounds">
		<summary>This function returns the phrase arounds specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:phrase-around)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-phrase-arounds($config,
        xdmp:database("myDatabase") )
  (: returns the phrase arounds specifications for the database :)

</example>
	</function>
	<function name="database-add-phrase-around" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-phrase-around">
		<summary>This function adds a phrase around to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="phrase-arounds" type="element(db:phrase-around)*" optional="false">A phrase around specification, typically the result of an
				<code>admin:database-phrase-around</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $paspec := admin:database-phrase-around("my/namepsace",
     "elementname" )
  return
  admin:database-add-phrase-around($config, $dbid, $paspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-phrase-around" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-phrase-around">
		<summary>This function deletes a phrase around for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="phrase-arounds" type="element(db:phrase-around)*" optional="false">A phrase specification, typically the result of an
				<code>admin:database-phrase-through</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $paspec := admin:database-phrase-around("my/namepsace",
     "elementname" )
  return
  admin:database-delete-phrase-around($config, $dbid, $paspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-element-word-query-through" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-element-word-query-through">
		<summary>This function constructs an element word query through specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
		</params>
		<return>element(db:element-word-query-through)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-element-word-query-through("my/namepsace", "elementname" )
  (: returns the element word query through specification :)

</example>
	</function>
	<function name="database-get-element-word-query-throughs" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-element-word-query-throughs">
		<summary>This function returns the element word query throughs specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:element-word-query-through)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-element-word-query-throughs($config,
        xdmp:database("myDatabase") )
  (: returns the element word query through specifications for the database :)

</example>
	</function>
	<function name="database-add-element-word-query-through" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-element-word-query-through">
		<summary>This function adds an element word query through to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="element-word-query-throughs" type="element(db:element-word-query-through)*" optional="false">An element word query through specification, typically the result of an
				<code>admin:database-element-word-query-through</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $ewqtspec := admin:database-element-word-query-through("my/namepsace",
     "elementname" )
  return
  admin:database-add-element-word-query-through($config, $dbid, $ewqtspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-element-word-query-through" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-element-word-query-through">
		<summary>This function deletes an element word query through for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="throughs" type="element(db:element-word-query-through)*" optional="false">An element word query through specification, typically the result of an
				<code>admin:database-element-word-query-through</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $ewqtspec := admin:database-element-word-query-through("my/namepsace",
     "elementname" )
  return
  admin:database-delete-element-word-query-through($config, $dbid, $ewqtspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-word-lexicon">
		<summary>This function constructs a word lexicon specification.</summary>
		<params>
			<param name="collation" type="xs:string" optional="false">The collation URI (for example,
				<code>http://marklogic.com/collation/</code>.</param>
		</params>
		<return>element(db:word-lexicon)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-word-lexicon("http://marklogic.com/collation/")
  (: returns the word lexicon specification :)

</example>
	</function>
	<function name="database-get-word-lexicons" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-lexicons">
		<summary>This function returns the word lexicons specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:word-lexicon)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-lexicons($config, xdmp:database("myDatabase") )
  (: returns the word lexicon specifications for the database :)

</example>
	</function>
	<function name="database-add-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-word-lexicon">
		<summary>This function adds a word lexicon to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="word-lexicons" type="element(db:word-lexicon)*" optional="false">A word lexicon specification, typically the result of an
				<code>admin:database-word-lexicon</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $lexspec := admin:database-word-lexicon("http://marklogic.com/collation/")
  return
  admin:database-add-word-lexicon($config, $dbid, $lexspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-word-lexicon">
		<summary>This function deletes a word lexicon for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="word-lexicons" type="element(db:word-lexicon)*" optional="false">A word lexicon specification, typically the result of an
				<code>admin:database-word-lexicon</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $lexspec := admin:database-word-lexicon("http://marklogic.com/collation/")
  return
  admin:database-delete-word-lexicon($config, $dbid, $lexspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-geospatial-element-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-geospatial-element-index">
		<summary>This function constructs a geospatial element index specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
			<param name="coordinate-system" type="xs:string" optional="false">The coordinate system. Must be one of
				<code>wgs84</code>or
				<code>raw</code>.</param>
			<param name="range-value-positions" type="xs:boolean" optional="false">A boolean specifying whether to maintain value postions in this index (used with co-occurrences).</param>
			<param name="point-format" type="xs:string" optional="true">The point format in the data: "point" means latitude precedes longitude (this is the default); "long-lat-point" means longitude precedes latitude. To use the default value of "point", simply omit this parameter. Do not specify an empty string.</param>
		</params>
		<return>element(db:geospatial-element-index)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-geospatial-element-index(
           "/my/namespace",
           "elementname",
	   "wgs84",
	   fn:false(),
	   "long-lat-point" )

  (: returns the geospatial element index specification :)

</example>
	</function>
	<function name="database-get-geospatial-element-indexes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-geospatial-element-indexes">
		<summary>This function returns the geospatial element indexes specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:geospatial-element-index)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-geospatial-element-indexes($config,
        xdmp:database("myDatabase") )
  (: returns the geospatial index specifications for the database :)

</example>
	</function>
	<function name="database-add-geospatial-element-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-geospatial-element-index">
		<summary>This function adds a range element index to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="geospatial-element-indexes" type="element(db:geospatial-element-index)*" optional="false">A geospatial element index specification, typically the result of an
				<code>admin:database-geospatial-element-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $geospec := admin:database-geospatial-element-index("/my/namespace",
                "elementname", "wgs84", fn:false() )
  return
  admin:database-add-geospatial-element-index($config, $dbid, $geospec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-geospatial-element-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-geospatial-element-index">
		<summary>This function deletes a geospatial element index for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="geospatial-element-indexes" type="element(db:geospatial-element-index)*" optional="false">A geospatial element index specification, typically the result of an
				<code>admin:database-geospatial-element-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $geospec := admin:database-geospatial-element-index("/my/namespace",
                "elementname", "wgs84", fn:false() )
  return
  admin:database-delete-geospatial-element-index($config, $dbid, $geospec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-geospatial-element-child-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-geospatial-element-child-index">
		<summary>This function constructs a geospatial element child index specification.</summary>
		<params>
			<param name="parent-namespace" type="xs:string?" optional="false">The namespace of the parent element for the attribute.</param>
			<param name="parent-localname" type="xs:string" optional="false">The local name of the parent element for the attribute.</param>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI. Specify an empty string if the element is in no namespace.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
			<param name="coordinate-system" type="xs:string" optional="false">The coordinate system. Must be one of
				<code>wgs84</code>or
				<code>raw</code>.</param>
			<param name="range-value-positions" type="xs:boolean" optional="false">A boolean specifying whether to maintain value postions in this index (used with co-occurrences).</param>
			<param name="point-format" type="xs:string" optional="true">The point format in the data: "point" means latitude precedes longitude (this is the default); "long-lat-point" means longitude precedes latitude. To use the default value of "point", simply omit this parameter. Do not specify an empty string.</param>
		</params>
		<return>element(db:geospatial-element-child-index)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-geospatial-element-child-index(
        "/my/namespace",
        "elementname",
	"/my/namespace",
	"child-element",
        "wgs84",
	fn:false() )

  (: returns the geospatial element child index specification :)

</example>
	</function>
	<function name="database-get-geospatial-element-child-indexes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-geospatial-element-child-indexes">
		<summary>This function returns the geospatial element child indexes specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:geospatial-element-child-index)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-geospatial-element-child-indexes($config,
        xdmp:database("myDatabase") )
  (: returns the geospatial element child index specifications for the database :)

</example>
	</function>
	<function name="database-add-geospatial-element-child-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-geospatial-element-child-index">
		<summary>This function adds a geospatial element child index to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="geospatial-element-child-indexes" type="element(db:geospatial-element-child-index)*" optional="false">A geospatial element child index specification, typically the result of an
				<code>admin:database-geospatial-element-child-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $geospec := admin:database-geospatial-element-child-index("/my/namespace",
          "elementname", "/my/namespace", "child-element",
          "wgs84", fn:false() )
  return
  admin:database-add-geospatial-element-child-index($config, $dbid, $geospec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-geospatial-element-child-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-geospatial-element-child-index">
		<summary>This function deletes a geospatial element child index for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="geospatial-element-child-indexes" type="element(db:geospatial-element-child-index)*" optional="false">A geospatial element child index specification, typically the result of an
				<code>admin:database-geospatial-element-child-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $geospec := admin:database-geospatial-element-child-index("/my/namespace",
        "elementname", "/my/namespace", "child-element", "wgs84", fn:false() )
  return
  admin:database-delete-geospatial-element-child-index($config, $dbid, $geospec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-geospatial-element-pair-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-geospatial-element-pair-index">
		<summary>This function constructs a geospatial element pair index specification.</summary>
		<params>
			<param name="parent-namespace" type="xs:string?" optional="false">The namespace of the parent element for the attribute.</param>
			<param name="parent-localname" type="xs:string" optional="false">The local name of the parent element for the attribute.</param>
			<param name="latitude-namespace" type="xs:string?" optional="false">The namespace for the element containing the latitude.</param>
			<param name="latitude-localname" type="xs:string" optional="false">The local name for the element containing the latitude.</param>
			<param name="longitude-namespace" type="xs:string?" optional="false">The namespace for the element containing the longitude.</param>
			<param name="longitude-localname" type="xs:string" optional="false">The local name for the element containing the longitude.</param>
			<param name="coordinate-system" type="xs:string" optional="false">The coordinate system. Must be one of
				<code>wgs84</code>or
				<code>raw</code>.</param>
			<param name="range-value-positions" type="xs:boolean" optional="false">A boolean specifying whether to maintain value postions in this index (used with co-occurrences).</param>
		</params>
		<return>element(db:geospatial-element-pair-index)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-geospatial-element-pair-index("/my/namespace",
          "elementname", "/my/namespace", "lat",
          "/my/namespace", "long", "wgs84", fn:false() )
  (: returns the geospatial element pair index specification :)

</example>
	</function>
	<function name="database-get-geospatial-element-pair-indexes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-geospatial-element-pair-indexes">
		<summary>This function returns the geospatial element pair indexes specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:geospatial-element-pair-index)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config :=  admin:get-configuration()
  return
  admin:database-get-geospatial-element-pair-indexes($config,
       xdmp:database("myDatabase"))
  (: returns the specification :)

</example>
	</function>
	<function name="database-add-geospatial-element-pair-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-geospatial-element-pair-index">
		<summary>This function adds a geospatial element pair index to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="geospatial-element-pair-indexes" type="element(db:geospatial-element-pair-index)*" optional="false">A geospatial element pair index specification, typically the result of an
				<code>admin:database-geospatial-element-pair-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config :=  admin:get-configuration()
  let $geospec :=  admin:database-geospatial-element-pair-index("/my/namespace",
          "elementname", "/my/namespace", "lat",
	  "/my/namespace", "long", "wgs84", fn:false() )
  return
  admin:database-add-geospatial-element-pair-index($config,
     xdmp:database("myDatabase"), $geospec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-geospatial-element-pair-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-geospatial-element-pair-index">
		<summary>This function deletes a geospatial element pair index for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="geospatial-element-pair-indexes" type="element(db:geospatial-element-pair-index)*" optional="false">A geospatial element pair index specification, typically the result of an
				<code>admin:database-geospatial-element-pair-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config :=  admin:get-configuration()
  let $geospec :=  admin:database-geospatial-element-pair-index("/my/namespace",
          "elementname", "/my/namespace", "lat",
	  "/my/namespace", "long", "wgs84", fn:false() )
  return
  admin:database-delete-geospatial-element-pair-index($config,
     xdmp:database("myDatabase"), $geospec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-geospatial-element-attribute-pair-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-geospatial-element-attribute-pair-index">
		<summary>This function constructs a geospatial element attribute pair index specification.</summary>
		<params>
			<param name="parent-namespace" type="xs:string?" optional="false">The namespace of the parent element for the attribute.</param>
			<param name="parent-localname" type="xs:string" optional="false">The local name of the parent element for the attribute.</param>
			<param name="latitude-namespace" type="xs:string?" optional="false">The namespace for the element containing the latitude.</param>
			<param name="latitude-localname" type="xs:string" optional="false">The local name for the element containing the latitude.</param>
			<param name="longitude-namespace" type="xs:string?" optional="false">The namespace for the element containing the longitude.</param>
			<param name="longitude-localname" type="xs:string" optional="false">The local name for the element containing the longitude.</param>
			<param name="coordinate-system" type="xs:string" optional="false">The coordinate system. Must be one of
				<code>wgs84</code>or
				<code>raw</code>.</param>
			<param name="range-value-positions" type="xs:boolean" optional="false">A boolean specifying whether to maintain value postions in this index (used with co-occurrences).</param>
		</params>
		<return>element(db:geospatial-element-attribute-pair-index)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-geospatial-element-attribute-pair-index("/my/namespace",
          "elementname", "/my/namespace", "lat",
          "/my/namespace", "long", "wgs84", fn:false() )
  (: returns the geospatial element attribute pair index specification :)

</example>
	</function>
	<function name="database-get-geospatial-element-attribute-pair-indexes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-geospatial-element-attribute-pair-indexes">
		<summary>This function returns the geospatial element attribute pair indexes specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:geospatial-element-attribute-pair-index)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-geospatial-element-attribute-pair-indexes($config,
        xdmp:database("myDatabase") )
  (: returns the geospatial element attribute pair index specifications for the database :)

</example>
	</function>
	<function name="database-add-geospatial-element-attribute-pair-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-geospatial-element-attribute-pair-index">
		<summary>This function adds a geospatial element attribute pair index to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="geospatial-element-attribute-pair-indexes" type="element(db:geospatial-element-attribute-pair-index)*" optional="false">A geospatial element attribute pair index specification, typically the result of an
				<code>admin:database-geospatial-element-attribute-pair-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config :=  admin:get-configuration()
  let $geospec := admin:database-geospatial-element-attribute-pair-index(
	  "/my/namespace", "elementname", "/my/namespace", "lat",
	  "/my/namespace", "long", "wgs84", fn:false() )
  return
  admin:database-add-geospatial-element-attribute-pair-index($config,
     xdmp:database("myDatabase"), $geospec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-geospatial-element-attribute-pair-index" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-geospatial-element-attribute-pair-index">
		<summary>This function deletes a geospatial element attribute pair index in the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="indexes" type="element(db:geospatial-element-attribute-pair-index)*" optional="false">A geospatial element attribute pair index specification, typically the result of an
				<code>admin:database-geospatial-element-attribute-pair-index</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config :=  admin:get-configuration()
  let $geospec := admin:database-geospatial-element-attribute-pair-index(
	  "/my/namespace", "elementname", "/my/namespace", "lat",
	  "/my/namespace", "long", "wgs84", fn:false() )
  return
  admin:database-delete-geospatial-element-pair-index($config,
     xdmp:database("myDatabase"), $geospec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-name">
		<summary>This function changes the name of the database with the specified ID to the specified name.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new name for the database.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  return
  admin:database-set-name($config, $dbid, "myNewDatabaseName")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-enabled">
		<summary>This function sets the enabled value for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">The new boolean value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-enabled($config, xdmp:database("myDatabase"), fn:false())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-security-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-security-database">
		<summary>This function sets the security database for a database to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedLong" optional="false">The new database ID for the auxiliary database.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-security-database($config, xdmp:database("myDatabase"),
        xdmp:database("mySecurityDatabase"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-schema-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-schema-database">
		<summary>This function sets the schema database for a database to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedLong" optional="false">The new database ID for the auxiliary database.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-schema-database($config, xdmp:database("myDatabase"),
        xdmp:database("mySchemasDatabase"))
 (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-triggers-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-triggers-database">
		<summary>This function sets the triggers database to the specified database ID for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedLong" optional="false">The new database ID for the auxiliary database.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-triggers-database($config, xdmp:database("myDatabase"),
        xdmp:database("myTriggersDatabase"))
 (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-language" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-language">
		<summary>This function sets the language for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The locale string representing the new language. Must be a valid value for
				<code>xml:lang</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-language($config, xdmp:database("myDatabase"),
        "fr")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-stemmed-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-stemmed-searches">
		<summary>This function sets the stemmed searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new stemmed search value. Must be one of
				<code>off</code>,
				<code>basic</code>,
				<code>advanced</code>, or
				<code>decompounding</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-stemmed-searches($config, xdmp:database("myDatabase"),
        "advanced")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-searches">
		<summary>This function sets the word searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-searches($config, xdmp:database("myDatabase"),
        fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-positions">
		<summary>This function sets the word positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-positions($config, xdmp:database("myDatabase"),
        fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-fast-phrase-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-fast-phrase-searches">
		<summary>This function sets the fast phrase searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-fast-phrase-searches($config, xdmp:database("myDatabase"),
        fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-fast-case-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-fast-case-sensitive-searches">
		<summary>This function sets the fast case sensitive searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-fast-case-sensitive-searches($config, xdmp:database("myDatabase"),
        fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-fast-reverse-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-fast-reverse-searches">
		<summary>This function sets the fast reverse searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-fast-reverse-searches($config, xdmp:database("myDatabase"),
        fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-fast-diacritic-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-fast-diacritic-sensitive-searches">
		<summary>This function sets the fast diacritic-sensitive searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-fast-diacritic-sensitive-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-fast-element-word-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-fast-element-word-searches">
		<summary>This function sets the element word searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-fast-element-word-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-element-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-element-word-positions">
		<summary>This function sets the element word positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-element-word-positions($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-fast-element-phrase-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-fast-element-phrase-searches">
		<summary>This function sets the fast element phrase searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-fast-element-phrase-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-element-value-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-element-value-positions">
		<summary>This function sets the element value positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-element-value-positions($config, xdmp:database("myDatabase"),
        fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-attribute-value-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-attribute-value-positions">
		<summary>This function sets the attribute value positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-attribute-value-positions($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-trailing-wildcard-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-trailing-wildcard-searches">
		<summary>This function sets the trailing wildcard searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-trailing-wildcard-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-trailing-wildcard-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-trailing-wildcard-word-positions">
		<summary>This function sets the trailing wildcard word positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-trailing-wildcard-word-positions($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-fast-element-trailing-wildcard-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-fast-element-trailing-wildcard-searches">
		<summary>This function sets the fast element trailing wildcard searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-trailing-wildcard-word-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-three-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-three-character-searches">
		<summary>This function sets the three character searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-three-character-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-three-character-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-three-character-word-positions">
		<summary>This function sets the three character word positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-three-character-word-positions($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-two-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-two-character-searches">
		<summary>This function sets the two character searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-two-character-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-one-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-one-character-searches">
		<summary>This function sets the one character searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-one-character-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-fast-element-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-fast-element-character-searches">
		<summary>This function sets the fast element character searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-fast-element-character-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-uri-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-uri-lexicon">
		<summary>This function sets the URI lexicon setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-uri-lexicon($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-collection-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-collection-lexicon">
		<summary>This function sets the collection lexicon setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-collection-lexicon($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-reindexer-enable" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-reindexer-enable">
		<summary>This function sets the reindexer enable setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-reindexer-enable($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-maintain-last-modified" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-maintain-last-modified">
		<summary>This function sets the maintain last modified setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-maintain-last-modified($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-maintain-directory-last-modified" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-maintain-directory-last-modified">
		<summary>This function sets the maintain directory last modified setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-maintain-directory-last-modified($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-inherit-permissions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-inherit-permissions">
		<summary>This function sets the inherit permissions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-inherit-permissions($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-inherit-collections" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-inherit-collections">
		<summary>This function sets the inherit collections setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-inherit-collections($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-inherit-quality" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-inherit-quality">
		<summary>This function sets the inherit quality setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-inherit-quality($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-preallocate-journals" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-preallocate-journals">
		<summary>This function sets the preallocate journals setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-preallocate-journals($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-preload-mapped-data" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-preload-mapped-data">
		<summary>This function sets the preload mapped data setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-preload-mapped-data($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-range-index-optimize" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-range-index-optimize">
		<summary>This function sets the range index optimize setting for the specified database in the configuration. When set to
			<code>facet-time</code>, range indexes are optimized to minimize the amount of CPU time used. When set to
			<code>memory-size</code>, range indexes are optimized to minimize the amount of memory used.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new range index optimize value. Must be one of
				<code>facet-time</code>or
				<code>memory-size</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-range-index-optimize($config, xdmp:database("myDatabase"),
        "memory-size")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-directory-creation" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-directory-creation">
		<summary>This function sets the directory creation setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new directory creation setting. Must be one of:
				<code>automatic</code>,
				<code>manual-enforced</code>, or
				<code>manual</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-directory-creation($config,
        xdmp:database("myDatabase"), "automatic")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-format-compatibility" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-format-compatibility">
		<summary>This function sets the format cpmpatibility setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new format-compatibility setting. Must be one of:
				<code>automatic</code>,
				<code>4.0</code>,
				<code>3.2</code>,
				<code>3.1</code>,
				<code>3.0</code>, or
				<code>2.2</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-format-compatibility($config,
        xdmp:database("myDatabase"), "automatic")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-index-detection" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-index-detection">
		<summary>This function sets the index detection setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new index detection setting. Must be one of:
				<code>automatic</code>or
				<code>none</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-index-detection($config,
        xdmp:database("myDatabase"), "automatic")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-expunge-locks" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-expunge-locks">
		<summary>This function sets the expunge locks setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new expunge locks setting. Must be one of:
				<code>automatic</code>or
				<code>none</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-expunge-locks($config,
        xdmp:database("myDatabase"), "automatic")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-reindexer-timestamp" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-reindexer-timestamp">
		<summary>This function sets the reindexer timestamp setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The system timestamp before which fragments will be reindexed. 0 indicates no forced reindex.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-reindexer-timestamp($config,
        xdmp:database("myDatabase"), 0)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-in-memory-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-in-memory-limit">
		<summary>This function sets the in-memory limit setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value, indicating the maximum number of fragments allowed in an in-memory stand before it is saved to disk.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-in-memory-limit($config,
        xdmp:database("myDatabase"), 65536)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-in-memory-list-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-in-memory-list-size">
		<summary>This function sets the in-memory list size setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new size, in megabytes.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-in-memory-list-size($config,
        xdmp:database("myDatabase"), 256)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-in-memory-tree-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-in-memory-tree-size">
		<summary>This function sets the in-memory tree size setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new size, in megabytes.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-in-memory-tree-size($config,
        xdmp:database("myDatabase"), 64)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-in-memory-range-index-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-in-memory-range-index-size">
		<summary>This function sets the in-memory range index size setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new size, in megabytes.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-in-memory-range-index-size($config,
        xdmp:database("myDatabase"), 8)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-in-memory-reverse-index-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-in-memory-reverse-index-size">
		<summary>This function sets the in-memory range reverse index size setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new size, in megabytes.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-in-memory-reverse-index-size($config,
        xdmp:database("myDatabase"), 8)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-large-size-threshold" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-large-size-threshold">
		<summary>This function sets the threshold at which binary documents in the specified database should be handled as binary large objects (BLOBs). Binary documents less than or equal to the threshold are treated as small binary objects, stored in stands. Binary documents larger than the threshold are stored in the Large Data Directory for more efficient memory consumption.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The size in kilobytes beyond which binary documents are treated as binary large objects (BLOBs) and stored in the Large Data Directory. The default is 1 MB.</param>
		</params>
		<return>element(configuration)</return>
		<usage>Binary documents with size less than or equal to the configured threshold are treated as small binary objects and stored in stands. The entire contents of a small binary document is cached in memory. Binary documents larger than the threshold are stored in the Large Data Directory for more efficient memory usage. For details about small vs. large binaries, see "Binary Format" in the
			<em>Application Developer's Guide</em>.
			<p>The threshold value is in kilobytes and must be in the range:</p>
			<ul>
				<li>128 KB &lt;= threshold &lt;= 512 MB on 64-bit systems</li>
				<li>128 KB &lt;= threshold &lt;= 128 MB on 32-bit systems</li>
			</ul>
			<p>The location of the Large Data Directory may be configured during forest creation by setting the "large data directory" property on the Forest configuration page of the Admin Interface, or by passing a
				<code>large-data-directory</code>parameter to
				<code>admin:forest-create</code>.</p></usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-large-size-threshold($config, xdmp:database("myDatabase"),
      2048)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-locking" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-locking">
		<summary>This function sets the locking setting for the specified database in the configuration. When set to
			<code>strict</code>, locking enforces mutual exclusion on existing documents and on new documents. When set to
			<code>fast</code>, locking enforces mutual exclusion on existing documents but not on new documents. When set to
			<code>off</code>, locking does not enforce mutual exclusion on existing documents or on new documents.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new locking value. Must be one of
				<code>strict</code>,
				<code>fast</code>, or
				<code>off</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-locking($config, xdmp:database("myDatabase"),
        "fast")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-journaling" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-journaling">
		<summary>This function sets the journaling setting for the specified database in the configuration. When set to
			<code>strict</code>, the journal protects against MarkLogic Server process failures, host operating system kernel failures, and host hardware failures. When set to
			<code>fast</code>, the journal protects against MarkLogic Server process failures but not against host operating system kernel failures or host hardware failures. When set to
			<code>off</code>, the journal does not protect against MarkLogic Server process failures, host operating system kernel failures, or host hardware failures.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new journaling value. Must be one of
				<code>strict</code>,
				<code>fast</code>, or
				<code>off</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-journaling($config, xdmp:database("myDatabase"),
        "strict")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-journal-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-journal-size">
		<summary>This function sets the journal size setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new size, in megabytes.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-journal-size($config,
        xdmp:database("myDatabase"), 320)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-positions-list-max-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-positions-list-max-size">
		<summary>This function sets the positions list max size setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new size, in megabytes.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-positions-list-max-size($config,
        xdmp:database("myDatabase"), 64)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-merge-max-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-merge-max-size">
		<summary>This function sets the merge max size setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new size, in megabytes.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-merge-max-size($config,
        xdmp:database("myDatabase"), 500)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-merge-min-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-merge-min-size">
		<summary>This function sets the merge minimum size setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new size, in number of fragments.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-merge-min-size($config,
        xdmp:database("myDatabase"), 5000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-merge-min-ratio" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-merge-min-ratio">
		<summary>This function sets the merge min ratio setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new ratio. Larger ratios trigger more merges.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-merge-min-ratio($config,
        xdmp:database("myDatabase"), 2)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-merge-priority" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-merge-priority">
		<summary>This function sets the CPU scheduler priority for merges.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new CPU scheduler priority value. Must be one of
				<code>normal</code>or
				<code>lower</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-merge-priority($config,
        xdmp:database("myDatabase"), "lower")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-merge-timestamp" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-merge-timestamp">
		<summary>This function sets the merge timestamp setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedLong" optional="false">The new system timestamp after which to preserve fragments in a merge. A value of 0 indicates to keep only the latest version of fragments.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-merge-timestamp($config,
        xdmp:database("myDatabase"), 0)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-reindexer-throttle" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-reindexer-throttle">
		<summary>This function sets the reindexer throttle setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new setting, which must be a number between 1 and 5 (inclusive). Larger numbers mean to work harder at reindexing.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-reindexer-throttle($config,
        xdmp:database("myDatabase"), 5)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-attached-forests" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-attached-forests">
		<summary>This function returns the attached forest IDs for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-attached-forests($config, xdmp:database("myDatabase"))
  (: returns the IDs of the attached forests :)

</example>
	</function>
	<function name="database-get-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-id">
		<summary>This function returns the ID for the specified database from the configuration. The difference between this function and
			<code>xdmp:database()</code>is that the ID from this function can come from a database that has not yet been saved (that is, from a database that has been created in the same query with the Admin library but has not yet been saved to the cluster configuration files). This ID enables you to completely configure a newly created database without the need to first save the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-name" type="xs:string" optional="false">The name of the database.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $config := admin:database-create($config, "myNewDatabase",
                  xdmp:database("Security"), xdmp:database("Schemas"))
  let $databaseID := admin:database-get-id($config, "myNewDatabase")
  let $fieldspec := admin:database-field("myField", fn:true() )
  let $config := admin:database-add-field($config, $databaseID, $fieldspec)

  return
      admin:database-attach-forest($config, $databaseID,
          xdmp:forest("newForest") )

  (: Attaches "newForest" and adds the field, "myField" to the newly created
     database, "myNewDatabase" :)

</example>
	</function>
	<function name="database-get-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-enabled">
		<summary>This function returns the enabled value for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-enabled($config, xdmp:database("myDatabase"))
  (: returns the enabled setting :)

</example>
	</function>
	<function name="database-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-name">
		<summary>This function returns the name for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-name($config, xdmp:database("myDatabase"))
  (: returns the name setting :)


</example>
	</function>
	<function name="database-get-security-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-security-database">
		<summary>This function returns the ID of the security database for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-security-database($config, xdmp:database("myDatabase"))
  (: returns the ID of the security database :)


</example>
	</function>
	<function name="database-get-schema-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-schema-database">
		<summary>This function returns the ID of the schema database for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-schema-database($config, xdmp:database("myDatabase"))
  (: returns the ID of the schema database :)

</example>
	</function>
	<function name="database-get-triggers-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-triggers-database">
		<summary>This function returns the ID of the triggers database for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-triggers-database($config, xdmp:database("myDatabase"))
  (: returns the ID of the triggers database :)

</example>
	</function>
	<function name="database-get-language" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-language">
		<summary>This function returns the language for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-language($config, xdmp:database("myDatabase"))
  (: returns the language setting :)

</example>
	</function>
	<function name="database-get-stemmed-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-stemmed-searches">
		<summary>This function returns the stemmed searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-stemmed-searches($config, xdmp:database("myDatabase"))
  (: returns the stemmed searches setting :)

</example>
	</function>
	<function name="database-get-word-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-searches">
		<summary>This function returns the word searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-searches($config, xdmp:database("myDatabase"))
  (: returns the word searches setting :)

</example>
	</function>
	<function name="database-get-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-positions">
		<summary>This function returns the word positions setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-positions($config, xdmp:database("myDatabase"))
  (: returns the word positions setting :)

</example>
	</function>
	<function name="database-get-fast-phrase-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fast-phrase-searches">
		<summary>This function returns the fast phrase searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fast-phrase-searches($config, xdmp:database("myDatabase"))
  (: returns the fast phrase searches setting :)

</example>
	</function>
	<function name="database-get-fast-case-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fast-case-sensitive-searches">
		<summary>This function returns the fast case sensitive searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fast-case-sensitive-searches($config, xdmp:database("myDatabase"))
  (: returns the fast case sensitive searches setting :)

</example>
	</function>
	<function name="database-get-fast-reverse-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fast-reverse-searches">
		<summary>This function returns the fast reverse searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fast-reverse-searches($config, xdmp:database("myDatabase"))
  (: returns the stemmed searches setting :)

</example>
	</function>
	<function name="database-get-fast-diacritic-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fast-diacritic-sensitive-searches">
		<summary>This function returns the fast diacritic sensitive searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fast-diacritic-sensitive-searches($config,
      xdmp:database("myDatabase"))
  (: returns the fast diacritic sensitive searches setting :)


</example>
	</function>
	<function name="database-get-fast-element-word-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fast-element-word-searches">
		<summary>This function returns the fast element word searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fast-element-word-searches($config,
       xdmp:database("myDatabase"))
  (: returns the element word searches setting :)

</example>
	</function>
	<function name="database-get-element-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-element-word-positions">
		<summary>This function returns the element word positions setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-element-word-postions($config, xdmp:database("myDatabase"))
  (: returns the element word positions setting :)

</example>
	</function>
	<function name="database-get-fast-element-phrase-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fast-element-phrase-searches">
		<summary>This function returns the fast element phrase searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fast-element-phrase-searches($config,
       xdmp:database("myDatabase"))
  (: returns the fast element phrase searches setting :)

</example>
	</function>
	<function name="database-get-element-value-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-element-value-positions">
		<summary>This function returns the element value positions setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-element-value-positions($config,
        xdmp:database("myDatabase"))
  (: returns the element value positions setting :)

</example>
	</function>
	<function name="database-get-attribute-value-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-attribute-value-positions">
		<summary>This function returns the attribute value positions setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-attribute-value-positions($config,
        xdmp:database("myDatabase"))
  (: returns the attribute value positions setting :)

</example>
	</function>
	<function name="database-get-trailing-wildcard-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-trailing-wildcard-searches">
		<summary>This function returns the trailing wildcard searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-trailing-wildcard-searches($config,
        xdmp:database("myDatabase"))
  (: returns the trailing wildcard searches setting :)

</example>
	</function>
	<function name="database-get-trailing-wildcard-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-trailing-wildcard-word-positions">
		<summary>This function returns the trailing wildcard word positions setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-trailing-wildcard-word-positions($config,
        xdmp:database("myDatabase"))
  (: returns the trailing wildcard word positions setting :)

</example>
	</function>
	<function name="database-get-fast-element-trailing-wildcard-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fast-element-trailing-wildcard-searches">
		<summary>This function returns the trailing wildcard searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fast-element-trailing-wildcard-searches($config,
        xdmp:database("myDatabase"))
  (: returns the fast element trailing wildcard searches setting :)

</example>
	</function>
	<function name="database-get-three-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-three-character-searches">
		<summary>This function returns the three character searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-three-character-searches($config,
        xdmp:database("myDatabase"))
  (: returns the three character searches setting :)

</example>
	</function>
	<function name="database-get-three-character-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-three-character-word-positions">
		<summary>This function returns the three character word positions setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-three-character-word-positions($config,
        xdmp:database("myDatabase"))
  (: returns the three character word positions setting :)

</example>
	</function>
	<function name="database-get-two-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-two-character-searches">
		<summary>This function returns the two character searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-two-character-searches($config,
        xdmp:database("myDatabase"))
  (: returns the two character searches setting :)

</example>
	</function>
	<function name="database-get-one-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-one-character-searches">
		<summary>This function returns the one character searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-one-character-searches($config,
        xdmp:database("myDatabase"))
  (: returns the one character searches setting :)

</example>
	</function>
	<function name="database-get-fast-element-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fast-element-character-searches">
		<summary>This function returns the fast element character searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fast-element-character-searches($config,
        xdmp:database("myDatabase"))
  (: returns the fast element character searches setting :)

</example>
	</function>
	<function name="database-get-uri-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-uri-lexicon">
		<summary>This function returns the URI lexicon setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-uri-lexicon($config, xdmp:database("myDatabase"))
  (: returns the uri lexicon setting :)

</example>
	</function>
	<function name="database-get-collection-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-collection-lexicon">
		<summary>This function returns the collection lexicon setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-collection-lexicon($config, xdmp:database("myDatabase"))
  (: returns the collection lexicon setting :)

</example>
	</function>
	<function name="database-get-reindexer-enable" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-reindexer-enable">
		<summary>This function returns the reindexer enable setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-reindexer-enable($config, xdmp:database("myDatabase"))
  (: returns the reindexer enable setting :)

</example>
	</function>
	<function name="database-get-maintain-last-modified" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-maintain-last-modified">
		<summary>This function returns the maintain last modified setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-maintain-last-modified($config, xdmp:database("myDatabase"))
  (: returns the maintain last modified setting :)

</example>
	</function>
	<function name="database-get-maintain-directory-last-modified" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-maintain-directory-last-modified">
		<summary>This function returns the maintain directory last modified setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-maintain-directory-last-modified($config, xdmp:database("myDatabase"))
  (: returns the maintain directory last modified setting :)

</example>
	</function>
	<function name="database-get-inherit-permissions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-inherit-permissions">
		<summary>This function returns the inherit positions setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-inherit-permissions($config, xdmp:database("myDatabase"))
  (: returns the inherit permissions setting :)

</example>
	</function>
	<function name="database-get-inherit-collections" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-inherit-collections">
		<summary>This function returns the inherit collections setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-inherit-collections($config, xdmp:database("myDatabase"))
  (: returns the inherit collections setting :)

</example>
	</function>
	<function name="database-get-inherit-quality" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-inherit-quality">
		<summary>This function returns the inherit quality setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-inherit-quality($config, xdmp:database("myDatabase"))
  (: returns the inherit quality setting :)

</example>
	</function>
	<function name="database-get-preallocate-journals" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-preallocate-journals">
		<summary>This function returns the preallocate journals setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-preallocate-journals($config, xdmp:database("myDatabase"))
  (: returns the preallocate journals setting :)

</example>
	</function>
	<function name="database-get-preload-mapped-data" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-preload-mapped-data">
		<summary>This function returns the preload mapped data setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-preload-mapped-data($config, xdmp:database("myDatabase"))
  (: returns the preload mapped data setting :)

</example>
	</function>
	<function name="database-get-range-index-optimize" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-range-index-optimize">
		<summary>This function returns the range index optimize setting for the specified database from the configuration. When set to
			<code>facet-time</code>, range indexes are optimized to minimize the amount of CPU time used. When set to
			<code>memory-size</code>, range indexes are optimized to minimize the amount of memory used.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-range-index-optimize($config, xdmp:database("myDatabase"))
  (: returns the range index optimize setting :)

</example>
	</function>
	<function name="database-get-directory-creation" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-directory-creation">
		<summary>This function returns the directory creation setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-directory-creation($config, xdmp:database("myDatabase"))
  (: returns the directory creation setting :)

</example>
	</function>
	<function name="database-get-format-compatibility" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-format-compatibility">
		<summary>This function returns the format compatibility setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-format-compatibility($config, xdmp:database("myDatabase"))
  (: returns the format compatibility setting :)

</example>
	</function>
	<function name="database-get-index-detection" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-index-detection">
		<summary>This function returns the index detection setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-index-detection($config, xdmp:database("myDatabase"))
  (: returns the index detection setting :)

</example>
	</function>
	<function name="database-get-expunge-locks" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-expunge-locks">
		<summary>This function returns the expunge locks setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-expunge-locks($config, xdmp:database("myDatabase"))
  (: returns the expunge-locks setting :)

</example>
	</function>
	<function name="database-get-reindexer-timestamp" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-reindexer-timestamp">
		<summary>This function returns the reindexer timestamp setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-reindexer-timestamp($config, xdmp:database("myDatabase"))
  (: returns the reindexer timestamp setting :)

</example>
	</function>
	<function name="database-get-in-memory-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-in-memory-limit">
		<summary>This function returns the in memory limit setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-in-memory-limit($config, xdmp:database("myDatabase"))
  (: returns the in memory limit setting :)

</example>
	</function>
	<function name="database-get-in-memory-list-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-in-memory-list-size">
		<summary>This function returns the in memory list size setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-in-memory-list-size($config, xdmp:database("myDatabase"))
  (: returns the in memory list size setting :)

</example>
	</function>
	<function name="database-get-in-memory-tree-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-in-memory-tree-size">
		<summary>This function returns the in memory tree size setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-in-memory-tree-size($config, xdmp:database("myDatabase"))
  (: returns the in memory tree size setting :)

</example>
	</function>
	<function name="database-get-in-memory-range-index-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-in-memory-range-index-size">
		<summary>This function returns the in memory range index size setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-in-memory-range-index-size($config,
        xdmp:database("myDatabase"))
  (: returns the in memory range index size setting :)

</example>
	</function>
	<function name="database-get-in-memory-reverse-index-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-in-memory-reverse-index-size">
		<summary>This function returns the in memory reverse index size setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-in-memory-reverse-index-size($config,
        xdmp:database("myDatabase"))
  (: returns the in memory reverse index size setting :)

</example>
	</function>
	<function name="database-get-locking" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-locking">
		<summary>This function returns the locking setting for the specified database in the configuration. When set to
			<code>strict</code>, locking enforces mutual exclusion on existing documents and on new documents. When set to
			<code>fast</code>, locking enforces mutual exclusion on existing documents but not on new documents. When set to
			<code>off</code>, locking does not enforce mutual exclusion on existing documents or on new documents.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-locking($config, xdmp:database("myDatabase"))
  (: returns the locking setting :)

</example>
	</function>
	<function name="database-get-journaling" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-journaling">
		<summary>This function returns the journaling setting for the specified database in the configuration. When set to
			<code>strict</code>, the journal protects against MarkLogic Server process failures, host operating system kernel failures, and host hardware failures. When set to
			<code>fast</code>, the journal protects against MarkLogic Server process failures but not against host operating system kernel failures or host hardware failures. When set to
			<code>off</code>, the journal does not protect against MarkLogic Server process failures, host operating system kernel failures, or host hardware failures.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-journaling($config, xdmp:database("myDatabase"))
  (: returns the journaling setting :)

</example>
	</function>
	<function name="database-get-journal-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-journal-size">
		<summary>This function returns the journal size setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-journal-size($config, xdmp:database("myDatabase"))
  (: returns the journal size setting :)

</example>
	</function>
	<function name="database-get-positions-list-max-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-positions-list-max-size">
		<summary>This function returns the positions list max size setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-positions-list-max-size($config,
        xdmp:database("myDatabase"))
  (: returns the in positions list max size setting :)

</example>
	</function>
	<function name="database-get-merge-max-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-merge-max-size">
		<summary>This function returns the merge max size setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-merge-max-size($config, xdmp:database("myDatabase"))
  (: returns the merge max size setting :)

</example>
	</function>
	<function name="database-get-merge-min-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-merge-min-size">
		<summary>This function returns the merge min size setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-merge-min-size($config, xdmp:database("myDatabase"))
  (: returns the merge min size setting :)

</example>
	</function>
	<function name="database-get-merge-min-ratio" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-merge-min-ratio">
		<summary>This function returns the merge min ratio setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-merge-min-ratio($config, xdmp:database("myDatabase"))
  (: returns the merge min ratio setting :)

</example>
	</function>
	<function name="database-get-merge-priority" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-merge-priority">
		<summary>This function returns the CPU scheduler priority for merges for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-merge-priority($config, xdmp:database("myDatabase"))
  (: returns the merge priority setting :)

</example>
	</function>
	<function name="database-get-merge-timestamp" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-merge-timestamp">
		<summary>This function returns the merge timestamp setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-merge-timestamp($config, xdmp:database("myDatabase"))
  (: returns the merge timestamp setting :)

</example>
	</function>
	<function name="database-get-reindexer-throttle" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-reindexer-throttle">
		<summary>This function returns the reindexer throttle setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-reindexer-throttle($config, xdmp:database("myDatabase"))
  (: returns the reindexer throttle setting :)

</example>
	</function>
	<function name="database-included-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-included-element">
		<summary>This function constructs an included element specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI. Specify an empty string if the element is in no namespace.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
			<param name="weight" type="xs:double" optional="false">The query weight to use in relavance calculations.</param>
			<param name="attribute-namespace" type="xs:string?" optional="false">The namespace for the attribute to constrain on. Specify an empty string if there is no attribute to constrain on or if the attribute is in no namespace.</param>
			<param name="attribute-localname" type="xs:string" optional="false">The local name of the attribute to constrain on. Specify an empty string if there is no attribute to constrain on.</param>
			<param name="attribute-value" type="xs:string" optional="false">The value for the attribute to constrain on (only attributes with this value). Specify an empty string if there is no attribute to constrain on.</param>
		</params>
		<return>element(db:included-element)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-included-element("http://myuri/namespace",
	"element-name", 1.0, "", "myAttribute", "some value")
  (: the constructed element :)

</example>
	</function>
	<function name="database-excluded-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-excluded-element">
		<summary>This function constructs an excluded element specification.</summary>
		<params>
			<param name="namespace" type="xs:string?" optional="false">The namespace URI. Specify an empty string if the element is in no namespace.</param>
			<param name="localname" type="xs:string" optional="false">The local name for the node.</param>
			<param name="attribute-namespace" type="xs:string?" optional="true">The namespace URI for the constraining attribute.</param>
			<param name="attribute-localname" type="xs:string" optional="true">The localname for the constraining attribute.</param>
			<param name="attribute-value" type="xs:string" optional="true">The value for the constraing attribute.</param>
		</params>
		<return>element(db:excluded-element)</return>
		<usage>If the third parameter is included, the fourth and fifth must also be included. These parameters are for constraining the excluded element based on a particular attribute value.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-excluded-element("http://myuri/namespace",
	"element-name")
  (: the constructed element :)

</example>
	</function>
	<function name="database-field" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-field">
		<summary>This function constructs a field specification.</summary>
		<params>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="include-root" type="xs:boolean" optional="false">A boolean value, true to start including at the root, false to not include until an included element is reached.</param>
		</params>
		<return>element(db:field)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:database-field("myField", fn:true() )
  (: the constructed element :)

</example>
	</function>
	<function name="database-get-word-query-included-elements" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-included-elements">
		<summary>This function returns the word query included elements setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:included-element)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-included-elements($config,
        xdmp:database("myDatabase"))
  (: returns the included elements specifications from the configuration :)

</example>
	</function>
	<function name="database-get-word-query-excluded-elements" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-excluded-elements">
		<summary>This function returns the word query excluded elements setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:excluded-element)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-excluded-elements($config,
        xdmp:database("myDatabase"))
  (: returns the excluded elements specifications from the configuration :)

</example>
	</function>
	<function name="database-get-fields" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-fields">
		<summary>This function returns the fields specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(db:field)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-fields($config, xdmp:database("myDatabase"))
  (: returns the field settings :)

</example>
	</function>
	<function name="database-get-field-included-elements" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-included-elements">
		<summary>This function returns the fields included elements specification for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>element(db:included-element)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-included-elements($config,
      xdmp:database("myDatabase"), "myField")
  (: returns the field settings :)

</example>
	</function>
	<function name="database-get-field-excluded-elements" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-excluded-elements">
		<summary>This function returns the field excluded elements specification for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>element(db:excluded-element)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-excluded-elements($config,
      xdmp:database("myDatabase"), "myField")
  (: returns the field settings :)

</example>
	</function>
	<function name="database-get-field" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field">
		<summary>This function returns the field specification for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>element(db:field)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field($config,
      xdmp:database("myDatabase"), "myField")
  (: returns the field settings :)

</example>
	</function>
	<function name="database-add-field" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-field">
		<summary>This function adds the field specification to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="fields" type="element(db:field)*" optional="false">The field specification, typically the result of an
				<code>admin:database-field</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $fieldspec := admin:database-field("myField", fn:true() )
  return
  admin:database-add-field($config, $dbid, $fieldspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-field" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-field">
		<summary>This function deletes the field specification in the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-names" type="xs:string*" optional="false">The name(s) of the field(s) to delete.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  return
  admin:database-delete-field($config, $dbid, "myField")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-add-word-query-included-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-word-query-included-element">
		<summary>This function adds the word query included element specification to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="included-elements" type="element(db:included-element)*" optional="false">The included elements specification, typically the result of an
				<code>admin:database-included-element</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $wqspec :=   admin:database-included-element("http://myuri/namespace",
  "element-name", 1.0, "", "myAttribute", "some value")
  return
  admin:database-add-word-query-included-element($config, $dbid, $wqspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-word-query-included-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-word-query-included-element">
		<summary>This function deletes the word query included element specification in the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="included-elements" type="element(db:included-element)*" optional="false">The included elements specification, typically the result of an
				<code>admin:database-included-element</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $wqspec :=   admin:database-included-element("http://myuri/namespace",
  "element-name", 1.0, "", "myAttribute", "some value")
  return
  admin:database-delete-word-query-included-element($config, $dbid, $wqspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-add-field-included-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-field-included-element">
		<summary>This function adds the field included element specification tn the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="included-elements" type="element(db:included-element)*" optional="false">The included elements specification, typically the result of an
				<code>admin:database-included-element</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $fieldspec :=   admin:database-included-element("http://myuri/namespace",
  "element-name", 1.0, "", "myAttribute", "some value")
  return
  admin:database-add-field-included-element($config, $dbid,
       "myField", $fieldspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-field-included-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-field-included-element">
		<summary>This function deletes the field included element specification in the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="included-elements" type="element(db:included-element)*" optional="false">The included elements specification, typically the result of an
				<code>admin:database-included-element</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $fieldspec :=   admin:database-included-element("http://myuri/namespace",
  "element-name", 1.0, "", "myAttribute", "some value")
  return
  admin:database-delete-field-included-element($config, $dbid,
       "myField", $fieldspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-add-word-query-excluded-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-word-query-excluded-element">
		<summary>This function adds the word query excluded element specification for the specified database to the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="excluded-elements" type="element(db:excluded-element)*" optional="false">The excluded elements specification, typically the result of an
				<code>admin:database-excluded-element</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $wqspec := admin:database-excluded-element("http://myuri/namespace",
	"element-name")
  return
  admin:database-add-word-query-excluded-element($config, $dbid, $wqspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-word-query-excluded-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-word-query-excluded-element">
		<summary>This function deletes the word query excluded element specification in the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="excluded-elements" type="element(db:excluded-element)*" optional="false">The excluded elements specification, typically the result of an
				<code>admin:database-excluded-element</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $wqspec := admin:database-excluded-element("http://myuri/namespace",
	"element-name")
  return
  admin:database-delete-word-query-excluded-element($config, $dbid, $wqspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-add-field-excluded-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-field-excluded-element">
		<summary>This function adds the field excluded element specification in the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="excluded-elements" type="element(db:excluded-element)*" optional="false">The excluded elements specification, typically the result of an
				<code>admin:database-excluded-element</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $fieldspec := admin:database-excluded-element("http://myuri/namespace",
	"element-name")
  return
  admin:database-add-field-excluded-element($config, $dbid,
       "myField", $fieldspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-field-excluded-element" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-field-excluded-element">
		<summary>This function deletes the field excluded element specification in the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="excluded-elements" type="element(db:excluded-element)*" optional="false">The excluded elements specification, typically the result of an
				<code>admin:database-excluded-element</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("myDatabase")
  let $fieldspec := admin:database-excluded-element("http://myuri/namespace",
	"element-name")
  return
  admin:database-delete-field-excluded-element($config, $dbid,
       "myField", $fieldspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-field-word-lexicons" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-word-lexicons">
		<summary>This function returns the word lexicons specification(s) for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>element(db:word-lexicon)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-word-lexicons($config, xdmp:database("myDatabase"),
    "myField")
  (: returns the word lexicon specifications for the database's field :)

</example>
	</function>
	<function name="database-add-field-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-add-field-word-lexicon">
		<summary>This function adds a word lexicon to the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="word-lexicons" type="element(db:word-lexicon)*" optional="false">A word lexicon specification, typically the result of an
				<code>admin:database-word-lexicon</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $lexspec := admin:database-word-lexicon("http://marklogic.com/collation/")
  return
  admin:database-add-field-word-lexicon($config, $dbid, "myField", $lexspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-delete-field-word-lexicon" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-delete-field-word-lexicon">
		<summary>This function deletes a word lexicon for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="word-lexicons" type="element(db:word-lexicon)*" optional="false">A word lexicon specification, typically the result of an
				<code>admin:database-word-lexicon</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("Documents")
  let $lexspec := admin:database-word-lexicon("http://marklogic.com/collation/")
  return
  admin:database-delete-field-word-lexicon($config, $dbid, "myField", $lexspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-word-query-include-document-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-include-document-root">
		<summary>This function returns the word query include document root setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-include-document-root($config,
        xdmp:database("myDatabase"))
  (: returns the word query include document root setting :)

</example>
	</function>
	<function name="database-get-word-query-stemmed-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-stemmed-searches">
		<summary>This function returns the reindexer word query stemmed searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-stemmed-searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query stemmed searches setting :)

</example>
	</function>
	<function name="database-get-word-query-word-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-word-searches">
		<summary>This function returns true if the word query searches setting for the specified database is enabled in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-word searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query word searches setting :)

</example>
	</function>
	<function name="database-get-word-query-fast-phrase-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-fast-phrase-searches">
		<summary>This function returns true if the word query fast phrase searches setting for the specified database is set in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-fast-phrase-searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query fast phrase searches setting :)

</example>
	</function>
	<function name="database-get-word-query-fast-case-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-fast-case-sensitive-searches">
		<summary>This function returns true if the word query fast case sensitive searches setting is enabled for the specified database in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions. An empty return value means the option is not set (false).</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-fast-case-sensitive-searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query fast case sensitive searches setting :)

</example>
	</function>
	<function name="database-get-word-query-fast-diacritic-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-fast-diacritic-sensitive-searches">
		<summary>This function returns true if the word query fast diacritic sensitive searches setting is enabled for the specified database in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-fast-diacritic-sensitive-searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query fast iacritic sensitive searches setting :)

</example>
	</function>
	<function name="database-get-word-query-trailing-wildcard-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-trailing-wildcard-searches">
		<summary>This function returns true if the word query trailing wildcard searches setting is enabled for the specified database in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-trailing-wildcard-searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query trailing wildcard searches setting :)

</example>
	</function>
	<function name="database-get-word-query-trailing-wildcard-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-trailing-wildcard-word-positions">
		<summary>This function returns true if the word query trailing wildcard word positions setting is enabled for the specified database in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-trailing-wildcard-word-positions($config,
        xdmp:database("myDatabase"))
  (: returns the word query trailing wildcard word positions setting :)

</example>
	</function>
	<function name="database-get-word-query-three-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-three-character-searches">
		<summary>This function returns true if the word query three character searches setting is enabled for the specified database in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-three-character-searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query three character searches setting :)

</example>
	</function>
	<function name="database-get-word-query-three-character-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-three-character-word-positions">
		<summary>This function returns true if the word query three character word positions setting is enabled for the specified database from the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-three-character-word-positions($config,
        xdmp:database("myDatabase"))
  (: returns the word query three character word positions setting :)

</example>
	</function>
	<function name="database-get-word-query-two-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-two-character-searches">
		<summary>This function returns true if the word query two character searches setting is enabled for the specified database in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-two-character-searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query two character searches setting :)

</example>
	</function>
	<function name="database-get-word-query-one-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-word-query-one-character-searches">
		<summary>This function returns true if the word query one character searches setting is enabled for the specified database in the configuration. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-word-query-one-character-searches($config,
        xdmp:database("myDatabase"))
  (: returns the word query one character searches setting :)

</example>
	</function>
	<function name="database-set-word-query-stemmed-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-stemmed-searches">
		<summary>This function sets the word query stemmed searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string?" optional="false">The new stemmed search value. Must be one of
				<code>basic</code>,
				<code>advanced</code>, or
				<code>decompounding</code>. It must be equal to or greater than the database setting. The empty sequence turns this setting off for word query.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-stemmed-searches($config,
        xdmp:database("myDatabase"), "advanced")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-word-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-word-searches">
		<summary>This function sets the word query word searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-word-searches($config,
               xdmp:database("myDatabase"), fn:true())

  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-fast-phrase-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-fast-phrase-searches">
		<summary>This function sets the word query fast phrase searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-fast-phrase-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-fast-case-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-fast-case-sensitive-searches">
		<summary>This function returns the word query fast case sensitive searches setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-fast-case-sensitive-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-fast-diacritic-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-fast-diacritic-sensitive-searches">
		<summary>This function sets the word query fast diacritic sensitive searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-fast-diacritic-sensitive-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-trailing-wildcard-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-trailing-wildcard-searches">
		<summary>This function sets the word query trailing wildcard searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-trailing-wildcard-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-trailing-wildcard-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-trailing-wildcard-word-positions">
		<summary>This function sets the word query trailing wildcard word positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-trailing-wildcard-word-positions($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-three-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-three-character-searches">
		<summary>This function sets the word query three character searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-three-character-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-three-character-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-three-character-word-positions">
		<summary>This function sets the word query three character word positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-three-character-word-positions($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-two-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-two-character-searches">
		<summary>This function sets the word query two character searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-two-character-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-one-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-one-character-searches">
		<summary>This function sets the word query one character searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-one-character-searches($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-word-query-include-document-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-word-query-include-document-root">
		<summary>This function sets the word query include document root setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-word-query-include-document-root($config,
        xdmp:database("myDatabase"), fn:false())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-field-include-document-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-include-document-root">
		<summary>This function returns the field include document root setting for the specified field from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-include-document-root($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-stemmed-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-stemmed-searches">
		<summary>This function returns stemmed searches setting for the specified field if configured. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-stemmed-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the word query stemmed searches setting :)

</example>
	</function>
	<function name="database-get-field-word-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-word-searches">
		<summary>This function returns true if the word searches setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-word-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-fast-phrase-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-fast-phrase-searches">
		<summary>This function returns true if the fast phrase searches setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-fast-phrase-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-fast-case-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-fast-case-sensitive-searches">
		<summary>This function returns true if the fast case sensitive searches setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-fast-case-sensitive-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-fast-diacritic-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-fast-diacritic-sensitive-searches">
		<summary>This function returns true if the fast diacritic sensitive searches setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-fast-diacritic-sensitive-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-trailing-wildcard-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-trailing-wildcard-searches">
		<summary>This function returns true if the trailing wildcard searches setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-trailing-wildcard-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-trailing-wildcard-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-trailing-wildcard-word-positions">
		<summary>This function returns true if the trailing wildcard word positions setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-wildcard-word-positions($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-three-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-three-character-searches">
		<summary>This function returns true if the three character searches setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-three-character-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-three-character-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-three-character-word-positions">
		<summary>This function returns true if the three character word positions setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-three-character-word-positions($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-two-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-two-character-searches">
		<summary>This function returns true if the two character searches setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-two-character-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-get-field-one-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-one-character-searches">
		<summary>This function returns true if the one character searches setting for the specified field is enabled. Otherwise, it returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-one-character-searches($config,
        xdmp:database("myDatabase"), "myField")
  (: returns the setting :)

</example>
	</function>
	<function name="database-set-field-stemmed-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-stemmed-searches">
		<summary>This function sets the field stemmed searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:string?" optional="false">The new stemmed search value. Must be one of
				<code>basic</code>,
				<code>advanced</code>,
				<code>decompounding</code>, or
				<code>off</code>. It must be equal to or greater than the database setting. The empty sequence turns this setting off for the field.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-stemmed-searches($config,
        xdmp:database("myDatabase"), "myField", "decompounding")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-word-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-word-searches">
		<summary>This function sets the field word searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-word-searches($config,
        xdmp:database("myDatabase"), "myField", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-fast-phrase-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-fast-phrase-searches">
		<summary>This function sets the field fast phrase searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-fast-phrase-searches($config,
        xdmp:database("myDatabase"), "myField", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-fast-case-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-fast-case-sensitive-searches">
		<summary>This function sets the field fast case sensitive searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-fast-case-sensitive-searches($config,
        xdmp:database("myDatabase"), "myField", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-fast-diacritic-sensitive-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-fast-diacritic-sensitive-searches">
		<summary>This function sets the field fast diacritic sensitive searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-fast-diacritic-sensitive-searches($config,
        xdmp:database("myDatabase"), "myField", fn:false())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-trailing-wildcard-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-trailing-wildcard-searches">
		<summary>This function sets the field trailing wildcard searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-trailing-wildcard-searches($config,
        xdmp:database("myDatabase"), "myField", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-trailing-wildcard-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-trailing-wildcard-word-positions">
		<summary>This function sets the field trailing wildcard word positions setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-wildcard-word-positions($config,
        xdmp:database("myDatabase"), "myField", fn:false())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-three-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-three-character-searches">
		<summary>This function sets the field three character searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-three-character-searches($config,
        xdmp:database("myDatabase"), "myField", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-three-character-word-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-three-character-word-positions">
		<summary>This function sets the field three character word positions setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-three-character-word-positions($config,
        xdmp:database("myDatabase"), "myField", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-two-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-two-character-searches">
		<summary>This function sets the field two character searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-two-character-searches($config,
        xdmp:database("myDatabase"), "myField", fn:false())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-one-character-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-one-character-searches">
		<summary>This function sets the field one character searches setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>or the empty sequence to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-one-character-searches($config,
        xdmp:database("myDatabase"), "myField", fn:false())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-include-document-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-include-document-root">
		<summary>This function sets the field include document root setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-include-document-root($config,
        xdmp:database("myDatabase"), "myField", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-name">
		<summary>This function sets the field name setting for the specified field in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:string" optional="false">The new name for the field.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-name($config,
        xdmp:database("myDatabase"), "myField", "myNewFieldName")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="forest-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-name">
		<summary>This function returns the name of the specified forest, given the forest ID.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. If the ID does not correspond to a valid forest ID, then an exception is thrown.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:forest-get-name(admin:get-configuration(), 18220031759147104956)

</example>
	</function>
	<function name="forest-get-host" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-host">
		<summary>This function returns the ID of the host in which the specified forest resides.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:forest-get-host(admin:get-configuration(), xdmp:forest("myForest"))

  =&gt; the ID of the host that services the forest named "myForest"

</example>
	</function>
	<function name="forest-get-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-id">
		<summary>This function returns the ID of the forest with the specified name, from the specified configuration. The difference between this function and
			<code>xdmp:forest()</code>is that the ID from this function can come from a forest that has not yet been saved (that is, from a forest that has been created in the same query with the Admin library but has not yet been saved to the cluster configuration files).</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-name" type="xs:string" optional="false">The name of the forest.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:forest-get-id(admin:get-configuration(), "myForest")

</example>
	</function>
	<function name="forest-get-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-enabled">
		<summary>This function returns the enabled state of the specified forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-get-enabled($config, admin:forest-get-id($config, "test"))

</example>
	</function>
	<function name="forest-get-data-directory" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-data-directory">
		<summary>This function returns the name of the data directory of the specified forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-get-data-directory($config,
         admin:forest-get-id($config, "test"))

</example>
	</function>
	<function name="forest-get-large-data-directory" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-large-data-directory">
		<summary>This function returns the name of the large data directory of the specified forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-get-large-data-directory($config,
         admin:forest-get-id($config, "test"))

</example>
	</function>
	<function name="forest-get-failover-enable" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-failover-enable">
		<summary>This function returns the state of whether failover is enabled for the specified forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-get-failover-enable($config,
         admin:forest-get-id($config, "test"))

</example>
	</function>
	<function name="forest-get-updates-allowed" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-updates-allowed">
		<summary>This function returns the state of what kinds of updates are allowed for the specified forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-get-updates-allowed($config,
         admin:forest-get-id($config, "test"))

</example>
	</function>
	<function name="forest-get-failover-hosts" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-failover-hosts">
		<summary>This function returns the IDs of the hosts defined as failover hosts for this forest. The order in which the hosts IDs are returned is significant, with the first ID being the primary host, the second (if there is one) being the secondary, and so on.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-get-failover-hosts($config,
         admin:forest-get-id($config, "test"))


</example>
	</function>
	<function name="forest-set-host" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-set-host">
		<summary>This function sets a forest configuration to a new host.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
			<param name="value" type="xs:unsignedLong" optional="false">The host ID of the new host.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-set-host($config, admin:forest-get-id($config, "Documents"),
              xdmp:host("myNewHost"))

</example>
	</function>
	<function name="forest-set-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-set-enabled">
		<summary>This function sets the enabled state for a forest configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
			<param name="value" type="xs:boolean" optional="false">The new state of the forest, for example
				<code>fn:true()</code>for enabled,
				<code>fn:false()</code>for disabled.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-set-enabled($config, admin:forest-get-id($config, "Documents"),
      fn:false())

  =&gt; sets the forest named "Documents" to the disabled state

</example>
	</function>
	<function name="forest-set-failover-enable" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-set-failover-enable">
		<summary>This function sets the forest failover enabled state for a forest configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
			<param name="value" type="xs:boolean" optional="false">The new failover-enable state of the forest, for example
				<code>fn:true()</code>for enabled,
				<code>fn:false()</code>for disabled.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-set-failover-enable($config,
      admin:forest-get-id($config, "Documents"),
      fn:true())

      =&gt; sets the failover state of the forest named "Documents" to
         the enabled state

</example>
	</function>
	<function name="forest-set-updates-allowed" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-set-updates-allowed">
		<summary>This function sets the updates-allowed state for a forest configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
			<param name="value" type="xs:string" optional="false">The new updates-allowed state of the forest. Must be one of
				<code>all</code>for all updates allowed,
				<code>delete-only</code>for only deletes allowed,
				<code>read-only</code>for no updates allowed and to cause updating transactions to abort immediately,
				<code>flash-backup</code>for no updates allowed and to make updating transactions retry for a time period specified in the group's retry timeout.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-set-updates-allowed($config,
      admin:forest-get-id($config, "Documents"),
      "delete-only")

      =&gt; sets the updates-allowed state of the forest named "Documents" to
         the true state

</example>
	</function>
	<function name="forest-add-failover-host" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-add-failover-host">
		<summary>This function adds a failover host to the list of failover hosts for the specified forest in the specified configuration. If there are already any hosts specified, this host is added to the end of the list of failover hosts.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
			<param name="hosts" type="xs:unsignedLong*" optional="false">The host ID(s) for the host(s) you want to restart. For example,
				<code>xdmp:host()</code>returns the ID for the current host.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-add-failover-host($config,
      admin:forest-get-id($config, "Documents"),
      xdmp:host("myFailoverHost"))

      =&gt; add the failover host "myFailoverHost" to the end of the
         list of failover hosts


</example>
	</function>
	<function name="forest-delete-failover-host" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-delete-failover-host">
		<summary>This function deletes the specified failover host(s) from the failover-host list in the specified configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
			<param name="hosts" type="xs:unsignedLong*" optional="false">The host ID(s) for the host(s) you want to delete. For example,
				<code>xdmp:host()</code>returns the ID for the current host.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-delete-failover-host($config,
      admin:forest-get-id($config, "Documents"),
      xdmp:host("myFailoverHost"))

      =&gt; deletes the failover host "myFailoverHost" from the
         list of failover hosts


</example>
	</function>
	<function name="forest-delete" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-delete">
		<summary>This function deletes the configuration for the specified forest from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="false">One or more forest ids. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
			<param name="delete-data" type="xs:boolean" optional="false">If set to true, deletes the data directory as well as the configuration (Note: all documents in the forest will be permanently deleted). If set to false, deletes only the configuration information, leaving the forest data in the data directory on disk.</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any forest whose ID you pass into this function must not be attached to a database when the transaction begins, otherwise an exception is thrown. If you need to detach the forest, do so in a separate transaction before using them in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-delete($config, admin:forest-get-id($config, "Documents"),
      fn:false())

      =&gt; deletes the forest configuration for the forest
         named "Documents"


</example>
	</function>
	<function name="forest-create" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-create">
		<summary>This function creates a new forest configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-name" type="xs:string" optional="false">The name of the forest. The must be unique for all forests in the cluster.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The ID of the host (for example,
				<code>xdmp:host()</code>for the current host.</param>
			<param name="data-directory" type="xs:string?" optional="false">The optional data directory of the forest. If no directory is specified, then it will be a private forest.</param>
			<param name="large-data-directory" type="xs:string?" optional="true">The optional directory where large objects are stored. If no directory is specified, then large objects will be stored in DATA_DIR/Forests/FOREST_NAME/Large.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:forest-create(admin:get-configuration(), "newForest", xdmp:host(), ())


</example>
	</function>
	<function name="forest-copy" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-copy">
		<summary>This function creates a new forest specification with the same settings as the forest with the specified ID. The new forest configuration will have the specified name. It copies the forest configuration, but does not copy the forest data.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest. For example,
				<code>xdmp:forest("myForest")</code>specified the ID for a forest named "myForest".</param>
			<param name="forest-name" type="xs:string" optional="false">The name for the new forest.</param>
			<param name="data-directory" type="xs:string?" optional="false">The optional data directory of the forest. If no directory is specified, then it will be a private forest.</param>
			<param name="large-data-directory" type="xs:string?" optional="true">The optional directory where large objects are stored. If no directory is specified, then large objects will be stored in DATA_DIR/Forests/FOREST_NAME/Large.</param>
			<param name="fast-data-directory" type="xs:string?" optional="true">An optional directory located on a fast storage device, such as an SSD.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:forest-copy(admin:get-configuration(), xdmp:forest("myForest"),
         "myNewForest",())


</example>
	</function>
	<function name="forest-get-backups" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-backups">
		<summary>This function returns the scheduled backups for the specified forest from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the forest (for example,
				<code>xdmp:forest("myforest")</code>).</param>
		</params>
		<return>element(as:forest-backup)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:forest-get-backups($config, xdmp:forest("myforest") )
  (: returns the scheduled backups for the forest :)


</example>
	</function>
	<function name="forest-weekly-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-weekly-backup">
		<summary>This function constructs a weekly scheduled backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory where the backup will be saved to.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The how many weeks between each backup.</param>
			<param name="days" type="xs:string+" optional="false">The day(s) of the week. Must be a sequence of zero or more of
				<code>monday</code>,
				<code>tuesday</code>,
				<code>wednesday</code>,
				<code>thusday</code>,
				<code>friday</code>,
				<code>saturday</code>,
				<code>sunday</code>.</param>
			<param name="start-time" type="xs:time" optional="false">A time for the scheduled backup to start.</param>
		</params>
		<return>element(as:forest-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:forest-weekly-backup("/backup-dir", 2, "monday", xs:time("09:45:00"))
  (: returns the weekly backup specification :)


</example>
	</function>
	<function name="forest-monthly-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-monthly-backup">
		<summary>This function constructs a monthly scheduled backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory where the backup will be saved to.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The number of months to elapse between each backup.</param>
			<param name="backup-month-day" type="xs:unsignedInt" optional="false">The day of the month the backup will happen (between 1 and 31)</param>
			<param name="start-time" type="xs:time" optional="false">A time for the scheduled backup to start.</param>
		</params>
		<return>element(as:forest-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:forest-monthly-backup("/backup-dir", 1, 1, xs:time("09:45:00"))
  (: returns the monthly backup specification :)


</example>
	</function>
	<function name="forest-one-time-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-one-time-backup">
		<summary>This function constructs a one-time backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory where the backup will be saved to.</param>
			<param name="start" type="xs:dateTime" optional="false">The starting dateTime of the scheduled backup.</param>
		</params>
		<return>element(as:forest-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:forest-one-time-backup("/backup-dir",
        xs:dateTime("2008-02-14T09:45:00"))
  (: returns the one-time backup :)



</example>
	</function>
	<function name="forest-add-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-add-backup">
		<summary>This function adds scheduled backup specifications for a forest to a configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the forest (for example,
				<code>xdmp:forest("myforest")</code>).</param>
			<param name="backups" type="element(as:forest-backup)*" optional="false">The scheduled backup specification(s), typically the result of an
				<code>admin:forest-one-time-backup</code>or an
				<code>admin:forest-monthly-backup</code>or an
				<code>admin:forest-weekly-backup</code>call</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $forest := xdmp:forest("myforest")
  let $backup := admin:forest-one-time-backup("/backup-dir",
        xs:dateTime("2008-02-14T09:45:00"))
  return
  admin:forest-add-backup($config, $forest, $backup)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="forest-delete-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-delete-backup">
		<summary>This function deletes scheduled backup specifications for a forest from a configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the forest (for example,
				<code>xdmp:forest("myforest")</code>).</param>
			<param name="backups" type="element(as:forest-backup)*" optional="false">The scheduled backup(s) to delete. Typically, the result of an
				<code>admin:forest-get-backups</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config  := admin:get-configuration()
  let $forest  := xdmp:forest("Documents")
  let $backups := admin:forest-get-backups($config, $forest)[1 to 3]
  return
  admin:forest-delete-backup($config, $forest, $backups)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="host-get-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:host-get-id">
		<summary>This function return the ID for the specified host from the configuration. The difference between this function and
			<code>xdmp:host()</code>is that the ID from this function can come from a host that has not yet been saved (that is, from a host that has been created in the same query with the Admin library but has not yet been saved to the cluster configuration files). This ID enables you to completely configure a newly created host without the need to first save the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-name" type="xs:string" optional="false">The name of the host. If the host is the current host,
				<code>xdmp:host-name()</code>returns the name.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:host-get-id($config, xdmp:host-name())
  (: returns the host ID :)


</example>
	</function>
	<function name="host-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:host-get-name">
		<summary>This function returns the name for the host with the specified ID.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The host ID. Typically, the result of an
				<code>admin:host-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:host-get-name($config, admin:host-get-id($config, xdmp:host-name()))
  (: returns the host name :)


</example>
	</function>
	<function name="host-get-group" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:host-get-group">
		<summary>This function returns the group ID for the host with the specified ID.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The host ID. Typically, the result of an
				<code>admin:host-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:host-get-group($config, admin:host-get-id($config, xdmp:host-name()))
  (: returns the group ID :)


</example>
	</function>
	<function name="host-get-port" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:host-get-port">
		<summary>This function returns the bind port for the host with the specified ID.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The host ID. Typically, the result of an
				<code>admin:host-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:host-get-port($config, admin:host-get-id($config, xdmp:host-name()))
  (: returns the bind port for the host :)


</example>
	</function>
	<function name="host-set-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:host-set-name">
		<summary>This function changes the name of an existing host to the newly specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The host ID. Typically, the result of an
				<code>admin:host-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new name of the host.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $hostid := admin:host-get-id($config, "myOldHostname")
  return
  admin:host-set-name($config, $hostid, "myNewHostName")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="host-set-group" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:host-set-group">
		<summary>This function changes the group to which an existing host belongs to the newly specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The host ID. Typically, the result of an
				<code>admin:host-get-id</code>call.</param>
			<param name="value" type="xs:unsignedLong" optional="false">The new group ID value (typically from a
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any group whose ID you pass into this function must exist when the transaction begins, otherwise an exception is thrown. If you need to create the group, do so in a separate transaction before using them in in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $hostid := admin:host-get-id($config, xdmp:host-name())
  return
  admin:host-set-group($config, $hostid,
      admin:group-get-id($config, "Default"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="host-set-port" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:host-set-port">
		<summary>This function changes the bind port value for the host to the newly specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The host ID. Typically, the result of an
				<code>admin:host-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new bind port value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $hostid := admin:host-get-id($config, xdmp:host-name())
  return
  admin:host-set-port($config, $hostid, 7999)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-get-type" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-type">
		<summary>This function returns the type of appserver with the specified ID. It will be either "http", "xdbc", or "WebDAV".</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-type($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))
  (: returns "http", "xdbc", or "WebDAV" :)

</example>
	</function>
	<function name="appserver-get-group-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-group-id">
		<summary>This function returns the ID of the specified App Server's group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:appserver-get-group-id($config, admin:appserver-get-id($config, (),
    "myAppServer"))


</example>
	</function>
	<function name="appserver-get-host-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-host-ids">
		<summary>This function returns the ID(s) of the hosts the specified App Server's is currently running on.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:appserver-get-host-ids($config, admin:appserver-get-id($config, (),
    "myAppServer"))


</example>
	</function>
	<function name="appserver-get-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-id">
		<summary>This function returns the ID of the specified App Server. The difference between this function and
			<code>xdmp:server()</code>is that the ID from this function can come from an appserver that has not yet been saved (that is, from an appserver that has been created in the same query with the Admin library but has not yet been saved to the cluster configuration files). This ID enables you to completely configure a newly created appserver without the need to first save the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-ids" type="xs:unsignedLong*" optional="false">The optional group-ids in which to restrict the appserver ids returned. If no group-id is specified, this function will return all matching appservers across all groups.</param>
			<param name="appserver-name" type="xs:string" optional="false">The name of the App Server.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:appserver-get-id($config, admin:group-get-id($config, "Default"),
         "myAppServer")


</example>
	</function>
	<function name="appserver-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-name">
		<summary>This function returns the name of the appserver with the specified ID.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-name($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-root">
		<summary>This function returns the root for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-root($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-port" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-port">
		<summary>This function returns the port for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-port($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-modules-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-modules-database">
		<summary>This function returns the ID of the database set as the modules database for the specified database.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong</return>
		<usage>
			<p>This function throws an exception if the specified App Server is a WebDAV server (because WebDAV servers do not use a modules database).</p>
		</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-modules-database($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-database">
		<summary>This function returns the ID of the database to which the App Server is set to execute queries against for the specified database.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-database($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-last-login" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-last-login">
		<summary>This function returns the ID of the database to which the App Server stores users' last login information.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-last-login($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-display-last-login" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-display-last-login">
		<summary>This function returns the value of the whether or not the appserver should display users' last login information.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-display-last-login($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-address" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-address">
		<summary>This function returns the IP address of the App Server configuration. The default is
			<code>0.0.0.0</code>.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-address($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-backlog" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-backlog">
		<summary>This function returns the socket listen backlog setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-backlog($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-threads" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-threads">
		<summary>This function returns the maximum number of threads configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-threads($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-request-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-request-timeout">
		<summary>This function returns the request timeout value configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-request-timeout($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-keep-alive-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-keep-alive-timeout">
		<summary>This function returns the keep alive timeout value configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-keep-alive-timeout($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-session-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-session-timeout">
		<summary>This function returns the session timeout value configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-session-timeout($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-default-time-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-default-time-limit">
		<summary>This function returns the default time limit value configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-default-time-limit($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-max-time-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-max-time-limit">
		<summary>This function returns the max time limit value configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-max-time-limit($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-pre-commit-trigger-depth" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-pre-commit-trigger-depth">
		<summary>This function returns the pre commit trigger depth value configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-pre-commit-trigger-depth($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-pre-commit-trigger-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-pre-commit-trigger-limit">
		<summary>This function returns the pre commit trigger limit value configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-pre-commit-trigger-limit($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-collation" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-collation">
		<summary>This function returns the collation URI set in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-collation($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-authentication" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-authentication">
		<summary>This function returns the authentication scheme (basic, digest, digestbasic, or application-level) configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-authentication($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-default-user" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-default-user">
		<summary>This function returns the default user value configured for the specified App Server. The default user only is used with application-level authentication.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-default-user($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-privilege" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-privilege">
		<summary>This function returns the privilege ID for the specified App Server. If no privilege is configured, It returns 0.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-privilege($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-concurrent-request-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-concurrent-request-limit">
		<summary>This function returns the concurrent request limit for any user for the specified App Server. 0 indicates no bound on the number of concurrent requests.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml"

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-concurrent-request-limit($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-log-errors" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-log-errors">
		<summary>This function returns the value of the log errors setting configured for this App Server, where true indicates that the App Server will send uncaught exceptions to the
			<code>ErrorLog.txt</code>file, and false indicates that it will not.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-log-errors($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-debug-allow" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-debug-allow">
		<summary>This function returns the value of debug allow setting configured for this App Server, where true indicates that the App Server will allow queries to be debugged, and false indicates that it will not.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-debug-allow($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-profile-allow" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-profile-allow">
		<summary>This function returns the value of the profile allow setting configured for this App Server, where true indicates that the App Server will allow queries to be profiled, and false indicates that it will not.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-profile-allow($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-default-xquery-version" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-default-xquery-version">
		<summary>This function returns the value of the default xquery version configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-default-xquery-version($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-multi-version-concurrency-control" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-multi-version-concurrency-control">
		<summary>This function returns the value of the multi version concurrency control option configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-multi-version-concurrency-control($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-sgml-character-entities" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-sgml-character-entities">
		<summary>This function returns the value for the output sgml character entities setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-sgml-character-entities($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-encoding" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-encoding">
		<summary>This function returns the value for the output encoding setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-encoding($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-error-handler" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-error-handler">
		<summary>This function returns the path to the error handler configured for this App Server. If no error handler is configured, returns the empty string.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-error-handler($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-url-rewriter" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-url-rewriter">
		<summary>This function returns the path to the URL rewriter configured for this App Server. If no URL rewriter is configured, returns the empty string.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-url-rewriter($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))

</example>
	</function>
	<function name="appserver-get-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-enabled">
		<summary>This function returns the enabled state for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-enabled($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-schemas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-schemas">
		<summary>This function returns the value of any schemas definitions predefined for the specified App Server. If none are defined, returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>element(gr:schema)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-schemas($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-namespaces" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-namespaces">
		<summary>This function returns the value of any namespace definitions predefined for the specified App Server. If none are defined, returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>element(gr:namespace)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-namespaces($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))



</example>
	</function>
	<function name="appserver-get-static-expires" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-static-expires">
		<summary>This function returns the value of the "expires" HTTP header for static content to expire after this many seconds port for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-static-expires($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-compute-content-length" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-compute-content-length">
		<summary>This function returns the value of whether the WebDAV server computes content length.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-compute-content-length($config,
             admin:appserver-get-id($config, $groupid, "myWebDAVServer"))


</example>
	</function>
	<function name="appserver-set-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-name">
		<summary>This function changes the name of an existing App Server to the newly specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new name for the specified App Server.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-name($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "myNewAppServerName")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-root" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-root">
		<summary>This function changes the root for a specified App Server to the newly specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new value for the root. The root must be either a fully qualified path (for example,
				<code>/space/myRoot</code>or
				<code>c:/space/myRoot</code>) or a relative path (for example,
				<code>myRoot</code>); relative paths are resolved relative to the directory in which MarkLogic Server is installed.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-root($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "myNewRoot")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="appserver-set-port" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-port">
		<summary>This function changes the port in the configuration for the specified App Server to the specified number. Changing the port is a "cold" operation; when you use
			<code>admin:save-configuration</code>to save the configuration, it will automatically restart MarkLogic Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new port number.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-port($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         1234)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-modules-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-modules-database">
		<summary>This function sets the value in the configuration of modules database for the specified App Server to the specified database ID.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="item()" optional="false">The database ID for the database to set as the modules database. To specify the filesystem, use 0 or "file-system"</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any database whose ID you pass into this function must exist when the transaction begins, otherwise an exception is thrown. If you need to create the database, do so in a separate transaction before using them in in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-modules-database($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         xdmp:database("Modules"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)



</example>
	</function>
	<function name="appserver-set-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-database">
		<summary>This function sets the value in the configuration of the database for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedLong" optional="false">The database ID for the database to set as the database for the specified App Server.</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any database whose ID you pass into this function must exist when the transaction begins, otherwise an exception is thrown. If you need to create the database, do so in a separate transaction before using them in in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-database($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         xdmp:database("myDatabase"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-last-login" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-last-login">
		<summary>This function sets the value in the configuration of the last login database for the specified App Server. If the value is equal to 0, then the last-login feature is disabled for this appserver.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedLong?" optional="false">The database ID for the database to set as the database for the specified App Server. To disable the last-login feature, use the empty sequence or 0 for this value</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any database whose ID you pass into this function must exist when the transaction begins, otherwise an exception is thrown. If you need to create the database, do so in a separate transaction before using them in in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-last-login($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         xdmp:database("Last-Login"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-display-last-login" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-display-last-login">
		<summary>This function sets the display last login setting in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value specifying whether to indicate if the appserver should display last login information.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-display-last-login($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-address" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-address">
		<summary>This function changes the IP Address in the configuration for the specified App Server to the specified address. Changing the address is a "cold" operation; when you use
			<code>admin:save-configuration</code>to save the configuration, it will automatically restart MarkLogic Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new value for the IP address for the specified App Server.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-address(
         $config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "127.0.0.1")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-backlog" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-backlog">
		<summary>This function sets the value in the configuration of the backlog (the maximum number of pending connections allowed on the HTTP socket) for the specified App Server. This is a "cold" operation; when you use
			<code>admin:save-configuration</code>to save the configuration, it will automatically restart MarkLogic Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new integer value for the backlog.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-backlog($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         64)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-threads" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-threads">
		<summary>This function sets the value in the configuration of the maximum number of threads for the specified App Server. This is a "cold" operation; when you use
			<code>admin:save-configuration</code>to save the configuration, it will automatically restart MarkLogic Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new integer value for the number of threads.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-threads($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         10)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-request-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-request-timeout">
		<summary>This function sets the value of the socket request timeout (the number of seconds before the socket times out) in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">An integer specifying the number of seconds before a socket request times out.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-request-timeout($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         10)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-keep-alive-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-keep-alive-timeout">
		<summary>This function sets the keep-alive timeout (the maximum number of second for subsequent socket requests to time out) in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new integer timeout value (specifies the number of seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-keep-alive-timeout($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         10)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-session-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-session-timeout">
		<summary>This function sets the session timeout value (in seconds) in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new integer timeout value (specifies the number of seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-session-timeout($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         10000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-default-time-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-default-time-limit">
		<summary>This function sets the default time limit (the maximum total amount of time to service a request before the App Server throws a timeout exception) in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new integer timeout value (specifies the number of seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-default-time-limit($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         10000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-max-time-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-max-time-limit">
		<summary>This function sets the max time limit (the maximum total amount of time to service a request before the App Server throws a timeout exception) in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new integer timeout value (specifies the number of seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-max-time-limit($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         10000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-pre-commit-trigger-depth" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-pre-commit-trigger-depth">
		<summary>This function sets the maximum depth (how many triggers can cause other triggers to fire, which in turn cause others to fire, and so on) in the configuration for the specifed App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The maximum depth (how many triggers can cause other triggers to fire, which in turn cause others to fire, and so on) for pre-commit triggers.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-pre-commit-trigger-depth($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         10000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)



</example>
	</function>
	<function name="appserver-set-pre-commit-trigger-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-pre-commit-trigger-limit">
		<summary>This function sets the value in the configuration for the maximum number of pre-commit triggers a single statement can invoke for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The limit for the number of pre-commit triggers a single statement can invoke.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-pre-commit-trigger-limit($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         1000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="appserver-set-collation" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-collation">
		<summary>This function sets the default collation in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">A valid collation URI (for example,
				<code>http://marklogic.com/collation/</code>).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-collation($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
	 "http://marklogic.com/collation/")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-authentication" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-authentication">
		<summary>This function sets the authentication scheme in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The authentication scheme (
				<code>basic</code>,
				<code>digest</code>,
				<code>digestbasic</code>, or
				<code>application-level</code>).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-authentication($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "digest")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-default-user" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-default-user">
		<summary>This function sets the default user (for use with application-level authentication) in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedLong" optional="false">The user ID of the user to set as the default user.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-default-user($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
	 xdmp:eval('
                  xquery version "1.0-ml";
                  import module "http://marklogic.com/xdmp/security"
	           at "/MarkLogic/security.xqy";
	          sec:uid-for-name("annabelle")', (),
	   &lt;options xmlns="xdmp:eval"&gt;
	        &lt;database&gt;{xdmp:security-database()}&lt;/database&gt;
	   &lt;/options&gt;))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-privilege" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-privilege">
		<summary>This function sets an execute privilege in the configuration for the specified App Server. When a privilege is set, the user who makes a request to the App Server must have been granted (via a role, either directly or indirectly) the specified privilege.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedLong" optional="false">The privilege ID of an execute privilege needed to access this App Server.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-privilege($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
	 xdmp:eval('
                xquery version "1.0-ml";
                import module "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";
      sec:get-privilege("http://marklogic.com/my.uri",
         "execute")/sec:privilege-id',
      (),
     &lt;options xmlns="xdmp:eval"&gt;
     &lt;database&gt;{xdmp:security-database()}&lt;/database&gt;
     &lt;/options&gt;))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-concurrent-request-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-concurrent-request-limit">
		<summary>This function sets the limit on concurrent requests that any user may have on a particular appserver. Setting the limit to 0 indicates there is no bound on the number of concurrent requests.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The limit of concurrent requests.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-concurrent-request-limit($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         15)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-log-errors" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-log-errors">
		<summary>This function sets the log errors setting in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value specifying whether to allow send uncaught exceptions on this App Server to the
				<code>ErrorLog.txt</code>file (true) or not (false).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-log-errors($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-debug-allow" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-debug-allow">
		<summary>This function sets the debug allow setting in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value specifying whether to allow debugging on this App Server (true) or not (false).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-debug-allow($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-profile-allow" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-profile-allow">
		<summary>This function sets the profile allow setting in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value specifying whether to allow profiling on this App Server (true) or not (false).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-profile-allow($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-default-xquery-version" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-default-xquery-version">
		<summary>This function sets the default XQuery version setting in the configuration for this App Server. This setting determines the XQuery dialect used in queries against this App Server when one is not explicitly specified in the XQuery version declaration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default XQuery version value, one of
				<code>1.0-ml</code>,
				<code>1.0</code>, or
				<code>0.9-ml</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-default-xquery-version($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "1.0-ml")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-multi-version-concurrency-control" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-multi-version-concurrency-control">
		<summary>This function sets the multi version concurrency control value in the configuration for this App Server. This option specifies how the latest timestamp is chosen for lock-free queries. When set to
			<code>contemporaneous</code>, the server chooses the latest timestamp for which
			<em>any</em>transaction is known to have committed, even though there still may be other transactions for that timestamp that have not yet fully committed. Queries will see more timely results, but may block waiting for contemporaneous transactions to fully commit. When set to
			<code>nonblocking</code>, the server chooses the latest timestamp for which
			<em>all</em>transactions are known to have committed, even though there may be a later timestamp for which another transaction has committed. Queries won't block waiting for transactions, but they may see less timely results.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The multi version concurrency control value, one of
				<code>contemporaneous</code>or
				<code>nonblocking</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-multi-version-concurrency-control($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "nonblocking")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-sgml-character-entities" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-sgml-character-entities">
		<summary>This function sets the SGML character entity output setting in the configuration for the specified App Server. The SGML setting determines how characters that can be represented as SGML entites are serialized upon output by default in a query against the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for outputting SGML entities, one of
				<code>none</code>,
				<code>default</code>,
				<code>math</code>, or
				<code>pub</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-sgml-character-entities($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "default")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-encoding" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-encoding">
		<summary>This function sets the value for the default output encoding in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for outputting characters. The value must be the name of a valid character set (for example,
				<code>UTF-8</code>,
				<code>ASCII</code>, and so on.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-encoding($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "ascii")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-error-handler" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-error-handler">
		<summary>This function sets the value of the path to the error handler in the configuration for the specified App Server. The path should specify a relative or absolute path to an XQuery module that is executed in the event of any 400 or 500 series HTTP errors (sometime known as a "sorry" server to give the user a clean error page).</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The path to the XQuery main module to execute when 400 or 500 series errors occur on the App Server.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-error-handler($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "sorry.xqy")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :);


</example>
	</function>
	<function name="appserver-set-url-rewriter" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-url-rewriter">
		<summary>This function sets the value of the path to the URL rewriter in the configuration for the specified App Server. The path should specify a relative or absolute path to an XQuery module that is executed to rewrite incoming URLs.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The path to the XQuery main module to execute to rewrite URLs.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy"  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-url-rewriter($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "rewriter.xqy")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :);


</example>
	</function>
	<function name="appserver-set-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-enabled">
		<summary>This function sets the enabled state in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">The enabled state of the App Server to set, true for enabled and false for disabled.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-enabled($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="appserver-set-static-expires" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-static-expires">
		<summary>This function changes the value of the "expires" HTTP header for a specified App Server to the newly specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value for the "expires" header.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-static-expires($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         3600)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="appserver-set-compute-content-length" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-compute-content-length">
		<summary>This function changes the value whether a WebDAV server computes content length.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">The new value for compute content length.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-compute-content-length($config,
         admin:appserver-get-id($config, $groupid, "myWebDAVServer"),
         fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="appserver-get-request-blackouts" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-request-blackouts">
		<summary>This function returns the request blackouts specification for the specified appserver from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The id of the appserver (for example,
				<code>xdmp:server("myAppserver")</code>).</param>
		</params>
		<return>element(gr:request-blackout)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:appserver-get-request-blackouts($config, xdmp:server("myAppserver") )
  (: returns the request-blackouts specification for the appserver :)


</example>
	</function>
	<function name="appserver-recurring-request-blackout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-recurring-request-blackout">
		<summary>This function constructs a request-blackout specification.</summary>
		<params>
			<param name="users" type="xs:unsignedLong*" optional="false">A sequence of user ID(s) that the request blackout applies too.</param>
			<param name="roles" type="xs:unsignedLong*" optional="false">A sequence of role ID(s) that the request blackout applies too.</param>
			<param name="days" type="xs:string*" optional="false">The day(s) of the week. Must be a sequence of zero or more of
				<code>monday</code>,
				<code>tuesday</code>,
				<code>wednesday</code>,
				<code>thusday</code>,
				<code>friday</code>,
				<code>saturday</code>,
				<code>sunday</code>.</param>
			<param name="start-time" type="xs:time?" optional="false">A time for the request blackout to start.</param>
			<param name="end-time" type="xs:time?" optional="false">A time for the request blackout to end.</param>
			<param name="duration" type="xs:duration?" optional="false">The amount of time for the blackout to last.</param>
		</params>
		<return>element(gr:request-blackout)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:appserver-recurring-request-blackout((),(), "monday",
        xs:time("09:45:00"), xs:time("11:45:00"), () )
  (: returns the request-blackout specification :)


</example>
	</function>
	<function name="appserver-one-time-request-blackout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-one-time-request-blackout">
		<summary>This function constructs a one-time request-blackout specification.</summary>
		<params>
			<param name="users" type="xs:unsignedLong*" optional="false">A sequence of user ID(s) that the request blackout applies too.</param>
			<param name="roles" type="xs:unsignedLong*" optional="false">A sequence of role ID(s) that the request blackout applies too.</param>
			<param name="start" type="xs:dateTime" optional="false">The starting dateTime of the request blackout.</param>
			<param name="end" type="xs:dateTime?" optional="false">The ending dateTime of the request blackout.</param>
			<param name="duration" type="xs:duration?" optional="false">The amount of time for the blackout to last.</param>
		</params>
		<return>element(gr:request-blackout)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:appserver-one-time-request-blackout((),(),
        xs:dateTime("2008-02-14T09:45:00"),
        (), xs:dayTimeDuration("PT3H") )
  (: returns the one-time request-blackout specification :)



</example>
	</function>
	<function name="appserver-add-request-blackout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-add-request-blackout">
		<summary>This function adds a request blackout specification for a appserver to a configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The id of the appserver (for example,
				<code>xdmp:server("myAppserver")</code>).</param>
			<param name="request-blackouts" type="element(gr:request-blackout)*" optional="false">The request blackout specification(s), typically the result of an
				<code>admin:appserver-one-time-request-blackout</code>or an
				<code>admin:appserver-recurring-request-blackout</code>call</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $app-id := xdmp:server("myAppserver")
  let $requestspec := admin:appserver-one-time-request-blackout((),(),
        xs:dateTime("2008-02-14T09:45:00"),
        (), xs:dayTimeDuration("PT3H") )
  return
  admin:appserver-add-request-blackout($config, $app-id, $requestspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-delete-request-blackout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-delete-request-blackout">
		<summary>This function deletes a request blackout specification for a appserver from a configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The id of the appserver (for example,
				<code>xdmp:server("myAppserver")</code>).</param>
			<param name="blackouts" type="element(gr:request-blackout)*" optional="false">The request blackout(s) to delete. Typically, the result of an
				<code>admin:appserver-get-request-blackouts</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $app-id := xdmp:server("myAppserver")
  let $requestspec := admin:appserver-get-request-blackouts($config,
        $app-id )
  return
  admin:appserver-delete-request-blackout($config, $app-id, $requestspec)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="group-schema" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-schema">
		<summary>This function constructs a schema element with the specified prefix and URI.</summary>
		<params>
			<param name="namespace-uri" type="xs:string" optional="false">The namespace URI for the schema.</param>
			<param name="schema-location" type="xs:string" optional="false">The schema location.</param>
		</params>
		<return>element(gr:schema)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:group-schema("http://myuri/namespace", "/some/schema.xsd")
  (: the schema element :)

</example>
	</function>
	<function name="appserver-add-schema" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-add-schema">
		<summary>This function adds a schema binding definition to the existing schema binding definitions in the configuration for the specified App Server. Schemas with a schema binding definition are automatically imported into queries run against the App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="schemas" type="element(gr:schema)*" optional="false">A list of schema specification elements of the form:
				<pre xml:space="preserve">
&lt;schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://marklogic.com/xdmp/group"&gt;
  &lt;namespace-uri&gt;foo&lt;/namespace-uri&gt;
  &lt;schema-location&gt;/foo.xsd&lt;/schema-location&gt;
&lt;/schema&gt;
</pre>Typically the result of an
				<code>admin:group-schema</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-add-schema($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
  &lt;schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://marklogic.com/xdmp/group"&gt;
     &lt;namespace-uri&gt;foo&lt;/namespace-uri&gt;
     &lt;schema-location&gt;/foo.xsd&lt;/schema-location&gt;
  &lt;/schema&gt;)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-delete-schema" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-delete-schema">
		<summary>This function deletes a schema definition in the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="schemas" type="element(gr:schema)*" optional="false">A list of schema specification elements of the form:
				<pre xml:space="preserve">
&lt;schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://marklogic.com/xdmp/group"&gt;
  &lt;namespace-uri&gt;foo&lt;/namespace-uri&gt;
  &lt;schema-location&gt;/foo.xsd&lt;/schema-location&gt;
&lt;/schema&gt;
</pre>Typically the result of an
				<code>admin:group-schema</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-delete-schema($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
  &lt;schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://marklogic.com/xdmp/group"&gt;
     &lt;namespace-uri&gt;foo&lt;/namespace-uri&gt;
     &lt;schema-location&gt;/foo.xsd&lt;/schema-location&gt;
  &lt;/schema&gt;)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="group-namespace" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-namespace">
		<summary>This function constructs a namespace element with the specified prefix and URI.</summary>
		<params>
			<param name="prefix" type="xs:string" optional="false">The namespace prefix.</param>
			<param name="namespace-uri" type="xs:string" optional="false">The namespace URI.</param>
		</params>
		<return>element(gr:namespace)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:group-namespace("myprefix", "http://myuri/namespace")
  (: the namespace element :)


</example>
	</function>
	<function name="appserver-add-namespace" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-add-namespace">
		<summary>Add one or more namespaces to an App Server configuration, which will predefine the namespace(s) for all requests evaluated against the App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">The configuration for the cluster, typically the result of
				<code>admin:get-configuration()</code>call.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="namespaces" type="element(gr:namespace)*" optional="false">
				<p>A list of namespaces to add. Each namespace specification has the following form:</p>
				<pre xml:space="preserve">
  &lt;namespace xmlns="http://marklogic.com/xdmp/group"&gt;
    &lt;prefix&gt;myprefix&lt;/prefix&gt;
    &lt;namespace-uri&gt;http://myuri/forthisprefix&lt;/namespace-uri&gt;
  &lt;/namespace&gt;

</pre>Typically the result of an
				<code>admin:group-namespace</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:appserver-add-namespace($config,
    admin:appserver-get-id($config,(), "Docs"),
    &lt;namespace xmlns="http://marklogic.com/xdmp/group"&gt;
      &lt;prefix&gt;myprefix&lt;/prefix&gt;
      &lt;namespace-uri&gt;http://myuri/forthisprefix&lt;/namespace-uri&gt;
    &lt;/namespace&gt;)

  =&gt; The XML for new configuration with this namespace added.  Use
     this as the argument to admin:save-configuration to change
     the configuration.

</example>
	</function>
	<function name="appserver-delete-namespace" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-delete-namespace">
		<summary>This function deletes a namespace configuration from the configuration for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="namespaces" type="element(gr:namespace)*" optional="false">
				<p>A list of namespaces to add. Each namespace specification has the following form:</p>
				<pre xml:space="preserve">
  &lt;namespace xmlns="http://marklogic.com/xdmp/group"&gt;
    &lt;prefix&gt;myprefix&lt;/prefix&gt;
    &lt;namespace-uri&gt;http://myuri/forthisprefix&lt;/namespace-uri&gt;
  &lt;/namespace&gt;

</pre>Typically the result of an
				<code>admin:group-namespace</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-delete-namespace($config,
       admin:appserver-get-id($config, $groupid, "myAppServer"),
   &lt;namespace xmlns="http://marklogic.com/xdmp/group"&gt;
     &lt;prefix&gt;myprefix&lt;/prefix&gt;
     &lt;namespace-uri&gt;http://myuri/forthisprefix&lt;/namespace-uri&gt;
   &lt;/namespace&gt;)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-delete" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-delete">
		<summary>This function deletes one or more App Servers in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-ids" type="xs:unsignedLong*" optional="false">The ID(s) of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "myGroup")
  return
  admin:appserver-delete($config,
        admin:appserver-get-id($config, $groupid, "myAppServer") )
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="http-server-create" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:http-server-create">
		<summary>This function creates a new HTTP App Server with the specified name, root, and port in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="appserver-name" type="xs:string" optional="false">The name of the App Server. The name must be unique among the App Server names for the group.</param>
			<param name="root" type="xs:string" optional="false">The root of the App Server.</param>
			<param name="port" type="xs:unsignedLong" optional="false">The port on which the App Server listens. The port must be available on the host.</param>
			<param name="modules-id" type="item()" optional="false">The id of the modules database (for example,
				<code>xdmp:database("Modules")</code>). To specify the filesystem, use 0 or "file-system"</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any group or database whose ID you pass into this function must exist when the transaction begins, otherwise an exception is thrown. If you need to create the group and/or database, do so in a separate transaction before using them in in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "myGroup")
  return
  admin:http-server-create($config, $groupid, "myNewAppServer",
        "/space/mycode", 8005, 0, xdmp:database("myDatabase") )
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="xdbc-server-create" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:xdbc-server-create">
		<summary>This function creates a new XDBC App Server with the specified name, root, and port in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="appserver-name" type="xs:string" optional="false">The name of the App Server. The name must be unique among the App Server names for the group.</param>
			<param name="root" type="xs:string" optional="false">The path to the module directory root of this XDBC server.</param>
			<param name="port" type="xs:unsignedLong" optional="false">The port on which the App Server listens. The port must be available on the host.</param>
			<param name="modules-id" type="item()" optional="false">The id of the modules database (for example,
				<code>xdmp:database("Modules")</code>). To specify the filesystem, use 0 or "file-system"</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any group or database whose ID you pass into this function must exist when the transaction begins, otherwise an exception is thrown. If you need to create the group and/or database, do so in a separate transaction before using them in in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "myGroup")
  return
  admin:xdbc-server-create($config, $groupid, "myNewAppServer",
        "/space/mycode", 8005, 0, xdmp:database("myDatabase") )
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="webdav-server-create" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:webdav-server-create">
		<summary>This function creates a new WebDAV App Server with the specified name, library, and port in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="appserver-name" type="xs:string" optional="false">The name of the App Server. The name must be unique among the App Server names for the group.</param>
			<param name="root" type="xs:string" optional="false">The root of the App Server.</param>
			<param name="port" type="xs:unsignedLong" optional="false">The port on which the App Server listens. The port must be available on the host.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any group or database whose ID you pass into this function must exist when the transaction begins, otherwise an exception is thrown. If you need to create the group and/or database, do so in a separate transaction before using them in in this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "myGroup")
  return
  admin:webdav-server-create($config, $groupid, "myNewAppServer",
        "/space/mycode", 8005, xdmp:database("myDatabase") )
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-copy" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-copy">
		<summary>This function creates a new App Server specification with the same settings as the App Server with the specified ID. The new App Server configuration will have the specified name. You can copy the App Server to a new one either in the same group (by specifying $old-group-id and $new-group-id with the same group ID) or in a different group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="target-group-id" type="xs:unsignedLong?" optional="false">The optional group ID of the new group to which the App Server is copied. If no ID is provided, the appserver will be copied to the same group it exists in. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="appserver-name" type="xs:string" optional="false">The new name for the App Server.</param>
			<param name="port" type="xs:unsignedLong" optional="false">The port number for the new App Server.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  let $appserver-id := admin:appserver-get-id($config, $group-id,
                       "myAppServer")
  return
  admin:appserver-copy($config, $appserver-id, $group-id,
                       "myNewAppServer", 8012)

  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-name">
		<summary>This function returns the name of the task server for the specified group from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-name($config, $group-id)
  (: returns the name of the task server :)


</example>
	</function>
	<function name="taskserver-get-threads" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-threads">
		<summary>This function returns the number of threads configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-threads($config, $group-id)
  (: returns the number of threads configured on the task server :)


</example>
	</function>
	<function name="taskserver-get-debug-threads" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-debug-threads">
		<summary>This function returns the number of debug threads configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-debug-threads($config, $group-id)
  (: returns the number of debug threads configured on the task server :)



</example>
	</function>
	<function name="taskserver-get-default-time-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-default-time-limit">
		<summary>This function returns the default time limit configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-default-time-limit($config, $group-id)
  (: returns the default time limit configured on the task server :)



</example>
	</function>
	<function name="taskserver-get-max-time-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-max-time-limit">
		<summary>This function returns the maximum time limit configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-max-time-limit($config, $group-id)
  (: returns the maximum time limit configured on the task server :)



</example>
	</function>
	<function name="taskserver-get-queue-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-queue-size">
		<summary>This function returns the number queue size configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-queue-size($config, $group-id)
  (: returns the queue size configured on the task server :)


</example>
	</function>
	<function name="taskserver-get-pre-commit-trigger-depth" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-pre-commit-trigger-depth">
		<summary>This function returns the maximum pre-commit trigger depth configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-pre-commit-trigger-depth($config, $group-id)
  (: returns the pre-commit trigger depth configured on the task server :)


</example>
	</function>
	<function name="taskserver-get-post-commit-trigger-depth" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-post-commit-trigger-depth">
		<summary>This function returns the maximum post-commit trigger depth configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-post-commit-trigger-depth($config, $group-id)
  (: returns the post-commit trigger depth configured on the task server :)


</example>
	</function>
	<function name="taskserver-get-pre-commit-trigger-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-pre-commit-trigger-limit">
		<summary>This function returns the pre-commit trigger limit configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-pre-commit-trigger-limit($config, $group-id)
  (: returns the pre-commit trigger limit configured on the task server :)


</example>
	</function>
	<function name="taskserver-get-log-errors" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-log-errors">
		<summary>This function returns the value for the log-errors setting configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-log-errors($config, $group-id)
  (: returns the log-errors setting configured on the task server :)


</example>
	</function>
	<function name="taskserver-get-debug-allow" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-debug-allow">
		<summary>This function returns the value for the debug-allow setting configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-debug-allow($config, $group-id)
  (: returns the debug-allow setting configured on the task server :)


</example>
	</function>
	<function name="taskserver-get-profile-allow" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-get-profile-allow">
		<summary>This function returns the value for the profile-allow setting configured on the task server for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group-id := admin:group-get-id($config, "Default")
  return
  admin:taskserver-get-profile-allow($config, $group-id)
  (: returns the profile-allow setting configured on the task server :)


</example>
	</function>
	<function name="taskserver-set-threads" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-threads">
		<summary>This function sets the value in the configuration of the maximum number of threads for the specified task server. This is a "cold" operation; when you use
			<code>admin:save-configuration</code>to save the configuration, it will automatically restart MarkLogic Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new threads value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-threads($config, $groupid, 10)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-debug-threads" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-debug-threads">
		<summary>This function sets the value in the configuration of the maximum number of debug threads for the specified task server. This is a "cold" operation; when you use
			<code>admin:save-configuration</code>to save the configuration, it will automatically restart MarkLogic Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new threads value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-debug-threads($config, $groupid, 10)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-default-time-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-default-time-limit">
		<summary>This function sets the task server default time limit in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value for the time limit (specified the number of seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-default-time-limit($config, $groupid, 10000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-max-time-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-max-time-limit">
		<summary>This function sets the task server max time limit in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value for the max time limit (specified the number of seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-max-time-limit($config, $groupid, 10000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-queue-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-queue-size">
		<summary>This function sets the value in the configuration of the maximum queue size for the specified task server. This is a "cold" operation; when you use
			<code>admin:save-configuration</code>to save the configuration, it will automatically restart MarkLogic Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value for the queue size.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-queue-size($config, $groupid, 100000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-pre-commit-trigger-depth" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-pre-commit-trigger-depth">
		<summary>This function sets the value for the task server pre-commit trigger depth in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-pre-commit-trigger-depth($config, $groupid, 1000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-post-commit-trigger-depth" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-post-commit-trigger-depth">
		<summary>This function sets the value for the task server post-commit trigger depth in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new post-commit trigger depth.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-post-commit-trigger-depth($config, $groupid, 1000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-pre-commit-trigger-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-pre-commit-trigger-limit">
		<summary>This function sets the value for the task server pre-commit trigger depth in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-pre-commit-trigger-depth($config, $groupid, 1000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-log-errors" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-log-errors">
		<summary>This function sets the value for the log errors setting for the task server in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">The new boolean value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-log-errors($config, $groupid, 1000)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-debug-allow" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-debug-allow">
		<summary>This function sets the value for the debug allow setting for the task server in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">The new boolean value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-debug-allow($config, $groupid, fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="taskserver-set-profile-allow" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:taskserver-set-profile-allow">
		<summary>This function sets the value for the profile allow setting for the task server in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group to which the App Server belongs. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">The new boolean value.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:taskserver-set-profile-allow($config, $groupid, fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="group-get-host-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-host-ids">
		<summary>This function returns the IDs of all hosts belonging to the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-host-ids($config, admin:group-get-id($config,"myGroup"))
  (: returns the group's host IDs :)

</example>
	</function>
	<function name="group-get-appserver-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-appserver-ids">
		<summary>This function returns the IDs of all appservers belonging to the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-appserver-ids($config, admin:group-get-id($config,"myGroup"))
  (: returns the group's appserver IDs :)

</example>
	</function>
	<function name="group-get-httpserver-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-httpserver-ids">
		<summary>This function returns the IDs of all httpservers belonging to the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-httpserver-ids($config, admin:group-get-id($config,"myGroup"))
  (: returns the group's httpserver IDs :)

</example>
	</function>
	<function name="group-get-xdbcserver-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-xdbcserver-ids">
		<summary>This function returns the IDs of all xdbcservers belonging to the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-xdbcserver-ids($config, admin:group-get-id($config,"myGroup"))
  (: returns the group's xdbcserver IDs :)

</example>
	</function>
	<function name="group-get-webdavserver-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-webdavserver-ids">
		<summary>This function returns the IDs of all webdavservers belonging to the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-webdavserver-ids($config, admin:group-get-id($config,"myGroup"))
  (: returns the group's webdavserver IDs :)

</example>
	</function>
	<function name="group-get-taskserver-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-taskserver-id">
		<summary>This function returns the ID of of the taskserver belonging to the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-taskserver-id($config, admin:group-get-id($config,"myGroup"))
  (: returns the group's taskserver ID :)

</example>
	</function>
	<function name="group-get-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-id">
		<summary>This function returns the ID of the group. The difference between this function and
			<code>xdmp:group()</code>is that the ID from this function can come from a group that has not yet been saved (that is, from a group that has been created in the same query with the Admin library but has not yet been saved to the cluster configuration files). This ID enables you to completely configure a newly created group without the need to first save the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-name" type="xs:string" optional="false">The name of the group.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-id($config, "myGroup"))
  (: returns the group ID :)

</example>
	</function>
	<function name="group-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-name">
		<summary>This function returns the name of the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-name($config, admin:group-get-id($config, "myGroup"))
  (: returns the group name :)


</example>
	</function>
	<function name="group-get-list-cache-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-list-cache-size">
		<summary>This function returns the value for the list cache size setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-list-cache-size($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the list cache size value :)


</example>
	</function>
	<function name="group-get-list-cache-partitions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-list-cache-partitions">
		<summary>This function returns the value for the list cache partitions setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-list-cache-partitions($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the list cache partitions value :)


</example>
	</function>
	<function name="group-get-compressed-tree-cache-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-compressed-tree-cache-size">
		<summary>This function returns the value for the compressed tree cache size setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-compressed-tree-cache-size($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the compressed tree cache size value :)


</example>
	</function>
	<function name="group-get-compressed-tree-cache-partitions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-compressed-tree-cache-partitions">
		<summary>This function returns the value for the compressed tree cache partitions setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-compressed-tree-cache-partitions($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the compressed tree cache partitions value :)



</example>
	</function>
	<function name="group-get-compressed-tree-read-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-compressed-tree-read-size">
		<summary>This function returns the value for the compressed tree read size (in kilobytes) setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-compressed-tree-read-size($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the compressed tree read size value :)


</example>
	</function>
	<function name="group-get-expanded-tree-cache-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-expanded-tree-cache-size">
		<summary>This function returns the value for the expanded tree cache size setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-expanded-tree-cache-size($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the expanded tree cache size value :)


</example>
	</function>
	<function name="group-get-expanded-tree-cache-partitions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-expanded-tree-cache-partitions">
		<summary>This function returns the value for the expanded tree cache partitions setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-expanded-tree-cache-partitions($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the expanded tree cache partitions value :)



</example>
	</function>
	<function name="group-get-smtp-relay" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-smtp-relay">
		<summary>This function returns the value for the smtp relay setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-smtp-relay($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the smtp relay value :)



</example>
	</function>
	<function name="group-get-smtp-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-smtp-timeout">
		<summary>This function returns the value for the smtp timeout setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-smtp-timeout($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the smtp timeout value :)



</example>
	</function>
	<function name="group-get-http-user-agent" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-http-user-agent">
		<summary>This function returns the value for the http user agent setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-http-user-agent($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the http user agent value :)



</example>
	</function>
	<function name="group-get-http-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-http-timeout">
		<summary>This function returns the value for the http timeout setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-http-timeout($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the http timeout value :)



</example>
	</function>
	<function name="group-get-xdqp-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-xdqp-timeout">
		<summary>This function returns the value for the xdqp timeout setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-xdqp-timeout($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the xdqp timeout value :)

</example>
	</function>
	<function name="group-get-host-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-host-timeout">
		<summary>This function returns the value for the host timeout setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-host-timeout($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the host timeout value :)

</example>
	</function>
	<function name="group-get-host-initial-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-host-initial-timeout">
		<summary>This function returns the value for the host initial timeout setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-host-initial-timout($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the host initial timeout value :)

</example>
	</function>
	<function name="group-get-retry-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-retry-timeout">
		<summary>This function returns the value for the number of seconds a request will retry before timing out.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-host-retry-timout($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the host initial timeout value :)

</example>
	</function>
	<function name="group-get-system-log-level" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-system-log-level">
		<summary>This function returns the value for the system log level setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-system-log-level($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the system log level value :)

</example>
	</function>
	<function name="group-get-file-log-level" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-file-log-level">
		<summary>This function returns the value for the file log level setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-file-log-level($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the file log level value :)

</example>
	</function>
	<function name="group-get-rotate-log-files" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-rotate-log-files">
		<summary>This function returns the value for the rotate log files setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-rotate-log-files($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the rotate log files value :)

</example>
	</function>
	<function name="group-get-keep-log-files" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-keep-log-files">
		<summary>This function returns the value for the keep log files setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-keep-log-files($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the keep log files value :)

</example>
	</function>
	<function name="group-get-failover-enable" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-failover-enable">
		<summary>This function returns the value for the failover enable setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-failover-enable($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the failover enable value :)

</example>
	</function>
	<function name="group-get-trace-events-activated" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-trace-events-activated">
		<summary>This function returns the value for the trace events activated setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-trace-events-activated($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the trace events activated value :)

</example>
	</function>
	<function name="group-get-schemas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-schemas">
		<summary>This function returns the value of any schemas definitions predefined for the specified group. If none are defined, returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>element(gr:schema)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")

  return
     admin:group-get-schemas($config, $groupid)

</example>
	</function>
	<function name="group-get-namespaces" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-namespaces">
		<summary>This function returns the value of any namespace definitions predefined for the specified group. If none are defined, returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>element(gr:namespace)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-get-namespaces($config, $groupid)

</example>
	</function>
	<function name="group-get-trace-events" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-trace-events">
		<summary>This function returns the value of any trace events activated for the specified group. If none are defined, returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>element(gr:event)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-get-trace-events($config, $groupid)

</example>
	</function>
	<function name="group-set-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-name">
		<summary>This function changes the name of the group with the specified ID to the specified name.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new name for the group.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-name($config, $groupid, "myNewGroupName")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-list-cache-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-list-cache-size">
		<summary>This function changes the list cache size setting of the group with the specified ID to the specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new list cache value (in megabytes).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-list-cache-size($config, $groupid, 256)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-list-cache-partitions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-list-cache-partitions">
		<summary>This function changes the list cache partitions setting of the group with the specified ID to the specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value for the partions.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-list-cache-partitions($config, $groupid, 2)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-compressed-tree-cache-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-compressed-tree-cache-size">
		<summary>This function changes the compressed tree cache size setting of the group with the specified ID to the specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new cache value (in megabytes).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-compressed-tree-cache-size($config, $groupid, 256)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-compressed-tree-cache-partitions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-compressed-tree-cache-partitions">
		<summary>This function changes the compressed tree cache partitions setting of the group with the specified ID to the specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value for the partions.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-compressed-tree-cache-partitions($config, $groupid, 2)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-compressed-tree-read-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-compressed-tree-read-size">
		<summary>This function changes the compressed tree read size setting of the group with the specified ID to the specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new read size value (in kilobytes).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-compressed-tree-read-size($config, $groupid, 256)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-expanded-tree-cache-size" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-expanded-tree-cache-size">
		<summary>This function changes the expanded tree cache size setting of the group with the specified ID to the specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new cache value (in megabytes).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-expanded-tree-cache-size($config, $groupid, 256)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-expanded-tree-cache-partitions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-expanded-tree-cache-partitions">
		<summary>This function changes the expanded tree cache partitions setting of the group with the specified ID to the specified value.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new value for the partions.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-expanded-tree-cache-partitions($config, $groupid, 2)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-smtp-relay" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-smtp-relay">
		<summary>This function changes the SMTP relay setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new value for the SMTP relay host.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-smtp-relay($config, $groupid, "mail")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-smtp-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-smtp-timeout">
		<summary>This function changes the SMTP timeout setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new SMTP response timeout (in seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-smtp-timeout($config, $groupid, 30)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-http-user-agent" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-http-user-agent">
		<summary>This function changes the HTTP User-Agent setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new value for the HTTP User-Agent.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-http-user-agent($config, $groupid, "MarkLogic")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-http-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-http-timeout">
		<summary>This function changes the HTTP timeout setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new timeout setting (in seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-http-timeout($config, $groupid, 60)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-xdqp-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-xdqp-timeout">
		<summary>This function changes the XDQP timeout setting (the timeout for communication between data nodes and evaluator nodes) for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new timeout setting (in seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-xdqp-timout($config, $groupid, 20)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-host-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-host-timeout">
		<summary>This function changes the host timeout setting (the timeout for communication between hosts) for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new timeout setting (in seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-host-timout($config, $groupid, 60)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-host-initial-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-host-initial-timeout">
		<summary>This function changes the host initial timeout setting (the time the cluster will wait for a host to come online during cluster startup) for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new timeout setting (in seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-host-initial-timout($config, $groupid, 300)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-retry-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-retry-timeout">
		<summary>This function changes the the number of seconds a request will retry before timing out.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The new timeout setting (in seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-retry-timout($config, $groupid, 180)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-system-log-level" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-system-log-level">
		<summary>This function changes the host system log level setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new log level (must be one of
				<code>finest</code>,
				<code>finer</code>,
				<code>fine</code>,
				<code>debug</code>,
				<code>config</code>,
				<code>info</code>,
				<code>notice</code>,
				<code>warning</code>,
				<code>error</code>,
				<code>critical</code>,
				<code>alert</code>,
				<code>emergency</code>).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-system-log-level($config, $groupid, "debug")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-file-log-level" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-file-log-level">
		<summary>This function changes the host file log level setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new log level (must be one of
				<code>finest</code>,
				<code>finer</code>,
				<code>fine</code>,
				<code>debug</code>,
				<code>config</code>,
				<code>info</code>,
				<code>notice</code>,
				<code>warning</code>,
				<code>error</code>,
				<code>critical</code>,
				<code>alert</code>,
				<code>emergency</code>).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-file-log-level($config, $groupid, "debug")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-rotate-log-files" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-rotate-log-files">
		<summary>This function changes the rotate log files setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new log level (must be one of
				<code>never</code>,
				<code>daily</code>,
				<code>monday</code>,
				<code>tuesday</code>,
				<code>wednesday</code>,
				<code>thursday</code>,
				<code>friday</code>,
				<code>saturday</code>,
				<code>sunday</code>,
				<code>monthly</code>).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-rotate-log-files($config, $groupid, "wednesday")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-keep-log-files" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-keep-log-files">
		<summary>This function changes the keep log files setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">A number indicating the number of log files to keep before deleting them.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-keep-log-files($config, $groupid, 20)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-failover-enable" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-failover-enable">
		<summary>This function changes the failover enable setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">The new setting (true to enable failover for the group, false to disable it).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-failover-enable($config, $groupid, fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-trace-events-activated" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-trace-events-activated">
		<summary>This function changes the value for trace events in the group configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">The new trace event value (true for enabled, false for disabled).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-trace-events-activated($config, $groupid, fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-add-schema" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-add-schema">
		<summary>This function adds a schema binding definition to the existing schema binding definitions in the configuration for the specified Group. Schemas with a schema binding definition are automatically imported into queries run against any App Server in the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="schemas" type="element(gr:schema)*" optional="false">A list of schema specification elements of the form:
				<pre xml:space="preserve">
&lt;schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://marklogic.com/xdmp/group"&gt;
  &lt;namespace-uri&gt;foo&lt;/namespace-uri&gt;
  &lt;schema-location&gt;/foo.xsd&lt;/schema-location&gt;
&lt;/schema&gt;
</pre>Typically the result of an
				<code>admin:group-schema</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-add-schema($config, $groupid,
  &lt;schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://marklogic.com/xdmp/group"&gt;
     &lt;namespace-uri&gt;foo&lt;/namespace-uri&gt;
     &lt;schema-location&gt;/foo.xsd&lt;/schema-location&gt;
  &lt;/schema&gt;)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-delete-schema" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-delete-schema">
		<summary>This function deletes a schema binding definition to the existing schema binding definitions in the configuration for the specified Group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="schemas" type="element(gr:schema)*" optional="false">A list of schema specification elements of the form:
				<pre xml:space="preserve">
&lt;schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://marklogic.com/xdmp/group"&gt;
  &lt;namespace-uri&gt;foo&lt;/namespace-uri&gt;
  &lt;schema-location&gt;/foo.xsd&lt;/schema-location&gt;
&lt;/schema&gt;
</pre>Typically the result of an
				<code>admin:group-schema</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-delete-schema($config, $groupid,
  &lt;schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://marklogic.com/xdmp/group"&gt;
     &lt;namespace-uri&gt;foo&lt;/namespace-uri&gt;
     &lt;schema-location&gt;/foo.xsd&lt;/schema-location&gt;
  &lt;/schema&gt;)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-add-namespace" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-add-namespace">
		<summary>Add one or more namespaces to a Group configuration, which will predefine the namespace(s) for all requests evaluated against any App Server in the Group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="namespaces" type="element(gr:namespace)*" optional="false">A list of namespaces to add. Typically the result of an
				<code>admin:group-namespace</code>call.
				<p />Each namespace specification has the following form:
				<pre xml:space="preserve">
  &lt;namespace xmlns="http://marklogic.com/xdmp/group"&gt;
    &lt;prefix&gt;myprefix&lt;/prefix&gt;
    &lt;namespace-uri&gt;http://myuri/forthisprefix&lt;/namespace-uri&gt;
  &lt;/namespace&gt;

</pre></param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-add-namespace($config, $groupid,
       &lt;namespace xmlns="http://marklogic.com/xdmp/group"&gt;
         &lt;prefix&gt;myprefix&lt;/prefix&gt;
         &lt;namespace-uri&gt;http://myuri/forthisprefix&lt;/namespace-uri&gt;
        &lt;/namespace&gt;)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-delete-namespace" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-delete-namespace">
		<summary>This function deletes the specified namespaces from the configuration for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="namespaces" type="element(gr:namespace)*" optional="false">
				<p>A list of namespaces to delete. Each namespace specification has the following form:</p>
				<pre xml:space="preserve">
  &lt;namespace xmlns="http://marklogic.com/xdmp/group"&gt;
    &lt;prefix&gt;myprefix&lt;/prefix&gt;
    &lt;namespace-uri&gt;http://myuri/forthisprefix&lt;/namespace-uri&gt;
  &lt;/namespace&gt;

</pre>Typically the result of an
				<code>admin:group-namespace</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
     admin:group-delete-namespace($config, $groupid,
        admin:group-get-namespaces($config, $groupid))

  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-trace-event" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-trace-event">
		<summary>This function constructs an event element for the specified event name.</summary>
		<params>
			<param name="event-id" type="xs:string" optional="false">The exact name of the trace event.</param>
		</params>
		<return>element(gr:event)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  admin:group-trace-event("CPF on-state-enter")
  (: returns the event element for the CPF on state enter trace event :)

</example>
	</function>
	<function name="group-add-trace-event" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-add-trace-event">
		<summary>This function adds trace events to the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="events" type="element(gr:event)*" optional="false">Zero or more event specifications, which you can construct with the
				<code>admin:group-trace-event</code>function.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-add-trace-event($config,
      admin:group-get-id($config, "Default"),
      admin:group-trace-event("CPF on-state-enter"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-delete-trace-event" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-delete-trace-event">
		<summary>This function deletes the specified trace events from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="events" type="element(gr:event)*" optional="false">Zero or more event specifications, which you can construct with the
				<code>admin:group-trace-event</code>function.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-delete-trace-event($config,
      admin:group-get-id($config, "Default"),
      admin:group-trace-event("CPF on-state-enter"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-delete" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-delete">
		<summary>This function deletes one or more groups in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-ids" type="xs:unsignedLong*" optional="false">The IDs of the groups to be deleted. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<usage>Any group whose ID you pass into this function must not have any hosts belonging to it when the transaction begins, otherwise an exception is thrown. If you need to delete the group, remove its hosts in a separate transaction before calling this function.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-delete($config, admin:group-get-id($config, "myOldGroup"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-create" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-create">
		<summary>This function creates a new group with the specified name in the configuration. The new group has the default values.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-name" type="xs:string" optional="false">The name for the new group.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-create($config, "myNewGroup")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-copy" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-copy">
		<summary>This function creates a new group specification with the same settings as the group with the specified ID. The new group configuration will have the specified name.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="group-name" type="xs:string" optional="false">The name of the new group to create.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-copy($config, admin:group-get-id($config, "myOldGroup"),
                    "myNewGroup")

  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-get-audit-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-enabled">
		<summary>This function returns the value for the audit enabled setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-audit-enabled($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the failover enable value :)

</example>
	</function>
	<function name="group-set-audit-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-audit-enabled">
		<summary>This function changes the audit enabled setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">The new setting (true to enable auditing for the group, false to disable it).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-audit-enabled($config, $groupid, fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-get-rotate-audit-files" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-rotate-audit-files">
		<summary>This function returns the value for the rotate audit files setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-rotate-audit-files($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the rotate audit files value :)

</example>
	</function>
	<function name="group-get-keep-audit-files" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-keep-audit-files">
		<summary>This function returns the value for the keep audit files setting from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:group-get-keep-audit-files($config,
        admin:group-get-id($config, "myGroup"))
  (: returns the keep audit files value :)

</example>
	</function>
	<function name="group-set-rotate-audit-files" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-rotate-audit-files">
		<summary>This function changes the rotate audit files setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The new audit level (must be one of
				<code>never</code>,
				<code>daily</code>,
				<code>monday</code>,
				<code>tuesday</code>,
				<code>wednesday</code>,
				<code>thursday</code>,
				<code>friday</code>,
				<code>saturday</code>,
				<code>sunday</code>,
				<code>monthly</code>).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-rotate-audit-files($config, $groupid, "wednesday")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-set-keep-audit-files" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-keep-audit-files">
		<summary>This function changes the keep audit files setting for the group in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="value" type="xs:unsignedInt" optional="false">A number indicating the number of audit log files to keep before deleting them.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-keep-audit-files($config, $groupid, 20)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-enable-audit-event-type" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-enable-audit-event-type">
		<summary>This function changes the audit event type(s) enabled setting for the audit configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="event-type" type="xs:string*" optional="false">The event types to enable (must be one of: "amp-usage" "audit-configuration-change" "audit-shutdown" "audit-startup" "authentication-failure" "concurrent-request-denial" "configuration-change" "document-execute" "document-insert" "document-read" "document-update" "estimate" "eval" "exists" "lexicon-read" "no-permission" "no-privilege" "permission-change" "request-blackout-denial" "role-change-failure" "search" "security-access" "server-restart" "server-shutdown" "server-startup" "user-configuration-change" "user-role-addition" "user-role-removal" ).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-enable-audit-event-type($config, $groupid,
        ("no-permission","no-privilege"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
	to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-disable-audit-event-type" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-disable-audit-event-type">
		<summary>This function changes the audit event type(s) enabled setting for the audit configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="event-type" type="xs:string*" optional="false">The event types to disable (must be one of: "amp-usage" "audit-configuration-change" "audit-shutdown" "audit-startup" "authentication-failure" "concurrent-request-denial" "configuration-change" "document-execute" "document-insert" "document-read" "document-update" "estimate" "eval" "exists" "lexicon-read" "no-permission" "no-privilege" "permission-change" "request-blackout-denial" "role-change-failure" "search" "security-access" "server-restart" "server-shutdown" "server-startup" "user-configuration-change" "user-role-addition" "user-role-removal" ).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-disable-audit-event-type($config, $groupid,
        ("no-permission","no-privilege"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-get-audit-event-type-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-event-type-enabled">
		<summary>This function returns the audit event type's enabled setting for the audit configuration. A value of
			<code>true</code>is returned is the specified event type is set. Otherwise
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="event-type" type="xs:string" optional="false">The event type to check (must be one of: "amp-usage" "audit-configuration-change" "audit-shutdown" "audit-startup" "authentication-failure" "concurrent-request-denial" "configuration-change" "document-execute" "document-insert" "document-read" "document-update" "estimate" "eval" "exists" "lexicon-read" "no-permission" "no-privilege" "permission-change" "request-blackout-denial" "role-change-failure" "search" "security-access" "server-restart" "server-shutdown" "server-startup" "user-configuration-change" "user-role-addition" "user-role-removal" ).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-get-audit-event-type-enabled($config, $groupid,
        "no-permission")
  (: returns the new enabled status for the No-Permission event-type :)

</example>
	</function>
	<function name="group-set-audit-user-restriction" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-audit-user-restriction">
		<summary>This function restricts the audit configuration by excluding or including by user.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="restriction-type" type="xs:string" optional="false">The restriction type (must be one of: "inclusion" or "exclusion").</param>
			<param name="users" type="xs:string*" optional="false">The sequence of users affected by the restriction type.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-audit-user-restriction($config, $groupid,
        "exclusion",("admin1","admin2"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-get-audit-excluded-users" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-excluded-users">
		<summary>This function returns the users excluded from auditing. If auditing has a "inclusion" restriction, this function returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
    admin:group-get-audit-excluded-users($config, $groupid)
  (: returns a sequence of users in the excluded user restriction:)

</example>
	</function>
	<function name="group-get-audit-included-users" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-included-users">
		<summary>This function returns the users included from auditing. If auditing has a "exclusion" restriction, this function returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
    admin:group-get-audit-included-users($config, $groupid)
  (: returns a sequence of users in the included user restriction:)

</example>
	</function>
	<function name="group-set-audit-role-restriction" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-audit-role-restriction">
		<summary>This function restricts the audit configuration by excluding or including by role.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="restriction-type" type="xs:string" optional="false">The restriction type (must be one of: "inclusion" or "exclusion").</param>
			<param name="roles" type="xs:string*" optional="false">The sequence of roles affected by the restriction type.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-audit-role-restriction($config, $groupid,
        "exclusion",("admin-role","developer-role"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-get-audit-excluded-roles" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-excluded-roles">
		<summary>This function returns the roles excluded from auditing. If auditing has a "inclusion" restriction, this function returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
    admin:group-get-audit-excluded-roles($config, $groupid)
  (: returns a sequence of roles in the excluded role restriction:)

</example>
	</function>
	<function name="group-get-audit-included-roles" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-included-roles">
		<summary>This function returns the roles included from auditing. If auditing has a "exclusion" restriction, this function returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
    admin:group-get-audit-included-roles($config, $groupid)
  (: returns a sequence of roles in the included role restriction:)

</example>
	</function>
	<function name="group-set-audit-uri-restriction" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-audit-uri-restriction">
		<summary>This function restricts the audit configuration by excluding or including by document uri(s).</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="restriction-type" type="xs:string" optional="false">The restriction type (must be one of: "inclusion" or "exclusion").</param>
			<param name="uris" type="xs:string*" optional="false">The sequence of document-uris affected by the restriction type.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-audit-uri-restriction($config, $groupid,
        "inclusion",("/important/foo.xml","/important/foo1.xml"))
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-get-audit-excluded-uris" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-excluded-uris">
		<summary>This function returns the uris excluded from auditing. If auditing has a "inclusion" restriction, this function returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
    admin:group-get-audit-excluded-uris($config, $groupid)
  (: returns a sequence of uris in the excluded uri restriction:)

</example>
	</function>
	<function name="group-get-audit-included-uris" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-included-uris">
		<summary>This function returns the uris included from auditing. If auditing has a "exclusion" restriction, this function returns the empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
    admin:group-get-audit-included-uris($config, $groupid)
  (: returns a sequence of uris in the included uri restriction:)

</example>
	</function>
	<function name="group-set-audit-outcome-restriction" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-audit-outcome-restriction">
		<summary>This function restricts the audit configuration by auditing events only if they are "success" or "failure" events.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="outcome" type="xs:string*" optional="false">The outcomes to audit (must be one of: "success" or "failure" or "both").</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:group-set-audit-outcome-restriction($config, $groupid,
        "failure")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="group-get-audit-outcome-restriction" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-audit-outcome-restriction">
		<summary>This function returns whether auditing events are restricted by a success or failure outcome. Returns "success","failure", or "both"</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
    admin:group-get-audit-outcome-restriction($config, $groupid)
  (: returns either "success","failure", or "both":)

</example>
	</function>
	<function name="mimetypes-add" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="mimetypes" hidden="false" fullname="admin:mimetypes-add">
		<summary>This function adds mimetypes to the configuration. This function always requires a server restart to take effect.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="mimetypes" type="element(mt:mimetype)*" optional="false">A mimetype specification, typically the result of an
				<code>admin:mimetype</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $mimetype := admin:mimetype("application/foo","foo bar","binary")
  return
  admin:mimetypes-add($config, $mimetype)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="mimetypes-delete" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="mimetypes" hidden="false" fullname="admin:mimetypes-delete">
		<summary>This function deletes mimetypes from the configuration. This function always requires a server restart to take effect.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="mimetypes" type="element(mt:mimetype)*" optional="false">A mimetype specification, typically the result of an
				<code>admin:mimetype</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $mimetype := admin:mimetype("application/foo","foo bar","binary")
  return
  admin:mimetypes-delete($config, $mimetype)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="mimetypes-get" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="mimetypes" hidden="false" fullname="admin:mimetypes-get">
		<summary>This function returns all the mimetypes from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>element(mt:mimetype)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:mimetypes-get($config)
  (: returns the mimetypes specifications for the cluster :)

</example>
	</function>
	<function name="mimetype" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="mimetypes" hidden="false" fullname="admin:mimetype">
		<summary>This function constructs a mimetype specification.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the mimetype.</param>
			<param name="extensions" type="xs:string" optional="false">The extension(s) for the mimetype.</param>
			<param name="format" type="xs:string" optional="false">A valid format for the mimetype. Must be on of:
				<code>binary</code>,
				<code>xml</code>, or
				<code>text</code>.</param>
		</params>
		<return>element(mt:mimetype)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";
  return
  admin:mimetype("application/foo","foo bar","binary")
  (: returns the mimetype specification :)

</example>
	</function>
	<function name="database-daily-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-daily-backup">
		<summary>This function constructs a daily scheduled database backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory to save the backup.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The number of days to elapse between each backup</param>
			<param name="start-time" type="xs:time" optional="false">The time of day of the backup, in 24:00:00 notation.</param>
			<param name="max-backups" type="xs:unsignedLong" optional="false">The maximum number of backups to keep. When you reach the specified maximum number of backups, the next backup will delete the oldest backup. Specify 0 to keep an unlimited number of backups.</param>
			<param name="backup-security-db" type="xs:boolean" optional="false">Whether to backup the security database alongside the current backup.</param>
			<param name="backup-schemas-db" type="xs:boolean" optional="false">Whether to backup the schemas database alongside the current backup.</param>
			<param name="backup-triggers-db" type="xs:boolean" optional="false">Whether to backup the triggers database alongside the current backup.</param>
			<param name="include-replicas" type="xs:boolean" optional="true">If set to
				<code>false</code>, do not include the replicas in the backup. The default is
				<code>true</code>, which means to include all replicas in the backup.</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether or not to enable journal archiving. Defaults to
				<code>false</code>.</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path for where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong?" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 900.</param>
		</params>
		<return>element(db:database-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
   admin:database-daily-backup("/backup-dir", 2,
      xs:time("19:45:00"),10,true(),true(),true())

  (: returns the daily database backup specification :)

</example>
    <example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
   admin:database-daily-backup("/backup-dir", 2,
      xs:time("19:45:00"),10,true(),true(),true(),false(),true(),(),500)

  (: returns the daily database backup specification :)

</example>
	</function>
	<function name="database-hourly-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-hourly-backup">
		<summary>This function constructs a hourly scheduled database backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory to save the backup.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The number of hours to elapse between each backup.</param>
			<param name="start-minute" type="xs:nonNegativeInteger" optional="false">The number of minutes after the hour to start the backup. Note that this setting does not add to the backup period value.</param>
			<param name="max-backups" type="xs:unsignedLong" optional="false">The maximum number of backups to keep. When you reach the specified maximum number of backups, the next backup will delete the oldest backup. Specify 0 to keep an unlimited number of backups.</param>
			<param name="backup-security-db" type="xs:boolean" optional="false">Whether to backup the security database alongside the current backup.</param>
			<param name="backup-schemas-db" type="xs:boolean" optional="false">Whether to backup the schemas database alongside the current backup.</param>
			<param name="backup-triggers-db" type="xs:boolean" optional="false">Whether to backup the triggers database alongside the current backup.</param>
			<param name="include-replicas" type="xs:boolean" optional="true">If set to
				<code>false</code>, do not include the replicas in the backup. The default is
				<code>true</code>, which means to include all replicas in the backup.</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether or not to enable journal archiving. Defaults to
				<code>false</code>.</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path for where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong?" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 900.</param>
		</params>
		<return>element(db:database-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
    admin:database-hourly-backup("/backup-dir", 2,
      30, 10, true(), true(), true())

  (: Returns the hourly database backup specification. For example, if the current
     time is 2:15pm, the backup will run at 4:30pm, 6:30pm, 8:30pm, and so on. :)

</example>
    <example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
    admin:database-hourly-backup("/backup-dir", 2,
      30, 10, true(), true(), true(),false(),true(),(),500)

  (: Returns the hourly database backup specification. For example, if the current
     time is 2:15pm, the backup will run at 4:30pm, 6:30pm, 8:30pm, and so on. :)

</example>
	</function>
	<function name="database-minutely-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-minutely-backup">
		<summary>This function constructs a scheduled database backup on a number-of-minutes basis.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory to save the backup.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The number of minutes to elapse between each backup.</param>
			<param name="max-backups" type="xs:unsignedLong" optional="false">The maximum number of backups to keep. When you reach the specified maximum number of backups, the next backup will delete the oldest backup. Specify 0 to keep an unlimited number of backups.</param>
			<param name="backup-security-db" type="xs:boolean" optional="false">Whether to backup the security database alongside the current backup.</param>
			<param name="backup-schemas-db" type="xs:boolean" optional="false">Whether to backup the schemas database alongside the current backup.</param>
			<param name="backup-triggers-db" type="xs:boolean" optional="false">Whether to backup the triggers database alongside the current backup.</param>
			<param name="include-replicas" type="xs:boolean" optional="true">If set to
				<code>false</code>, do not include the replicas in the backup. The default is
				<code>true</code>, which means to include all replicas in the backup.</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether or not to enable journal archiving. Defaults to
				<code>false</code>.</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path for where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong?" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 900.</param>
		</params>
		<return>element(db:database-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
    admin:database-minutely-backup("/backup-dir", 45,
      10, true(), true(), true())

  (: Returns the minutely database backup specification. :)

</example>
    <example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
    admin:database-minutely-backup("/backup-dir", 45,
      10, true(), true(), true(),false(),true(),(),500)

  (: Returns the minutely database backup specification. :)

</example>
	</function>
	<function name="forest-hourly-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-hourly-backup">
		<summary>This function constructs a hourly scheduled forest backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory to save the backup.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The number of hours to elapse between each backup</param>
			<param name="start-minute" type="xs:nonNegativeInteger" optional="false">The number of minutes after the hour to start the backup. Note that this setting does not add to the backup period value.</param>
		</params>
		<return>element(as:forest-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
    admin:forest-hourly-backup("/backup-dir", 2, 30)

  (: returns the hourly forest backup specification. For example, if the
     current time is 2:15pm, the backup will run at 4:30pm, 6:30pm, 8:30pm,
     and so on. :)

</example>
	</function>
	<function name="forest-minutely-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-minutely-backup">
		<summary>This function constructs a scheduled forest backup on a number-of-minutes basis.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory to save the backup.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The number of minutes to elapse between each backup</param>
		</params>
		<return>element(as:forest-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
      admin:forest-minutely-backup("/backup-dir", 45)

  (: returns the minutely forest backup specification. :)

</example>
	</function>
	<function name="group-get-scheduled-tasks" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-get-scheduled-tasks">
		<summary>This function returns all of the tasks scheduled for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group on which the scheduled tasks are configured. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
		</params>
		<return>element(gr:scheduled-task)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
    admin:group-get-scheduled-tasks($config,
      admin:group-get-id($config, "Default"))

   =&gt;

  &lt;scheduled-task xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns="http://marklogic.com/xdmp/group"&gt;
    &lt;task-path&gt;/Scheduler_test.xqy&lt;/task-path&gt;
    &lt;task-root&gt;/Docs&lt;/task-root&gt;
    &lt;task-type&gt;minutely&lt;/task-type&gt;
    &lt;task-period&gt;15&lt;/task-period&gt;
    &lt;task-days/&gt;
    &lt;task-timestamp&gt;2009-02-27T12:16:06.152-08:00&lt;/task-timestamp&gt;
    &lt;task-database&gt;3439178527237237454&lt;/task-database&gt;
    &lt;task-modules&gt;0&lt;/task-modules&gt;
    &lt;task-user&gt;10677693687367813363&lt;/task-user&gt;
  &lt;/scheduled-task&gt;

</example>
	</function>
	<function name="group-add-scheduled-task" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-add-scheduled-task">
		<summary>This function adds one or more scheduled tasks to the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group on which the scheduled tasks are configured. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="scheduled-tasks" type="element(gr:scheduled-task)*" optional="false">One or more scheduled tasks, such as those created by the task-create functions.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  let $task := admin:group-hourly-scheduled-task(
      "/Scheduler_test.xqy",
      "/Docs",
      2,
      30,
      xdmp:database("Documents"),
      0,
      xdmp:user("Jim"),
      0)

  let $addTask := admin:group-add-scheduled-task($config,
      admin:group-get-id($config, "Default"), $task)

  return
      admin:save-configuration($addTask)

  (: Creates an hourly scheduled task and adds it to the "Default" group. :)

</example>
	</function>
	<function name="group-delete-scheduled-task" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-delete-scheduled-task">
		<summary>This function deletes one or more scheduled tasks from the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The ID of the group on which the scheduled tasks are configured. Typically, this is the result of an
				<code>admin:group-get-id</code>call.</param>
			<param name="scheduled-tasks" type="element(gr:scheduled-task)*" optional="false">One or more scheduled tasks.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config, "Default")
  let $tasks := admin:group-get-scheduled-tasks($config, $group)

  return
   admin:group-delete-scheduled-task($config, $group, $tasks)

  (: Returns a configuration element with the scheduled tasks in the
      "Default" group deleted -- use admin:save-configuration
      to save the changes to the configuration or pass the configuration
      to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="group-one-time-scheduled-task" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-one-time-scheduled-task">
		<summary>This function constructs a task to be invoked once, at a specific calendar day and time.</summary>
		<params>
			<param name="task-path" type="xs:string" optional="false">The name of the module to be invoked. The task path must begin with a forward slash (/) and cannot contain a question mark '?', colon ':' or pound '#' character.</param>
			<param name="task-root" type="xs:string" optional="false">The root directory (files system) or URI root (database) that contains the module. For example, if the module is located in the filesystem under MarkLogic/Docs, specify Docs.</param>
			<param name="task-start" type="xs:dateTime" optional="false">The date and time on which the task is to start.</param>
			<param name="task-database" type="xs:unsignedLong" optional="false">The id of the database on which the module is to be invoked.</param>
			<param name="task-modules" type="xs:unsignedLong" optional="false">The id of the modules database. For example, xdmp:database("Modules"). To specify the filesystem, use 0.</param>
			<param name="task-user" type="xs:unsignedLong" optional="false">The id of the user with permission to invoke the module. For example, xdmp:user("Jim").</param>
			<param name="task-host" type="xs:unsignedLong?" optional="false">The id of the host on which to invoke the module. Leave empty, (), to specify all hosts.</param>
			<param name="task-priority" type="xs:string?" optional="true">The priority of the task. Either "normal" or "higher".</param>
		</params>
		<return>element(gr:scheduled-task)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
     admin:group-one-time-scheduled-task(
        "/Scheduler_test.xqy",
        "/Docs",
        xs:dateTime("2009-03-29T14:42:52"),
        xdmp:database("Documents"),
        xdmp:database("Documents"),
        xdmp:user("Jim"),
	admin:host-get-id($config, xdmp:host-name()),
        "normal")

    (: returns a one-time scheduled task. :)

</example>
	</function>
	<function name="group-monthly-scheduled-task" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-monthly-scheduled-task">
		<summary>This function constructs a task to be invoked at monthly intervals.</summary>
		<params>
			<param name="task-path" type="xs:string" optional="false">The name of the module to be invoked. The task path must begin with a forward slash (/) and cannot contain a question mark '?', colon ':' or pound '#' character.</param>
			<param name="task-root" type="xs:string" optional="false">The root directory (files system) or URI root (database) that contains the module. For example, if the module is located in the filesystem under MarkLogic/Docs, specify Docs.</param>
			<param name="task-period" type="xs:positiveInteger" optional="false">The number of months to elapse between each invocation of the module.</param>
			<param name="task-month-day" type="xs:unsignedLong" optional="false">The day of the month to invoke the module.</param>
			<param name="task-start-time" type="xs:time" optional="false">The time of day (in 24:00 notation) to invoke the module.</param>
			<param name="task-database" type="xs:unsignedLong" optional="false">The id of the database on which the module is to be invoked.</param>
			<param name="task-modules" type="xs:unsignedLong" optional="false">The id of the modules database. For example, xdmp:database("Modules"). To specify the filesystem, use 0.</param>
			<param name="task-user" type="xs:unsignedLong" optional="false">The id of the user with permission to invoke the module. For example, xdmp:user("Jim").</param>
			<param name="task-host" type="xs:unsignedLong?" optional="false">The id of the host on which to invoke the module. Leave empty, (), to specify all hosts.</param>
			<param name="task-priority" type="xs:string?" optional="true">The priority of the task. Either "normal" or "higher".</param>
		</params>
		<return>element(gr:scheduled-task)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
     admin:group-monthly-scheduled-task(
        "/Scheduler_test.xqy",
        "/Docs",
	2,
	3,
	xs:time("14:42:52"),
        xdmp:database("Documents"),
        0,
        xdmp:user("Jim"),
	0,
        "normal")

     (: returns a monthly scheduled task. :)

</example>
	</function>
	<function name="group-weekly-scheduled-task" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-weekly-scheduled-task">
		<summary>This function constructs a task to be invoked at weekly intervals.</summary>
		<params>
			<param name="task-path" type="xs:string" optional="false">The name of the module to be invoked. The task path must begin with a forward slash (/) and cannot contain a question mark '?', colon ':' or pound '#' character.</param>
			<param name="task-root" type="xs:string" optional="false">The root directory (files system) or URI root (database) that contains the module. For example, if the module is located in the filesystem under MarkLogic/Docs, specify Docs.</param>
			<param name="task-period" type="xs:positiveInteger" optional="false">The number of weeks to elapse between each invocation of the module.</param>
			<param name="task-days" type="xs:string+" optional="false">One or more days on the specified week to invoke the module</param>
			<param name="task-start-time" type="xs:time" optional="false">The time of day (in 24:00 notation) to invoke the module.</param>
			<param name="task-database" type="xs:unsignedLong" optional="false">The id of the database on which the module is to be invoked.</param>
			<param name="task-modules" type="xs:unsignedLong" optional="false">The id of the modules database. For example, xdmp:database("Modules"). To specify the filesystem, use 0.</param>
			<param name="task-user" type="xs:unsignedLong" optional="false">The id of the user with permission to invoke the module. For example, xdmp:user("Jim").</param>
			<param name="task-host" type="xs:unsignedLong?" optional="false">The id of the host on which to invoke the module. Leave empty, (), to specify all hosts.</param>
			<param name="task-priority" type="xs:string?" optional="true">The priority of the task. Either "normal" or "higher".</param>
		</params>
		<return>element(gr:scheduled-task)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
     admin:group-weekly-scheduled-task(
        "/Scheduler_test.xqy",
        "/Docs",
        2,
        ("Monday", "Wednesday"),
        xs:time("14:42:52"),
        xdmp:database("Documents"),
        xdmp:database("Documents"),
        xdmp:user("Jim"),
        admin:host-get-id($config, xdmp:host-name()),
        "normal")

     (: returns a weekly scheduled task. :)

</example>
	</function>
	<function name="group-daily-scheduled-task" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-daily-scheduled-task">
		<summary>This function constructs a task to be invoked at daily intervals.</summary>
		<params>
			<param name="task-path" type="xs:string" optional="false">The name of the module to be invoked. The task path must begin with a forward slash (/) and cannot contain a question mark '?', colon ':' or pound '#' character.</param>
			<param name="task-root" type="xs:string" optional="false">The root directory (files system) or URI root (database) that contains the module. For example, if the module is located in the filesystem under MarkLogic/Docs, specify Docs.</param>
			<param name="task-period" type="xs:positiveInteger" optional="false">The number of days to elapse between each invocation of the module.</param>
			<param name="task-start-time" type="xs:time" optional="false">The time of day (in 24:00 notation) to invoke the module.</param>
			<param name="task-database" type="xs:unsignedLong" optional="false">The id of the database on which the module is to be invoked.</param>
			<param name="task-modules" type="xs:unsignedLong" optional="false">The id of the modules database. For example, xdmp:database("Modules"). To specify the filesystem, use 0.</param>
			<param name="task-user" type="xs:unsignedLong" optional="false">The id of the user with permission to invoke the module. For example, xdmp:user("Jim").</param>
			<param name="task-host" type="xs:unsignedLong?" optional="false">The id of the host on which to invoke the module. Leave empty, (), to specify all hosts.</param>
			<param name="task-priority" type="xs:string?" optional="true">The priority of the task. Either "normal" or "higher".</param>
		</params>
		<return>element(gr:scheduled-task)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
     admin:group-daily-scheduled-task(
        "/Scheduler_test.xqy",
        "/Docs",
        2,
        xs:time("09:30:00"),
        xdmp:database("Documents"),
        xdmp:database("Modules"),
        xdmp:user("Jim"),
        0,
        "normal")

  (: returns a daily scheduled task. :)

</example>
	</function>
	<function name="group-hourly-scheduled-task" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-hourly-scheduled-task">
		<summary>This function constructs a task to be invoked at hourly intervals.</summary>
		<params>
			<param name="task-path" type="xs:string" optional="false">The name of the module to be invoked. The task path must begin with a forward slash (/) and cannot contain a question mark '?', colon ':' or pound '#' character.</param>
			<param name="task-root" type="xs:string" optional="false">The root directory (filesystem) or URI root (database) that contains the module. For example, if the module is located in the filesystem under MarkLogic/Docs, specify Docs.</param>
			<param name="task-period" type="xs:positiveInteger" optional="false">The number of hours to elapse between each invocation of the module.</param>
			<param name="task-minute" type="xs:nonNegativeInteger" optional="false">The number of minutes after the hour to invoke the module. This value must be 59 or less. Note that this setting does not add to the task-period value.</param>
			<param name="task-database" type="xs:unsignedLong" optional="false">The id of the database on which the module is to be invoked.</param>
			<param name="task-modules" type="xs:unsignedLong" optional="false">The id of the modules database. For example, xdmp:database("Modules"). To specify the filesystem, use 0.</param>
			<param name="task-user" type="xs:unsignedLong" optional="false">The id of the user with permission to invoke the module. For example, xdmp:user("Jim").</param>
			<param name="task-host" type="xs:unsignedLong?" optional="false">The id of the host on which to invoke the module. Leave empty, (), to specify all hosts.</param>
			<param name="task-priority" type="xs:string?" optional="true">The priority of the task. Either "normal" or "higher".</param>
		</params>
		<return>element(gr:scheduled-task)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
     admin:group-hourly-scheduled-task(
         "/Scheduler_test.xqy",
         "/Docs",
         2,
         30,
         xdmp:database("Documents"),
         0,
         xdmp:user("Jim"),
         0,
        "normal")

    (: returns an hourly scheduled task. :)

</example>
	</function>
	<function name="group-minutely-scheduled-task" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Scheduler" hidden="false" fullname="admin:group-minutely-scheduled-task">
		<summary>This function constructs a task to be invoked at intervals defined in terms of minutes.</summary>
		<params>
			<param name="task-path" type="xs:string" optional="false">The name of the module to be invoked. The task path must begin with a forward slash (/) and cannot contain a question mark '?', colon ':' or pound '#' character.</param>
			<param name="task-root" type="xs:string" optional="false">The root directory (filesystem) or URI root (database) that contains the module. For example, if the module is located in the filesystem under MarkLogic/Docs, specify Docs.</param>
			<param name="task-period" type="xs:positiveInteger" optional="false">The number of minutes to elapse between each invocation of the module.</param>
			<param name="task-database" type="xs:unsignedLong" optional="false">The id of the database on which the module is to be invoked.</param>
			<param name="task-modules" type="xs:unsignedLong" optional="false">The id of the modules database. For example, xdmp:database("Modules"). To specify the filesystem, use 0.</param>
			<param name="task-user" type="xs:unsignedLong" optional="false">The id of the user with permission to invoke the module. For example, xdmp:user("Jim").</param>
			<param name="task-host" type="xs:unsignedLong?" optional="false">The id of the host on which to invoke the module. Leave empty, (), to specify all hosts.</param>
			<param name="task-priority" type="xs:string?" optional="true">The priority of the task. Either "normal" or "higher".</param>
		</params>
		<return>element(gr:scheduled-task)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
     admin:group-minutely-scheduled-task(
        "/Scheduler_test.xqy",
        "/Docs",
        45,
        xdmp:database("Documents"),
        0,
        xdmp:user("Jim"),
        0,
        "normal")

    (: returns a minutely scheduled task. :)

</example>
	</function>
	<function name="appserver-get-ssl-certificate-template" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-ssl-certificate-template">
		<summary>This function returns the id of the SSL certificate template used by the specified App Server. If no template is set for the App Server, 0 is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
     admin:appserver-get-ssl-certificate-template($config, $appServer)

    (: returns the id of the SSL certificate template. :)

</example>
	</function>
	<function name="appserver-get-ssl-ciphers" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-ssl-ciphers">
		<summary>This function returns the SSL ciphers set for the App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
     admin:appserver-get-ssl-ciphers($config, $appServer)

  (: returns the SSL ciphers set for the App Server. :)

</example>
	</function>
	<function name="appserver-get-ssl-hostname" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-ssl-hostname">
		<summary>This function returns the SSL hostname for the specified App Server. If no hostname is set, nothing is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
     admin:appserver-get-ssl-hostname($config, $appServer)

  (: returns the SSL hostname for the App Server, if set. :)

</example>
	</function>
	<function name="appserver-set-ssl-certificate-template" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-ssl-certificate-template">
		<summary>This function sets an SSL certificate template for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedLong" optional="false">The id of the certificate template. This would typically be the result of a
				<code>pki:insert-template(pki:create-template())</code>call.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "myAppServer")
  let $tid := pki:template-get-id(pki:get-template-by-name("mycert"))

  return
     admin:appserver-set-ssl-certificate-template(
                          $config,
                          $appServer,
                          $tid)

  (: Sets the certificate template, "mycert," for the "myAppServer" App Server. :)

</example>
	</function>
	<function name="appserver-set-ssl-ciphers" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-ssl-ciphers">
		<summary>This function sets SSL ciphers for the specified App Server. This is the standard cipher specification string for OpenSSL.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The SSL ciphers to set.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
     admin:appserver-set-ssl-ciphers($config, $appServer, "All")

  (: Sets the ciphers for the "Docs" App Server to "All".  :)

</example>
	</function>
	<function name="appserver-set-ssl-hostname" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-ssl-hostname">
		<summary>This function sets an SSL hostname for the specified App Server.
			<p>The SSL hostname should only be set when a proxy or load balancer is used to represent multiple servers. In this case, you can specify an SSL hostname with this function and all instances of the application server will identify themselves as that host.</p></summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The SSL hostname.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
     admin:appserver-set-ssl-hostname($config, $appServer, "AllHost")

  (: Sets the SSL hostname for the "Docs" App Server to "AllHost".  :)

</example>
	</function>
	<function name="appserver-get-ssl-allow-sslv3" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-ssl-allow-sslv3">
		<summary>This function returns true if the SSL v3 protocol is enabled for the specified App Server, or false if SSL v3 is disabled.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
      admin:appserver-get-ssl-allow-sslv3($config, $appServer)

   (: Returns true if SSL v3 is enabled for the "Docs" App Server.  Otherwise false. :)

</example>
	</function>
	<function name="appserver-get-ssl-allow-tls" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-ssl-allow-tls">
		<summary>This function returns true if the TLS protocol is enabled for the specified App Server, or false if TLS is disabled.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
      admin:appserver-get-ssl-allow-tls($config, $appServer)

   (: Returns true if TLS is enabled for the "Docs" App Server.  Otherwise false. :)

</example>
	</function>
	<function name="appserver-get-ssl-client-certificate-authorities" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-ssl-client-certificate-authorities">
		<summary>This function returns the id(s) of the client certificate authority for the specified App Server. If no client certificate authority is set, this function returns an empty sequence.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
     admin:appserver-get-ssl-client-certificate-authorities($config, $appServer)

  (: Returns the id(s) of the client certificate authority for the "Docs" App Server, if set.
  Otherwise returns an empty sequence. :)

</example>
	</function>
	<function name="appserver-set-ssl-allow-sslv3" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-ssl-allow-sslv3">
		<summary>This function enables or disables the SSL v3 protocol for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
      admin:appserver-set-ssl-allow-sslv3($config, $appServer, fn:false())

   (: Disables SSL v3 for the "Docs" App Server. :)

</example>
	</function>
	<function name="appserver-set-ssl-allow-tls" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-ssl-allow-tls">
		<summary>This function enables or disables the TLS protocol for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
       admin:appserver-set-ssl-allow-tls($config, $appServer, fn:true())

   (: Enables TLS for the "Docs" App Server. :)

</example>
	</function>
	<function name="appserver-set-ssl-client-certificate-authorities" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-ssl-client-certificate-authorities">
		<summary>This function sets one or more client certificate authorities that sign client certificates for the specified App Server. This function is typically used along with the
			<code>pki:insert-trusted-certificates</code>and
			<code>pki:get-trusted-certificate-ids</code>functions to import trusted Certificate Authorities for client certificates.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:unsignedLong*" optional="false">One or more ids for trusted certificates generated by the certificate authority to be set.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace pki = "http://marklogic.com/xdmp/pki"
        at "/MarkLogic/pki.xqy";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
  at "/MarkLogic/admin.xqy";

  declare namespace x509 = "http://marklogic.com/xdmp/x509";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  let $appservid := admin:appserver-get-id($config, $groupid, "myAppServer")

  let $cert-id :=
    for $cert in pki:get-certificates(pki:get-trusted-certificate-ids())
      where $cert/x509:cert/x509:subject/x509:commonName eq "Acme Certificate Authority" and
            $cert/x509:cert/x509:subject/x509:organizationName eq "Acme Corporation"
    return
      fn:data($cert/pki:certificate-id)

  return
    admin:appserver-set-ssl-client-certificate-authorities(
	$config,
        $appservid,
	$cert-id)

  (: Locates the trusted certificates from the Certificate Authority, "Acme
     Corporation," with the common name of "Acme Certificate Authority" and
     adds the Certificate Authority to the list of Client Certificate Authorities
     for the App Server, "myAppServer." :)

</example>
	</function>
	<function name="forest-daily-backup" lib="admin" category="Admin Library" bucket="XQuery Library Modules" hidden="false" fullname="admin:forest-daily-backup">
		<summary>This function constructs a daily scheduled forest backup.</summary>
		<params>
			<param name="backup-dir" type="xs:string" optional="false">The directory to save the backup.</param>
			<param name="backup-period" type="xs:positiveInteger" optional="false">The number of days to elapse between each backup.</param>
			<param name="start-time" type="xs:time" optional="false">The time of day of the backup, in 24:00:00 notation.</param>
		</params>
		<return>element(as:forest-backup)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  admin:forest-daily-backup("/backup-dir", 2, xs:time("19:45:00"))

  (: returns a daily forest backup specification. :)

</example>
	</function>
	<function name="database-set-tf-normalization" lib="admin" category="Admin Library" bucket="XQuery Library Modules" hidden="false" fullname="admin:database-set-tf-normalization">
		<summary>This function specifies whether to use the default term-frequency normalization (
			<code>scaled-log</code>), which scales the term frequency based on the size of the document, or to use the
			<code>unscaled-log</code>, which uses term frequency as a function of the actual term frequency in a document, regardless of the document size.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:string" optional="false">The new term-frequency normalization setting. Must be one of:
				<code>scaled-log</code>or
				<code>unscaled-log</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  let $db := admin:database-get-id($config, "myDatabase")

  return   &lt;apidoc:param name="config" type="element(configuration)"&gt;
     A configuration specification, typically as returned
     from one of the Admin module functions.
   &lt;/apidoc:param&gt;
   &lt;apidoc:param name="group-id" type="xs:unsignedLong"&gt;
     The name of the group.
   &lt;/apidoc:param&gt;
      admin:database-set-tf-normalization($config, $db, "unscaled-log")

  (: Sets the term-frequency normalization setting to "unscaled-log" for the
     database, "myDatabase." :)

</example>
	</function>
	<function name="database-get-tf-normalization" lib="admin" category="Admin Library" bucket="XQuery Library Modules" hidden="false" fullname="admin:database-get-tf-normalization">
		<summary>This function returns the current term-frequency normalization setting for the database. The returned value is either (
			<code>scaled-log</code>), which means to scale the term frequency based on the size of the document, or
			<code>unscaled-log</code>, which means to use term frequency as a function of the actual term frequency in a document, regardless of the document size.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  let $db := admin:database-get-id($config, "myDatabase")

  return
      admin:database-get-tf-normalization($config, $db)

  (: Returns the term-frequency normalization setting for the database, "myDatabase." :)

</example>
	</function>
	<function name="group-get-xdqp-ssl-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-xdqp-ssl-enabled">
		<summary>This function returns
			<code>true</code>if SSL is enabled for the group. Otherwise,
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config,"Default")

  return
     admin:group-get-xdqp-ssl-enabled($config, $group)

  (: Returns 'true' if SSL is enabled for the Default group.  Otherwise, 'false'. :)

</example>
	</function>
	<function name="group-get-xdqp-ssl-allow-sslv3" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-xdqp-ssl-allow-sslv3">
		<summary>This function returns
			<code>true</code>if the SSL v3 protocol is enabled for the group. Otherwise,
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config,"Default")

  return
     admin:group-get-xdqp-ssl-allow-sslv3($config, $group)

  (: Returns 'true' if the SSL v3 protocol is enabled for the Default group.
     Otherwise, 'false'. :)

</example>
	</function>
	<function name="group-get-xdqp-ssl-allow-tls" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-xdqp-ssl-allow-tls">
		<summary>This function returns
			<code>true</code>if the TLS protocol is enabled for the group. Otherwise,
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config,"Default")

  return
     admin:group-get-xdqp-ssl-allow-tls($config, $group)

  (: Returns 'true' if the TLS protocol is enabled for the Default group.
     Otherwise, 'false'. :)

</example>
	</function>
	<function name="group-get-xdqp-ssl-ciphers" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-get-xdqp-ssl-ciphers">
		<summary>This function returns the SSL ciphers set for the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config,"Default")

  return
     admin:group-get-xdqp-ssl-ciphers($config, $group)

  (: Returns the SSL cipher settings for the Default group. :)

</example>
	</function>
	<function name="group-set-xdqp-ssl-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-xdqp-ssl-enabled">
		<summary>This function enables or disables SSL for the group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
			<param name="value" type="xs:boolean" optional="false">Specify
				<code>true</code>to enable SSL for the group or
				<code>false</code>to disable SSL.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config,"Default")

  return
        admin:group-set-xdqp-ssl-enabled($config, $group, fn:false())

  (: Disables SSL on the Default group. :)

</example>
	</function>
	<function name="group-set-xdqp-ssl-allow-sslv3" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-xdqp-ssl-allow-sslv3">
		<summary>This function enables or disables the SSL v3 protocol for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
			<param name="value" type="xs:boolean" optional="false">Specify
				<code>true</code>to enable the SSL v3 protocol for the group or
				<code>false</code>to disable the SSL v3 protocol.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config,"Default")

  return
        admin:group-set-xdqp-ssl-allow-sslv3($config, $group, fn:false())

  (: Disables the SSL v3 protocol on the Default group. :)

</example>
	</function>
	<function name="group-set-xdqp-ssl-allow-tls" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-xdqp-ssl-allow-tls">
		<summary>This function enables or disables the TLS protocol for the specified group.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
			<param name="value" type="xs:boolean" optional="false">Specify
				<code>true</code>to enable the TLS protocol for the group or
				<code>false</code>to disable the TLS protocol.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config,"Default")

  return
        admin:group-set-xdqp-ssl-allow-tls($config, $group, fn:true())

  (: Enables the TLS protocol on the Default group. :)

</example>
	</function>
	<function name="group-set-xdqp-ssl-ciphers" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-set-xdqp-ssl-ciphers">
		<summary>This function sets SSL ciphers for the specified group. This is the standard cipher specification string for OpenSSL.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-id" type="xs:unsignedLong" optional="false">The name of the group.</param>
			<param name="value" type="xs:string" optional="false">The SSL ciphers to set.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $group := admin:group-get-id($config,"Default")

  return
        admin:group-set-xdqp-ssl-ciphers($config, $group, "All")

  (: Sets the ciphers for the Default group to "All".  :)

</example>
	</function>
	<function name="appserver-get-ssl-require-client-certificate" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-ssl-require-client-certificate">
		<summary>This function returns true if a client certificate is required for the specified App Server. Otherwise, it returns false.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  return
     admin:appserver-get-ssl-require-client-certificate($config,
         admin:appserver-get-id($config,(), "Docs"))

  (: Returns true if a client certificate is required for the "Docs" App Server.  Otherwise, false.  :)

</example>
	</function>
	<function name="appserver-set-ssl-require-client-certificate" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-ssl-require-client-certificate">
		<summary>This function determines whether or not a client certificate is required for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $appServer := admin:appserver-get-id($config,
          admin:group-get-id($config, "Default"),
          "Docs")

  return
      admin:appserver-set-ssl-require-client-certificate($config, $appServer, fn:false())

  (: Specifies that the "Docs" App Server does not require a client certificate. :)

</example>
	</function>
	<function name="database-exists" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-exists">
		<summary>This function determines whether or not the specified database exists. Returns
			<code>true</code>if the database exists, otherwise
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-name" type="xs:string" optional="false">The name of the database to check.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  return admin:database-exists($config, "Documents")

  (: Returns true if the Documents database exists. :)

</example>
	</function>
	<function name="forest-exists" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-exists">
		<summary>This function determines whether or not the specified forest exists. Returns
			<code>true</code>if the forest exists, otherwise
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-name" type="xs:string" optional="false">The name of the forest to check.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  return admin:forest-exists($config, "Documents")

  (: Returns true, if the Documents forest exists. :)

</example>
	</function>
	<function name="forest-get-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-database">
		<summary>This function returns the ID of the database that uses the specified forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the forest used by the database to be returned (for example,
				<code>xdmp:forest("myForest")</code>).</param>
		</params>
		<return>xs:unsignedLong?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $forest := xdmp:forest("Documents")

  return admin:forest-get-database($config, $forest)

  (: Returns the ID of the database that uses the Documents forest. :)

</example>
	</function>
	<function name="forest-get-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-replicas">
		<summary>This function returns the IDs of the forest replicas for the specified forest. If it returns the empty sequence, then no replacas are assigned to the specified forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the forest having the replica forests to be returned (for example,
				<code>xdmp:forest("myForest")</code>).</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $forest := xdmp:forest("Documents")

  return admin:forest-get-replicas($config, $forest)

  (: Returns the forest replicas associated with the Documents forest. :)

</example>
	</function>
	<function name="forest-add-replica" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-add-replica">
		<summary>This function adds a forest replica to a master forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="master-id" type="xs:unsignedLong" optional="false">The ID of the master forest to which to add the replica forest (for example,
				<code>xdmp:forest("MasterForest")</code>).</param>
			<param name="replica-id" type="xs:unsignedLong" optional="false">The ID of the replica forest to add to the master forest (for example,
				<code>xdmp:forest("ReplicaForest")</code>).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $forest := xdmp:forest("Documents")
  let $replica-forest := xdmp:forest("my-replica")

  return admin:forest-add-replica($config, $forest, $replica-forest)

  (: returns the new configuration element --
     use admin:save-configuration to save the changes to the
     configuration or pass the configuration to other
     Admin API functions to make other changes.  :)



</example>
	</function>
	<function name="forest-remove-replica" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-remove-replica">
		<summary>This function removes a forest replica from a master forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="master-id" type="xs:unsignedLong" optional="false">The ID of the master forest from which to remove the replica forest (for example,
				<code>xdmp:forest("MasterForest")</code>).</param>
			<param name="replica-id" type="xs:unsignedLong" optional="false">The ID of the replica forest to remove from the master forest (for example,
				<code>xdmp:forest("ReplicaForest")</code>).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $forest := xdmp:forest("failover1")
  let $replica-forest := xdmp:forest("replica1")

  return admin:forest-remove-replica($config, $forest, $replica-forest)

  (: returns the new configuration element --
     use admin:save-configuration to save the changes to the
     configuration or pass the configuration to other
     Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="host-exists" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="host" hidden="false" fullname="admin:host-exists">
		<summary>This function determines whether or not the specified Host exists. Returns
			<code>true</code>if the Host exists, otherwise
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-name" type="xs:string" optional="false">The name of the host to check.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  return admin:host-exists($config, "hp6910-624v64b.marklogic.com")

  (: Returns true, if the specified host exists. :)

</example>
	</function>
	<function name="appserver-exists" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-exists">
		<summary>This function determines whether or not the specified App Server exists. Returns
			<code>true</code>if the App Server exists, otherwise
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-ids" type="xs:unsignedLong*" optional="false">The list of group IDs returned from the
				<code>admin:get-group-ids</code>function.</param>
			<param name="appserver-name" type="xs:string" optional="false">The name of the App Server to check.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groups := admin:get-group-ids($config)

  return admin:appserver-exists($config, $groups, "Admin")

  (: Returns true, if the Admin App Server exists. :)

</example>
	</function>
	<function name="group-exists" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="group" hidden="false" fullname="admin:group-exists">
		<summary>This function determines whether or not the specified Group exists. Returns
			<code>true</code>if the Group exists, otherwise
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="group-name" type="xs:string" optional="false">The name of the group to check.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  return admin:group-exists($config, "Default")

  (: Returns true, if the Default group exists. :)

</example>
	</function>
	<function name="database-set-field-value-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-value-positions">
		<summary>This function sets the field value positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database to copy (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-value-positions($config,
        xdmp:database("myDatabase"), "my-field", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-set-field-value-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-field-value-searches">
		<summary>This function sets the field value searches setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database to copy (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
			<param name="value" type="xs:boolean?" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-field-value-searches($config,
        xdmp:database("myDatabase"), "my-field", fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-field-value-positions" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-value-positions">
		<summary>This function gets the field value positions setting for the specified database in the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database to copy (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-value-positions($config,
        xdmp:database("myDatabase"), "my-field")
  (: returns the field value positions setting :)

</example>
	</function>
	<function name="database-get-field-value-searches" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-field-value-searches">
		<summary>This function....</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database to copy (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="field-name" type="xs:string" optional="false">The name of the field.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-field-value-searches($config,
       xdmp:database("myDatabase"), "my-field")
  (: returns the field value searches setting :)

</example>
	</function>
	<function name="database-set-preload-replica-mapped-data" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-set-preload-replica-mapped-data">
		<summary>This function....</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
			<param name="value" type="xs:boolean" optional="false">A boolean value,
				<code>fn:true()</code>to enable,
				<code>fn:false()</code>to disable.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-set-preload-replica-mapped-data($config,
        xdmp:database("myDatabase"), fn:true())
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)

</example>
	</function>
	<function name="database-get-preload-replica-mapped-data" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-preload-replica-mapped-data">
		<summary>This function returns the preload replica mapped data setting for the specified database from the configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database (for example,
				<code>xdmp:database("myDatabase")</code>).</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  return
  admin:database-get-preload-replica-mapped-data($config,
       xdmp:database("myDatabase"))
  (: returns the preload mapped data setting :)

</example>
	</function>
	<function name="database-foreign-replica" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-replica">
		<summary>This function returns a replica database configuration. Use the output of this function in the
			<code>admin:database-set-foreign-replicas</code>function to place the replica database configuration into the cluster configuration.</summary>
		<params>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster containing the replica database.</param>
			<param name="foreign-database-id" type="xs:unsignedLong" optional="false">The id of the replica database.</param>
			<param name="connect-forests-by-name" type="xs:boolean" optional="false">Boolean that indicates whether to connect to forests by name. If
				<code>fn:true</code>, forests will automatically connect to/from foreign forests of the same name. If
				<code>false</code>, forests must be individually configured to replicate to/from foreign forests. Individual forest settings override the database level setting.</param>
			<param name="lag-limit" type="xs:unsignedInt" optional="false">This parameter controls how far (in seconds) the replica may fall behind before the master stops accepting updates. If contact with the foreign cluster is lost, a warning will be logged and master forests will permit updates to proceed with no enforcement of the lag limit.</param>
		</params>
		<return>element(db:foreign-replica)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $fdb := 7746794057802787479
  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:database-foreign-replica($fcl, $fdb, fn:true(), 300)

  (: Returns the replica database configuration.  Use the
     admin:database-set-foreign-replicas function to set
     the confirguration. :)

</example>
	</function>
	<function name="database-foreign-replica-get-cluster-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-replica-get-cluster-id">
		<summary>This function returns the id of the replica cluster from the replica database configuration.</summary>
		<params>
			<param name="foreign-replica" type="element(db:foreign-replica)" optional="false">The foreign replica configuration element.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $freplica := admin:database-get-foreign-replicas($cfg, xdmp:database("Documents"))

  return admin:database-foreign-replica-get-cluster-id($freplica)

  (: Returns the id of the replica cluster from the foreign replica database
     configuration element. :)

</example>
	</function>
	<function name="database-foreign-replica-get-database-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-replica-get-database-id">
		<summary>This function returns the id of the replica database from the replica database configuration.</summary>
		<params>
			<param name="foreign-replica" type="element(db:foreign-replica)" optional="false">The foreign replica configuration element.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $freplica := admin:database-get-foreign-replicas($cfg, xdmp:database("Documents"))

  return admin:database-foreign-replica-get-database-id($freplica)

  (: Returns the id of the replica database from the foreign replica database
     configuration element. :)

</example>
	</function>
	<function name="database-foreign-replica-get-connect-forests-by-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-replica-get-connect-forests-by-name">
		<summary>This function returns the connect-forests-by-name setting from the replica database configuration. This function must be executed on the master cluster.</summary>
		<params>
			<param name="foreign-replica" type="element(db:foreign-replica)" optional="false">The configuration element for the foreign replicas.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $freplica := admin:database-get-foreign-replicas($cfg, xdmp:database("Documents"))

  return admin:database-foreign-replica-get-connect-forests-by-name($freplica)

  (: Returns the connect-forests-by-name setting from the foreign replica database
     configuration element. :)

</example>
	</function>
	<function name="database-foreign-replica-get-lag-limit" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-replica-get-lag-limit">
		<summary>This function returns the lag limit value from the replica database configuration.</summary>
		<params>
			<param name="foreign-replica" type="element(db:foreign-replica)" optional="false">The configuration element for the foreign replica database.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $freplica := admin:database-get-foreign-replicas($cfg, xdmp:database("Documents"))

  return admin:database-foreign-replica-get-lag-limit($freplica)

  (: Returns the lag limit setting from the foreign replica database
     configuration element. :)

</example>
	</function>
	<function name="database-foreign-master" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-master">
		<summary>This function returns a master database configuration. Use the output of this function in the
			<code>admin:database-set-foreign-master</code>function to set the master database configuration.</summary>
		<params>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster containing the master host.</param>
			<param name="foreign-database-id" type="xs:unsignedLong" optional="false">The id of the master database.</param>
			<param name="connect-forests-by-name" type="xs:boolean" optional="false">Boolean that indicates whether to connect to forests by name. If
				<code>fn:true</code>, forests will automatically connect to/from foreign forests of the same name. If
				<code>false</code>, forests must be individually configured to replicate to/from foreign forests. Individual forest settings override the database level setting.</param>
		</params>
		<return>element(db:foreign-master)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $fdb := 476761383313557950
  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:database-foreign-master($fcl, $fdb, fn:true())

  (: Returns a master database configuration element.  Use the
     admin:database-set-foreign-master function to set the
     configuration. :)

</example>
	</function>
	<function name="database-foreign-master-get-cluster-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-master-get-cluster-id">
		<summary>This function returns the id of the cluster from the specified foreign master configuration.</summary>
		<params>
			<param name="foreign-master" type="element(db:foreign-master)" optional="false">The foreign master configuration.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmaster := admin:database-get-foreign-master($cfg, xdmp:database("Documents"))

  return admin:database-foreign-master-get-cluster-id($fmaster)

  (: Returns the id of the master cluster from the foreign master configuration
     element. :)

</example>
	</function>
	<function name="database-foreign-master-get-database-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-master-get-database-id">
		<summary>This function returns the id of the foreign master database. This function must be executed on the replica cluster.</summary>
		<params>
			<param name="foreign-master" type="element(db:foreign-master)" optional="false">The foreign master configuration.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmaster := admin:database-get-foreign-master($cfg, xdmp:database("Documents"))

  return admin:database-foreign-master-get-database-id($fmaster)

  (: Returns the id of the master database from the foreign master configuration
     element. :)

</example>
	</function>
	<function name="database-foreign-master-get-connect-forests-by-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-foreign-master-get-connect-forests-by-name">
		<summary>This function returns the connect-forests-by-name setting from the master database configuration. This function must be executed on the replica cluster.</summary>
		<params>
			<param name="foreign-master" type="element(db:foreign-master)" optional="false">The configuration element for the foreign master.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmaster := admin:database-get-foreign-master($cfg, xdmp:database("Documents"))

  return admin:database-foreign-master-get-connect-forests-by-name($fmaster)

  (: Returns the connect-forests-by-name setting from the foreign master database
     configuration element. :)

</example>
	</function>
	<function name="database-set-foreign-master" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-set-foreign-master">
		<summary>This function configures the specified replica database to receive replicated data from the specified foreign master. This function must be executed on the replica cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database.</param>
			<param name="foreign-master" type="element(db:foreign-master)" optional="false">The foreign master configuration returned by the
				<code>admin:database-foreign-master</code>function.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $fdb := 476761383313557950
  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fmaster := admin:database-foreign-master($fcl, $fdb, fn:true())

  return admin:database-set-foreign-master(
                $cfg,
                xdmp:database("Documents"),
                $fmaster)

  (: Returns a configuration element that includes the foreign master configuration
     for the 'Documents' database. Use admin:save-configuration to save the changes
     to the configuration or pass the configuration to other Admin API functions
     to make other changes. :)

</example>
	</function>
	<function name="database-delete-foreign-master" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-delete-foreign-master">
		<summary>This function removes the specified master database from the database replication configuration on the replica host. This function must be executed on the replica cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the domestic database whose foreign master is to be removed from the database replication configuration.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:database-delete-foreign-master($cfg, xdmp:database("Documents"))

  (: Returns a configuration element with the foreign master database, 'Documents',
     removed.  Use admin:save-configuration to save the changes to the configuration
     or pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="database-get-foreign-master" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-get-foreign-master">
		<summary>This function returns the configuration for the foreign master database. This function must be executed on the replica host.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database.</param>
		</params>
		<return>element(db:foreign-master)?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:database-get-foreign-master($cfg, xdmp:database("Documents"))

  (: Returns the configuration element for the foreign master database. :)

</example>
	</function>
	<function name="database-add-foreign-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-add-foreign-replicas">
		<summary>This function adds one or more replica databases to the database replication configuration. This function must be executed on the master cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the replica database to be added.</param>
			<param name="replicas" type="element(db:foreign-replica)*" optional="false">One or more replica database configuration elements. More than one replica database elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $fdb := 7746794057802787479
  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $freplica := admin:database-foreign-replica($fcl, $fdb, fn:true(), 300)

  return admin:database-add-foreign-replicas($cfg, xdmp:database("NewDB"), $freplica)

  (: Adds the 'NewDB' database to the replica databases configuration. Use
     admin:save-configuration to save the changes to the configuration or
     pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="database-set-foreign-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-set-foreign-replicas">
		<summary>This function sets the foreign replica database configuration. This function must be executed on the master cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database.</param>
			<param name="replicas" type="element(db:foreign-replica)*" optional="false">One or more replica configuration elements. More than one replica database elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $fdb := 7746794057802787479
  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $freplica := admin:database-foreign-replica($fcl, $fdb, fn:true(), 300)

  return admin:database-set-foreign-replicas($cfg, xdmp:database("Documents"), $freplica)

  (: Returns the full database configuration element that includes the replication configuration
     for the 'Documents' database. Use admin:save-configuration to save the changes to the
     configuration or pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="database-delete-foreign-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-delete-foreign-replicas">
		<summary>This function deletes the foreign replica database configurations for the specified master database. This function must be executed on the master cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database.</param>
			<param name="foreign-replicas" type="element(db:foreign-replica)*" optional="false">The configuration elements for the replica databases. These configuration elements can be returned using the
				<code>admin:database-get-foreign-replicas</code>function. More than one replica database elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $freplica := admin:database-get-foreign-replicas($cfg, xdmp:database("Documents"))

  return admin:database-delete-foreign-replicas($cfg, xdmp:database("Documents"), $freplica)

  (: Removes the foreign replca databases for the master database, 'Documents', from
     the database replication configuration.  Use admin:save-configuration to save the
     changes to the configuration or pass the configuration to other Admin API functions
     to make other changes. :)

</example>
	</function>
	<function name="database-get-foreign-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:database-get-foreign-replicas">
		<summary>This function returns the configuration elements of the replica databases associated with the master database specified by
			<code>database-id</code>. This function must be executed on the master cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database.</param>
		</params>
		<return>element(db:foreign-replica)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:database-get-foreign-replicas($cfg, xdmp:database("Documents"))

  (: Returns the configuration element for the replica databases associated with
     the master database, 'Documents'. :)

</example>
	</function>
	<function name="forest-foreign-replica" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-foreign-replica">
		<summary>This function returns a replica forest configuration. Use the output of this function in the
			<code>admin:forest-set-foreign-replicas</code>function to place the replica forest configuration into the cluster configuration. This function must be executed on the master host.</summary>
		<params>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster containing the replica host.</param>
			<param name="foreign-database-id" type="xs:unsignedLong" optional="false">The id of the replica database.</param>
			<param name="foreign-forest-id" type="xs:unsignedLong" optional="false">The id of the foreign forest.</param>
		</params>
		<return>element(as:foreign-replica)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fdb := admin:database-foreign-replica-get-database-id(
                      admin:database-get-foreign-replicas($cfg, xdmp:database("Documents")))

  return admin:forest-foreign-replica($fcl, $fdb , 2331251018938912591)

  (: Returns a replica forest configuration for the master 'Documents' forest. :)

</example>
	</function>
	<function name="forest-foreign-replica-get-cluster-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-foreign-replica-get-cluster-id">
		<summary>This function returns the id of the replica cluster from the specified replica forest configuration element. This function must be executed on the master cluster.</summary>
		<params>
			<param name="foreign-replica" type="element(as:foreign-replica)" optional="false">The element returned by the
				<code>admin:forest-foreign-replica</code>or
				<code>admin:forest-get-foreign-replicas</code>function that specifies the configuration for the replica forest.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmforest := admin:forest-get-foreign-replicas($cfg, xdmp:forest("Documents"))

  return admin:forest-foreign-replica-get-cluster-id($fmforest)

  (: Returns the id for the foreign replica cluster configured for the
     master 'Documents' forest. :)

</example>
	</function>
	<function name="forest-foreign-replica-get-database-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-foreign-replica-get-database-id">
		<summary>This function returns the id of the replica database from the specified replica forest configuration element. This function must be executed on the master cluster.</summary>
		<params>
			<param name="foreign-replica" type="element(as:foreign-replica)" optional="false">The element returned by the
				<code>admin:forest-foreign-replica</code>or
				<code>admin:forest-get-foreign-replicas</code>function that specifies the configuration for the replica forest.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmforest := admin:forest-get-foreign-replicas($cfg, xdmp:forest("Documents"))

  return admin:forest-foreign-replica-get-database-id($fmforest)

  (: Returns the id for the foreign replica database configured for the
     master 'Documents' forest. :)

</example>
	</function>
	<function name="forest-foreign-replica-get-forest-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-foreign-replica-get-forest-id">
		<summary>This function returns the id of the replica forest from the specified replica forest configuration element. This function must be executed on the master cluster.</summary>
		<params>
			<param name="foreign-replica" type="element(as:foreign-replica)" optional="false">The element returned by the
				<code>admin:forest-foreign-replica</code>or
				<code>admin:forest-get-foreign-replicas</code>function that specifies the configuration for the replica forest.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmforest := admin:forest-get-foreign-replicas($cfg, xdmp:forest("Documents"))

  return admin:forest-foreign-replica-get-forest-id($fmforest)

  (: Returns the id for the foreign replica forest configured for the
     master 'Documents' forest. :)

</example>
	</function>
	<function name="forest-foreign-master" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-foreign-master">
		<summary>This function creates a replicaton configuration element for the specified master forest. This function must be executed on the replica cluster.</summary>
		<params>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">The id of the master cluster.</param>
			<param name="foreign-database-id" type="xs:unsignedLong" optional="false">The id of the master database.</param>
			<param name="foreign-forest-id" type="xs:unsignedLong" optional="false">The id of the master forest.</param>
		</params>
		<return>element(as:foreign-master)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fdb := admin:database-foreign-master-get-database-id(
                  admin:database-get-foreign-master($cfg, xdmp:database("Documents")))

  return admin:forest-foreign-master($fcl, $fdb , 3017132713745743620)

  (: Returns a configuration element for the foreign master forest. :)

</example>
	</function>
	<function name="forest-foreign-master-get-cluster-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-foreign-master-get-cluster-id">
		<summary>This function returns the id for the cluster from the foreign master forest configuration element.</summary>
		<params>
			<param name="foreign-master" type="element(as:foreign-master)" optional="false">The element returned by the
				<code>admin:forest-foreign-master</code>or
				<code>admin:forest-get-foreign-master</code>function that specifies the configuration for the master forest. More than one forest master configuration elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmforest := admin:forest-get-foreign-master($cfg, xdmp:forest("Documents"))

  return admin:forest-foreign-master-get-cluster-id($fmforest)

  (: Returns the id for the foreign master cluster. :)

</example>
	</function>
	<function name="forest-foreign-master-get-database-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-foreign-master-get-database-id">
		<summary>This function returns the id for the database from the foreign master forest configuration element.</summary>
		<params>
			<param name="foreign-master" type="element(as:foreign-master)" optional="false">The element returned by the
				<code>admin:forest-foreign-master</code>or
				<code>admin:forest-get-foreign-master</code>function that specifies the configuration for the master forest. More than one forest master configuration elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmforest := admin:forest-get-foreign-master($cfg, xdmp:forest("Documents"))

  return admin:forest-foreign-master-get-database-id($fmforest)

  (: Returns the id for the foreign master database. :)

</example>
	</function>
	<function name="forest-foreign-master-get-forest-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-foreign-master-get-forest-id">
		<summary>This function returns the id for the forest from the foreign master forest configuration element.</summary>
		<params>
			<param name="foreign-master" type="element(as:foreign-master)" optional="false">The element returned by the
				<code>admin:forest-foreign-master</code>or
				<code>admin:forest-get-foreign-master</code>function that specifies the configuration for the master forest. More than one forest master configuration elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fmforest := admin:forest-get-foreign-master($cfg, xdmp:forest("Documents"))

  return admin:forest-foreign-master-get-forest-id($fmforest)

  (: Returns the id for the foreign master forest. :)

</example>
	</function>
	<function name="forest-set-foreign-master" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-set-foreign-master">
		<summary>This function writes the specified foreign master forest configuration into the database replication configuration. Any forest-level configuration will override the database level-configuration. This function must be executed on the replica cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the replica forest associated with the master forest to be set.</param>
			<param name="foreign-master" type="element(as:foreign-master)" optional="false">The element returned by the
				<code>admin:forest-foreign-master</code>or
				<code>admin:forest-get-foreign-master</code>function that specifies the configuration for the master forest. More than one forest master configuration elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fdb := admin:database-foreign-master-get-database-id(
                   admin:database-get-foreign-master($cfg, xdmp:database("Documents")))
  let $fforest := admin:forest-foreign-master($fcl, $fdb , 3017132713745743620)

  return admin:forest-set-foreign-master($cfg, xdmp:forest("Documents"), $fforest)

  (: Sets the configuration for the specified foreign master forest.  Use
     admin:save-configuration to save the changes to the configuration or
     pass the configuration to other Admin API functions to make other changes. :):)

</example>
	</function>
	<function name="forest-delete-foreign-master" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-delete-foreign-master">
		<summary>This function deletes the master forest associated with the specified replica forest from the database replication configuration. This function must be executed on the replica host.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the replica forest associated with the master forest to be deleted from the database replication configuration.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:forest-delete-foreign-master($cfg, xdmp:forest("Documents"))

  (: Deletes the foreign master forest from the configuration.  Use
     admin:save-configuration to save the changes to the configuration
     or pass the configuration to other Admin API functions to make other changes. :):)

</example>
	</function>
	<function name="forest-get-foreign-master" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-get-foreign-master">
		<summary>This function returns the replication configuration for the master forest associated with the specified replica forest. This function must be executed on the replica host.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the replica forest.</param>
		</params>
		<return>element(as:foreign-master)?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:forest-get-foreign-master($cfg, xdmp:forest("Documents"))

 (: Returns the replication configuration for the master forest. :)

</example>
	</function>
	<function name="forest-add-foreign-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-add-foreign-replicas">
		<summary>This function adds the replica forest that is associated with the specified master forest to the database replication configuration. This function must be executed on the master host.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the forest on the master host to be replicated.</param>
			<param name="foreign-replicas" type="element(as:foreign-replica)*" optional="false">The element returned by the
				<code>admin:forest-foreign-replica</code>function that specifies the configuration for the replica forest. More than one forest replica configuration elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fdb := admin:database-foreign-replica-get-database-id(
                      admin:database-get-foreign-replicas($cfg, xdmp:database("Documents")))
  let $mforest := xdmp:forest("Documents2")
  let $fforest := admin:forest-foreign-replica($fcl, $fdb , 2863600501631949400)

  return admin:forest-add-foreign-replicas($cfg, $mforest, $fforest)

  (: Adds the foreign forest, 'Document2', to the forests used by the replica database,
    'Documents'.  Use admin:save-configuration to save the changes to the configuration
    or pass the configuration to other Admin API functions to make other changes. :):)

</example>
	</function>
	<function name="forest-set-foreign-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-set-foreign-replicas">
		<summary>This function writes the specified replica forest configuration into the database replication configuration. Any forest-level configuration will override the database level-configuration. This function must be executed on the master cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the forest on the master host to be replicated.</param>
			<param name="foreign-replicas" type="element(as:foreign-replica)*" optional="false">The element returned by the
				<code>admin:forest-foreign-replica</code>function that specifies the configuration for the replica forest. More than one forest replica configuration elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fdb := admin:database-foreign-replica-get-database-id(
                      admin:database-get-foreign-replicas($cfg, xdmp:database("Documents")))

  let $fforest :=
    admin:forest-foreign-replica($fcl, $fdb , 2331251018938912591)

  return
     admin:forest-set-foreign-replicas($cfg, xdmp:forest("Documents2"), $fforest)

  (: Returns a configuration element that includes the specified foreign replica
     forests.  Use admin:save-configuration to save the changes to the configuration
     or pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="forest-delete-foreign-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-delete-foreign-replicas">
		<summary>This function deletes the foreign replica of the specified forest on the master host.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the replicated forest on the master host.</param>
			<param name="foreign-replicas" type="element(as:foreign-replica)*" optional="false">The element returned by the
				<code>admin:forest-get-foreign-replicas</code>function that specifies the configuration for the replica forest. More than one forest replica configuration elements may be specified in a one-to-many replication scheme.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $freplica := admin:forest-get-foreign-replicas($cfg, xdmp:forest("Documents"))

  return admin:forest-delete-foreign-replicas($cfg, xdmp:forest("Documents"), $freplica)

  (: Returns a configuration element with the foreign replica forest, 'Documents',
     removed. Use admin:save-configuration to save the changes to the configuration
     or pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="forest-get-foreign-replicas" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database Replication" hidden="false" fullname="admin:forest-get-foreign-replicas">
		<summary>This function returns the foreign replicas configuration element. This function must be executed on the master cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the master forest.</param>
		</params>
		<return>element(as:foreign-replica)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:forest-get-foreign-replicas($cfg, xdmp:forest("Documents"))

  (: Returns the configuration element for the foreign replicas. :)

</example>
	</function>
	<function name="host-get-foreign-port" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:host-get-foreign-port">
		<summary>This function returns the port used by the specified host to listen for communications from foreign hosts.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The id of the domestic host.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $hid := xdmp:host("master.marklogic.com")

  return admin:host-get-foreign-port($cfg, $hid)

  (: Returns the port used by the specified host to listen for foreign
     communications. :)

</example>
	</function>
	<function name="host-set-foreign-port" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:host-set-foreign-port">
		<summary>This function configures the specified domestic host to listen for communications from foreign hosts over the specified port.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">The id of the domestic host.</param>
			<param name="value" type="xs:unsignedInt" optional="false">The port number on which to listen for communications.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $hid := xdmp:host("master.marklogic.com")

  return admin:host-set-foreign-port($cfg, $hid, 7998)

  (: Configures the specified host to listen for foreign communications over
     port 7998.  Use admin:save-configuration to save the changes to the
     configuration or pass the configuration to other Admin API functions
     to make other changes. :)

</example>
	</function>
	<function name="cluster-get-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-id">
		<summary>This function returns the id of this cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:cluster-get-id($cfg)

  (: Returns the id of this cluster. :)

</example>
	</function>
	<function name="cluster-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-name">
		<summary>This function returns the name of this cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:cluster-get-name($cfg)

  (: Returns the name of this cluster. :)

</example>
	</function>
	<function name="cluster-set-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-set-name">
		<summary>This function sets the name for this cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="name" type="xs:string" optional="false">The name to be assigned to this cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:cluster-set-name($cfg, "replica")

  (: Assigns 'replica' as the name of this cluster. Use admin:save-configuration
     to save the changes to the configuration or pass the configuration to other
     Admin API functions to make other changes. :):)

</example>
	</function>
	<function name="cluster-set-xdqp-ssl-certificate" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-set-xdqp-ssl-certificate">
		<summary>This function sets the SSL certificate used to establish secure communication with this cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="value" type="xs:string" optional="false">The SSL certificate for this cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $cert := "----BEGIN CERTIFICATE-----
               MIICzjCCAbagAwIBAgIJAMieG0IJQAWQMA0GCSqGSIb3DQEBBQUAMB8xHTAbBgNV
               BAMTFDE3MDY0ODkwODY2NTc0NzgxNTcxMB4XDTExMDYwMjIwMjA1M1oXDTIxMDUz
               MDIwMjA1M1owHzEdMBsGA1UEAxMUMTcwNjQ4OTA4NjY1NzQ3ODE1NzEwggEiMA0G
               CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDPM9XLSbmVN1Fykz523I7H9Cq4zgO9
               cUSHI/FArYnWNXUbJIesvDifu2DggfsE7HD6Glwa1ZvkVTBDyZhYv1MZMpBy18Au
               9McoBbl9NYHOIhtM6bHTJAWNDoHi+TL/rFJzxo5h+bC/JnOjbE40MZKkzSzV944t
               LbpYT3JfGtMJgcCEWqVLp7vkSRUsKCPuJdPpFfMixDaLA75+W9PVdm01jDvihrgr
               CZkVjlMzZersHYQDsuNNWwt/9fM1skKabVWUVB0vHV307j2JHwVUJS3+hVxSiT61
               GaIO3GSL6dVI5ZlYZCCyyFNc0cqPutu0Q3MfZq6MpFlt5Iffm0cWwSkvAgMBAAGj
               DTALMAkGA1UdEwQCMAAwDQYJKoZIhvcNAQEFBQADggEBAIKRSFrk3a7JBl9bBsBb
               sWxob3eVM4wh8f6EPjdiIZL0V7HH4dH2hdcvtXB0NdMntiTeJfjm/tdzzMMS0al/
               LZV3BxxMa7vYk6JtRFUaMdMwwsSa319n2WXKHlqZksWk4H5gC8AH5Vpdex44SKP4
               GYVh0MO5kIS07yHfuv66PWsTRQiIHQSHYe33Dot/Mfs9BT/sVm1qRJ1ZO5GAf136
               3iQhwf8fa0PdYGfmN9I1yQMneet3W3k9T4J86mp4RuYl44Z0sv1p3oDCcuiVRgbF
               ro0dL8n7gE6fW8Hj5tnZQxYzFCwUqy8nhab+MwpOsoACOM8WvULnaMgPdflEklQT
               VL0=
               -----END CERTIFICATE-----"

  return admin:cluster-set-xdqp-ssl-certificate($cfg, $cert)

  (: Sets the SSL certificate for the cluster.  Use admin:save-configuration to save the
     changes to the configuration or pass the configuration to other Admin API functions
     to make other changes. :)

</example>
	</function>
	<function name="cluster-get-xdqp-ssl-certificate" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-xdqp-ssl-certificate">
		<summary>This function returns the SSL certificate used to establish secure communication with this cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  return admin:cluster-get-xdqp-ssl-certificate($config)

  (: Returns the SSL certificate for the cluster. :)

</example>
	</function>
	<function name="cluster-get-xdqp-ssl-private-key" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-xdqp-ssl-private-key">
		<summary>This function returns the private key for the cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  return admin:cluster-get-xdqp-ssl-private-key($config)

  (: Returns the private key used by this cluster.  :)

</example>
	</function>
	<function name="cluster-set-xdqp-bootstrap-hosts" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-set-xdqp-bootstrap-hosts">
		<summary>This function sets the bootstrap hosts for the domestic cluster. Bootstrap hosts are accessed by hosts on foreign clusters to establish communication with the domestic cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="host-ids" type="xs:unsignedLong*" optional="false">One or more ids for hosts to be used as bootstrap hosts for this cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:cluster-set-xdqp-bootstrap-hosts($cfg, 11043766148104991860)

  (: Sets the specified host as the bootstrap host for this cluster.  Use
     admin:save-configuration to save the changes to the configuration or
     pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="cluster-get-xdqp-bootstrap-hosts" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-xdqp-bootstrap-hosts">
		<summary>This function returns the ids of the bootstrap hosts configured for this cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:cluster-get-xdqp-bootstrap-hosts($cfg)

  (: Returns the ids for this cluster's bootstrap hosts. :)

</example>
	</function>
	<function name="foreign-host" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-host">
		<summary>This function configures a foreign host to be set by the
			<code>admin:foreign-cluster-set-bootstrap-hosts</code>function as the bootstrap host for the foreign cluster.</summary>
		<params>
			<param name="host-id" type="xs:unsignedLong" optional="false">The id of the foreign host.</param>
			<param name="host-name" type="xs:string" optional="false">The name of the foreign host.</param>
			<param name="connect-port" type="xs:unsignedInt" optional="false">The port on which the foreign bootstrap host will listen for connections. This should be port 7998 in most situations.</param>
		</params>
		<return>element(cl:foreign-host)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-host(13134636216063499728,
                            "master.marklogic.com",
                            7998)

 (: Configures a host to be used as a foreign cluster bootstrap host. :)

</example>
	</function>
	<function name="foreign-host-get-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-host-get-id">
		<summary>This function returns the id of the foreign bootstrap host.</summary>
		<params>
			<param name="fh" type="element(cl:foreign-host)" optional="false">The foreign host configuration element returned by the
				<code>admin:foreign-host</code>or
				<code>admin:foreign-cluster-get-bootstrap-hosts</code>function.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fh := admin:foreign-cluster-get-bootstrap-hosts($cfg, $fcl)

  return admin:foreign-host-get-id($fh)

  (: Returns the id of the foreign bootstrap host. :)

</example>
	</function>
	<function name="foreign-host-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-host-get-name">
		<summary>This function returns the name of the foreign bootstrap host.</summary>
		<params>
			<param name="fh" type="element(cl:foreign-host)" optional="false">The foreign host configuration element returned by the
				<code>admin:foreign-host</code>or
				<code>admin:foreign-cluster-get-bootstrap-hosts</code>function.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fh := admin:foreign-cluster-get-bootstrap-hosts($cfg, $fcl)

  return admin:foreign-host-get-name($fh)

  (: Returns the name of the foreign bootstrap host. :)

</example>
	</function>
	<function name="foreign-host-get-connect-port" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-host-get-connect-port">
		<summary>This function returns the number of the port configured for the foreign bootstrap host.</summary>
		<params>
			<param name="fh" type="element(cl:foreign-host)" optional="false">The foreign host configuration element returned by the
				<code>admin:foreign-host</code>or
				<code>admin:foreign-cluster-get-bootstrap-hosts</code>function.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $fh := admin:foreign-cluster-get-bootstrap-hosts($cfg, $fcl)

  return admin:foreign-host-get-connect-port($fh)

 (: Returns the number of the port configured for the foreign bootstrap host. :)

</example>
	</function>
	<function name="foreign-cluster-delete" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-delete">
		<summary>This function deletes the configuration for the specified foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return  admin:foreign-cluster-delete($cfg, $fcl)

  (: Deletes the configuration for the specified foreign cluster.  Use
     admin:save-configuration to save the changes to the configuration
     or pass the configuration to other Admin API functions to make
     other changes. :)

</example>
	</function>
	<function name="foreign-cluster-replace" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-replace">
		<summary>This function replaces a configuration for a foreign cluster with a new configuration.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="cluster-name" type="xs:string" optional="false">The name of the foreign cluster.</param>
			<param name="xdqp-timeout" type="xs:unsignedInt?" optional="false">The XDQP timeout setting (in seconds) for the foreign cluster.</param>
			<param name="host-timeout" type="xs:unsignedInt?" optional="false">the host timeout setting (in seconds) for the foreign cluster.</param>
			<param name="ssl-certificate" type="xs:string?" optional="false">The SSL certificate returned by the
				<code>admin:cluster-get-xdqp-ssl-certificate</code>function on the foreign cluster.</param>
			<param name="xdqp-ssl-enabled" type="xs:boolean?" optional="false">Specify
				<code>fn:true()</code>to enable SSL for the foreign cluster or
				<code>fn:false()</code>to disable SSL.</param>
			<param name="xdqp-ssl-allow-sslv3" type="xs:boolean?" optional="false">Specify
				<code>fn:true()</code>to enable the SSL v3 protocol for the foreign cluster or
				<code>fn:false()</code>to disable the SSL v3 protocol.</param>
			<param name="xdqp-ssl-allow-tls" type="xs:boolean?" optional="false">Specify
				<code>fn:true()</code>to enable the TLS protocol for the foreign cluster or
				<code>fn:false()</code>to disable the TLS protocol.</param>
			<param name="xdqp-ssl-ciphers" type="xs:string?" optional="false">The SSL ciphers to set. This can be any standard cipher specification string for OpenSSL.</param>
			<param name="foreign-bootstrap-hosts" type="element(cl:foreign-host)*" optional="false">The boot strap host configuration returned from the
				<code>admin:foreign-host</code>function. You can specify multiple bootstrap hosts on a cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  let $cert := "----BEGIN CERTIFICATE-----
               MIICzjCCAbagAwIBAgIJAMieG0IJQAWQMA0GCSqGSIb3DQEBBQUAMB8xHTAbBgNV
               BAMTFDE3MDY0ODkwODY2NTc0NzgxNTcxMB4XDTExMDYwMjIwMjA1M1oXDTIxMDUz
               MDIwMjA1M1owHzEdMBsGA1UEAxMUMTcwNjQ4OTA4NjY1NzQ3ODE1NzEwggEiMA0G
               CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDPM9XLSbmVN1Fykz523I7H9Cq4zgO9
               cUSHI/FArYnWNXUbJIesvDifu2DggfsE7HD6Glwa1ZvkVTBDyZhYv1MZMpBy18Au
               9McoBbl9NYHOIhtM6bHTJAWNDoHi+TL/rFJzxo5h+bC/JnOjbE40MZKkzSzV944t
               LbpYT3JfGtMJgcCEWqVLp7vkSRUsKCPuJdPpFfMixDaLA75+W9PVdm01jDvihrgr
               CZkVjlMzZersHYQDsuNNWwt/9fM1skKabVWUVB0vHV307j2JHwVUJS3+hVxSiT61
               GaIO3GSL6dVI5ZlYZCCyyFNc0cqPutu0Q3MfZq6MpFlt5Iffm0cWwSkvAgMBAAGj
               DTALMAkGA1UdEwQCMAAwDQYJKoZIhvcNAQEFBQADggEBAIKRSFrk3a7JBl9bBsBb
               sWxob3eVM4wh8f6EPjdiIZL0V7HH4dH2hdcvtXB0NdMntiTeJfjm/tdzzMMS0al/
               LZV3BxxMa7vYk6JtRFUaMdMwwsSa319n2WXKHlqZksWk4H5gC8AH5Vpdex44SKP4
               GYVh0MO5kIS07yHfuv66PWsTRQiIHQSHYe33Dot/Mfs9BT/sVm1qRJ1ZO5GAf136
               3iQhwf8fa0PdYGfmN9I1yQMneet3W3k9T4J86mp4RuYl44Z0sv1p3oDCcuiVRgbF
               ro0dL8n7gE6fW8Hj5tnZQxYzFCwUqy8nhab+MwpOsoACOM8WvULnaMgPdflEklQT
               VL0=
               -----END CERTIFICATE-----"

 let $host := admin:foreign-host(13134636216063499728, "master.marklogic.com", 7998)

 return admin:foreign-cluster-replace($cfg, $fcl, "master", 15, 35, $cert, fn:true(),
                                      fn:false(), fn:false(), "All", $host)

  (: Replaces an existing configuration for the foreign cluster. Use
     admin:save-configuration to save the changes to the configuration
     or pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="foreign-cluster-create" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-create">
		<summary>This function creates a complete configuration for a foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster, obtained by running the
				<code>admin:cluster-get-id</code>function on the foreign cluster.</param>
			<param name="cluster-name" type="xs:string" optional="false">The name of the foreign cluster.</param>
			<param name="xdqp-timeout" type="xs:unsignedInt?" optional="false">The XDQP timeout setting (in seconds) for the foreign cluster.</param>
			<param name="host-timeout" type="xs:unsignedInt?" optional="false">the host timeout setting (in seconds) for the foreign cluster.</param>
			<param name="ssl-certificate" type="xs:string?" optional="false">The SSL certificate returned by the
				<code>admin:cluster-get-xdqp-ssl-certificate</code>function on the foreign cluster.</param>
			<param name="xdqp-ssl-enabled" type="xs:boolean?" optional="false">Specify
				<code>fn:true()</code>to enable SSL for the foreign cluster or
				<code>fn:false()</code>to disable SSL.</param>
			<param name="xdqp-ssl-allow-sslv3" type="xs:boolean?" optional="false">Specify
				<code>fn:true()</code>to enable the SSL v3 protocol for the foreign cluster or
				<code>fn:false()</code>to disable the SSL v3 protocol.</param>
			<param name="xdqp-ssl-allow-tls" type="xs:boolean?" optional="false">Specify
				<code>fn:true()</code>to enable the TLS protocol for the foreign cluster or
				<code>fn:false()</code>to disable the TLS protocol.</param>
			<param name="xdqp-ssl-ciphers" type="xs:string?" optional="false">The SSL ciphers to set. This can be any standard cipher specification string for OpenSSL.</param>
			<param name="foreign-bootstrap-hosts" type="element(cl:foreign-host)*" optional="false">The boot strap host configuration returned from the
				<code>admin:foreign-host</code>function. You can specify multiple bootstrap hosts on a cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  (: Obtain foreign cluster id by running admin:cluster-get-id on the foreign cluster. :)
  let $fcl := 15499567556358534770

  let $cert := "----BEGIN CERTIFICATE-----
               MIICzjCCAbagAwIBAgIJAMieG0IJQAWQMA0GCSqGSIb3DQEBBQUAMB8xHTAbBgNV
               BAMTFDE3MDY0ODkwODY2NTc0NzgxNTcxMB4XDTExMDYwMjIwMjA1M1oXDTIxMDUz
               MDIwMjA1M1owHzEdMBsGA1UEAxMUMTcwNjQ4OTA4NjY1NzQ3ODE1NzEwggEiMA0G
               CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDPM9XLSbmVN1Fykz523I7H9Cq4zgO9
               cUSHI/FArYnWNXUbJIesvDifu2DggfsE7HD6Glwa1ZvkVTBDyZhYv1MZMpBy18Au
               9McoBbl9NYHOIhtM6bHTJAWNDoHi+TL/rFJzxo5h+bC/JnOjbE40MZKkzSzV944t
               LbpYT3JfGtMJgcCEWqVLp7vkSRUsKCPuJdPpFfMixDaLA75+W9PVdm01jDvihrgr
               CZkVjlMzZersHYQDsuNNWwt/9fM1skKabVWUVB0vHV307j2JHwVUJS3+hVxSiT61
               GaIO3GSL6dVI5ZlYZCCyyFNc0cqPutu0Q3MfZq6MpFlt5Iffm0cWwSkvAgMBAAGj
               DTALMAkGA1UdEwQCMAAwDQYJKoZIhvcNAQEFBQADggEBAIKRSFrk3a7JBl9bBsBb
               sWxob3eVM4wh8f6EPjdiIZL0V7HH4dH2hdcvtXB0NdMntiTeJfjm/tdzzMMS0al/
               LZV3BxxMa7vYk6JtRFUaMdMwwsSa319n2WXKHlqZksWk4H5gC8AH5Vpdex44SKP4
               GYVh0MO5kIS07yHfuv66PWsTRQiIHQSHYe33Dot/Mfs9BT/sVm1qRJ1ZO5GAf136
               3iQhwf8fa0PdYGfmN9I1yQMneet3W3k9T4J86mp4RuYl44Z0sv1p3oDCcuiVRgbF
               ro0dL8n7gE6fW8Hj5tnZQxYzFCwUqy8nhab+MwpOsoACOM8WvULnaMgPdflEklQT
               VL0=
               -----END CERTIFICATE-----"

 let $host := admin:foreign-host(13134636216063499728, "master.marklogic.com", 7998)

 return admin:foreign-cluster-create($cfg, $fcl, "master", 15, 35, $cert, fn:true(),
                                     fn:false(), fn:false(), "All", $host)

  (: Creates a complete configuration for the foreign cluster. Use
     admin:save-configuration to save the changes to the configuration or
     pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="cluster-get-foreign-cluster-ids" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-foreign-cluster-ids">
		<summary>This function returns the ids of the foreign clusters.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:cluster-get-foreign-cluster-ids($cfg)

  (: Returns the ids of the foreign clusters. :)

</example>
	</function>
	<function name="cluster-get-foreign-cluster-id" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-foreign-cluster-id">
		<summary>This function returns the id of the specified foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="name" type="xs:string" optional="false">The name of the cluster.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  (: Returns the id of the foreign cluster named 'ClusterA'. :)

</example>
	</function>
	<function name="foreign-cluster-get-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-name">
		<summary>This function returns the name of the foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return  admin:foreign-cluster-get-name($cfg, $fcl)

  (: Returns the name of the foreign cluster. :)

</example>
	</function>
	<function name="foreign-cluster-set-name" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-name">
		<summary>This function sets the name of a foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="cluster-name" type="xs:string" optional="false">The name to be set for the foreign cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return  admin:foreign-cluster-set-name($cfg, $fcl, "replca")

  (: Sets the name of the 'ClusterA' foreign cluster to 'replica'.  Use
     admin:save-configuration to save the changes to the configuration or
     pass the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="foreign-cluster-set-xdqp-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-xdqp-timeout">
		<summary>This function sets the timeout (in seconds) for XDQP communication between data nodes and evaluator nodes in the domestic cluster and their counterparts in the foreign cluster. By default, the XDQP timeout setting is 10 seconds.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="xdqp-timeout" type="xs:unsignedInt" optional="false">The timeout setting (in seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return  admin:foreign-cluster-set-xdqp-timeout($cfg, $fcl, 20)

  (: Sets the XDQP timeout setting for the foreign cluster to 20 seconds. Use
     admin:save-configuration to save the changes to the configuration or pass
     the configuration to other Admin API functions to make other changes. :):)

</example>
	</function>
	<function name="foreign-cluster-get-xdqp-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-xdqp-timeout">
		<summary>This function returns the timeout setting (in seconds) for XDQP communication between data nodes and evaluator nodes in the domestic cluster and their counterparts in the foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return  admin:foreign-cluster-get-xdqp-timeout($cfg, $fcl)

  (: Returns the XDQP timeout setting for the foreign cluster. :)

</example>
	</function>
	<function name="foreign-cluster-set-host-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-host-timeout">
		<summary>This function sets the timeout period (in seconds) for communication between domestic hosts and hosts in the specified foreign cluster. By default, the host timeout setting is 30 seconds.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="host-timeout" type="xs:unsignedInt" optional="false">The timeout setting (in seconds).</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return  admin:foreign-cluster-set-host-timeout($cfg, $fcl, 50)

  (: Sets the host timeout period for the foreign cluster to 50 seconds. Use
     admin:save-configuration to save the changes to the configuration or pass
     the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="foreign-cluster-get-host-timeout" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-host-timeout">
		<summary>This function returns the timeout period (in seconds) for communication between domestic hosts and hosts in the specified foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-get-host-timeout($cfg, $fcl)

  (: Returns the host timeout period set in the foreign cluster. :)

</example>
	</function>
	<function name="foreign-cluster-get-ssl-certificate" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-ssl-certificate">
		<summary>This function returns the SSL certificate used to communicate with hosts in the foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-get-ssl-certificate($cfg, $fcl)

  (: Returns the SSL certificate used to communicate with the foreign cluster. :)

</example>
	</function>
	<function name="foreign-cluster-set-ssl-certificate" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-ssl-certificate">
		<summary>This function sets the specified SSL certificate for secure communication with hosts in a foreign cluster. This certificate is shared by all hosts in the cluster when communicating with foreign hosts.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="ssl-certificate" type="xs:string?" optional="false">The SSL certificate returned by the
				<code>admin:cluster-get-xdqp-ssl-certificate</code>function on the foreign cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $cert := "----BEGIN CERTIFICATE-----
               MIICzjCCAbagAwIBAgIJAMieG0IJQAWQMA0GCSqGSIb3DQEBBQUAMB8xHTAbBgNV
               BAMTFDE3MDY0ODkwODY2NTc0NzgxNTcxMB4XDTExMDYwMjIwMjA1M1oXDTIxMDUz
               MDIwMjA1M1owHzEdMBsGA1UEAxMUMTcwNjQ4OTA4NjY1NzQ3ODE1NzEwggEiMA0G
               CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDPM9XLSbmVN1Fykz523I7H9Cq4zgO9
               cUSHI/FArYnWNXUbJIesvDifu2DggfsE7HD6Glwa1ZvkVTBDyZhYv1MZMpBy18Au
               9McoBbl9NYHOIhtM6bHTJAWNDoHi+TL/rFJzxo5h+bC/JnOjbE40MZKkzSzV944t
               LbpYT3JfGtMJgcCEWqVLp7vkSRUsKCPuJdPpFfMixDaLA75+W9PVdm01jDvihrgr
               CZkVjlMzZersHYQDsuNNWwt/9fM1skKabVWUVB0vHV307j2JHwVUJS3+hVxSiT61
               GaIO3GSL6dVI5ZlYZCCyyFNc0cqPutu0Q3MfZq6MpFlt5Iffm0cWwSkvAgMBAAGj
               DTALMAkGA1UdEwQCMAAwDQYJKoZIhvcNAQEFBQADggEBAIKRSFrk3a7JBl9bBsBb
               sWxob3eVM4wh8f6EPjdiIZL0V7HH4dH2hdcvtXB0NdMntiTeJfjm/tdzzMMS0al/
               LZV3BxxMa7vYk6JtRFUaMdMwwsSa319n2WXKHlqZksWk4H5gC8AH5Vpdex44SKP4
               GYVh0MO5kIS07yHfuv66PWsTRQiIHQSHYe33Dot/Mfs9BT/sVm1qRJ1ZO5GAf136
               3iQhwf8fa0PdYGfmN9I1yQMneet3W3k9T4J86mp4RuYl44Z0sv1p3oDCcuiVRgbF
               ro0dL8n7gE6fW8Hj5tnZQxYzFCwUqy8nhab+MwpOsoACOM8WvULnaMgPdflEklQT
               VL0=
               -----END CERTIFICATE-----"

  return admin:foreign-cluster-set-ssl-certificate($cfg, $fcl, $cert)

  (: Sets the SSL certificate for communication with the foreign cluster. Use
     admin:save-configuration to save the changes to the configuration or pass
     the configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="foreign-cluster-get-xdqp-ssl-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-xdqp-ssl-enabled">
		<summary>This function returns
			<code>true</code>if SSL is enabled for the foreign cluster. Otherwise,
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-get-xdqp-ssl-enabled($cfg, $fcl)

  (: Returns 'true' if SSL is enabled for the foreign cluster. Otherwise, 'false'. :)

</example>
	</function>
	<function name="foreign-cluster-set-xdqp-ssl-enabled" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-xdqp-ssl-enabled">
		<summary>This function enables or disables SSL for the foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="value" type="xs:boolean" optional="false">Specify
				<code>fn:true()</code>to enable SSL for the foreign cluster or
				<code>fn:false()</code>to disable SSL.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-set-xdqp-ssl-enabled($cfg, $fcl, fn:false())

  (: Disables SSL on the foreign cluster. Use admin:save-configuration to save the
     changes to the configuration or pass the configuration to other Admin API functions
     to make other changes. :)

</example>
	</function>
	<function name="foreign-cluster-get-xdqp-ssl-allow-sslv3" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-xdqp-ssl-allow-sslv3">
		<summary>This function returns
			<code>true</code>if the SSL v3 protocol is enabled for the foreign cluster. Otherwise,
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-get-xdqp-ssl-allow-sslv3($cfg, $fcl)

  (: Returns 'true' if the SSL v3 protocol is enabled for the foreign cluster.
     Otherwise, 'false'. :)

</example>
	</function>
	<function name="foreign-cluster-set-xdqp-ssl-allow-sslv3" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-xdqp-ssl-allow-sslv3">
		<summary>This function enables or disables the SSL v3 protocol for the specified foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="value" type="xs:boolean" optional="false">Specify
				<code>fn:true()</code>to enable the SSL v3 protocol for the foreign cluster or
				<code>fn:false()</code>to disable the SSL v3 protocol.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-set-xdqp-ssl-allow-sslv3($cfg, $fcl, fn:false())

  (: Disables the SSL v3 protocol on the foreign cluster.  Use admin:save-configuration
     to save the changes to the configuration or pass the configuration to other Admin
     API functions to make other changes. :)

</example>
	</function>
	<function name="foreign-cluster-get-xdqp-ssl-allow-tls" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-xdqp-ssl-allow-tls">
		<summary>This function returns
			<code>true</code>if the TLS protocol is enabled for the foreign cluster. Otherwise,
			<code>false</code>is returned.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-get-xdqp-ssl-allow-tls($cfg, $fcl)

  (: Returns 'true' if the TLS protocol is enabled for the foreign cluster.
     Otherwise, 'false'. :)

</example>
	</function>
	<function name="foreign-cluster-set-xdqp-ssl-allow-tls" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-xdqp-ssl-allow-tls">
		<summary>This function enables or disables the TLS protocol for the specified foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="value" type="xs:boolean" optional="false">Specify
				<code>fn:true()</code>to enable the TLS protocol for the foreign cluster or
				<code>fn:false()</code>to disable the TLS protocol.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-set-xdqp-ssl-allow-tls($cfg, $fcl, fn:true())

 (: Enables the TLS protocol on the foreign cluster. Use admin:save-configuration to save the
    changes to the configuration or pass the configuration to other Admin API functions
    to make other changes. :)

</example>
	</function>
	<function name="foreign-cluster-get-xdqp-ssl-ciphers" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-xdqp-ssl-ciphers">
		<summary>This function returns the SSL ciphers set for the specified foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-get-xdqp-ssl-ciphers($cfg, $fcl)

  (: Returns the ciphers set for the specified foreign cluster.  :)

</example>
	</function>
	<function name="foreign-cluster-set-xdqp-ssl-ciphers" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-xdqp-ssl-ciphers">
		<summary>This function sets SSL ciphers for the specified foreign cluster. The
			<code>value</code>parameter can be any standard cipher specification string for OpenSSL.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="value" type="xs:string" optional="false">The SSL ciphers to set.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-set-xdqp-ssl-ciphers($cfg, $fcl, "All")

  (: Sets the ciphers for the foreign cluster to "All". Use admin:save-configuration to
     save the changes to the configuration or pass the configuration to other Admin API
     functions to make other changes. :)

</example>
	</function>
	<function name="foreign-cluster-get-bootstrap-hosts" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-get-bootstrap-hosts">
		<summary>This function returns one or more configuration elements that identify the bootstrap hosts on the specified foreign cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
		</params>
		<return>element(cl:foreign-host)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")

  return admin:foreign-cluster-get-bootstrap-hosts($cfg, $fcl)

  (: Returns configuration information on the bootstrap hosts on the
     foreign cluster. :)

</example>
	</function>
	<function name="foreign-cluster-set-bootstrap-hosts" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:foreign-cluster-set-bootstrap-hosts">
		<summary>This function identifies the foreign host to be used to bootstrap communication with the foreign cluster. When a bootstrap host on a foreign cluster initially starts, it will bootstrap communications by establishing a connection to one or more of the hosts on this cluster. Once a connection has been established between cluster hosts, the bootstrap host retrieves configuration information to identify which foreign hosts are responsible for specific foreign forests.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster.</param>
			<param name="bootstrap-hosts" type="element(cl:foreign-host)*" optional="false">The boot strap host configuration returned from the
				<code>admin:foreign-host</code>function. You can specify multiple bootstrap hosts on a cluster.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fcl := admin:cluster-get-foreign-cluster-id($cfg, "ClusterA")
  let $host := admin:foreign-host(13134636216063499728,
                                  "master.marklogic.com",
                                  7998)

  return admin:foreign-cluster-set-bootstrap-hosts($cfg, $fcl, $host)

  (: Sets 'master.marklogic.com' as the bootstrap host for the foreign cluster.  Use
     admin:save-configuration to save the changes to the configuration or pass the
     configuration to other Admin API functions to make other changes. :)

</example>
	</function>
	<function name="database-get-large-size-threshold" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-large-size-threshold">
		<summary>This function returns the threshold at which binary documents in the specified database should be handled as binary large objects (BLOBs). Binary documents less than or equal to the threshold are treated as small binary objects, stored in stands. Binary documents larger than the threshold are stored in the Large Data Directory for more efficient memory consumption.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the database.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
&gt;
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()

  return admin:database-get-large-size-threshold($cfg, xdmp:database("Documents"))

  (: Returns the threshold for binary large objects (BLOBs). :)

</example>
	</function>
	<function name="forest-get-fast-data-directory" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="forest" hidden="false" fullname="admin:forest-get-fast-data-directory">
		<summary>This function returns the directory path set in the fast data directory field for the specified forest.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The id of the forest.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $fid := admin:forest-get-id($cfg, "myForest")

  return admin:forest-get-fast-data-directory($cfg, $fid)

  (: Returns the directory path set in the fast data directory field
     for the myForest forest. :)

</example>
	</function>
	<function name="cluster-get-foreign-replica-databases" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-foreign-replica-databases">
		<summary>This function is executed on the master cluster to return the replication configuration for the specified local database to the specified foreign replica cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign replica cluster.</param>
			<param name="database-ids" type="xs:unsignedLong*" optional="false">The id of the master database on the local cluster.</param>
		</params>
		<return>element(db:foreign-replicas)*</return>
		<example xml:space="preserve">
  (: This function must be executed on the master cluster. :)

  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $dbid := admin:database-get-id($cfg, "Documents")

  for $cid in admin:cluster-get-foreign-cluster-ids($cfg)
      return admin:cluster-get-foreign-replica-databases($cfg, $cid, $dbid)

  (: Returns the database replication configuration for the Documents
     database to all of the replica clusters. :)

</example>
	</function>
	<function name="cluster-get-foreign-master-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="false" fullname="admin:cluster-get-foreign-master-database">
		<summary>This function is executed on a replica cluster to return the replication configuration for the specified local database from the specified foreign master cluster.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign master cluster.</param>
			<param name="database-ids" type="xs:unsignedLong*" optional="false">The id of the replica database on the local cluster.</param>
		</params>
		<return>element(db:foreign-master)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $cfg := admin:get-configuration()
  let $dbid := admin:database-get-id($cfg, "Documents")
  let $cid := admin:cluster-get-foreign-cluster-ids($cfg)

  return admin:cluster-get-foreign-master-database($cfg, $cid, $dbid)

  (: Returns the database replication configuration for the Documents
     database on the master cluster. :)

</example>
	</function>
	<function name="database-get-config-for-foreign-replicas-on-foreign-cluster" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-config-for-foreign-replicas-on-foreign-cluster">
		<summary>This function....</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">Parameter description...</param>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>element(db:database)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";


</example>
	</function>
	<function name="database-get-config-for-foreign-master-on-foreign-cluster" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="database" hidden="false" fullname="admin:database-get-config-for-foreign-master-on-foreign-cluster">
		<summary>This function....</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">Parameter description...</param>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>element(db:database)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";


</example>
	</function>
	<function name="appserver-get-output-method" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-method">
		<summary>This function returns the value for the default output serialization method setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-method($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-byte-order-mark" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-byte-order-mark">
		<summary>This function returns the value for the output byte order mark setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-byte-order-mark($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-cdata-section-namespace-uri" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-cdata-section-namespace-uri">
		<summary>This function returns the value for the output CDATA section namespace URI setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-cdata-section-namespace-uri($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-cdata-section-localname" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-cdata-section-localname">
		<summary>This function returns the value for the output CDATA section localname setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-cdata-section-localname($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-doctype-public" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-doctype-public">
		<summary>This function returns the value for the public doctype output setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-doctype-public($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-doctype-system" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-doctype-system">
		<summary>This function returns the value for the system doctype output setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-doctype-system($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-escape-uri-attributes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-escape-uri-attributes">
		<summary>This function returns the value for the output escape URI attributes setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-escape-uri-attributes($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-include-content-type" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-include-content-type">
		<summary>This function returns the value for the output include content type setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-include-content-type($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-indent" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-indent">
		<summary>This function returns the value for the output indent setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-indent($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-indent-untyped" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-indent-untyped">
		<summary>This function returns the value for the output indent untyped setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-indent-untyped($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-media-type" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-media-type">
		<summary>This function returns the value for the output media type setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-media-type($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-normalization-form" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-normalization-form">
		<summary>This function returns the value for the output normalization form setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-normalization-form($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-omit-xml-declaration" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-omit-xml-declaration">
		<summary>This function returns the value for the output omit XML declaration setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-omit-xml-declaration($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-standalone" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-standalone">
		<summary>This function returns the value for the output standalone setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-standalone($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-undeclare-prefixes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-undeclare-prefixes">
		<summary>This function returns the value for the output undeclare prefixes setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-undeclare-prefixes($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-version" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-version">
		<summary>This function returns the value for the output version setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-version($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-get-output-include-default-attributes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-get-output-include-default-attributes">
		<summary>This function returns the value for the output include default attributes setting for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-get-output-include-default-attributes($config,
             admin:appserver-get-id($config, $groupid, "myAppServer"))


</example>
	</function>
	<function name="appserver-set-output-method" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-method">
		<summary>This function configures the default output serialization method for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for the serialization method, one of
				<code>xml</code>,
				<code>html</code>,
				<code>xhtml</code>,
				<code>text</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-method($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "html")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-byte-order-mark" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-byte-order-mark">
		<summary>This function configures whether for the specified App Server the output sequence of octets is or is not to be preceded by a byte order mark by default.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for outputting a byte order mark, one of
				<code>yes</code>,
				<code>no</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-byte-order-mark($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "yes")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-cdata-section-namespace-uri" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-cdata-section-namespace-uri">
		<summary>This function sets the namespace URI for any CDATA section localnames configured for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">A namespace URI for CDATA section elements.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-cdata-section-namespace-uri($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "http://myNamespace.com")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-cdata-section-localname" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-cdata-section-localname">
		<summary>This function sets the default element localname or list of element localnames to be output as CDATA sections for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">A CDATA section element localname or space-separated list of CDATA section element localnames.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-cdata-section-localname($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "myElement")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-doctype-public" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-doctype-public">
		<summary>This function configures a default public identifier to use on the emitted DOCTYPE for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">A public identifier URI.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-doctype-public($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "http://myPublicIdentifier")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-doctype-system" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-doctype-system">
		<summary>This function configures a default system identifier to use on the emitted DOCTYPE for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">A system identifier URI.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-doctype-system($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "http://mySystemIdentifier")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-escape-uri-attributes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-escape-uri-attributes">
		<summary>This function configures whether or not to apply Unicode normalization, percent-encoding, and HTML escaping when serializing URI attributes by default for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for escaping serialized URI attributes, one of
				<code>yes</code>,
				<code>no</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-escape-uri-attributes($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "no")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-include-content-type" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-include-content-type">
		<summary>This function configures whether or not to include the content-type declaration when serializing nodes for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for including a content-type declaration, one of
				<code>yes</code>,
				<code>no</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-include-content-type($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "no")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-indent" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-indent">
		<summary>This function configures whether or not to pretty-print (indent) typed XML (that is, XML for which there is an in-scope schema) output for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for indenting output for typed XML, one of
				<code>yes</code>,
				<code>no</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-indent($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "no")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-indent-untyped" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-indent-untyped">
		<summary>This function configures whether or not to pretty-print (indent) untyped XML (that is, XML for which there is no in-scope schema) output for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for indenting output for typed XML, one of
				<code>yes</code>,
				<code>no</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-indent-untyped($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "yes")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-media-type" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-media-type">
		<summary>This function sets the default serialization media type for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for output media type, a MIME type string such as
				<code>text/xml.</code></param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-media-type($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "text/plain")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-normalization-form" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-normalization-form">
		<summary>This function sets a Unicode normalization form to be applied by default to serialized output for the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for the output normalization form, one of
				<code>none</code>,
				<code>NFC</code>,
				<code>NFD</code>, or
				<code>NFKD</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-normalization-form($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "NFKD")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-omit-xml-declaration" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-omit-xml-declaration">
		<summary>This function configures whether serialized output for the specified App Server should omit the inclusion of an XML declaration by default.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for omitting the XML declaration, one of
				<code>yes</code>,
				<code>no</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-omit-xml-declaration($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "yes")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-standalone" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-standalone">
		<summary>This function configures whether for the specified App Server an XML delcaration in serialized output should include a
			<code>standalone</code>attribute by default.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">For a value of
				<code>yes</code>or
				<code>no</code>, include
				<code>standalone=</code>
				<i>value</i>in the XML declaration; for a value of
				<code>omit</code>, omit
				<code>standalone=</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-standalone($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "yes")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-undeclare-prefixes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-undeclare-prefixes">
		<summary>This function configures whether by default, serialization for the specified App Server should undeclare the namespace prefix of any child element that does not bind the prefix of its parent element.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for undeclaring prefixes, one of
				<code>yes</code>,
				<code>no</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-undeclare-prefixes($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "yes")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-version" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-version">
		<summary>This function stipulates a version of the default serialization method associated with the specified App Server.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">A release version string, one of
				<code>1.0</code>or
				<code>4.0</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-version($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "1.0")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="appserver-set-output-include-default-attributes" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="appserver" hidden="false" fullname="admin:appserver-set-output-include-default-attributes">
		<summary>This function configures whether for the specified App Server, attributes defaulted with a schema should be included in the serialization.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="appserver-id" type="xs:unsignedLong" optional="false">The ID of the App Server. Typically, this is the result of an
				<code>admin:appserver-get-id</code>call.</param>
			<param name="value" type="xs:string" optional="false">The default value for including default attributes in serialization, one of
				<code>yes</code>,
				<code>no</code>, or
				<code>default</code>.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $groupid := admin:group-get-id($config, "Default")
  return
  admin:appserver-set-output-include-default-attributes($config,
         admin:appserver-get-id($config, $groupid, "myAppServer"),
         "yes")
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="database-add-foreign-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="true" fullname="admin:database-add-foreign-database">
		<summary>This function adds a foreign database to a database</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the replica database to be added.</param>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster containing the replica host.</param>
			<param name="foreign-database-id" type="xs:unsignedLong" optional="false">The id of the replica database.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("db1")
  return
  admin:database-add-foreign-database($config, $dbid,
        17017686053246134246, 6853205931373075521)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="database-delete-foreign-database" lib="admin" category="Admin Library" bucket="XQuery Library Modules" subcategory="Cluster" hidden="true" fullname="admin:database-delete-foreign-database">
		<summary>This function removes a foreign database from a database</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically as returned from one of the Admin module functions.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The id of the replica database to be added.</param>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">The id of the foreign cluster containing the replica host.</param>
			<param name="foreign-database-id" type="xs:unsignedLong" optional="false">The id of the replica database.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
	         at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $dbid := xdmp:database("db1")
  return
  admin:database-delete-foreign-database($config, $dbid,
        17017686053246134246, 6853205931373075521)
  (: returns the new configuration element -- use admin:save-configuration
     to save the changes to the configuration or pass the configuration
     to other Admin API functions to make other changes.  :)


</example>
	</function>
	<function name="make-config" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:make-config">
		<summary>Create an alerting configuration associated with a particular URI. The URI will be used to create a protected collection when the config is inserted into the database with
			<code>alert:config-insert</code>. This URI will also be used as a directory for all documents (config, actions, and rules) associated with the config.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI for this alerting config.</param>
			<param name="name" type="xs:string" optional="false">The name for this alerting config.</param>
			<param name="description" type="xs:string" optional="false">A description for this alerting config.</param>
			<param name="options" type="element(alert:options)" optional="false">Additional options available to an alerting application for extra state.</param>
		</params>
		<return>element(alert:config)</return>
		<privilege>The
			<code>alert-admin</code>role is required to run this function (or all of the privileges in the
			<code>alert-admin</code>role).</privilege>
		<usage>If you add the
			<code>&lt;alert:unfiltered&gt;true&lt;/alert:unfiltered&gt;</code>option to the
			<code>$options</code>parameter, it will cause all
			<code>cts:search</code>operations that use this config to run unfiltered. This applies to the functions in the Alerting API that use
			<code>cts:search</code>(for example,
			<code>alert:find-matching rules</code>). The default is for them to run filtered. Unfiltered searches skip the filtering stage of query processing, relying on the index resolution for the accuracy of the results. The unfiltered option can give a performance boost to configurations whose index settings do not require results to be filtered.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:make-config(
	 "http://acme.com/alert/message-board",
        "Message Board",
        "Alerting config for messages on the message board",
        &lt;alert:options/&gt;
    )

</example>
	</function>
	<function name="config-insert" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-insert">
		<summary>Inserts a config into the database. If this is the first time the config has been inserted, a protected collection will be created for the config's URI. A user must have the alert-admin privilege to call this function.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">the config to insert</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $config := alert:make-config(...)
  return alert:config-insert($config)
</example>
	</function>
	<function name="config-get" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-get">
		<summary>Gets the config associated with the specified URI. The user must have the alert-user privilege to call this function.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the alerting config.</param>
		</params>
		<return>element(alert:config)?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-get("http://acme.com/alert/message-board")

</example>
	</function>
	<function name="config-delete" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-delete">
		<summary>Remove an alerting configuration identified by the specified URI. If the config does not exist, an exception will be thrown. Any triggers associated with the alerting configuration will be automatically removed. Any actions and/or rules associated by the config will also be removed as well as the protected collection. The caller must have the alert-admin privilege to call this function.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the alerting config.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-delete("http://acme.com/alert/message-board")

</example>
	</function>
	<function name="config-get-id" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-get-id">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-get-id($config)


</example>
	</function>
	<function name="config-set-uri" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="true" fullname="alert:config-set-uri">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration</param>
			<param name="uri" type="xs:string" optional="false">The URI of the specified configuration.</param>
		</params>
		<return>element (alert:config)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-set-uri($config, "http://acme.com/alert/message-board")

</example>
	</function>
	<function name="config-get-uri" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-get-uri">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-get-uri($config)


</example>
	</function>
	<function name="config-get-name" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-get-name">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-get-name($config)


</example>
	</function>
	<function name="config-set-name" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-set-name">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration</param>
			<param name="name" type="xs:string" optional="false">The name of the specified configuration.</param>
		</params>
		<return>element(alert:config)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-set-name($config, "message-board")

</example>
	</function>
	<function name="config-get-description" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-get-description">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-get-description($config)

</example>
	</function>
	<function name="config-set-description" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-set-description">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
			<param name="description" type="xs:string" optional="false">The description of the specified configuration.</param>
		</params>
		<return>element(alert:config)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-set-description($config, "The message board configuration")

</example>
	</function>
	<function name="config-get-trigger-ids" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-get-trigger-ids">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $trigger-ids := alert:config-get-trigger-ids($config)

</example>
	</function>
	<function name="config-set-trigger-ids" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-set-trigger-ids">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
			<param name="ids" type="xs:unsignedLong*" optional="false">The trigger IDs of the specified configuration.</param>
		</params>
		<return>element(alert:config)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $ids := (xs:unsignedLong(123456789), xs:unsignedLong(987654321))
  return alert:config-set-trigger-ids($config, $ids)

</example>
	</function>
	<function name="config-get-cpf-domain-ids" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="true" fullname="alert:config-get-cpf-domain-ids">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-get-cpf-domain-ids($config)

</example>
	</function>
	<function name="config-get-cpf-domain-names" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-get-cpf-domain-names">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-get-cpf-domain-names($config)

</example>
	</function>
	<function name="config-set-cpf-domain-names" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-set-cpf-domain-names">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
			<param name="names" type="xs:string*" optional="false">The name(s) of the domains to use with this alerting config. The names must be valid domain names for the the database in which the alerting config references.</param>
		</params>
		<return>element(alert:config)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-set-cpf-domain-names($config, $domain-names)

</example>
	</function>
	<function name="config-set-cpf-domain-ids" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="true" fullname="alert:config-set-cpf-domain-ids">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
			<param name="ids" type="xs:unsignedLong*" optional="false">The CPF domain IDs of the specified configuration.</param>
		</params>
		<return>element(alert:config)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-set-cpf-domain-ids($config, $domain-ids)

</example>
	</function>
	<function name="config-get-options" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-get-options">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
		</params>
		<return>element(alert:options)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-get-options($config)

</example>
	</function>
	<function name="config-set-options" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:config-set-options">
		<summary>This function provides convenient access to the specified sub-element within an alerting config.</summary>
		<params>
			<param name="config" type="element(alert:config)" optional="false">The specified alerting configuration.</param>
			<param name="options" type="element(alert:options)" optional="false">The options of the specified configuration.</param>
		</params>
		<return>element(alert:config)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:config-set-options($config, &lt;alert:options /&gt;)

</example>
	</function>
	<function name="create-triggers" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:create-triggers">
		<summary>Create triggers that invoke the standard alerting trigger module. The caller must have the
			<code>alert-admin</code>privilege. The returned trigger IDs must be associated with the config using
			<code>alert:config-set-trigger-ids</code>and then saving the updated config with
			<code>alert:config-insert</code>.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI specified to
				<code>alert:make-config</code>.</param>
			<param name="events" type="element(trgr:data-event)*" optional="false">Events for which to create triggers.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $uri := "http://acme.com/alert/message-board"
  let $trigger-ids :=
    alert:create-triggers (
        $uri,
        trgr:trigger-data-event(
            trgr:directory-scope("/", "infinity"),
            trgr:document-content(("create", "modify")),
            trgr:pre-commit())))
  let $config := alert:config-get($uri)
  let $new-config := alert:config-set-trigger-ids($config, $trigger-ids)
  return alert:config-insert($new-config)

</example>
	</function>
	<function name="remove-triggers" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:remove-triggers">
		<summary>Remove triggers whose IDs are listed in the config. The caller must have the alert-admin privilege. This function writes the updated configuration to the database, so if you need to delete the configuration as well (using
			<code>admin:delete-config</code>, for example), you should do so in another transaction.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI specified to
				<code>alert:make-config</code>.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:remove-triggers("http://acme.com/alert/message-board")

</example>
	</function>
	<function name="find-matching-rules" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:find-matching-rules">
		<summary>Returns a list of all rules associated with the specified config that match the specified document. You must have the
			<code>alert-admin</code>privilege to call this function.</summary>
		<params>
			<param name="config-uri" type="xs:string" optional="false">The alerting configuration from which to match rules.</param>
			<param name="doc" type="node()" optional="false">The document to match against.</param>
		</params>
		<return>element(alert:rule)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";


  alert:find-matching-rules("http://myconfig/uri/",
           fn:doc("/mydocs/doc.xml"))

</example>
	</function>
	<function name="invoke-matching-actions" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:invoke-matching-actions">
		<summary>Finds the rules that match the specified document and invokes their associated actions. The actions will be invoked as the user who owns each rule. The caller can use options to control whether the actions run in the same or a different transaction.</summary>
		<params>
			<param name="config-uri" type="xs:string" optional="false">The alerting configuration from which to match rules.</param>
			<param name="doc" type="node()" optional="false">The document to match against.</param>
			<param name="options" type="node()" optional="false">The options node to pass to
				<code>xdmp:invoke</code>when invoking each action. The options node should be in the
				<code>xdmp:eval</code>namespace.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:invoke-matching-actions("http://myconfig/uri/",
           fn:doc("/mydocs/doc.xml"), &lt;options/&gt;)

</example>
	</function>
	<function name="spawn-matching-actions" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:spawn-matching-actions">
		<summary>Finds the rules that match the specified document and spawns their associated actions. The spawned tasks will run as the user that owns the rule.</summary>
		<params>
			<param name="config-uri" type="xs:string" optional="false">The alerting configuration from which to match rules.</param>
			<param name="doc" type="node()" optional="false">The document to match against.</param>
			<param name="options" type="node()" optional="false">The options mode to pass to
				<code>xdmp:spawn</code>when spawning each action. The options node should be in the
				<code>xdmp:eval</code>namespace.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";


  alert:spawn-matching-actions("http://myconfig/uri/",
           fn:doc("/mydocs/doc.xml"), &lt;options xmlns="xdmp:eval"/&gt;)

</example>
	</function>
	<function name="make-rule" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:make-rule">
		<summary>This function creates the XML representing a rule. If the caller does not have the
			<code>alert-admin</code>privilege then
			<code>$user-id</code>must be the ID of the current user from the security database. If
			<code>$user-id</code>is 0, it will be automatically replaced with the current user's ID.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name given to the rule.</param>
			<param name="description" type="xs:string" optional="false">A text description of the rule.</param>
			<param name="user-id" type="xs:unsignedLong" optional="false">The user ID from the security database of the user who will be notified of matches.</param>
			<param name="query" type="cts:query" optional="false">The query that the rule will be matched against for alerting.</param>
			<param name="action" type="xs:string" optional="false">The name of the action to occur upon the matching of the rule.</param>
			<param name="options" type="element(alert:options)" optional="false">Information specific to the application for the rule.</param>
		</params>
		<return>element(alert:rule)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:make-rule(
    "nucleic acids email",
    "Alert me to anything concerning nucleic acids",
    0,
    cts:or-query((
        cts:word-query("dna"),
        cts:word-query("rna")
       )),
    "email",
    &lt;alert:options&gt;
        &lt;alert:email-address&gt;me@somedomain.com&lt;/alert:email-address&gt;
    &lt;/alert:options&gt;
  )

</example>
	</function>
	<function name="rule-insert" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-insert">
		<summary>This function inserts rule into the database associated with the specified alerting configuration. A user must have the alert-user privilege to call this function.</summary>
		<params>
			<param name="collection-uri" type="xs:string" optional="false">The URI passed to
				<code>alert:make-config</code>.</param>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $rule := alert:make-rule("")
  return alert:rule-insert("http://acme.com/alert/message-board", $rule)

</example>
	</function>
	<function name="rule-remove" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-remove">
		<summary>This function removes the XML representing the rule from the collection. A user must have the
			<code>alert-user</code>privilege to call this function. An exception is thrown if the rule does not exist. A user must have the
			<code>alert-admin</code>privilege to delete other users' rules.</summary>
		<params>
			<param name="collection-uri" type="xs:string" optional="false">The URI passed to
				<code>alert:make-config</code>.</param>
			<param name="id" type="xs:unsignedLong" optional="false">The ID of the rule to be removed.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-remove("http://acme.com/alert/message-board", 987654321)

</example>
	</function>
	<function name="get-all-rules" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:get-all-rules">
		<summary>This function returns all rules visible to the current user.</summary>
		<params>
			<param name="collection-uri" type="xs:string" optional="false">The URI passed to
				<code>alert:make-config</code>.</param>
			<param name="query" type="cts:query" optional="false">The
				<code>cts:query</code>with which to restrict the rules that are returned.</param>
		</params>
		<return>element(alert:rule)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/xdmp-alert-user</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:get-all-rules("my-collection", cts:word-query("my query"))

</example>
	</function>
	<function name="get-my-rules" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:get-my-rules">
		<summary>This function returns all rules associated with the current user.</summary>
		<params>
			<param name="collection-uri" type="xs:string" optional="false">The URI passed to
				<code>alert:make-config</code>.</param>
			<param name="query" type="cts:query" optional="false">The
				<code>cts:query</code>with which to restrict the rules that are returned.</param>
		</params>
		<return>element(alert:rule)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/xdmp-alert-user</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:get-my-rules("my-collection", cts:word-query("my query"))

</example>
	</function>
	<function name="rule-id-query" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-id-query">
		<summary>This function creates a query to find rules with any of the specified IDs. Returns a query to be passed to
			<code>alert:get-my-rules</code>or
			<code>alert:get-all-rules</code>.</summary>
		<params>
			<param name="ids" type="xs:unsignedLong*" optional="false">A list of IDs for the rules to be retrieved.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:get-my-rules(alert:rule-id-query((987654321, 987654322)))
  =&gt;Returns the rules with IDs 987654321 and 987654322

</example>
	</function>
	<function name="rule-name-query" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-name-query">
		<summary>This function creates a query to find rules with any of the specified names. Returns a query to be passed to
			<code>alert:get-my-rules</code>or
			<code>alert:get-all-rules</code>.</summary>
		<params>
			<param name="names" type="xs:string*" optional="false">A list of names for the rules to be retrieved.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:get-all-rules("my-alert-config",
	  alert:rule-name-query(("dna-alert", "rna-alert")))
  =&gt;Returns the rules with names "dna-alert" or "rna-alert"

</example>
	</function>
	<function name="rule-user-id-query" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-user-id-query">
		<summary>This function creates a query to find rules with any of the specified user IDs. Returns a query to be passed to
			<code>alert:get-my-rules</code>or
			<code>alert:get-all-rules</code>.</summary>
		<params>
			<param name="user-ids" type="xs:unsignedLong*" optional="false">A list of user IDs for the rules to be retrieved.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:get-all-rules("my-alert-config",
	  alert:rule-user-id-query((192837465, 192837466)))
  =&gt;Returns the rules with user IDs 192837465 or 192837466

</example>
	</function>
	<function name="rule-action-query" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-action-query">
		<summary>This function creates a query to find rules with any of the specified actions. Returns a query to be passed to
			<code>alert:get-my-rules</code>or
			<code>alert:get-all-rules</code>.</summary>
		<params>
			<param name="actions" type="xs:string*" optional="false">A list of action names for the rules to be retrieved.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:get-all-rules("my-alert-config",
	  alert:rule-action-query(("email", "sms")))
  =&gt;Returns the rules with actions "email" and "sms"

</example>
	</function>
	<function name="rule-get-id" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-get-id">
		<summary>This function returns the ID of a given rule.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-get-id($rule)
  =&gt; 4363547345

</example>
	</function>
	<function name="rule-get-user-id" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-get-user-id">
		<summary>This function returns the user ID of a given rule.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-get-user-id($rule)
  =&gt; 123456789

</example>
	</function>
	<function name="rule-set-user-id" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-set-user-id">
		<summary>This function returns the rule with the user ID updated. If the caller does not have the
			<code>alert-config</code>privilege, an exception will be thrown if the caller attempts to save a rule for a user other than himself.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
			<param name="user-id" type="xs:unsignedLong" optional="false">The user ID value to set for the given rule.</param>
		</params>
		<return>element(alert:rule)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-set-user-id($rule, 123456789)
  =&gt; Returns the XML representation of the rule with the
     new user ID updated to 123456789

</example>
	</function>
	<function name="rule-get-action" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-get-action">
		<summary>This function returns the action of a given rule.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-get-action($rule)
  =&gt; sms

</example>
	</function>
	<function name="rule-set-action" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-set-action">
		<summary>This function returns the rule with the action updated.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
			<param name="action" type="xs:string" optional="false">The action value to set for the given rule.</param>
		</params>
		<return>element(alert:rule)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-set-action($rule, "sms")
  =&gt; Returns the XML representation of the rule with the new action
  updated to "sms"

</example>
	</function>
	<function name="rule-get-name" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-get-name">
		<summary>This function returns the name of a given rule.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-get-name($rule)
  =&gt; "nucleic acids email"

</example>
	</function>
	<function name="rule-set-name" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-set-name">
		<summary>This function returns the rule with the name of the rule updated.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
			<param name="name" type="xs:string" optional="false">The name value to set for the given rule.</param>
		</params>
		<return>element(alert:rule)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-set-name($rule, "nucleic acids email")
  =&gt; Returns the XML representation of the rule with the name updated
  to "nucleic acids email"

</example>
	</function>
	<function name="rule-get-description" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-get-description">
		<summary>This function returns the description of a given rule.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-get-description($rule)
  =&gt; "Email when new article about DNA"

</example>
	</function>
	<function name="rule-set-description" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-set-description">
		<summary>This function returns the rule with the description of the rule updated.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of a rule.</param>
			<param name="description" type="xs:string" optional="false">The description value to set for the given rule.</param>
		</params>
		<return>element(alert:rule)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-set-description($rule, "Email when new article about DNA")
  =&gt; Returns the XML representation of the rule with the description
     updated to "Email when new article about DNA"

</example>
	</function>
	<function name="rule-get-query" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-get-query">
		<summary>Get the
			<code>cts:query</code>corresponding to the rule's query expression.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of the rule.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";


</example>
	</function>
	<function name="rule-set-query" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-set-query">
		<summary>Set the cts:query corresponding to the rule's query expression.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of the rule.</param>
			<param name="query" type="cts:query" optional="false">The serialized version of the query for documents to match on.</param>
		</params>
		<return>element(alert:rule)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";


</example>
	</function>
	<function name="rule-get-options" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-get-options">
		<summary>This function returns the options of a given rule.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of the rule.</param>
		</params>
		<return>element(alert:options)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-get-options($rule)
  =&gt; &lt;alert:options&gt;
       &lt;alert:email-address&gt;me@somedomain.com&lt;/alert:email-address&gt;
     &lt;/alert:options&gt;

</example>
	</function>
	<function name="rule-set-options" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:rule-set-options">
		<summary>This function returns the rule with the options of the rule updated.</summary>
		<params>
			<param name="rule" type="element(alert:rule)" optional="false">The XML representation of the rule.</param>
			<param name="options" type="element(alert:options)" optional="false">The options to set for the given rule.</param>
		</params>
		<return>element(alert:rule)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:rule-set-options(
  $rule,
  &lt;alert:options&gt;
    &lt;alert:email-address&gt;me@somedomain.com&lt;/alert:email-address&gt;
  &lt;/alert:options&gt;)
  =&gt; Returns the XML representation of the rule with the options
  updated to &lt;alert:options&gt;
	       &lt;myns:title&gt;Nucleic Acids Alert&lt;/myns:title&gt;
             &lt;/alert:options&gt;

</example>
	</function>
	<function name="action-get-name" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-get-name">
		<summary>This function returns the name of a given action.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The xml representation of an action.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:action-get-name($action)
  =&gt; sms

</example>
	</function>
	<function name="action-set-name" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-set-name">
		<summary>This function returns the action with the name of the action updated.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The xml representation of an action.</param>
			<param name="name" type="xs:string" optional="false">The name value to set for the given action.</param>
		</params>
		<return>element(alert:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:action-set-name($action, "sms")
  =&gt; Returns the XML representation of the action with the name updated to "sms"

</example>
	</function>
	<function name="action-get-description" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-get-description">
		<summary>This function returns the description of a given action.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:action-get-description($action)
  =&gt; "Sends basic SMS text message"

</example>
	</function>
	<function name="action-set-description" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-set-description">
		<summary>This function returns the action with the description of the action updated.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
			<param name="description" type="xs:string" optional="false">The description value to set for the given action.</param>
		</params>
		<return>element(alert:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:action-set-description($action, "Sends basic SMS text message")
  =&gt; Returns the XML representation of the action with the
     description updated to "Sends basic SMS text message"

</example>
	</function>
	<function name="action-get-module-db" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-get-module-db">
		<summary>This function returns the module database of a given action.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $action := alert:get-actions("my-alert-config-uri", "my-action")
  return
  alert:action-get-module-db($action)

</example>
	</function>
	<function name="action-set-module-db" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-set-module-db">
		<summary>This function sets the module database of a given action.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
			<param name="module-db" type="xs:unsignedLong" optional="false">The ID of the database containing the module of the action.</param>
		</params>
		<return>element(alert:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $action := alert:get-actions("my-alert-config-uri", "my-action")
  return
  alert:action-set-module-db($action, xdmp:database("my-new-database"))

</example>
	</function>
	<function name="action-get-module-root" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-get-module-root">
		<summary>This function returns the module root of a given action.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $action := alert:get-actions("my-alert-config-uri", "my-action")
  return
  alert:action-get-module-root($action)

</example>
	</function>
	<function name="action-set-module-root" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-set-module-root">
		<summary>This function sets the module root of a given action.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
			<param name="module-root" type="xs:string" optional="false">The new modules root for the action.</param>
		</params>
		<return>element(alert:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $action := alert:get-actions("my-alert-config-uri", "my-action")
  return
  alert:action-set-module-root($action, "/newroot/")

</example>
	</function>
	<function name="action-get-module" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-get-module">
		<summary>This function returns the module of a given action.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $action := alert:get-actions("my-alert-config-uri", "my-action")
  return
  alert:action-get-module($action)
  =&gt; /modules/sms.xqy (or whatever is the path to the module)

</example>
	</function>
	<function name="action-set-module" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-set-module">
		<summary>This function returns the action with the module of the action updated.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
			<param name="module" type="xs:string" optional="false">The module value to set for the given action.</param>
		</params>
		<return>element(alert:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:action-set-module($action, "/modules/sms.xqy")
  =&gt; Returns the XML representation of the action with the module
     updated to "/modules/sms.xqy"

</example>
	</function>
	<function name="action-get-options" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-get-options">
		<summary>This function returns the options of a given action.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
		</params>
		<return>element(alert:options)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:action-get-options($action)
  =&gt; &lt;alert:options&gt;
	  &lt;sms:provider name="Verizon" domain="vtext.com"/&gt;
     &lt;/alert:options&gt;
</example>
	</function>
	<function name="action-set-options" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-set-options">
		<summary>This function returns the action with the options of the action updated.</summary>
		<params>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
			<param name="options" type="element(alert:options)" optional="false">The options to set for the given action.</param>
		</params>
		<return>element(alert:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $action :=
    alert:action-set-options(
        $action,
	&lt;alert:options&gt;&lt;sms:provider name="Verizon" domain="vtext.com"/&gt;
	&lt;/alert:options&gt;
    )
    =&gt; Returns the XML representation of the action with the options
       updated to &lt;alert:options&gt;
	             &lt;myns:provider&gt;Verizon&lt;/myns:provider&gt;
	          &lt;/alert:options&gt;
</example>
	</function>
	<function name="make-action" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:make-action">
		<summary>
			<p>This function creates the xml representing an action. When a rule associated with the action matches a document, the action's module will be invoked with the following external variables set:</p>
			<pre xml:space="preserve">
declare variable $alert:config-uri as xs:string external;
declare variable $alert:doc as node() external;
declare variable $alert:rule as element(alert:rule) external;
declare variable $alert:action as element(alert:action) external;
</pre>
			<p>All actions must accept these external variables.</p>
		</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name give to the action.</param>
			<param name="description" type="xs:string" optional="false">A text description of the action.</param>
			<param name="module-db" type="xs:unsignedLong" optional="false">The database ID where the XQuery modules reside. Use
				<code>xdmp:module-database()</code>to specify the configured database.</param>
			<param name="module-root" type="xs:string" optional="false">The path to the module root. Use
				<code>xdmp:module-root()</code>to specify the configured root.</param>
			<param name="module" type="xs:string" optional="false">The URI of the module to invoke.</param>
			<param name="options" type="element(alert:options)" optional="false">Optional information specific to the action.</param>
		</params>
		<return>element(alert:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:make-action(
    "sms",
    "Sends basic SMS text message",
    xdmp:modules-database(),
    xdmp:modules-root(),
    "/modules/sms.xqy",
    &lt;alert:options&gt;
        &lt;provider name="T-Mobile" domain="tmomail.net"/&gt;
        &lt;provider name="Virgin" domain="vmobl.com"/&gt;
        &lt;provider name="Cingular" domain="cingularme.com"/&gt;
        &lt;provider name="Sprint" domain="messaging.sprintpcs.com"/&gt;
        &lt;provider name="Verizon" domain="vtext.com"/&gt;
        &lt;provider name="Nextel" domain="messaging-nextel.com"/&gt;
    &lt;/alert:options&gt;
  )
  =&gt; Returns the XML representing an action with the specified information
</example>
	</function>
	<function name="make-log-action" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:make-log-action">
		<summary>
			<p>Create a standard logging action named "log". Rules that reference this action must provide an
				<code>&lt;alert:directory/&gt;</code>element that specifies where the log file should be created. The inserted document will have a random long integer ID and its filename will be ID.xml within the specified directory.</p>Rules that reference this action may also provide options with an
			<code>&lt;alert:permissions&gt;</code>element containing a series of
			<code>&lt;sec:permission&gt;</code>elements and/or an
			<code>&lt;alert:collections&gt;</code>element containing
			<code>&lt;alert:collection&gt;</code>elements that specify the permissions and collections for the log document. This information is simply passed through to
			<code>xdmp:document-insert</code>. An example of the rule's options is as follows:
			<pre xml:space="preserve">
&lt;alert:options&gt;
  &lt;alert:directory&gt;/some/directory&lt;/alert:directory&gt;
  &lt;alert:permissions&gt;
    &lt;sec:permission&gt;
      &lt;sec:capability&gt;read&lt;/sec:capability&gt;
      &lt;sec:role-id&gt;129382323&lt;/sec:role-id&gt;
    &lt;/sec:permission&gt;
  &lt;/alert:permissions&gt;
  &lt;alert:collections&gt;
    &lt;alert:collection&gt;http://acme.com/alert-log&lt;/alert:collection&gt;
  &lt;/alert:collections&gt;
&lt;/alert:options&gt;

The log document has the following structure:

&lt;alert:log&gt;
  &lt;alert:log-id&gt;82388423&lt;/alert:log-id&gt;
  &lt;alert:config-uri&gt;http://acme.com/alert/message-board&lt;/alert:config-uri&gt;
  &lt;alert:rule-id&gt;12352&lt;/alert:rule-id&gt;
  &lt;alert:user-id&gt;8271938239&lt;/alert:user-id&gt;
  &lt;alert:document-uri&gt;/the/URI/of/the/matching/document&lt;/alert:document-uri&gt;
  &lt;alert:timestamp&gt;2008-05-31T08:20:00-08:00&lt;/alert:timestamp&gt;
&lt;/alert:log&gt;

The log document insertion will be performed as the user who created
the rule, and the user must have permission to create documents in any
collections they specify. The log-id is a random number chosen by
the action.
</pre></summary>
		<params />
		<return>element(alert:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:action-insert(alert:make-log-action())

</example>
	</function>
	<function name="action-insert" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-insert">
		<summary>This function inserts the xml representing the action into the collection. The caller must have the
			<code>alert-admin</code>privilege to call this function.</summary>
		<params>
			<param name="collection-uri" type="xs:string" optional="false">The URI passed to
				<code>alert:make-config</code>.</param>
			<param name="action" type="element(alert:action)" optional="false">The XML representation of an action.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/xdmp-alert-admin</code>,
			<code>http://marklogic.com/xdmp/privileges/xdmp-invoke-modules-change</code>(if changing the modules database),
			<code>http://marklogic.com/xdmp/privileges/xdmp-invoke-modules-change-fs</code>(if changing the modules db to someplace on the filesystem)</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  let $action := alert:make-action("")
  return alert:action-insert("http://acme.com/alert/message-board", $action)
  =&gt; Inserts the XML for the action into the database

</example>
	</function>
	<function name="action-remove" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:action-remove">
		<summary>This function removes the named action from the database or throws an exception if the action does not exist. The caller must have the
			<code>alert-admin</code>privilege to call this function.</summary>
		<params>
			<param name="collection-uri" type="xs:string" optional="false">The URI passed to
				<code>alert:make-config</code>.</param>
			<param name="name" type="xs:string" optional="false">The name of the action to be removed.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:action-remove("http://acme.com/action/message-board", "sms")
  =&gt; Removes the action with name "sms" from the
     collection "http://acme.com/message-board"

</example>
	</function>
	<function name="get-actions" lib="alert" category="Alerting" bucket="XQuery Library Modules" hidden="false" fullname="alert:get-actions">
		<summary>This function retrieves all the named actions in the specified config URI. Returns a list of actions.</summary>
		<params>
			<param name="collection-uri" type="xs:string" optional="false">The URI passed to
				<code>alert:make-config</code>.</param>
			<param name="names" type="xs:string*" optional="false">The names of the actions to retrieve, possibly using wildcards.</param>
		</params>
		<return>element(alert:action)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace alert = "http://marklogic.com/xdmp/alert"
	         at "/MarkLogic/alert.xqy";

  alert:get-actions("http://acme.com/alert/message-board", ("sms", "email"))
  =&gt; Returns the XML representation of the actions for SMS and email
  alert:get-actions("http://acme.com/alert/message-board",("*"))
  =&gt; Returns all actions in the specified alerting configuration

</example>
	</function>
	<function name="get-languages" type="cdict" lib="cdict" category="Custom Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="cdict:get-languages">
		<summary>Return the ISO language codes for all licensed languages.</summary>
		<return>xs:string*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/custom-dictionary-user</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cdict = "http://marklogic.com/xdmp/custom-dictionary"
	         at "/MarkLogic/custom-dictionary.xqy";

  cdict:get-languages()

  ==&gt; ("en", "ja", "zh", "zh_Hant")

</example>
	</function>
	<function name="dictionary-delete" type="cdict" lib="cdict" category="Custom Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="cdict:dictionary-delete">
		<summary>Delete the custom dictionary for $lang, an ISO language code for a licensed language. Returns an empty sequence. Raises an
			<code>XDMP-LANG</code>error if $lang is not a licensed language.</summary>
		<params>
			<param name="lang" type="xs:string" optional="false">The ISO language code of the dictionary.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/custom-dictionary-admin</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cdict = "http://marklogic.com/xdmp/custom-dictionary"
	         at "/MarkLogic/custom-dictionary.xqy";

  cdict:dictionary-delete("en")

</example>
	</function>
	<function name="dictionary-read" type="cdict" lib="cdict" category="Custom Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="cdict:dictionary-read">
		<summary>If $lang matches a licensed language with a custom dictionary, the custom dictionary from the local host is returned. The dictionary will have an
			<code>xml:lang</code>attribute for the language. If there is no custom dictionary for that language, an empty sequence is returned. Raises an
			<code>XDMP-LANG</code>error if $lang is not a licensed language.</summary>
		<params>
			<param name="lang" type="xs:string" optional="false">The ISO language code of the dictionary.</param>
		</params>
		<return>element(cdict:dictionary)?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cdict = "http://marklogic.com/xdmp/custom-dictionary"
	         at "/MarkLogic/custom-dictionary.xqy";

  cdict:dictionary-read("en")

  =&gt; &lt;cdict:dictionary
          xmlns:cdict="http://marklogic.com/xdmp/custom-dictionary"
          xml:lang="en"&gt;
       &lt;cdict:entry&gt;
         &lt;cdict:word&gt;Furbies&lt;/cdict:word&gt;
         &lt;cdict:stem&gt;Furby&lt;/cdict:stem&gt;
       &lt;/cdict:entry&gt;
       &lt;cdict:entry&gt;
         &lt;cdict:word&gt;servlets&lt;/cdict:word&gt;
         &lt;cdict:stem&gt;servlet&lt;/cdict:stem&gt;
       &lt;/cdict:entry&gt;
     &lt;/cdict:dictionary&gt;

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/custom-dictionary-user</code>
		</privilege>
	</function>
	<function name="dictionary-write" type="cdict" lib="cdict" category="Custom Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="cdict:dictionary-write">
		<summary>$lang is an ISO language code. $dict is the custom dictionary. If $lang matches a licensed language and $dict validates, the custom dictionary is installed on the cluster. Returns an empty sequence. Raises an
			<code>XDMP-LANG</code>error if $lang is not a licensed language. Raises validation errors if the dictionary fails to validate.</summary>
		<params>
			<param name="lang" type="xs:string" optional="false">The ISO language code of the dictionary.</param>
			<param name="dict" type="element(cdict:dictionary)" optional="false">A custom dictionary.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>ToKum</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/custom-dictionary-admin</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dict = "http://marklogic.com/xdmp/custom-dictionary"
	         at "/MarkLogic/custom-dictionary.xqy";

  let $dict := xdmp:document-get("/var/tmp/cdict-en.xml")/*
  return
    cdict:dictionary-write("en",$dict)

</example>
	</function>
	<function name="success" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:success">
		<summary>Concludes the action successfully, advancing the state as defined by the transition. The action must call this method to indicate completion of successful processing, passing the external variables
			<code>$cpf:document-uri</code>and
			<code>$cpf:transition</code>as parameters. If the document does not exist, do nothing.
			<p>Side effects: Advances the document state to the transition's on-success state, if any, and marks the document as processed in the current state.</p></summary>
		<params>
			<param name="docid" type="xs:string" optional="false">The URI of the document.</param>
			<param name="transition" type="element(*, p:transition)?" optional="false">The pipeline transition being executed.</param>
			<param name="override-state" type="xs:anyURI?" optional="false">The next state of the document, overriding the transition state.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  declare variable $cpf:document-uri as xs:string external;
  declare variable $cpf:transition as node() external;

  cpf:success( $cpf:document-uri, $cpf:transition, () )

</example>
	</function>
	<function name="failure" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:failure">
		<summary>Concludes the state action in failure, advancing the state as defined by the state transition. The state action must call this method to indicate failure, passing the external variables
			<code>$cpf:document-uri</code>,
			<code>$cpf:transition</code>, and
			<code>$cpf:exception</code>as parameters. If the document does not exist, do nothing.
			<p>Side effects: Advances the document state to the transition's on-failure state, if any, and marks the document as processed in the current state.</p></summary>
		<params>
			<param name="docid" type="xs:string" optional="false">The URI of the document.</param>
			<param name="transition" type="element(*, p:transition)?" optional="false">The pipeline transition being executed.</param>
			<param name="exception" type="node()?" optional="false">The exception leading to the processing failure, if any.</param>
			<param name="override-state" type="xs:anyURI?" optional="false">The next state of the document, overriding the transition state.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  declare variable $cpf:document-uri as xs:string external;
  declare variable $cpf:transition as node() external;
  declare variable $cpf:exception as node() external;

  cpf:failure( $cpf:document-uri, $cpf:transition, $cpf:exception, () )

</example>
	</function>
	<function name="check-transition" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:check-transition">
		<summary>
			<p>Verify that the current transition is the correct one for the document. If a document is touched from multiple threads certain race conditions may apply that will cause the lookup of the transition to end up out of sync with the transition action when it is actually executed. In this case the action should do nothing; not even call cpf:success or cpf:failure. Some other CPF thread has already done the work on this document.</p>
		</summary>
		<params>
			<param name="docid" type="xs:string" optional="false">The URI of the document.</param>
			<param name="transition" type="element(*, p:transition)?" optional="false">The pipeline transition being executed.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  declare variable $cpf:document-uri as xs:string external;
  declare variable $cpf:transition as node() external;

  if (cpf:check-transition( $cpf:document-uri, $cpf:transition )) then
     try {
        do-my-work(),
        cpf:success( $cpf:document-uri, $cpf:transition, () )
     } catch ($e) {
        cpf:failure( $cpf:document-uri, $cpf:transition, $e, () )
     }
  else ()

</example>
	</function>
	<function name="document-get-state" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:document-get-state">
		<summary>Determine the document's current state, if any.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>xs:anyURI?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  cpf:document-get-state( "/myDocs/example.xml" )

</example>
	</function>
	<function name="document-set-state" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:document-set-state">
		<summary>Set the document's state to the given state.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The URI of the document.</param>
			<param name="state" type="xs:anyURI" optional="false">The new state of the document.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>Setting a document's state may trigger content processing. If the document is currently being actively processed by the content processing framework, changing its state may have unexpected results. Manually setting the document's state should therefore be done only on documents whose processing status is "done".</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  cpf:document-set-state( "/myDocs/example.xml",
                          "http://marklogic.com/states/reprocess" )

</example>
	</function>
	<function name="document-get-processing-status" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:document-get-processing-status">
		<summary>Determine the document's current processing status, if any. The status will be one of "created", "updated", "deleted", "active", or "done".</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  cpf:document-get-processing-status( "/myDocs/example.xml" )

</example>
	</function>
	<function name="document-set-processing-status" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:document-set-processing-status">
		<summary>Set the document's processing status to the given value.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The URI of the document.</param>
			<param name="processing-status" type="xs:string" optional="false">The new processing status, one of "created", "updated", "deleted", "active", or "done".</param>
		</params>
		<return>empty-sequence()</return>
		<usage>In general, applications should not not need to set the processing status of a document. If the document is currently being actively processed by the content processing framework, changing its processing status may have unexpected results. Manually setting the document's processing status should therefore be done only on documents whose processing status is "done". Setting the document's processing status to "updated" can be a means of triggering reprocessing; setting it to "deleted" can be a means of providing a soft-delete capability.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  cpf:document-set-processing-status( "/myDocs/example.xml",
                                    "deleted" )

</example>
	</function>
	<function name="document-get-last-updated" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:document-get-last-updated">
		<summary>Determine the date and time of the last update to the document's content, if any.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>xs:dateTime?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  cpf:document-get-last-updated( "/myDocs/example.xml" )

</example>
	</function>
	<function name="document-set-last-updated" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:document-set-last-updated">
		<summary>Set the date and time of the document's last update.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The URI of the document.</param>
			<param name="last-updated" type="xs:dateTime" optional="false">The date and time at which the document was last updated, typically fn:current-dateTime().</param>
		</params>
		<return>empty-sequence()</return>
		<usage>In general, applications should only set the update time of a document in the document update action and should set it to the current date and time to ensure consistency of processing.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  cpf:document-set-last-updated( "/myDocs/example.xml",
	                      fn:current-dateTime() )

</example>
	</function>
	<function name="document-get-error" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:document-get-error">
		<summary>Fetch a trace of the error that caused the document's processing to fail, if any.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>node()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cpf = "http://marklogic.com/cpf"
	         at "/MarkLogic/cpf/cpf.xqy";

  cpf:document-get-error( "/myDocs/example.xml" )

</example>
	</function>
	<function name="document-set-error" type="cpf" lib="cpf" category="Content Processing Framework" bucket="CPF Functions" hidden="false" fullname="cpf:document-set-error">
		<summary>Set the document's error trace to the given value.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The URI of the document.</param>
			<param name="error" type="node()?" optional="false">The error causing processing failure, or empty to erase the existing trace.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>In general, applications should not not need to set the error trace of a document. cpf:failure will automatically set this trace, and cpf:success will clear it.</usage>
	</function>
	<function name="get" type="css" lib="css" category="CSS Conversion" bucket="CPF Functions" hidden="false" fullname="css:get">
		<summary>Fetch the CSS for the given document, be it embedded or linked. Limitation: doesn't account for @import directives in the CSS; assumes the linked CSS is in the database.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">The name of the parent document.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace css = "http://marklogic.com/cpf/css"
	         at "/MarkLogic/conversion/css.xqy";

  css:get("http://example.com/mydoc.xhtml")

</example>
	</function>
	<function name="convert" type="css" lib="css" category="CSS Conversion" bucket="CPF Functions" hidden="false" fullname="css:convert">
		<summary>Convert CSS text to an equivalent XML representation that is more suitable for analysis.</summary>
		<params>
			<param name="css" type="xs:string" optional="false">The CSS text itself.</param>
			<param name="options" type="element()?" optional="false">Options for the conversion. The following options are defined: "html-style", the name of the CSS class on the "html" element; "body-style", the name of the CSS class on the "body" element. These style names are used to improve weighting heuristics. The options are in the "css:convert" namespace.</param>
		</params>
		<return>element(css:styles)?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace css = "http://marklogic.com/cpf/css"
	         at "/MarkLogic/conversion/css.xqy";

  css:convert( css:get("http://example.com/mydoc.xhtml"), () )

</example>
	</function>
	<function name="and-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:and-query">
		<summary>Returns a query specifying the intersection of the matches specified by the sub-queries.</summary>
		<params>
			<param name="queries" type="cts:query*" optional="false">A sequence of sub-queries.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ordered"</dt>
						<dd>An ordered and-query, which specifies that the sub-query matches must occur in the order of the specified sub-queries. For example, if the sub-queries are "cat" and "dog", an ordered query will only match fragments where both "cat" and "dog" occur, and where "cat" comes before "dog" in the fragment.</dd>
						<dt>"unordered"</dt>
						<dd>An unordered and-query, which specifies that the sub-query matches can occur in any order.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>cts:and-query</return>
		<usage>
			<p>If the options parameter contains neither "ordered" nor "unordered", then the default is "unordered".</p>
			<p>If you specify the empty sequence for the
				<code>queries</code>parameter to
				<code>cts:and-query</code>, you will get a match for every document in the database. For example, the following query always returns true:</p>
			<pre xml:space="preserve">
   cts:contains(collection(), cts:and-query(()))
</pre>
			<p>In order to match a
				<code>cts:and-query</code>, the matches from each of the specified sub-queries must all occur in the same fragment.</p>
		</usage>
		<example xml:space="preserve">
  cts:search(//PLAY,
    cts:and-query((
      cts:word-query("to be or"),
      cts:word-query("or not to be"))))
  =&gt; .. a sequence of 'PLAY' elements which are
  ancestors (or self) of some node whose text content
  contains the phrase 'to be or' AND some node
  whose text content contains the phrase 'or not to be'.
  With high probability this intersection contains only
  one 'PLAY' element, namely,

    PLAY/TITLE =
      "The Tragedy of Hamlet, Prince of Denmark".
</example>
	</function>
	<function name="and-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:and-query-queries">
		<summary>Returns a sequence of the queries that were used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:and-query" optional="false">A query.</param>
		</params>
		<return>cts:query*</return>
		<example xml:space="preserve">
  cts:and-query-queries($query)
  =&gt; ... a sequence of the queries used to
            construct this query
</example>
    <example xml:space="preserve">
let $query :=
  cts:and-query((
    cts:word-query("to be or"),
    cts:word-query("or not to be")))
return cts:and-query-queries($query)
  =&gt; (cts:word-query("to be or", (), 1)
         cts:word-query("or not to be", (), 1))
</example>
	</function>
	<function name="and-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:and-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:and-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:and-query-options($query)
  =&gt; "ordered"
</example>
	</function>
	<function name="or-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:or-query">
		<summary>Returns a query specifying the union of the matches specified by the sub-queries.</summary>
		<params>
			<param name="queries" type="cts:query*" optional="false">A sequence of sub-queries.</param>
		</params>
		<return>cts:or-query</return>
		<example xml:space="preserve">
  cts:search(//PLAY,
    cts:or-query((
      cts:word-query("summer"),
      cts:word-query("sun of York"))))
  =&gt; .. a sequence of 'PLAY' elements which are
  ancestors (or self) of some node whose text content
  contains the word 'summer' OR some node
  whose text content contains the phrase 'sun of York'.
  This union contains at least one 'PLAY' node with:

    PLAY/TITLE =
      "The Tragedy of King Richard the Second",

  but also contains other 'PLAY' nodes containing some
  text node with the word "summer", for example,

    PLAY/TITLE = "A Midsummer Night's Dream".
</example>
	</function>
	<function name="or-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:or-query-queries">
		<summary>Returns a sequence of the queries that were used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:or-query" optional="false">A query.</param>
		</params>
		<return>cts:query*</return>
		<example xml:space="preserve">
  cts:or-query-queries($query)
  =&gt; ... a sequence of the queries used to construct this query
</example>
	</function>
	<function name="and-not-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:and-not-query">
		<summary>Returns a query specifying the set difference of the matches specified by two sub-queries.</summary>
		<params>
			<param name="positive-query" type="cts:query" optional="false">A positive query, specifying the search results filtered in.</param>
			<param name="negative-query" type="cts:query" optional="false">A negative query, specifying the search results to filter out.</param>
		</params>
		<return>cts:and-not-query</return>
		<usage>The
			<code>cts:and-not-query</code>constructor is fragment-based, so it returns true only if the specified query does not produce a match anywhere in a fragment. Therefore, a search using
			<code>cts:and-not-query</code>is only guaranteed to be accurate if the underlying query that is being negated is accurate from its index resolution (that is, if the unfiltered results of the
			<code>$negative-query</code>parameter to
			<code>cts:not-query</code>are accurate). The accuracy of the index resolution depends on many factors such as the query, if you search at a fragment root (that is, if the first parameter of
			<code>cts:search</code>specifies an XPath that resolves to a fragment root), the index options enabled on the database, the search options, and other factors. In cases where the
			<code>$negative-query</code>parameter has false positive matches, the negation of the query can miss matches (have false negative matches). In these cases, searches with
			<code>cts:and-not-query</code>can miss results, even if those searches are filtered.</usage>
		<example xml:space="preserve">
  cts:search(//PLAY,
    cts:and-not-query(
      cts:word-query("summer"),
      cts:word-query("glorious")))
  =&gt; .. sequence of 'PLAY' elements containing some
  text node with the word 'summer' BUT NOT containing
  any text node with the word 'glorious'.  This sequence
  may be (in fact is) non-empty, but certainly does not
  contain the PLAY element with:

    PLAY/TITLE =
      "The Tragedy of King Richard the Second"

  since this play contains both 'glorious' and 'summer'.
</example>
	</function>
	<function name="and-not-query-positive-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:and-not-query-positive-query">
		<summary>Returns the positive (first parameter) query used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:and-not-query" optional="false">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
let $query := cts:and-not-query(
                 cts:word-query("wanted"),
                 cts:word-query("unwanted"))
return cts:and-not-query-positive-query($query)

  =&gt; cts:word-query("wanted", (), 1)
</example>
	</function>
	<function name="and-not-query-negative-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:and-not-query-negative-query">
		<summary>Returns the negative (second parameter) query used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:and-not-query" optional="false">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
let $query := cts:and-not-query(
                 cts:word-query("wanted"),
                 cts:word-query("unwanted"))
return cts:and-not-query-negative-query($query)

  =&gt; cts:word-query("unwanted", (), 1)
</example>
	</function>
	<function name="not-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:not-query">
		<summary>Returns a query specifying the matches not specified by its sub-query.</summary>
		<params>
			<param name="query" type="cts:query" optional="false">A negative query, specifying the search results to filter out.</param>
			<!-- Do not document: this shouldn't be here and doesn't work
  <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order. The default is 1.0. The
    weight should be less than or equal to the absolute value of 16 (between
    -16 and 16); weights greater than 16 will have the same effect as a
    weight of 16.
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the
    score.
  </apidoc:param>
  -->
		</params>
		<return>cts:not-query</return>
		<usage>The
			<code>cts:not-query</code>constructor is fragment-based, so it returns true only if the specified query does not produce a match anywhere in a fragment. Therefore, a search using
			<code>cts:not-query</code>is only guaranteed to be accurate if the underlying query that is being negated is accurate from its index resolution (that is, if the unfiltered results of the
			<code>$query</code>parameter to
			<code>cts:not-query</code>are accurate). The accuracy of the index resolution depends on the many factors such as the query, if you search at a fragment root (that is, if the first parameter of
			<code>cts:search</code>specifies an XPath that resolves to a fragment root), the index options enabled on the database, the search options, and other factors. In cases where the
			<code>$query</code>parameter has false-positive matches, the negation of the query can miss matches (have false negative matches). In these cases, searches with
			<code>cts:not-query</code>can miss results, even if those searches are filtered.</usage>
		<example xml:space="preserve">
  cts:search(//PLAY,
    cts:not-query(
      cts:word-query("summer")))
  =&gt; ...  sequence of 'PLAY' elements not containing
          any text node with the word 'summer'.
</example>
    <example xml:space="preserve">
let $doc :=
  &lt;doc&gt;
   &lt;p n="1"&gt;Dogs, cats, and pigs&lt;/p&gt;
   &lt;p n="2"&gt;Trees, frogs, and cats&lt;/p&gt;
   &lt;p n="3"&gt;Dogs, alligators, and wolves&lt;/p&gt;
  &lt;/doc&gt;
return
$doc//p[cts:contains(., cts:not-query("cat"))]
(: Returns the third p element (the one without
   a "cat" term). Note that the
   cts:contains forces the constraint to happen
   in the filtering stage of the query. :)


</example>
	</function>
	<function name="not-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:not-query-query">
		<summary>Returns the query used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:not-query" optional="false">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  cts:not-query-query($query)
  =&gt; cts:word-query("MarkLogic Server")
</example>
	</function>
	<function name="not-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:not-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:not-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:word-query">
		<summary>Returns a query matching text content containing a given phrase.</summary>
		<params>
			<param name="text" type="xs:string*" optional="false">Some words or phrases to match. When multiple strings are specified, the query matches if any string matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive query.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive query.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive query.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive query.</dd>
						<dt>"punctuation-sensitive"</dt>
						<dd>A punctuation-sensitive query.</dd>
						<dt>"punctuation-insensitive"</dt>
						<dd>A punctuation-insensitive query.</dd>
						<dt>"whitespace-sensitive"</dt>
						<dd>A whitespace-sensitive query.</dd>
						<dt>"whitespace-insensitive"</dt>
						<dd>A whitespace-insensitive query.</dd>
						<dt>"stemmed"</dt>
						<dd>A stemmed query.</dd>
						<dt>"unstemmed"</dt>
						<dd>An unstemmed query.</dd>
						<dt>"wildcarded"</dt>
						<dd>A wildcarded query.</dd>
						<dt>"unwildcarded"</dt>
						<dd>An unwildcarded query.</dd>
						<dt>"exact"</dt>
						<dd>An exact match query. Shorthand for "case-sensitive", "diacritic-sensitive", "punctuation-sensitive", "whitespace-sensitive", "unstemmed", and "unwildcarded".</dd>
						<dt>"lang=
							<em>iso639code</em>"</dt>
						<dd>Specifies the language of the query. The
							<em>iso639code</em>code portion is case-insensitive, and uses the languages specified by
							<a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>. The default is specified in the database configuration.</dd>
						<dt>"distance-weight=
							<em>number</em>"</dt>
						<dd>A weight applied based on the minimum distance between matches of this query. Higher weights add to the importance of proximity (as opposed to term matches) when the relevance order is calculated. The default value is 0.0 (no impact of proximity). The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. This parameter has no effect if the
							<code>word positions</code>index is not enabled. This parameter has no effect on searches that use score-simple or score-random (because those scoring algorithms do not consider term frequency, proximity is irrelevant).</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<return>cts:word-query</return>
		<usage>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $text is used to determine case sensitivity. If $text contains no uppercase, it specifies "case-insensitive". If $text contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $text is used to determine diacritic sensitivity. If $text contains no diacritics, it specifies "diacritic-insensitive". If $text contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>If neither "punctuation-sensitive" nor "punctuation-insensitive" is present, $text is used to determine punctuation sensitivity. If $text contains no punctuation, it specifies "punctuation-insensitive". If $text contains punctuation, it specifies "punctuation-sensitive".</p>
			<p>If neither "whitespace-sensitive" nor "whitespace-insensitive" is present, the query is "whitespace-insensitive".</p>
			<p>If neither "wildcarded" nor "unwildcarded" is present, the database configuration and $text determine wildcarding. If the database has any wildcard indexes enabled ("three character searches", "two character searches", "one character searches", or "trailing wildcard searches") and if $text contains either of the wildcard characters '?' or '*', it specifies "wildcarded". Otherwise it specifies "unwildcarded".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, then the database configuration determines if a query is run as "stemmed" (stemmed searches enabled) or "unstemmed" (word searches enabled and stemmed searches disabled). If the query is a wildcard query and is also a phrase query (contains two or more terms), then any wildcard terms in the query will be "unstemmed".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
			<p>Relevance adjustment for the "distance-weight" option depends on the closest proximity of any two matches of the query. For example,</p>
			<pre xml:space="preserve">
  cts:word-query(("dog","cat"),("distance-weight=10"))

</pre>will adjust relevance based on the distance between the closest pair of matches of either "dog" or "cat" (the pair may consist only of matches of "dog", only of matches of "cat", or a match of "dog" and a match of "cat").</usage>
		<example xml:space="preserve">
  cts:search(//function,
    cts:word-query("MarkLogic Corporation"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'function' element
  ancestors (or self) of any node containing the phrase
  'MarkLogic Corporation'.
</example>
    <example xml:space="preserve">
  cts:search(//function,
    cts:word-query("MarkLogic Corporation",
                   "case-insensitive"))
  =&gt; .. relevance-ordered sequence of 'function'
  element ancestors (or self) of any node containing
  the phrase 'MarkLogic Corporation' or any other
  case-shift like 'MarkLogic Corporation',
  'MARKLOGIC Corporation', etc.
</example>
    <example xml:space="preserve">
  cts:search(//SPEECH,
    cts:word-query("to be, or not to be",
                   "punctuation-insensitive"))
  =&gt; .. relevance-ordered sequence of 'SPEECH'
  element ancestors (or self) of any node
  containing the phrase 'to be, or not to be',
  ignoring punctuation.
</example>
	</function>
	<function name="word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:word-query-text">
		<summary>Returns the text used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:word-query-text($query)
  =&gt; "choice of law"
</example>
	</function>
	<function name="word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:word-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</example>
	</function>
	<function name="word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:word-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:word-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:word-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-range-query">
		<summary>Returns a
			<code>cts:query</code>matching elements by name with a range-index entry equal a given value. Searches with the
			<code>cts:element-range-query</code>constructor require an element range index on the specified QName(s); if there is no range index configured, then an exception is thrown.</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="operator" type="xs:string" optional="false">A comparison operator.
				<p>Operators include:</p>
				<blockquote>
					<dl>
						<dt>"&lt;"</dt>
						<dd>Match range index values less than $value.</dd>
						<dt>"&lt;="</dt>
						<dd>Match range index values less than or equal to $value.</dd>
						<dt>"&gt;"</dt>
						<dd>Match range index values greater than $value.</dd>
						<dt>"&gt;="</dt>
						<dd>Match range index values greater than or equal to $value.</dd>
						<dt>"="</dt>
						<dd>Match range index values equal to $value.</dd>
						<dt>"!="</dt>
						<dd>Match range index values not equal to $value.</dd>
					</dl>
				</blockquote></param>
			<param name="value" type="xs:anyAtomicType*" optional="false">One or more element values to match. When multiple values are specified, the query matches if any value matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the range index with the collation specified by
							<em>URI</em>. If not specified, then the default collation from the query is used. If a range index with the specified collation does not exist, an error is thrown.</dd>
						<dt>"cached"</dt>
						<dd>Cache the results of this query in the list cache.</dd>
						<dt>"uncached"</dt>
						<dd>Do not cache the results of this query in the list cache.</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0. In the current release, this option is ignored; range queries do not contribute to the score.</param>
		</params>
		<return>cts:element-range-query</return>
		<usage>
			<p>If you want to constrain on a range of values, you can combine multiple
				<code>cts:element-range-query</code>constructors together with
				<code>cts:and-query</code>or any of the other composable
				<code>cts:query</code>constructors, as in the last part of the example below.</p>
			<p>If neither "cached" nor "uncached" is present, it specifies "cached".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
		</usage>
		<example xml:space="preserve">
(: create a document with test data :)
xdmp:document-insert("/dates.xml",
&lt;root&gt;
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
&lt;/root&gt;);

(:
   requires an element (range) index of
   type xs:date on "date"
:)
cts:search(doc("/dates.xml")/root/entry,
  cts:element-range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01")))
(:
  returns the following node:
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
:)
;
(:
   requires an element (range) index of
   type xs:date on "date"
:)
cts:search(doc("/dates.xml")/root/entry,
  cts:and-query((
   cts:element-range-query(xs:QName("date"), "&gt;",
      xs:date("2006-01-01")),
   cts:element-range-query(xs:QName("date"), "&lt;",
      xs:date("2008-01-01")))))
(:
  returns the following 2 nodes:
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;

  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
:)
</example>
	</function>
	<function name="element-range-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-range-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-range-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
cts:element-range-query-element-name($query)
  =&gt; xs:QName("function")
</example>
	</function>
	<function name="element-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-range-query-operator">
		<summary>Returns the operator used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-range-query" optional="false">A query.</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<example xml:space="preserve">
  cts:element-range-query-operator($query)
  =&gt; "&lt;"
</example>
	</function>
	<function name="element-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-range-query-value">
		<summary>Returns the value used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-range-query" optional="false">A query.</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<example xml:space="preserve">
  cts:element-range-query-value($query)
  =&gt; 123
</example>
	</function>
	<function name="element-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-range-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-range-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-range-query-options($query)
  =&gt; "collation=http://marklogic.com/collation/"
</example>
	</function>
	<function name="element-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-range-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-range-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:element-range-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="field-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-range-query">
		<summary>Returns a
			<code>cts:query</code>matching fields by name with a range-index entry equal a given value. Searches with the
			<code>cts:field-range-query</code>constructor require a field range index on the specified field name(s); if there is no range index configured, then an exception is thrown.</summary>
		<params>
			<param name="field-name" type="xs:string*" optional="false">One or more field names to match. When multiple field names are specified, the query matches if any field name matches.</param>
			<param name="operator" type="xs:string" optional="false">A comparison operator.
				<p>Operators include:</p>
				<blockquote>
					<dl>
						<dt>"&lt;"</dt>
						<dd>Match range index values less than $value.</dd>
						<dt>"&lt;="</dt>
						<dd>Match range index values less than or equal to $value.</dd>
						<dt>"&gt;"</dt>
						<dd>Match range index values greater than $value.</dd>
						<dt>"&gt;="</dt>
						<dd>Match range index values greater than or equal to $value.</dd>
						<dt>"="</dt>
						<dd>Match range index values equal to $value.</dd>
						<dt>"!="</dt>
						<dd>Match range index values not equal to $value.</dd>
					</dl>
				</blockquote></param>
			<param name="value" type="xs:anyAtomicType*" optional="false">One or more field values to match. When multiple values are specified, the query matches if any value matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the range index with the collation specified by
							<em>URI</em>. If not specified, then the default collation from the query is used. If a range index with the specified collation does not exist, an error is thrown.</dd>
						<dt>"cached"</dt>
						<dd>Cache the results of this query in the list cache.</dd>
						<dt>"uncached"</dt>
						<dd>Do not cache the results of this query in the list cache.</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0. In the current release, this option is ignored; range queries do not contribute to the score.</param>
		</params>
		<return>cts:field-range-query</return>
		<usage>
			<p>If you want to constrain on a range of values, you can combine multiple
				<code>cts:field-range-query</code>constructors together with
				<code>cts:and-query</code>or any of the other composable
				<code>cts:query</code>constructors.</p>
			<p>If neither "cached" nor "uncached" is present, it specifies "cached".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
		</usage>
		<example xml:space="preserve">
(: Insert few documents with test data :)
let $content1 :=  &lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;
let $content2 :=  &lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;
let $content3 :=  &lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;
let $content4 :=  &lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;
return (
xdmp:document-insert("/aname1.xml",$content1),
xdmp:document-insert("/aname2.xml",$content2),
xdmp:document-insert("/aname3.xml",$content3),
xdmp:document-insert("/aname4.xml",$content4));

(:
   requires a field (range) index of
   type xs:string on field "aname"
:)

(:
  returns the following:
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;
:)
;
(:
   requires an element (range) index of
   type xs:string on "aname"
:)
cts:contains(doc(),cts:field-range-query("aname","&gt;","Jim Kurla"))
(:
  returns "true".
:)
</example>
	</function>
	<function name="field-range-query-field-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-range-query-field-name">
		<summary>Returns the fieldname used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:field-range-query" optional="false">A query.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
cts:field-range-query-field-name($query)
  =&gt; xs:QName("function")
</example>
	</function>
	<function name="field-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-range-query-operator">
		<summary>Returns the operator used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:field-range-query" optional="false">A query.</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<example xml:space="preserve">
  cts:field-range-query-operator($query)
  =&gt; "&lt;"
</example>
	</function>
	<function name="field-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-range-query-value">
		<summary>Returns the value used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:field-range-query" optional="false">A query.</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<example xml:space="preserve">
  cts:field-range-query-value($query)
  =&gt; 123
</example>
	</function>
	<function name="field-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-range-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:field-range-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:field-range-query-options($query)
  =&gt; "collation=http://marklogic.com/collation/"
</example>
	</function>
	<function name="field-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-range-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:field-range-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:field-range-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-query">
		<summary>Returns a query matching elements by name with text content equal a given phrase.
			<code>cts:element-value-query</code>only matches against simple elements (that is, elements that contain only text and have no element children).</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="text" type="xs:string*" optional="false">One or more element values to match. When multiple strings are specified, the query matches if any string matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive query.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive query.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive query.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive query.</dd>
						<dt>"punctuation-sensitive"</dt>
						<dd>A punctuation-sensitive query.</dd>
						<dt>"punctuation-insensitive"</dt>
						<dd>A punctuation-insensitive query.</dd>
						<dt>"whitespace-sensitive"</dt>
						<dd>A whitespace-sensitive query.</dd>
						<dt>"whitespace-insensitive"</dt>
						<dd>A whitespace-insensitive query.</dd>
						<dt>"stemmed"</dt>
						<dd>A stemmed query.</dd>
						<dt>"unstemmed"</dt>
						<dd>An unstemmed query.</dd>
						<dt>"wildcarded"</dt>
						<dd>A wildcarded query.</dd>
						<dt>"unwildcarded"</dt>
						<dd>An unwildcarded query.</dd>
						<dt>"exact"</dt>
						<dd>An exact match query. Shorthand for "case-sensitive", "diacritic-sensitive", "punctuation-sensitive", "whitespace-sensitive", "unstemmed", and "unwildcarded".</dd>
						<dt>"lang=
							<em>iso639code</em>"</dt>
						<dd>Specifies the language of the query. The
							<em>iso639code</em>code portion is case-insensitive, and uses the languages specified by
							<a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>. The default is specified in the database configuration.</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<return>cts:element-value-query</return>
		<usage>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $text is used to determine case sensitivity. If $text contains no uppercase, it specifies "case-insensitive". If $text contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $text is used to determine diacritic sensitivity. If $text contains no diacritics, it specifies "diacritic-insensitive". If $text contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>If neither "punctuation-sensitive" nor "punctuation-insensitive" is present, $text is used to determine punctuation sensitivity. If $text contains no punctuation, it specifies "punctuation-insensitive". If $text contains punctuation, it specifies "punctuation-sensitive".</p>
			<p>If neither "whitespace-sensitive" nor "whitespace-insensitive" is present, the query is "whitespace-insensitive".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, the database configuration determines stemming. If the database has "stemmed searches" enabled, it specifies "stemmed". Otherwise it specifies "unstemmed".</p>
			<p>If neither "wildcarded" nor "unwildcarded" is present, the database configuration and $text determine wildcarding. If the database has any wildcard indexes enabled ("three character searches", "two character searches", "one character searches", or "trailing wildcard searches") and if $text contains either of the wildcard characters '?' or '*', it specifies "wildcarded". Otherwise it specifies "unwildcarded".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, then the database configuration determines if a query is run as "stemmed" (stemmed searches enabled) or "unstemmed" (word searches enabled and stemmed searches disabled). If the query is a wildcard query and is also a phrase query (contains two or more terms), then any wildcard terms in the query will be "unstemmed".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
			<p>Note that the text content for the value in a
				<code>cts:element-value-query</code>is treated the same as a phrase in a
				<code>cts:word-query</code>, where the phrase is the element value. Therefore, any wildcard and/or stemming rules are treated like a phrase. For example, if you have an element value of "hello friend" with wildcarding enabled for a query, a
				<code>cts:element-value-query</code>for "he*" will not match because the wildcard matches do not span word boundaries, but a
				<code>cts:element-value-query</code>for "hello *" will match. A search for "*" will match, because a "*" wildcard by itself is defined to match the value. Similarly, stemming rules are applied to each term, so a search for "hello friends" would match when stemming is enabled for the query because "friends" matches "friend". For an example, see the
				<a href="#evq4">fourth example</a>below.</p>
			<p>Similarly, because a "*" wildcard by itself is defined to match the value, the following query will match any element with the QName
				<code>my-element</code>, regardless of the wildcard indexes enabled in the database configuration:</p>
			<pre xml:space="preserve">
<code>cts:element-value-query(xs:QName("my-element"), "*", "wildcarded")</code>
</pre>
		</usage>
		<example xml:space="preserve">
  cts:search(//module,
    cts:element-value-query(
      xs:QName("function"),
      "MarkLogic Corporation"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements whose text
  content equals 'MarkLogic Corporation'.
</example>
    <example xml:space="preserve">
  cts:search(//module,
    cts:element-value-query(
      xs:QName("function"),
      "MarkLogic Corporation", "case-insensitive"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements whose text
  content equals 'MarkLogic Corporation', or any other
  case-shift like 'MARKLOGIC CorpoRation'.
</example>
    <example xml:space="preserve">
  cts:search(//module,
    cts:and-query((
      cts:element-value-query(
        xs:QName("function"),
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts:element-value-query(
        xs:QName("title"),
        "Word Query"))))
  =&gt; .. relevance-ordered sequence of 'module' elements
  which are ancestors of both:
  (a) 'function' elements with text content equal to
      'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' elements with text content equal to
      'Word Query', with the results of the first sub-query
      query given weight 0.5, and the results of the second
      sub-query given the default weight 1.0.  As a result,
      the title phrase 'Word Query' counts more heavily
      towards the relevance score.
</example>
    <example xml:space="preserve">
let $node := &lt;my-node&gt;hello friend&lt;/my-node&gt;
return (
cts:contains($node, cts:element-value-query(xs:QName('my-node'),
      "hello friends", "stemmed")),
cts:contains($node, cts:element-value-query(xs:QName('my-node'),
      "he*", "wildcarded")),
cts:contains($node, cts:element-value-query(xs:QName('my-node'),
      "hello f*", "wildcarded"))
)

=&gt; true
   false
   true
</example>
	</function>
	<function name="element-value-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-value-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-value-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-value-query-element-name($query)

  =&gt; xs:QName("function")
</example>
	</function>
	<function name="element-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-query-text">
		<summary>Returns the text used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-value-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-value-query-text($query)
  =&gt; "choice of law"
</example>
	</function>
	<function name="element-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-value-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-value-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</example>
	</function>
	<function name="element-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-value-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:element-value-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-word-query">
		<summary>Returns a query matching elements by name with text content containing a given phrase. Searches only through immediate text node children of the specified element as well as any text node children of child elements defined in the Admin Interface as element-word-query-throughs or phrase-throughs; does not search through any other children of the specified element.</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="text" type="xs:string*" optional="false">Some words or phrases to match. When multiple strings are specified, the query matches if any string matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive query.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive query.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive query.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive query.</dd>
						<dt>"punctuation-sensitive"</dt>
						<dd>A punctuation-sensitive query.</dd>
						<dt>"punctuation-insensitive"</dt>
						<dd>A punctuation-insensitive query.</dd>
						<dt>"whitespace-sensitive"</dt>
						<dd>A whitespace-sensitive query.</dd>
						<dt>"whitespace-insensitive"</dt>
						<dd>A whitespace-insensitive query.</dd>
						<dt>"stemmed"</dt>
						<dd>A stemmed query.</dd>
						<dt>"unstemmed"</dt>
						<dd>An unstemmed query.</dd>
						<dt>"wildcarded"</dt>
						<dd>A wildcarded query.</dd>
						<dt>"unwildcarded"</dt>
						<dd>An unwildcarded query.</dd>
						<dt>"exact"</dt>
						<dd>An exact match query. Shorthand for "case-sensitive", "diacritic-sensitive", "punctuation-sensitive", "whitespace-sensitive", "unstemmed", and "unwildcarded".</dd>
						<dt>"lang=
							<em>iso639code</em>"</dt>
						<dd>Specifies the language of the query. The
							<em>iso639code</em>code portion is case-insensitive, and uses the languages specified by
							<a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>. The default is specified in the database configuration.</dd>
						<dt>"distance-weight=
							<em>number</em>"</dt>
						<dd>A weight applied based on the minimum distance between matches of this query. Higher weights add to the importance of proximity (as opposed to term matches) when the relevance order is calculated. The default value is 0.0 (no impact of proximity). The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. This parameter has no effect if the
							<code>word positions</code>index is not enabled. This parameter has no effect on searches that use score-simple or score-random (because those scoring algorithms do not consider term frequency, proximity is irrelevant).</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<return>cts:element-word-query</return>
		<usage>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $text is used to determine case sensitivity. If $text contains no uppercase, it specifies "case-insensitive". If $text contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $text is used to determine diacritic sensitivity. If $text contains no diacritics, it specifies "diacritic-insensitive". If $text contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>If neither "punctuation-sensitive" nor "punctuation-insensitive" is present, $text is used to determine punctuation sensitivity. If $text contains no punctuation, it specifies "punctuation-insensitive". If $text contains punctuation, it specifies "punctuation-sensitive".</p>
			<p>If neither "whitespace-sensitive" nor "whitespace-insensitive" is present, the query is "whitespace-insensitive".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, the database configuration determines stemming. If the database has "stemmed searches" enabled, it specifies "stemmed". Otherwise it specifies "unstemmed".</p>
			<p>If neither "wildcarded" nor "unwildcarded" is present, the database configuration and $text determine wildcarding. If the database has any wildcard indexes enabled ("three character searches", "two character searches", "one character searches", or "trailing wildcard searches") and if $text contains either of the wildcard characters '?' or '*', it specifies "wildcarded". Otherwise it specifies "unwildcarded".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, then the database configuration determines if a query is run as "stemmed" (stemmed searches enabled) or "unstemmed" (word searches enabled and stemmed searches disabled). If the query is a wildcard query and is also a phrase query (contains two or more terms), then any wildcard terms in the query will be "unstemmed".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
			<p>Relevance adjustment for the "distance-weight" option depends on the closest proximity of any two matches of the query. For example,</p>
			<pre xml:space="preserve">
  cts:element-word-query(xs:QName("p"),("dog","cat"),("distance-weight=10"))

</pre>will adjust relevance based on the distance between the closest pair of matches of either "dog" or "cat" within an element named "p" (the pair may consist only of matches of "dog", only of matches of "cat", or a match of "dog" and a match of "cat").</usage>
		<example xml:space="preserve">
  cts:search(//module,
    cts:element-word-query(
      xs:QName("function"),
      "MarkLogic Corporation"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation'.
</example>
    <example xml:space="preserve">
  cts:search(//module,
    cts:element-word-query(
      xs:QName("function"),
        "MarkLogic Corporation", "case-sensitive"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation',
  or any other case-shift, like 'MarkLogic Corporation'.
</example>
    <example xml:space="preserve">
  cts:search(//module,
    cts:and-query((
      cts:element-word-query(
        xs:QName("function"),
        "MarkLogic Corporation",
        ("case-insensitive", "punctuation-insensitive"), 0.5),
      cts:element-word-query(
        xs:QName("title"),
        "faster"))))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of both:
  (a) 'function' elements with text content containing
      the phrase 'MarkLogic Corporation', ignoring embedded
      punctuation,
  AND
  (b) 'title' elements containing the word 'faster',
      with the results of the first sub-query query given
      weight 0.5, and the results of the second sub-query
      given the default weight 1.0.  As a result, the title
      term 'faster' counts more towards the relevance
      score.
</example>
	</function>
	<function name="element-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-word-query-text">
		<summary>Returns the text used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-word-query-text($query)
  =&gt; "choice of law"
</example>
	</function>
	<function name="element-word-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-word-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-word-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-word-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-word-query-element-name($query)

  =&gt; xs:QName("function")
</example>
	</function>
	<function name="element-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-word-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</example>
	</function>
	<function name="element-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-word-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-word-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:element-word-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="field-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-word-query">
		<summary>Returns a query matching text content containing a given phrase in the specified field. If the specified field does not exist,
			<code>cts:field-word-query</code>throws an exception. A field is a named object that specified elements to include and exclude from a search, and can include score weights for any included elements. You create fields at the database level using the Admin Interface. For details on fields, see the chapter on "Fields Database Settings" in the
			<em>Administrator's Guide</em>.</summary>
		<params>
			<param name="field-name" type="xs:string*" optional="false">One or more field names to search over. If multiple field names are supplied, the match can be in any of the specified fields (or-query semantics).</param>
			<param name="text" type="xs:string*" optional="false">The word or phrase to match. If multiple strings are specified, the query matches if any of the words or phrases match (or-query semantics).</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive query.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive query.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive query.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive query.</dd>
						<dt>"punctuation-sensitive"</dt>
						<dd>A punctuation-sensitive query.</dd>
						<dt>"punctuation-insensitive"</dt>
						<dd>A punctuation-insensitive query.</dd>
						<dt>"whitespace-sensitive"</dt>
						<dd>A whitespace-sensitive query.</dd>
						<dt>"whitespace-insensitive"</dt>
						<dd>A whitespace-insensitive query.</dd>
						<dt>"stemmed"</dt>
						<dd>A stemmed query.</dd>
						<dt>"unstemmed"</dt>
						<dd>An unstemmed query.</dd>
						<dt>"wildcarded"</dt>
						<dd>A wildcarded query.</dd>
						<dt>"unwildcarded"</dt>
						<dd>An unwildcarded query.</dd>
						<dt>"exact"</dt>
						<dd>An exact match query. Shorthand for "case-sensitive", "diacritic-sensitive", "punctuation-sensitive", "whitespace-sensitive", "unstemmed", and "unwildcarded".</dd>
						<dt>"lang=
							<em>iso639code</em>"</dt>
						<dd>Specifies the language of the query. The
							<em>iso639code</em>code portion is case-insensitive, and uses the languages specified by
							<a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>. The default is specified in the database configuration.</dd>
						<dt>"distance-weight=
							<em>number</em>"</dt>
						<dd>A weight applied based on the minimum distance between matches of this query. Higher weights add to the importance of proximity (as opposed to term matches) when the relevance order is calculated. The default value is 0.0 (no impact of proximity). The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. This parameter has no effect if the
							<code>word positions</code>index is not enabled. This parameter has no effect on searches that use score-simple or score-random (because those scoring algorithms do not consider term frequency, proximity is irrelevant).</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<return>cts:field-word-query</return>
		<usage>
			<p>If you use
				<code>cts:near-query</code>with
				<code>cts:field-word-query</code>, the distance supplied in the near query applies to the whole document, not just to the field. For example, if you specify a near query with a distance of 3, it will return matches when the words or phrases are within 3 words in the whole document, even if some of those words are not in the specified field. For a code example illustrating this, see the
				<a href="#fqex2">second example</a>below.</p>
			<p>Phrases are determined based on words being next to each other (word positions with a distance of 1) and words being in the same instance of the field. Because field word positions are determined based on the fragment, not on the field, field phrases cannot span excluded elements (this is because MarkLogic Server breaks out of the field when it encounters the excluded element and start a new field when it encounters the next included element). Similarly, field phrases will not span included sibling elements. The
				<a href="#fqex2">second code example below</a>illustrates this.</p>
			<p>Field phrases will automatically phrase-through all child elements of an included element, until it encounters an explicitly excluded element. The
				<a href="#fqex3">third example</a>below illustrates this. An example of when this automatic phrase-through behavior might be convenient is if you create a field that includes only the element
				<code>ABSTRACT</code>. Then all child elements of
				<code>ABSTRACT</code>are included in the field, and phrases would span all of the child elements (that is, phrases would "phrase-through" all the child elements).</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
		</usage>
		<example xml:space="preserve">
cts:search(fn:doc(), cts:field-word-query("myField", "my phrase"))

=&gt; a list of documents that contain the phrase
   "my phrase" in the field "myField". The field
   must exist in the database against which this query
   is evaluated.
</example>
    <example xml:space="preserve">
(:
   Assume the database has a field named
   "buzz" with the element "buzz"
   included and the element "baz" excluded.
:)
let $x :=
&lt;hello&gt;word1 word2 word3
  &lt;buzz&gt;word4 word5&lt;/buzz&gt;
  &lt;baz&gt;word6 word7 word8&lt;/baz&gt;
  &lt;buzz&gt;word9 word10&lt;/buzz&gt;
&lt;/hello&gt;
return (
cts:contains($x, cts:near-query(
  (cts:field-word-query("buzz", "word5"),
   cts:field-word-query("buzz", "word9")), 3)),
cts:contains($x, cts:near-query(
  (cts:field-word-query("buzz", "word5"),
   cts:field-word-query("buzz", "word9")), 4)),
cts:contains($x,
  cts:field-word-query("buzz", "word5 word9")))
(:
   Returns the sequence ("false", "true", "false").
   The first part does not match because
   the distance between "word5" and "word9"
   is 4.  This is because the distance is
   calculated based on the whole node (if the
   document was in a database, based on the
   fragment), not based on the field. The
   second part specifies a distance of 4, and
   therefore matches and returns true. The third
   part does not match because the phrase is
   based on the entire node, not on the field,
   and there are words between "word5" and "word9"
   in the node (even though not in the field).
:)


</example>
    <example xml:space="preserve">
(:
   Assume the database has a field named
   "buzz" with the element "buzz"
   included and the element "baz" excluded.
:)
let $x :=
&lt;hello&gt;
  &lt;buzz&gt;word1 word2
    &lt;gads&gt;word3 word4 word5&lt;/gads&gt;
    &lt;zukes&gt;word6 word7 word8&lt;/zukes&gt;
  word9 word10
  &lt;/buzz&gt;
&lt;/hello&gt;
return (
cts:contains($x,
  cts:field-word-query("buzz", "word2 word3")))
(:
   Returns "true" because the children of
   "buzz" are not excluded, and are therefore
   automatically phrased through.
:)


</example>
	</function>
	<function name="field-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-word-query-text">
		<summary>Returns the text used to construct the specified
			<code>cts:field-word-query</code>.</summary>
		<params>
			<param name="query" type="cts:field-word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query := cts:field-word-query("myField", "choice of law")
return
cts:field-word-query-text($query)

=&gt; "choice of law"
</example>
	</function>
	<function name="field-word-query-field-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-word-query-field-name">
		<summary>Returns the names used to construct the specified
			<code>cts:field-word-query</code>.</summary>
		<params>
			<param name="query" type="cts:field-word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query := cts:field-word-query(
                "function",
                "MarkLogic Corporation")
return
cts:field-word-query-field-name($query)

  =&gt; "function"
</example>
	</function>
	<function name="field-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-word-query-options">
		<summary>Returns the options for the specified
			<code>cts:field-word-query</code>.</summary>
		<params>
			<param name="query" type="cts:field-word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query := cts:field-word-query("myField",
      "to be or not to be",
      ("case-sensitive", "punctuation-insensitive"))
return
cts:field-word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive", "lang=en")
</example>
	</function>
	<function name="field-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-word-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:field-word-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:field-word-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="field-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-value-query">
		<summary>Returns a query matching text content containing a given value in the specified field. If the specified field does not exist,
			<code>cts:field-value-query</code>throws an exception. If the specified field does have the index setting
			<code>field value searches</code>enabled, either for the database or for the specified field, then a
			<code>cts:search</code>with a
			<code>cts:field-value-query</code>throws an exception. A field is a named object that specified elements to include and exclude from a search, and can include score weights for any included elements. You create fields at the database level using the Admin Interface. For details on fields, see the chapter on "Fields Database Settings" in the
			<em>Administrator's Guide</em>.</summary>
		<params>
			<param name="field-name" type="xs:string*" optional="false">One or more field names to search over. If multiple field names are supplied, the match can be in any of the specified fields (or-query semantics).</param>
			<param name="text" type="xs:string*" optional="false">The value to match. If multiple strings are specified, the query matches if any of the values match (or-query semantics).</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive query.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive query.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive query.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive query.</dd>
						<dt>"punctuation-sensitive"</dt>
						<dd>A punctuation-sensitive query.</dd>
						<dt>"punctuation-insensitive"</dt>
						<dd>A punctuation-insensitive query.</dd>
						<dt>"whitespace-sensitive"</dt>
						<dd>A whitespace-sensitive query.</dd>
						<dt>"whitespace-insensitive"</dt>
						<dd>A whitespace-insensitive query.</dd>
						<dt>"stemmed"</dt>
						<dd>A stemmed query.</dd>
						<dt>"unstemmed"</dt>
						<dd>An unstemmed query.</dd>
						<dt>"wildcarded"</dt>
						<dd>A wildcarded query.</dd>
						<dt>"unwildcarded"</dt>
						<dd>An unwildcarded query.</dd>
						<dt>"exact"</dt>
						<dd>An exact match query. Shorthand for "case-sensitive", "diacritic-sensitive", "punctuation-sensitive", "whitespace-sensitive", "unstemmed", and "unwildcarded".</dd>
						<dt>"lang=
							<em>iso639code</em>"</dt>
						<dd>Specifies the language of the query. The
							<em>iso639code</em>code portion is case-insensitive, and uses the languages specified by
							<a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>. The default is specified in the database configuration.</dd>
						<dt>"distance-weight=
							<em>number</em>"</dt>
						<dd>A weight applied based on the minimum distance between matches of this query. Higher weights add to the importance of proximity (as opposed to term matches) when the relevance order is calculated. The default value is 0.0 (no impact of proximity). The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. This parameter has no effect if the
							<code>word positions</code>index is not enabled. This parameter has no effect on searches that use score-simple or score-random (because those scoring algorithms do not consider term frequency, proximity is irrelevant).</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<return>cts:field-value-query</return>
		<usage>
			<p>If you use
				<code>cts:near-query</code>with
				<code>cts:field-value-query</code>, the distance supplied in the near query applies to the whole document, not just to the field. For example, if you specify a near query with a distance of 3, it will return matches when the values are within 3 words in the whole document, For a code example illustrating this, see the
				<a href="#fqex2">second example</a>below.</p>
			<p>Values are determined based on words (tokens)of values of elements that are included in the field. Field values span all the included elements. They cannot span excluded elements (this is because MarkLogic Server breaks out of the field when it encounters the excluded element and start it again field when it encounters the next included element). Field values will also span included sibling elements.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $text is used to determine case sensitivity. If $text contains no uppercase, it specifies "case-insensitive". If $text contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $text is used to determine diacritic sensitivity. If $text contains no diacritics, it specifies "diacritic-insensitive". If $text contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>If neither "punctuation-sensitive" nor "punctuation-insensitive" is present, $text is used to determine punctuation sensitivity. If $text contains no punctuation, it specifies "punctuation-insensitive". If $text contains punctuation, it specifies "punctuation-sensitive".</p>
			<p>If neither "whitespace-sensitive" nor "whitespace-insensitive" is present, the query is "whitespace-insensitive".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, the database configuration determines stemming. If the database has "stemmed searches" enabled, it specifies "stemmed". Otherwise it specifies "unstemmed".</p>
			<p>If neither "wildcarded" nor "unwildcarded" is present, the database configuration and $text determine wildcarding. If the database has any wildcard indexes enabled ("three character searches", "two character searches", "one character searches", or "trailing wildcard searches") and if $text contains either of the wildcard characters '?' or '*', it specifies "wildcarded". Otherwise it specifies "unwildcarded".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, then the database configuration determines if a query is run as "stemmed" (stemmed searches enabled) or "unstemmed" (word searches enabled and stemmed searches disabled). If the query is a wildcard query and is also a phrase query (contains two or more terms), then any wildcard terms in the query will be "unstemmed".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
		</usage>
		<example xml:space="preserve">
let $contents := &lt;Employee&gt;&lt;name&gt;&lt;fname&gt;Jaz&lt;/fname&gt;&lt;mname&gt;Roy&lt;/mname&gt;&lt;lname&gt;Smith&lt;/lname&gt;&lt;/name&gt;&lt;/Employee&gt;
return
cts:contains($contents,cts:field-value-query("myField","Jaz Roy Smith"))

=&gt; check if the filed myField has a value matching to "Jaz Roy Smith"
in node $contents. The field must exist in the database against which
this query is evaluated. "myField" in thic case includes element "name" and excludes "mname". This expression returns false.
</example>
    <example xml:space="preserve">
let $contents := &lt;Employee&gt;&lt;name&gt;&lt;fname&gt;Jaz&lt;/fname&gt;&lt;mname&gt;Roy&lt;/mname&gt;&lt;lname&gt;Smith&lt;/lname&gt;&lt;/name&gt;&lt;/Employee&gt;
return
cts:contains($contents,cts:field-value-query("myField","Jaz Smith"))

=&gt; Returns true.
</example>
    <example xml:space="preserve">
In this query, the search is fully resolved in the index.

cts:search(fn:doc("/Employee/jaz.xml"),cts:field-value-query("myField","Jaz Smith"),"unfiltered")

=&gt; Returns the doc which has field "myField" and a match with the value of the field.
</example>
	</function>
	<function name="field-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-value-query-text">
		<summary>Returns the text used to construct the specified
			<code>cts:field-value-query</code>.</summary>
		<params>
			<param name="query" type="cts:field-value-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query := cts:field-value-query("myField", "choice of law")
return
cts:field-value-query-text($query)

=&gt; "choice of law"
</example>
	</function>
	<function name="field-value-query-field-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-value-query-field-name">
		<summary>Returns the names used to construct the specified
			<code>cts:field-value-query</code>.</summary>
		<params>
			<param name="query" type="cts:field-value-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query := cts:field-value-query(
                "function",
                "MarkLogic Corporation")
return
cts:field-value-query-field-name($query)

  =&gt; "function"
</example>
	</function>
	<function name="field-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-value-query-options">
		<summary>Returns the options for the specified
			<code>cts:field-value-query</code>.</summary>
		<params>
			<param name="query" type="cts:field-value-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query := cts:field-value-query("myField",
      "to be or not to be",
      ("case-sensitive", "punctuation-insensitive"))
return
cts:field-value-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive", "lang=en")
</example>
	</function>
	<function name="field-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-value-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:field-value-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:field-value-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-attribute-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-range-query">
		<summary>Returns a
			<code>cts:query</code>matching elements by name with a range-index entry equal a given value. Searches with the
			<code>cts:element-attribute-range-query</code>constructor require an attribute range index on the specified QName(s); if there is no range index configured, then an exception is thrown.</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="attribute-name" type="xs:QName*" optional="false">One or more attribute QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="operator" type="xs:string" optional="false">A comparison operator.
				<p>Operators include:</p>
				<blockquote>
					<dl>
						<dt>"&lt;"</dt>
						<dd>Match range index values less than $value.</dd>
						<dt>"&lt;="</dt>
						<dd>Match range index values less than or equal to $value.</dd>
						<dt>"&gt;"</dt>
						<dd>Match range index values greater than $value.</dd>
						<dt>"&gt;="</dt>
						<dd>Match range index values greater than or equal to $value.</dd>
						<dt>"="</dt>
						<dd>Match range index values equal to $value.</dd>
						<dt>"!="</dt>
						<dd>Match range index values not equal to $value.</dd>
					</dl>
				</blockquote></param>
			<param name="value" type="xs:anyAtomicType*" optional="false">Some values to match. When multiple values are specified, the query matches if any value matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the range index with the collation specified by
							<em>URI</em>. If not specified, then the default collation from the query is used. If a range index with the specified collation does not exist, an error is thrown.</dd>
						<dt>"cached"</dt>
						<dd>Cache the results of this query in the list cache.</dd>
						<dt>"uncached"</dt>
						<dd>Do not cache the results of this query in the list cache.</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0. In the current release, this option is ignored; range queries do not contribute to the score.</param>
		</params>
		<return>cts:element-attribute-range-query</return>
		<usage>
			<p>If you want to constrain on a range of values, you can combine multiple
				<code>cts:element-attribute-range-query</code>constructors together with
				<code>cts:and-query</code>or other composable
				<code>cts:query</code>constructors.</p>
			<p>If neither "cached" nor "uncached" is present, it specifies "cached".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
		</usage>
		<example xml:space="preserve">
(: create a document with test data :)
xdmp:document-insert("/attributes.xml",
&lt;root&gt;
  &lt;entry sku="100"&gt;
    &lt;product&gt;apple&lt;/product&gt;
  &lt;/entry&gt;
  &lt;entry sku="200"&gt;
    &lt;product&gt;orange&lt;/product&gt;
  &lt;/entry&gt;
  &lt;entry sku="1000"&gt;
    &lt;product&gt;electric car&lt;/product&gt;
  &lt;/entry&gt;
&lt;/root&gt;) ;

(:
   requires an attribute (range) index of
   type xs:int on the "sku" attribute of
   the "entry" element
:)
cts:search(doc("/attributes.xml")/root/entry,
  cts:element-attribute-range-query(
      xs:QName("entry"), xs:QName("sku"), "&gt;=",
      500))
(:
  returns the following node:
  &lt;entry sku="1000"&gt;
    &lt;product&gt;electric car&lt;/product&gt;
  &lt;/entry&gt;
:)
</example>
	</function>
	<function name="element-attribute-range-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-range-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-range-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-range-query-element-name($query)

  =&gt; xs:QName("function")
</example>
	</function>
	<function name="element-attribute-range-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-range-query-attribute-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-range-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-range-query-attribute-name($query)

  =&gt; xs:QName("name")
</example>
	</function>
	<function name="element-attribute-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-range-query-operator">
		<summary>Returns the operator used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-range-query" optional="false">A query.</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<example xml:space="preserve">
  cts:element-attribute-range-query-operator($query)
  =&gt; "&lt;"
</example>
	</function>
	<function name="element-attribute-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-range-query-value">
		<summary>Returns the value used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-range-query" optional="false">A query.</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<example xml:space="preserve">
  cts:element-attribute-range-query-value($query)
  =&gt; 123
</example>
	</function>
	<function name="element-attribute-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-range-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-range-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-attribute-range-query-options($query)
  =&gt; "collation=http://marklogic.com/collation/"
</example>
	</function>
	<function name="element-attribute-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-range-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-attribute-range-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:element-attribute-range-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-attribute-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-query">
		<summary>Returns a query matching elements by name with attributes by name with text content equal a given phrase.</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="attribute-name" type="xs:QName*" optional="false">One or more attribute QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="text" type="xs:string*" optional="false">One or more attribute values to match. When multiple strings are specified, the query matches if any string matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive query.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive query.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive query.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive query.</dd>
						<dt>"punctuation-sensitive"</dt>
						<dd>A punctuation-sensitive query.</dd>
						<dt>"punctuation-insensitive"</dt>
						<dd>A punctuation-insensitive query.</dd>
						<dt>"whitespace-sensitive"</dt>
						<dd>A whitespace-sensitive query.</dd>
						<dt>"whitespace-insensitive"</dt>
						<dd>A whitespace-insensitive query.</dd>
						<dt>"stemmed"</dt>
						<dd>A stemmed query.</dd>
						<dt>"unstemmed"</dt>
						<dd>An unstemmed query.</dd>
						<dt>"wildcarded"</dt>
						<dd>A wildcarded query.</dd>
						<dt>"unwildcarded"</dt>
						<dd>An unwildcarded query.</dd>
						<dt>"exact"</dt>
						<dd>An exact match query. Shorthand for "case-sensitive", "diacritic-sensitive", "punctuation-sensitive", "whitespace-sensitive", "unstemmed", and "unwildcarded".</dd>
						<dt>"lang=
							<em>iso639code</em>"</dt>
						<dd>Specifies the language of the query. The
							<em>iso639code</em>code portion is case-insensitive, and uses the languages specified by
							<a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>. The default is specified in the database configuration.</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<return>cts:element-attribute-value-query</return>
		<usage>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $text is used to determine case sensitivity. If $text contains no uppercase, it specifies "case-insensitive". If $text contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $text is used to determine diacritic sensitivity. If $text contains no diacritics, it specifies "diacritic-insensitive". If $text contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>If neither "punctuation-sensitive" nor "punctuation-insensitive" is present, $text is used to determine punctuation sensitivity. If $text contains no punctuation, it specifies "punctuation-insensitive". If $text contains punctuation, it specifies "punctuation-sensitive".</p>
			<p>If neither "whitespace-sensitive" nor "whitespace-insensitive" is present, the query is "whitespace-insensitive".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, the database configuration determines stemming. If the database has "stemmed searches" enabled, it specifies "stemmed". Otherwise it specifies "unstemmed".</p>
			<p>If neither "wildcarded" nor "unwildcarded" is present, the database configuration and $text determine wildcarding. If the database has any wildcard indexes enabled ("three character searches", "two character searches", "one character searches", or "trailing wildcard searches") and if $text contains either of the wildcard characters '?' or '*', it specifies "wildcarded". Otherwise it specifies "unwildcarded".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, then the database configuration determines if a query is run as "stemmed" (stemmed searches enabled) or "unstemmed" (word searches enabled and stemmed searches disabled). If the query is a wildcard query and is also a phrase query (contains two or more terms), then any wildcard terms in the query will be "unstemmed".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
			<p>When multiple element and/or attribute QNames are specified, then all possible element/attribute QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
  cts:search(//module,
    cts:element-attribute-value-query(
      xs:QName("function"),
      xs:QName("type"),
      "MarkLogic Corporation"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of 'function' elements that have
  an attribute 'type' whose value equals 'MarkLogic
  Corporation'.
</example>
    <example xml:space="preserve">
  cts:search(//module,
    cts:and-query((
      cts:element-attribute-value-query(
        xs:QName("function"),
        xs:QName("type"),
        "MarkLogic Corporation",
        false(), true(), 0.5),
      cts:element-word-query(
        xs:QName("title"),
        "faster"))))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of both:
   (a) 'function' elements with attribute 'type' whose
       value equals the string 'MarkLogic Corporation',
       ignoring embedded punctuation,
   AND
   (b) 'title' elements whose text content contains the
       word 'faster', with the results from (a) given
       weight 0.5, and the results from (b) given default
       weight 1.0.
</example>
	</function>
	<function name="element-attribute-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-query-text">
		<summary>Returns the text used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-value-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-attribute-value-query-text($query)
  =&gt; "choice of law"
</example>
	</function>
	<function name="element-attribute-value-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-query-element-name">
		<summary>Returns the element QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-value-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("type"),
              "MarkLogic Corporation")
return
  cts:element-attribute-value-query-element-name($query)

  =&gt; xs:QName("function")
</example>
	</function>
	<function name="element-attribute-value-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-query-attribute-name">
		<summary>Returns the attribute QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-value-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("type"),
              "MarkLogic Corporation")
return
  cts:element-attribute-value-query-attribute-name($query)

  =&gt; xs:QName("type")
</example>
	</function>
	<function name="element-attribute-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-value-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-attribute-value-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</example>
	</function>
	<function name="element-attribute-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-attribute-value-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:element-attribute-value-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-attribute-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-word-query">
		<summary>Returns a query matching elements by name with attributes by name with text content containing a given phrase.</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="attribute-name" type="xs:QName*" optional="false">One or more attribute QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="text" type="xs:string*" optional="false">Some words or phrases to match. When multiple strings are specified, the query matches if any string matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive query.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive query.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive query.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive query.</dd>
						<dt>"punctuation-sensitive"</dt>
						<dd>A punctuation-sensitive query.</dd>
						<dt>"punctuation-insensitive"</dt>
						<dd>A punctuation-insensitive query.</dd>
						<dt>"whitespace-sensitive"</dt>
						<dd>A whitespace-sensitive query.</dd>
						<dt>"whitespace-insensitive"</dt>
						<dd>A whitespace-insensitive query.</dd>
						<dt>"stemmed"</dt>
						<dd>A stemmed query.</dd>
						<dt>"unstemmed"</dt>
						<dd>An unstemmed query.</dd>
						<dt>"wildcarded"</dt>
						<dd>A wildcarded query.</dd>
						<dt>"unwildcarded"</dt>
						<dd>An unwildcarded query.</dd>
						<dt>"exact"</dt>
						<dd>An exact match query. Shorthand for "case-sensitive", "diacritic-sensitive", "punctuation-sensitive", "whitespace-sensitive", "unstemmed", and "unwildcarded".</dd>
						<dt>"lang=
							<em>iso639code</em>"</dt>
						<dd>Specifies the language of the query. The
							<em>iso639code</em>code portion is case-insensitive, and uses the languages specified by
							<a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>. The default is specified in the database configuration.</dd>
						<dt>"min-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the minimum number of occurrences required. If fewer that this number of words occur, the fragment does not match. The default is 1.</dd>
						<dt>"max-occurs=
							<em>number</em>"</dt>
						<dd>Specifies the maximum number of occurrences required. If more than this number of words occur, the fragment does not match. The default is unbounded.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<return>cts:element-attribute-word-query</return>
		<usage>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $text is used to determine case sensitivity. If $text contains no uppercase, it specifies "case-insensitive". If $text contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $text is used to determine diacritic sensitivity. If $text contains no diacritics, it specifies "diacritic-insensitive". If $text contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>If neither "punctuation-sensitive" nor "punctuation-insensitive" is present, $text is used to determine punctuation sensitivity. If $text contains no punctuation, it specifies "punctuation-insensitive". If $text contains punctuation, it specifies "punctuation-sensitive".</p>
			<p>If neither "whitespace-sensitive" nor "whitespace-insensitive" is present, the query is "whitespace-insensitive".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, the database configuration determines stemming. If the database has "stemmed searches" enabled, it specifies "stemmed". Otherwise it specifies "unstemmed".</p>
			<p>If neither "wildcarded" nor "unwildcarded" is present, the database configuration and $text determine wildcarding. If the database has any wildcard indexes enabled ("three character searches", "two character searches", "one character searches", or "trailing wildcard searches") and if $text contains either of the wildcard characters '?' or '*', it specifies "wildcarded". Otherwise it specifies "unwildcarded".</p>
			<p>If neither "stemmed" nor "unstemmed" is present, then the database configuration determines if a query is run as "stemmed" (stemmed searches enabled) or "unstemmed" (word searches enabled and stemmed searches disabled). If the query is a wildcard query and is also a phrase query (contains two or more terms), then any wildcard terms in the query will be "unstemmed".</p>
			<p>Negative "min-occurs" or "max-occurs" values will be treated as 0 and non-integral values will be rounded down. An error will be raised if the "min-occurs" value is greater than the "max-occurs" value.</p>
		</usage>
		<example xml:space="preserve">
  cts:search(//module,
    cts:element-attribute-word-query(
      xs:QName("function"),
      xs:QName("type"),
      "MarkLogic Corporation"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements that have a 'type'
  attribute whose value contains the phrase
  'MarkLogic Corporation'.
</example>
    <example xml:space="preserve">
  cts:search(//module,
    cts:element-attribute-word-query(
      xs:QName("function"),
      xs:QName("type"),
      "MarkLogic Corporation", "case-insensitive"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements that have a 'type'
  attribute whose value contains the phrase
  'MarkLogic Corporation', or any other case-shift,
  like 'MARKLOGIC CorpoRation'.
</example>
    <example xml:space="preserve">
  cts:search(//module,
    cts:and-query((
      cts:element-attribute-word-query(
        xs:QName("function"),
        xs:QName("type"),
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts:element-word-query(
        xs:QName("title"),
        "faster"))))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of both:
  (a) 'function' elements with 'type' attribute whose value
      contains the phrase 'MarkLogic Corporation',
      ignoring embedded punctuation,
  AND
  (b) 'title' elements whose text content contains the
      term 'faster',
  with the results of the first query given weight 0.5,
  as opposed to the default 1.0 for the second query.
</example>
	</function>
	<function name="element-attribute-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-word-query-text">
		<summary>Returns the text used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-attribute-word-query-text($query)
  =&gt; "choice of law"
</example>
	</function>
	<function name="element-attribute-word-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-word-query-element-name">
		<summary>Returns the element QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-word-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("type"),
              "MarkLogic Corporation")
return
  cts:element-attribute-word-query-element-name($query)

  =&gt; xs:QName("function")
</example>
	</function>
	<function name="element-attribute-word-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-word-query-attribute-name">
		<summary>Returns the attribute QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-word-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("type"),
              "MarkLogic Corporation")
return
  cts:element-attribute-word-query-attribute-name($query)

  =&gt; xs:QName("type")
</example>
	</function>
	<function name="element-attribute-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-word-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-word-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:element-attribute-word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</example>
	</function>
	<function name="element-attribute-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-word-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-attribute-word-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:element-attribute-word-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="similar-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:similar-query">
		<summary>Returns a query matching nodes similar to the model nodes. It uses an algorithm which finds the most "relevant" terms in the model nodes (that is, the terms with the highest scores), and then creates a query equivalent to a
			<code>cts:or-query</code>of those terms. By default 16 terms are used.</summary>
		<params>
			<param name="nodes" type="node()*" optional="false">Some model nodes.</param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
			<param name="options" type="element()?" optional="true">An XML representation of the options for defining which terms to generate and how to evaluate them. The options node must be in the
				<code>cts:distinctive-terms</code>namespace. The following is a sample options node:
				<pre xml:space="preserve">
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
    &lt;/options&gt;
</pre>
				<p>See
					<a href="cts:distinctive-terms#db-term-options">the
						<code>cts:distinctive-terms</code>options</a>for the valid options to use with this function.</p>
				<p>Note that enabling index settings that are disabled in the database configuration will not affect the results, as similar documents will not be found on the basis of terms that do not exist in the actual database index.</p></param>
		</params>
		<return>cts:similar-query</return>
		<usage>As the number of fragments in a database grows, the results of
			<code>cts:similar-query</code>become increasingly accurate. For best results, there should be at least 10,000 fragments for 32-bit systems, and 1,000 fragments for 64-bit systems.</usage>
		<example xml:space="preserve">
  cts:search(//function,
    cts:similar-query((//function)[1]))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'function' element
  ancestors (or self) of any node similar to the first
  'function' element.
</example>
    <example xml:space="preserve">
xdmp:estimate(
  cts:search(//function,
    cts:similar-query((//function)[1], (),
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
      &lt;use-db-config&gt;true&lt;/use-db-config&gt;
    &lt;/options&gt;)))
=&gt; the number of fragments containing any node similar
   to the first 'function' element.
</example>
	</function>
	<function name="similar-query-nodes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:similar-query-nodes">
		<summary>Returns the nodes used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:similar-query" optional="false">A query.</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">
  cts:similar-query-nodes($query)
  =&gt; //function
</example>
	</function>
	<function name="similar-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:similar-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:similar-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:similar-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="contains" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:contains">
		<summary>Returns true if any of a sequence of nodes matches a query.</summary>
		<params>
			<param name="nodes" type="node()*" optional="false">Some nodes to be checked for a match.</param>
			<param name="query" type="cts:query" optional="false">A query to match against. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
cts:contains(//PLAY
  [TITLE="The Tragedy of Hamlet, Prince of Denmark"]
      /ACT[3]/SCENE[1],
    cts:word-query("To be, or not to be"))
  =&gt; ..true, if ACT II, SCENE I of Hamlet contains
    the phrase "To be, or not to be" (it does).
</example>
	</function>
	<function name="search" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:search">
		<summary>Returns a relevance-ordered sequence of nodes specified by a given query.</summary>
		<params>
			<param name="expression" type="node()*" optional="false">An expression to be searched. This must be an inline fully searchable path expression.</param>
			<param name="query" type="cts:query?" optional="false">A
				<code>cts:query</code>specifying the search to perform. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="options" type="xs:string*" optional="true">Options to this search. The default is ().
				<a id="unfiltered" />
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>"filtered"</p>
						</dt>
						<dd>
							<p>A filtered search (the default). Filtered searches eliminate any false-positive matches and properly resolve cases where there are multiple candidate matches within the same fragment. Filtered search results fully satisfy the specified
								<code>cts:query</code>.</p>
						</dd>
						<dt>
							<p>"unfiltered"</p>
						</dt>
						<dd>
							<p>An unfiltered search. An unfiltered search selects fragments from the indexes that are candidates to satisfy the specified
								<code>cts:query</code>, and then it returns a single node from within each fragment that satisfies the specified searchable path expression. Unfiltered searches are useful because of the performance they afford when jumping deep into the result set (for example, when paginating a long result set and jumping to the 1,000,000th result). However, depending on the searchable path expression, the
								<code>cts:query</code>specified, the structure of the documents in the database, and the configuration of the database, unfiltered searches may yield false-positive results being included in the search results. Unfiltered searches may also result in missed matches or in incorrect matches, especially when there are multiple candidate matches within a single fragment. To avoid these problems, you should only use unfiltered searches on top-level XPath expressions (for example, document nodes, collections, directories) or on fragment roots. Using unfiltered searches on complex XPath expressions or on XPath expressions that traverse below a fragment root can result in unexpected results.</p>
						</dd>
						<dt>
							<p>"score-logtfidf"</p>
						</dt>
						<dd>
							<p>Compute scores using the logtfidf method (the default scoring method). This uses the formula:
								<br />
								<br />
								<code>log(term frequency) * (inverse document frequency)</code></p>
						</dd>
						<dt>
							<p>"score-logtf"</p>
						</dt>
						<dd>
							<p>Compute scores using the logtf method. This does not take into account how many documents have the term and uses the formula:
								<br />
								<br />
								<code>log(term frequency)</code></p>
						</dd>
						<dt>
							<p>"score-simple"</p>
						</dt>
						<dd>
							<p>Compute scores using the simple method. The score-simple method gives a score of 8*weight for each matching term in the
								<code>cts:query</code>expression. It does not matter how many times a given term matches (that is, the term frequency does not matter); each match contributes 8*weight to the score. For example, the following query (assume the default weight of 1) would give a score of 8 for any fragment with one or more matches for "hello", a score of 16 for any fragment that also has one or more matches for "goodbye", or a score of zero for fragments that have no matches for either term:
								<br />
								<br />
								<code>cts:or-query(("hello", "goodbye"))</code></p>
						</dd>
						<dt>
							<p>"score-random"</p>
						</dt>
						<dd>
							<p>Compute scores using the random method. The score-random method gives a random value to the score. You can use this to randomly choose fragments matching a query.</p>
						</dd>
						<dt>"checked"</dt>
						<dd>
							<p>Word positions are checked (the default) when resolving the query. Checked searches eliminate false-positive matches for phrases during the index resolution phase of search processing.</p>
						</dd>
						<dt>"unchecked"</dt>
						<dd>
							<p>Word positions are not checked when resolving the query. Unchecked searches do not take into account word positions and can lead to false-positive matches during the index resolution phase of search processing. This setting is useful for debugging, but not recommended for normal use.</p>
						</dd>
					</dl>
				</blockquote></param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is (). You can use
				<code>cts:search</code>with this parameter and an empty
				<code>cts:and-query</code>to specify a forest-specific XPath statement (see the
				<a href="#searchEx3">third example</a>below). If you use this to constrain an XPath to one or more forests, you should set the
				<code>quality-weight</code>to zero to keep the XPath document order.</param>
		</params>
		<return>node()*</return>
		<usage>
			<p>Queries that use
				<code>cts:search</code>require that the XPath expression searched is fully searchable. A
				<em>fully searchable</em>path is one that has no steps that are unsearchable and whose last step is searchable. You can use the
				<code>xdmp:query-trace()</code>function to see if the path is fully searchable. If there are no entries in the
				<code>xdmp:query-trace()</code>output indicating that a step is unsearchable, and if the last step is searchable, then that path is fully searchable. Queries that use
				<code>cts:search</code>on unsearchable XPath expressions will fail with an an error message. You can often make the path expressions fully searchable by rewriting the query or adding new indexes.</p>
			<p>Each node that
				<code>cts:search</code>returns has a score with which it is associated. To access the score, use the
				<code>cts:score</code>function. The nodes are returned in relevance order (most relevant to least relevant), where more relevant nodes have a higher score.</p>
			<p>Only one of the "filtered" or "unfiltered" options may be specified in the options parameter. If neither "filtered" nor "unfiltered", is specified then the default is "filtered".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If the neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If the
				<code>cts:query</code>specified is the empty string (equivalent to
				<code>cts:word-query("")</code>), then the search returns the empty sequence.</p>
		</usage>
		<example xml:space="preserve">
  cts:search(//SPEECH,
    cts:word-query("with flowers"))

  =&gt; ... a sequence of 'SPEECH' element ancestors (or self)
     of any node containing the phrase 'with flowers'.
</example>
    <example xml:space="preserve">
  cts:search(collection("self-help")/book,
    cts:element-query(xs:QName("title"), "meditation"),
    "score-simple", 1.0, (xdmp:forest("prod"),xdmp:forest("preview")))

  =&gt; ... a sequence of book elements matching the XPath
     expression which are members of the "self-help"
     collection, reside in the the "prod" or "preview" forests and
     contain "meditation" in the title element, using the
     "score-simple" option.
</example>
    <example xml:space="preserve">
  cts:search(/some/xpath, cts:and-query(()), (), 0.0,
    xdmp:forest("myForest"))

  =&gt; ... a sequence of /some/xpath elements that are
     in the forest named "myForest".  Note the
     empty and-query, which matches all documents (and
     scores them all the same) and the quality-weight
     of 0, which together make each result have a score
     of 0, which keeps the results in document order.
</example>
		<algorithm type="internal">The algorithm uses two stages. The first stage selects fragments which are candidates for the second stage. The second stage does exact matching of nodes, attributes and text by scanning the fragments.
			<ul>
				<li>Construct a boolean query from the 'and', 'or', 'and-not' queries, with term query leaf nodes.</li>
				<li>Submit the boolean term query to the inverted file manager, which returns a sequence of fragments.</li>
				<li>Scan the fragment list and return a sequence of element nodes exactly matching the query.</li>
				<li>The fragments are relevance ordered, and this order is preserved throughout the subsequent scanning and matching.</li>
			</ul></algorithm>
	</function>
	<function name="quality" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:quality">
		<summary>Returns the quality of a node, or of the context node if no node is provided.</summary>
		<params>
			<param name="node" type="node()" optional="true">A node. Typically this is an item in the result sequence of a
				<code>cts:search</code>operation.</param>
		</params>
		<return>xs:integer</return>
		<usage>
			<p>If you run
				<code>cts:quality</code>on a constructed node, it always returns 0; it is primarily intended to run on nodes that are the retrieved from the database (an item from a
				<code>cts:search</code>result or an item from the result of an XPath expression that searches through the database).</p>
		</usage>
		<example xml:space="preserve">
  xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;, (), (), 50);
  for $x in cts:search(collection(),"my test")
  return cts:quality($x) =&gt; 50
</example>
    <example xml:space="preserve">
  for $a in cts:search(collection(),"my test")
  where $a[cts:quality() gt 10]
  return xdmp:node-uri($a) =&gt; /test.xml
</example>
	</function>
	<function name="score" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:score">
		<summary>Returns the score of a node, or of the context node if no node is provided.</summary>
		<params>
			<param name="node" type="node()" optional="true">A node. Typically this is an item in the result sequence of a
				<code>cts:search</code>operation.</param>
		</params>
		<return>xs:integer</return>
		<usage>
			<p>Score is computed according to the scoring method specified in the
				<code>cts:search</code>expression, if any.</p>
			<p>If you run
				<code>cts:score</code>on a constructed node, it always returns 0; it is primarily intended to run on nodes that are retrieved from the database (an item from a
				<code>cts:search</code>result or an item from the result of an XPath expression that searches through the database).</p>
		</usage>
		<example xml:space="preserve">
(: run this on the Shakespeare content set :)
for $hit in cts:search(//SPEECH,
    cts:word-query("with flowers"))[1 to 10]
return element hit {
  attribute score { cts:score($hit) },
  $hit
}
</example>
    <example xml:space="preserve">
  xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;);
  for $x in cts:search(doc("/test.xml"),"my test")
  return cts:score($x) =&gt; 11
</example>
    <example xml:space="preserve">
  for $a in cts:search(collection(),"my test")
  where $a[cts:score() gt 10]
  return xdmp:node-uri($a) =&gt; /test.xml
</example>
	</function>
	<function name="confidence" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:confidence">
		<summary>Returns the confidence of a node, or of the context node if no node is provided.</summary>
		<params>
			<param name="node" type="node()" optional="true">A node. Typically this is an item in the result sequence of a
				<code>cts:search</code>operation.</param>
		</params>
		<return>xs:float</return>
		<usage>
			<p>Confidence is similar to score, except that it is bounded. It is similar to fitness, except that it is influenced by term IDFs. It is an
				<code>xs:float</code>in the range of 0.0 to 1.0. It does not include quality.</p>
			<p>When using with any of the scoring methods, the confidence is calculated by first bounding the score in the range of 0.0 to 1.0, then taking the square root of that number.</p>
		</usage>
		<example xml:space="preserve">
  let $x := cts:search(collection(), "dog")
  return
  cts:confidence($x[1])

   =&gt; Returns the confidence value for the first item
      in the search.
</example>
	</function>
	<function name="fitness" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:fitness">
		<summary>Returns the fitness of a node, or of the context node if no node is provided. Fitness is a normalized measure of relevance that is based on how well a node matches the query issued, not taking into account the number of documents in which the query term(s) occur.</summary>
		<params>
			<param name="node" type="node()" optional="true">A node. Typically this is an item in the result sequence of a
				<code>cts:search</code>operation.</param>
		</params>
		<return>xs:float</return>
		<usage>
			<p>Fitness is similar to score, except that it is bounded. It is similar to confidence, except that it is not influenced by term IDFs. It is an
				<code>xs:float</code>in the range of 0.0 to 1.0. It does not include quality.</p>
		</usage>
		<example xml:space="preserve">
  let $x := cts:search(collection(), "dog")
  return
  cts:fitness($x[1])

   =&gt; Returns the fitness value for the first item
      in the search.
</example>
	</function>
	<function name="remainder" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:remainder">
		<summary>Returns an estimated search result size for a node, or of the context node if no node is provided. The search result size for a node is the number of fragments remaining (including the current node) in the result sequence containing the node. This is useful to quickly estimate the size of a search result sequence, without using
			<code>fn:count()</code>or
			<code>xdmp:estimate()</code>.</summary>
		<params>
			<param name="node" type="node()" optional="true">A node. Typically this is an item in the result sequence of a
				<code>cts:search</code>operation. If you specify the first item from a
				<code>cts:search</code>expression, then
				<code>cts:remainder</code>will return an estimate of the number of fragments that match that expression.</param>
		</params>
		<return>xs:integer</return>
		<usage>
			<p>This function makes it efficient to estimate the size of a search result and execute that search in the same query. If you only need an estimate of the size of a search but do not need to run the search, then
				<code>xdmp:estimate</code>is more efficient.</p>
			<p>To return the estimated size of a search with
				<code>cts:remainder</code>, use the first item of a
				<code>cts:search</code>result sequence as the parameter to
				<code>cts:remainder</code>. For example, the following query returns the estimated number of fragments that contain the word "dog":</p>
			<pre xml:space="preserve">
  cts:remainder(cts:search(collection(), "dog")[1])
</pre>
			<p>When you put the position predicate on the
				<code>cts:search</code>result sequence, MarkLogic Server will filter all of the false-positive results up to the specified position, but not the false-positive results beyond the specified position. Because of this, when you increase the position number in the parameter, the result from
				<code>cts:remainder</code>might decrease by a larger number than the increase in position number, or it might not decrease at all. For example, if the query above returned 10, then the following query might return 9, it might return 10, or it might return less than 9, depending on how the results are dispersed throughout different fragments:</p>
			<pre xml:space="preserve">
  cts:remainder(cts:search(collection(), "dog")[2])
</pre>
			<p>If you run
				<code>cts:remainder</code>on a constructed node, it always returns 0; it is primarily intended to run on nodes that are the retrieved from the database (an item from a
				<code>cts:search</code>result or an item from the result of an XPath expression that searches through the database).</p>
		</usage>
		<example xml:space="preserve">
  let $x := cts:search(collection(), "dog")
  return
  (cts:remainder($x[1]), $x)

   =&gt; Returns the estimated number of items in the search
      for "dog" followed by the results of the search.
</example>
    <example xml:space="preserve">
  xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;);
  for $x in cts:search(collection(),"my test")
  return cts:remainder($x) =&gt; 1
</example>
    <example xml:space="preserve">
  for $a in cts:search(collection(),"my test")
  where $a[cts:remainder() eq 1]
  return xdmp:node-uri($a) =&gt; /test.xml
</example>
	</function>
	<function name="tokenize" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:tokenize">
		<summary>Tokenizes text into words, punctuation, and spaces. Returns output in the type
			<code>cts:token</code>, which has subtypes
			<code>cts:word</code>,
			<code>cts:punctuation</code>, and
			<code>cts:space</code>, all of which are subtypes of
			<code>xs:string</code>.</summary>
		<params>
			<param name="text" type="xs:string" optional="false">A word or phrase to tokenize.</param>
			<param name="language" type="xs:string?" optional="true">A language to use for tokenization. If not supplied, it uses the database default language.</param>
		</params>
		<return>cts:token*</return>
		<usage>
			<p>When you tokenize a string with
				<code>cts:tokenize</code>, each word is represented by an instance of
				<code>cts:word</code>, each punctuation character is represented by an instance of
				<code>cts:punctuation</code>, each set of adjacent spaces is represented by an instance of
				<code>cts:space</code>, and each set of adjacent line breaks is represented by an instance of
				<code>cts:space</code>.</p>
			<p>Unlike the standard XQuery function
				<code>fn:tokenize</code>,
				<code>cts:tokenize</code>returns words, punctuation, and spaces as different types. You can therefore use a typeswitch to handle each type differently. For example, you can use
				<code>cts:tokenize</code>to remove all punctuation from a string, or create logic to test for the type and return different things for different types, as shown in the first two examples below.</p>
			<p>You can use
				<code>xdmp:describe</code>to show how a given string will be tokenized. When run on the results of
				<code>cts:tokenize</code>, the
				<code>xdmp:describe</code>function returns the types and the values for each token. For a sample of this pattern, see the third example below.</p>
		</usage>
		<example xml:space="preserve">
(: Remove all punctuation :)
let $string := "The red, blue, green, and orange
                balloons were launched!"
let $noPunctuation :=
  for $token in cts:tokenize($string)
  return
    typeswitch ($token)
     case $token as cts:punctuation return ""
     case $token as cts:word return $token
     case $token as cts:space return $token
     default return ()
return string-join($noPunctuation, "")

<br xmlns="http://www.w3.org/1999/xhtml" />
 =&gt; The red blue green and orange
    balloons were launched
</example>
    <example xml:space="preserve">
(: Insert the string "XX" before and after
   all punctuation tokens :)
let $string := "The red, blue, green, and orange
                 balloons were launched!"
let $tokens := cts:tokenize($string)
return string-join(
for $x in $tokens
return if ($x instance of cts:punctuation)
       then (concat("XX",
                     $x, "XX"))
       else ($x) , "")
 =&gt; The redXX,XX blueXX,XX greenXX,XX and orange
    balloons were launchedXX!XX

</example>
    <example xml:space="preserve">
(: show the types and tokens for a string :)
xdmp:describe(cts:tokenize("blue, green"))

=&gt; (cts:word("blue"), cts:punctuation(","),
    cts:space(" "), cts:word("green"))
</example>
	</function>
	<function name="stem" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:stem">
		<summary>Returns the stem(s) for a word.</summary>
		<params>
			<param name="text" type="xs:string" optional="false">A word or phrase to stem.</param>
			<param name="language" type="xs:string?" optional="true">A language to use for stemming. If not supplied, it uses the database default language.</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>In general, you should pass a word into
				<code>cts:stem</code>; if you enter a phrase, it will stem the phrase, which will normally stem to itself.</p>
			<p>When you stem a word through
				<code>cts:stem</code>, it returns all of the stems for the word, including decompounding and multiple stems, regardless of the database stemming setting.</p>
		</usage>
		<example xml:space="preserve">
cts:stem("ran","en")
=&gt; "run"
</example>
	</function>
	<function name="walk" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:walk">
		<summary>Walks a node, evaluating an expression with any text matching a query. It returns a sequence of all the values returned by the expression evaluations. This is similar to
			<code>cts:highlight</code>in how it evaluates its expression, but it is different in what it returns.</summary>
		<params>
			<param name="node" type="node()" optional="false">A node to walk. The node must be either a document node or an element node; it cannot be a text node.</param>
			<param name="query" type="cts:query" optional="false">A query specifying the text on which to evaluate the expression. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="expr" type="item()*" optional="false">An expression to evaluate with matching text. You can use the variables
				<code>$cts:text</code>,
				<code>$cts:node</code>,
				<code>$cts:queries</code>,
				<code>$cts:start</code>, and
				<code>$cts:action</code>(described below) in the expression.</param>
		</params>
		<return>item()*</return>
		<usage>
			<p>There are five built-in variables to represent a query match. These variables can be used inline in the expression parameter.</p>
			<blockquote>
				<dl>
					<dt>
						<code>$cts:text</code>as
						<code>xs:string</code></dt>
					<dd>
						<p>The matched text.</p>
					</dd>
					<dt>
						<code>$cts:node</code>as
						<code>text()</code></dt>
					<dd>
						<p>The node containing the matched text.</p>
					</dd>
					<dt>
						<code>$cts:queries</code>as
						<code>cts:query*</code></dt>
					<dd>
						<p>The matching queries.</p>
					</dd>
					<dt>
						<code>$cts:start</code>as
						<code>xs:integer</code></dt>
					<dd>
						<p>The string-length position of the first character of
							<code>$cts:text</code>in
							<code>$cts:node</code>. Therefore, the following always returns true:</p>
						<pre xml:space="preserve">
fn:substring($cts:node, $cts:start,
             fn:string-length($cts:text)) eq $cts:text
</pre>
					</dd>
					<dt>
						<code>$cts:action</code>as
						<code>xs:string</code></dt>
					<dd>
						<p>Use
							<code>xdmp:set</code>on this to specify what should happen next</p>
						<dl>
							<dt>"continue"</dt>
							<dd>(default) Walk the next match. If there are no more matches, return all evaluation results.</dd>
							<dt>"skip"</dt>
							<dd>Skip walking any more matches and return all evaluation results.</dd>
							<dt>"break"</dt>
							<dd>Stop walking matches and return all evaluation results.</dd>
						</dl>
					</dd>
				</dl>
			</blockquote>
			<p>You cannot use
				<code>cts:walk</code>to walk results matching
				<code>cts:similar-query</code>and
				<code>cts:element-attribute-*-query</code>items.</p>
			<p>Because the expressions can be any XQuery expression, they can be very simple like the above example or they can be extremely complex.</p>
		</usage>
		<example xml:space="preserve">
(:
   Return all text nodes containing matches to the query "the".
:)
let $x := &lt;p&gt;the quick brown fox &lt;b&gt;jumped&lt;/b&gt; over the lazy dog's back&lt;/p&gt;
return cts:walk($x, "the", $cts:node)
=&gt;
  (text{"the quick brown fox "}, text{" over the lazy dog's back"})

</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
(:
   Do not show any more matches that occur after
   $threshold characters.
:)
let $x := &lt;p&gt;This is 1, this is 2, this is 3, this is 4, this is 5.&lt;/p&gt;
let $pos := 1
let $threshold := 20
return
cts:walk($x, "this is",
 (if ( $pos gt $threshold )
  then xdmp:set($cts:action, "break")
  else ($cts:text, xdmp:set($pos, $cts:start)) ) )
=&gt;
("This is", "this is", "this is")
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
(:
   Show the first two matches.
:)
let $x := &lt;p&gt;This is 1, this is 2, this is 3, this is 4, this is 5.&lt;/p&gt;
let $match := 0
let $threshold := 2
return
cts:walk($x, "this is",
 (if ( $match ge $threshold )
  then xdmp:set($cts:action, "break")
  else ($cts:text, xdmp:set($match, $match + 1)) ) )
=&gt;
("This is", "this is")
</example>
	</function>
	<function name="highlight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:highlight">
		<summary>Returns a copy of the node, replacing any text matching the query with the specified expression. You can use this function to easily highlight any text found in a query. Unlike
			<code>fn:replace</code>and other XQuery string functions that match literal text,
			<code>cts:highlight</code>matches every term that matches the search, including stemmed matches or matches with different capitalization.</summary>
		<params>
			<param name="node" type="node()" optional="false">A node to highlight. The node must be either a document node or an element node; it cannot be a text node.</param>
			<param name="query" type="cts:query" optional="false">A query specifying the text to highlight. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="expr" type="item()*" optional="false">An expression with which to replace each match. You can use the variables
				<code>$cts:text</code>,
				<code>$cts:node</code>,
				<code>$cts:queries</code>,
				<code>$cts:start</code>, and
				<code>$cts:action</code>(described below) in the expression.</param>
		</params>
		<return>node()</return>
		<usage>
			<p>There are five built-in variables to represent a query match. These variables can be used inline in the expression parameter.</p>
			<blockquote>
				<dl>
					<dt>
						<code>$cts:text</code>as
						<code>xs:string</code></dt>
					<dd>
						<p>The matched text.</p>
					</dd>
					<dt>
						<code>$cts:node</code>as
						<code>text()</code></dt>
					<dd>
						<p>The node containing the matched text.</p>
					</dd>
					<dt>
						<code>$cts:queries</code>as
						<code>cts:query*</code></dt>
					<dd>
						<p>The matching queries.</p>
					</dd>
					<dt>
						<code>$cts:start</code>as
						<code>xs:integer</code></dt>
					<dd>
						<p>The string-length position of the first character of
							<code>$cts:text</code>in
							<code>$cts:node</code>. Therefore, the following always returns true:</p>
						<pre xml:space="preserve">
fn:substring($cts:node, $cts:start,
             fn:string-length($cts:text)) eq $cts:text
</pre>
					</dd>
					<dt>
						<code>$cts:action</code>as
						<code>xs:string</code></dt>
					<dd>
						<p>Use
							<code>xdmp:set</code>on this to specify what should happen next</p>
						<dl>
							<dt>"continue"</dt>
							<dd>(default) Walk the next match. If there are no more matches, return all evaluation results.</dd>
							<dt>"skip"</dt>
							<dd>Skip walking any more matches and return all evaluation results.</dd>
							<dt>"break"</dt>
							<dd>Stop walking matches and return all evaluation results.</dd>
						</dl>
					</dd>
				</dl>
			</blockquote>
			<p>You cannot use
				<code>cts:highlight</code>to highlight results matching
				<code>cts:similar-query</code>and
				<code>cts:element-attribute-*-query</code>items. Using
				<code>cts:highlight</code>with these queries will return the nodes without any highlighting.</p>
			<p>You can also use
				<code>cts:highlight</code>as a general search and replace function. The specified expression will replace any matching text. For example, you could replace the word "hello" with "goodbye" in a query similar to the following:</p>
			<pre xml:space="preserve">
 cts:highlight($node, "hello", "goodbye")
</pre>
			<p>Because the expressions can be any XQuery expression, they can be very simple like the above example or they can be extremely complex.</p>
		</usage>
		<example xml:space="preserve">
To highlight "MarkLogic" with bold in the following paragraph:

let $x :=  &lt;p&gt;MarkLogic Server is an enterprise-class
  database specifically built for content.&lt;/p&gt;
return
cts:highlight($x, "MarkLogic", &lt;b&gt;{$cts:text}&lt;/b&gt;)

Returns:

  &lt;p&gt;&lt;b&gt;MarkLogic&lt;/b&gt; Server is an enterprise-class
  database specifically built for content.&lt;/p&gt;

</example>
    <example xml:space="preserve">
Given the following document with the URI "hellogoodbye.xml":

&lt;root&gt;
  &lt;a&gt;It starts with hello and ends with goodbye.&lt;/a&gt;
&lt;/root&gt;

The following query will highlight the word "hello" in
blue, and everything else in red.

cts:highlight(doc("hellogoodbye.xml"),
       cts:and-query((cts:word-query("hello"),
                      cts:word-query("goodbye"))),
  if (cts:word-query-text($cts:queries) eq "hello")
  then (&lt;font color="blue"&gt;{$cts:text}&lt;/font&gt;)
  else (&lt;font color="red"&gt;{$cts:text}&lt;/font&gt;))

returns:

&lt;root&gt;
  &lt;a&gt;It starts with &lt;font color="blue"&gt;hello&lt;/font&gt;
  and ends with &lt;font color="red"&gt;goodbye&lt;/font&gt;.&lt;/a&gt;
&lt;/root&gt;
</example>
    <example xml:space="preserve">
for $x in cts:search(collection(), "MarkLogic")
return
cts:highlight($x, "MarkLogic", &lt;b&gt;{$cts:text}&lt;/b&gt;)

returns all of the nodes that contain "MarkLogic",
placing bold markup around the matched words.
</example>
	</function>
	<function name="entity-highlight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:entity-highlight">
		<summary>Returns a copy of the node, replacing any entities found with the specified expression. You can use this function to easily highlight any entities in an XML document in an arbitrary manner. If you do not need fine-grained control of the XML markup returned, you can use the
			<code>entity:enrich</code>XQuery module function instead. A valid entity enrichment license key is required to use
			<code>cts:entity-highlight</code>; without a valid license key, it throws an exception. If you have a valid license for entity enrichment, you can entity enrich text in English and in any other languages for which you have a valid license key. For languages in which you do not have a valid license key,
			<code>cts:entity-highlight</code>finds no entities for text in that language.</summary>
		<params>
			<param name="node" type="node()" optional="false">A node to run entity highlight on. The node must be either a document node or an element node; it cannot be a text node.</param>
			<param name="expr" type="item()*" optional="false">An expression with which to replace each match. You can use the variables
				<code>$cts:text</code>,
				<code>$cts:node</code>,
				<code>$cts:entity-type</code>and
				<code>$cts:normalized-text</code>,
				<code>$cts:start</code>, and
				<code>$cts:action</code>(described below) in the expression.</param>
		</params>
		<return>node()</return>
		<usage>
			<p>In addition to a valid Entity Enrichment license key, this function requires that you have installed the Entity Enrichment package. For details on installing the Entity Enrichment package, see the
				<em>Installation Guide</em>and the "Marking Up Documents With Entity Enrichment" chapter of the
				<em>Search Developer's Guide</em>.</p>
			<p>There are six built-in variables to represent an entity match. These variables can be used inline in the expression parameter.</p>
			<blockquote>
				<dl>
					<dt>
						<code>$cts:text</code>as
						<code>xs:string</code></dt>
					<dd>
						<p>The matched text.</p>
					</dd>
					<dt>
						<code>$cts:node</code>as
						<code>text()</code></dt>
					<dd>
						<p>The node containing the matched text.</p>
					</dd>
					<dt>
						<code>$cts:start</code>as
						<code>xs:integer</code></dt>
					<dd>
						<p>The string-length position of the first character of
							<code>$cts:text</code>in
							<code>$cts:node</code>. Therefore, the following always returns true:</p>
						<pre xml:space="preserve">
fn:substring($cts:node, $cts:start,
             fn:string-length($cts:text)) eq $cts:text
</pre>
					</dd>
					<dt>
						<code>$cts:action</code>as
						<code>xs:string</code></dt>
					<dd>
						<p>Use
							<code>xdmp:set</code>on this to specify what should happen next</p>
						<dl>
							<dt>"continue"</dt>
							<dd>(default) Walk the next match. If there are no more matches, return all evaluation results.</dd>
							<dt>"skip"</dt>
							<dd>Skip walking any more matches and return all evaluation results.</dd>
							<dt>"break"</dt>
							<dd>Stop walking matches and return all evaluation results.</dd>
						</dl>
					</dd>
					<dt>
						<p>
							<code>$cts:entity-type</code>as
							<code>xs:string</code></p>
					</dt>
					<dd>
						<p>The type of the matching entity.</p>
					</dd>
					<dt>
						<code>$cts:normalized-text</code>as
						<code>xs:string</code></dt>
					<dd>
						<p>The normalized entity text (only applicable for some languages).</p>
					</dd>
				</dl>
			</blockquote>
			<p>The following are the entity types returned from the
				<code>$cts:entity-type</code>built-in variable (in alphabetical order):</p>
			<blockquote>
				<dl>
					<dt>
						<code>FACILITY</code>
					</dt>
					<dd>A place used as a facility.</dd>
					<dt>
						<code>GPE</code>
					</dt>
					<dd>Geo-political entity. Differs from location because it has a person-made aspect to it (for example, California is a GPE because its boundaries were defined by a government).</dd>
					<dt>
						<code>IDENTIFIER:CREDIT_CARD_NUM</code>
					</dt>
					<dd>A number identifying a credit card number.</dd>
					<dt>
						<code>IDENTIFIER:DISTANCE</code>
					</dt>
					<dd>A number identifying a distance.</dd>
					<dt>
						<code>IDENTIFIER:EMAIL</code>
					</dt>
					<dd>Identifies an email address.</dd>
					<dt>
						<code>IDENTIFIER:LATITUDE_LONGITUDE</code>
					</dt>
					<dd>Latitude and longitude coordinates.</dd>
					<dt>
						<code>IDENTIFIER:MONEY</code>
					</dt>
					<dd>Identifies currency (dollars, euros, and so on).</dd>
					<dt>
						<code>IDENTIFIER:NUMBER</code>
					</dt>
					<dd>Identifies a number.</dd>
					<dt>
						<code>IDENTIFIER:PERSONAL_ID_NUM</code>
					</dt>
					<dd>A number identifying a social security number or other ID number.</dd>
					<dt>
						<code>IDENTIFIER:PHONE_NUMBER</code>
					</dt>
					<dd>A number identifying a telephone number.</dd>
					<dt>
						<code>IDENTIFIER:URL</code>
					</dt>
					<dd>Identifies a web site address (URL).</dd>
					<dt>
						<code>IDENTIFIER:UTM</code>
					</dt>
					<dd>Identifies Universal Transverse Mercator coordinates.</dd>
					<dt>
						<code>LOCATION</code>
					</dt>
					<dd>A geographic location (Mount Everest, for example).</dd>
					<dt>
						<code>NATIONALITY</code>
					</dt>
					<dd>The nationality of someone or something (for example, American).</dd>
					<dt>
						<code>ORGANIZATION</code>
					</dt>
					<dd>An organization.</dd>
					<dt>
						<code>PERSON</code>
					</dt>
					<dd>A person.</dd>
					<dt>
						<code>RELIGION</code>
					</dt>
					<dd>A religion.</dd>
					<dt>
						<code>TEMPORAL:DATE</code>
					</dt>
					<dd>Date-related.</dd>
					<dt>
						<code>TEMPORAL:TIME</code>
					</dt>
					<dd>Time-related.</dd>
					<dt>
						<code>TITLE</code>
					</dt>
					<dd>Appellation or honorific associated with a person.</dd>
					<dt>
						<code>URL</code>
					</dt>
					<dd>A URL on the world wide web.</dd>
					<dt>
						<code>UTM</code>
					</dt>
					<dd>A point in the Universal Transverse Mercator (UTM) coordinate system.</dd>
				</dl>
			</blockquote>
		</usage>
		<example xml:space="preserve">
let $myxml := &lt;node&gt;George Washington never visited Norway.
              If he had a Social Security number,
              it might be 000-00-0001.&lt;/node&gt;
return
cts:entity-highlight($myxml,
   element { fn:replace($cts:entity-type, ":", "-") } { $cts:text })

=&gt;
&lt;node&gt;
  &lt;PERSON&gt;George Washington&lt;/PERSON&gt; never visited &lt;GPE&gt;Norway&lt;/GPE&gt;.
  If he had a Social Security number, it might be
  &lt;IDENTIFIER-PERSONAL_ID_NUM&gt;000-00-0001&lt;/IDENTIFIER-PERSONAL_ID_NUM&gt;.
&lt;/node&gt;


</example>
	</function>
	<function name="near-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:near-query">
		<summary>Returns a query matching all of the specified queries, where the matches occur within the specified distance from each other.</summary>
		<params>
			<param name="queries" type="cts:query*" optional="false">A sequence of queries to match.</param>
			<param name="distance" type="xs:double?" optional="true">A distance, in number of words, between any two matching queries. The results match if two queries match and the distance between the two matches is equal to or less than the specified distance. A distance of 0 matches when the text is the exact same text or when there is overlapping text (see the third example below). A negative distance is treated as 0. The default value is 10.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default value is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ordered"</dt>
						<dd>Any near-query matches must occur in the order of the specified sub-queries.</dd>
						<dt>"unordered"</dt>
						<dd>Any near-query matches will satisfy the query, regardless of the order they were specified.</dd>
					</dl>
				</blockquote></param>
			<param name="distance-weight" type="xs:double?" optional="true">A weight attributed to the distance for this query. Higher weights add to the importance of distance (as opposed to term matches) when the relevance order is calculated. The default value is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score. This parameter has no effect if the
				<code>word positions</code>index is not enabled.</param>
		</params>
		<return>cts:near-query</return>
		<usage>
			<p>If the options parameter contains neither "ordered" nor "unordered", then the default is "unordered".</p>
			<p>The
				<code>word positions</code>index will speed the performance of queries that use
				<code>cts:near-query</code>. The
				<code>element word positions</code>index will speed the performance of element-queries that use
				<code>cts:near-query</code>.</p>
			<p>If you use
				<code>cts:near-query</code>with a field, the distance specified is the distance in the whole document, not the distance in the field. For example, if the distance between two words is 20 in the document, but the distance is 10 if you look at a view of the document that only includes the elements in a field, a
				<code>cts:near-query</code>must have a distance of 20 or more to match; a distance of 10 would not match.</p>
			<p>If you use
				<code>cts:near-query</code>with
				<code>cts:field-word-query</code>, the distance supplied in the near query applies to the whole document, not just to the field. For details, see
				<a href="#cts:field-word-query">
					<code>cts:field-word-query</code>
				</a>.</p>
			<p>Expressions using the
				<code>ordered</code>option are more efficient than those using the
				<code>unordered</code>option, especially if they specify many queries to match.</p>
		</usage>
		<example xml:space="preserve">
 The following query searches for paragraphs containing
 both "MarkLogic" and "Server" within 3 words of each
 other, given the following paragraphs in a database:

  &lt;p&gt;MarkLogic Server is an enterprise-class
  database specifically built for content.&lt;/p&gt;
  &lt;p&gt;MarkLogic is an excellent XML Content Server.&lt;/p&gt;

  cts:search(//p,
    cts:near-query(
      (cts:word-query("MarkLogic"),
      cts:word-query("Server")),
      3))

  =&gt;
  &lt;p&gt;MarkLogic Server is an enterprise-class
  database specifically built for content.&lt;/p&gt;

</example>
    <example xml:space="preserve">
let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("discontent", "winter"),
                    3, "ordered"))

=&gt; false because "discontent" comes after "winter"

let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("discontent", "winter"),
                    3, "unordered"))

=&gt; true because the query specifies "unordered",
        and it is still a match even though
        "discontent" comes after "winter"

</example>
    <example xml:space="preserve">
let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("is the winter", "winter of"),
                    0))

=&gt; true because the phrases overlap

let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("is the winter", "of our"),
                    0))

=&gt; false because the phrases do not overlap
         (they have 1 word distance, not 0)

</example>
	</function>
	<function name="near-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:near-query-queries">
		<summary>Returns the query sequence used to construct the near query.</summary>
		<params>
			<param name="query" type="cts:near-query" optional="false">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  cts:near-query-queries($query)
  =&gt; ... a sequence of the queries used to
            construct this query
</example>
    <example xml:space="preserve">
let $query :=
  cts:near-query((
    cts:word-query("to be or"),
    cts:word-query("or not to be")))
return cts:near-query-queries($query)
  =&gt; (cts:word-query("to be or", (), 1)
         cts:word-query("or not to be", (), 1))
</example>
	</function>
	<function name="near-query-distance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:near-query-distance">
		<summary>Returns the distance used to construct the near query.</summary>
		<params>
			<param name="query" type="cts:near-query" optional="false">A query.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
let $query := cts:near-query(
                 cts:word-query("wanted"),
                 cts:word-query("unwanted"),
                 12)
return cts:near-query-distance($query)
  =&gt; 12
</example>
	</function>
	<function name="near-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:near-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:near-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query := cts:near-query(
                 cts:word-query("wanted"),
                 cts:word-query("unwanted"),
                 12,
                 "ordered")
return
  cts:near-query-options($query)
  =&gt; "ordered"
</example>
	</function>
	<function name="near-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:near-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:near-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
let $query := cts:near-query(
                 cts:word-query("wanted"),
                 cts:word-query("unwanted"),
                 12, "ordered", 5.0)
return
  cts:near-query-weight($query)
  =&gt; 5.0
</example>
	</function>
	<function name="element-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-query">
		<summary>Returns a
			<code>cts:query</code>matching elements by name with the content constrained by the given
			<code>cts:query</code>in the second parameter. Searches for matches in the specified element and all of its descendants. If the specified query in the second parameter has any
			<code>cts:element-attribute-*-query</code>constructors, it will search attributes directly on the specified element and attributes on any descendant elements (see the
			<a href="#eq2">second example</a>below).</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="query" type="cts:query" optional="false">A query for the element to match. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
		</params>
		<return>cts:element-query</return>
		<usage>Enabling both the word position and element position indexes ("word position" and "element word position" in the database configuration screen of the Admin Interface) will speed up query performance for many queries that use
			<code>cts:element-query</code>. The position indexes enable MarkLogic Server to eliminate many false-positive results, which can reduce disk I/O and processing, thereby speeding the performance of many queries. The amount of benefit will vary depending on your data.</usage>
		<example xml:space="preserve">
  cts:search(//module,
    cts:element-query(
      xs:QName("function"),
      "MarkLogic Corporation"))

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic
  Corporation'.
</example>
    <example xml:space="preserve">
let $x := &lt;a attr="something"&gt;hello&lt;/a&gt;
return
cts:contains($x, cts:element-query(xs:QName("a"),
   cts:and-query((
     cts:element-attribute-word-query(xs:QName("a"),
         xs:QName("attr"), "something"),
     cts:word-query("hello")))))
(: returns true :)
</example>
	</function>
	<function name="element-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query := cts:element-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-query-element-name($query)

  =&gt; xs:QName("function")
</example>
	</function>
	<function name="element-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-query-query">
		<summary>Returns the query used to construct the element query.</summary>
		<params>
			<param name="query" type="cts:element-query" optional="false">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
let $query := cts:element-query(
                 cts:word-query("wanted"))
return cts:element-query-query($query)

  =&gt; cts:word-query("wanted", (), 1)
</example>
	</function>
	<function name="document-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:document-query">
		<summary>Returns a query matching documents with the given URIs. It will match both documents and properties documents with the given URIs.</summary>
		<params>
			<param name="uris" type="xs:string*" optional="false">One or more document URIs.</param>
		</params>
		<return>cts:document-query</return>
		<example xml:space="preserve">
  cts:search(//function,
    cts:document-query("/reports.xml"))

  =&gt; .. relevance-ordered sequence of 'function' elements
  in the document "/reports.xml".
</example>
    <example xml:space="preserve">
cts:search(//function, cts:and-query(("repair",
  cts:document-query(("/reports.xml", "/analysis.xml")))))

  =&gt; .. relevance ordered sequence of 'function' elements in
     any document that both contains the word "repair" and is
     in either the document "/reports.xml" or in the document
     "/analysis.xml".
</example>
	</function>
	<function name="document-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:document-query-uris">
		<summary>Returns the URIs used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:document-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:document-query-uris($query)
  =&gt; ("/reports.xml", "/analysis.xml")
</example>
	</function>
	<function name="collection-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:collection-query">
		<summary>Returns a query matching documents in the collections with the given URIs. It will match both documents and properties documents in the collections with the given URIs.</summary>
		<params>
			<param name="uris" type="xs:string*" optional="false">One or more collection URIs.</param>
		</params>
		<return>cts:collection-query</return>
		<example xml:space="preserve">
  cts:search(//function,
    cts:collection-query(("reports", "analysis")))

  =&gt; .. a sequence of 'function' elements in any document in the
     collection "reports" or in the collection "analysis".
</example>
    <example xml:space="preserve">
cts:search(//function, cts:and-query(("repair",
    cts:collection-query(("reports", "analysis")))))

  =&gt; .. relevance ordered sequence of 'function' elements in
     any document that both contains the word "repair" and is
     in either the collection "reports" or in the collection
     "analysis".
</example>
	</function>
	<function name="collection-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:collection-query-uris">
		<summary>Returns the URIs used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:collection-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:collection-query-uris($query)
  =&gt; ("reports", "analysis")
</example>
	</function>
	<function name="directory-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:directory-query">
		<summary>Returns a query matching documents in the directories with the given URIs.</summary>
		<params>
			<param name="uris" type="xs:string*" optional="false">One or more directory URIs.</param>
			<param name="depth" type="xs:string?" optional="true">"1" for immediate children, "infinity" for all. If not supplied, depth is "1".</param>
		</params>
		<return>cts:directory-query</return>
		<example xml:space="preserve">
  cts:search(//function,
    cts:directory-query(("/reports/","/analysis/"),"1"))

  =&gt; .. a sequence of 'function' elements in any document
     in the directory "/reports/" or the directory "/analysis/".
</example>
    <example xml:space="preserve">
cts:search(//function, cts:and-query(("repair",
  cts:directory-query(("/reports/", "/analysis/"), "1"))))

  =&gt; .. relevance ordered sequence of 'function' elements in
     any document that both contains the word "repair" and is
     in either the directory "/reports/" or in the directory
     "/analysis/".
</example>
	</function>
	<function name="directory-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:directory-query-uris">
		<summary>Returns the URIs used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:directory-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:directory-query-uris($query)
  =&gt; ("/reports", "/analysis/")
</example>
	</function>
	<function name="directory-query-depth" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:directory-query-depth">
		<summary>Returns the depth used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:directory-query" optional="false">A query.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  cts:directory-query-depth($query)
  =&gt; 1
</example>
	</function>
	<function name="register" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:register">
		<summary>Register a query for later use.</summary>
		<params>
			<param name="query" type="cts:query" optional="false">A query to register.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  cts:register(cts:collection-query("mycollection"))

  =&gt; 12345678901234567
</example>
	</function>
	<function name="deregister" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:deregister">
		<summary>Deregister a registered query, explicitly releasing the associated resources.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="false">A registered query identifier.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  cts:deregister(xs:unsignedLong("12345678901234567"))

   =&gt; ()
</example>
	</function>
	<function name="registered-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:registered-query">
		<summary>Returns a query matching fragments specified by previously registered queries (see
			<a href="#cts:register">
				<code>cts:register</code>
			</a>). If a registered query with the specified ID(s) is not found, then a
			<code>cts:search</code>operation with an invalid
			<code>cts:registered-query</code>throws an XDMP-UNREGISTERED exception.</summary>
		<params>
			<param name="ids" type="xs:unsignedLong*" optional="false">Some registered query identifiers.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"filtered"</dt>
						<dd>A filtered query (the default). Filtered queries eliminate any false-positive results and properly resolve cases where there are multiple candidate matches within the same fragment, thereby guaranteeing that the results fully satisfy the original
							<code>cts:query</code>item that was registered. This option is not available in the 4.0 release.</dd>
						<dt>"unfiltered"</dt>
						<dd>An unfiltered query. Unfiltered registered queries select fragments from the indexes that are candidates to satisfy the
							<code>cts:query</code>. Depending on the original
							<code>cts:query</code>, the structure of the documents in the database, and the configuration of the database, unfiltered registered queries may result in false-positive results or in incorrect matches when there are multiple candidate matches within the same fragment. To avoid these problems, you should only use unfiltered queries on top-level XPath expressions (for example, document nodes, collections, directories) or on fragment roots. Using unfiltered queries on complex XPath expressions or on XPath expressions that traverse below a fragment root can result in unexpected results. This option is required in the 4.0 release.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<return>cts:registered-query</return>
		<usage>
			<p>If the options parameter does not contain "unfiltered", then an error is returned, as the "unfiltered" option is required.</p>
			<p>Registered queries are persisted as a soft state only; they can become unregistered through an explicit direction (using
				<a href="#cts:deregister">
					<code>cts:deregister</code>
				</a>), as a result of the cache growing too large, or because of a server restart. Consequently, either your XQuery code or your middleware layer should handle the case when an XDMP-UNREGISTERED exception occurs (for example, you can wrap your
				<code>cts:registered-query</code>code in a try/catch block or your Java or .NET code can catch and handle the exception).</p>
		</usage>
		<example xml:space="preserve">
  cts:search(//function,
    cts:registered-query(1234567890123456,"unfiltered"))

  =&gt; .. relevance-ordered sequence of 'function' elements
  in any document that also matches the registered query
</example>
    <example xml:space="preserve">
(: wrap the registered query in a try/catch :)
try {
cts:search(fn:doc(),cts:registered-query(995175721241192518,"unfiltered")))
} catch ($e) {
  if ($e/err:code = "XDMP-UNREGISTERED")
  then ("Retry this query with the following registered query ID: ",
        cts:register(cts:word-query("hello*world","wildcarded")))
  else $e
}
</example>
	</function>
	<function name="registered-query-ids" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:registered-query-ids">
		<summary>Returns the registered query identifiers used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:registered-query" optional="false">A query.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  cts:registered-query-ids($query)
  =&gt; 1234567890123456
</example>
	</function>
	<function name="registered-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:registered-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:registered-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  cts:registered-query-options($query)
  =&gt; "unfiltered"
</example>
	</function>
	<function name="registered-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:registered-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:registered-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:registered-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:words">
		<summary>Returns words from the word lexicon. This function requires the word lexicon to be enabled. If the word lexicon is not enabled, an exception is thrown. The words are returned in collation order.</summary>
		<params>
			<param name="start" type="xs:string?" optional="true">A starting word. Returns only this word and any following words from the lexicon. If the parameter is not in the lexicon, then it returns the words beginning with the next word.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Words should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Words should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Words from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Words from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Words from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Words from locks fragments should be included.</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>words.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Words from skipped fragments are not included. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include words in fragments selected by the
				<code>cts:query</code>. The words do not need to match the query, but the words must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending".</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:words("aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</example>
	</function>
	<function name="word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:word-match">
		<summary>Returns words from the word lexicon that match the wildcard pattern. This function requires the word lexicon to be enabled. If the word lexicon is not enabled, an exception is thrown.</summary>
		<params>
			<param name="pattern" type="xs:string" optional="false">A wildcard pattern to match.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>Words should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Words should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Words from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Words from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Words from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Words from locks fragments should be included.</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>words.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Words from skipped fragments are not included. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include words in fragments selected by the
				<code>cts:query</code>. The words do not need to match the query, but the words must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending".</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
		</usage>
		<example xml:space="preserve">
  cts:word-match("aardvark*")
  =&gt; ("aardvark","aardvarks")
</example>
	</function>
	<function name="element-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-words">
		<summary>Returns words from the specified element word lexicon. This function requires an element word lexicon for each of the element specified in the function. If there is not an element word lexicon configured for any of the specified elements, an exception is thrown. The words are returned in collation order.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="start" type="xs:string?" optional="true">A starting word. Returns only this word and any following words from the lexicon. If the parameter is not in the lexicon, then it returns the words beginning with the next word.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Words should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Words should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Words from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Words from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Words from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Words from locks fragments should be included.</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>words.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Words from skipped fragments are not included. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include words in fragments selected by the
				<code>cts:query</code>. The words do not need to match the query, but the words must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending".</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>Only words that can be matched with element-word-query are included. That is, only words present in immediate text node children of the specified element as well as any text node children of child elements defined in the Admin Interface as element-word-query-throughs or phrase-throughs.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-words(xs:QName("animal"),"aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</example>
	</function>
	<function name="element-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-word-match">
		<summary>Returns words from the specified element word lexicon(s) that match a wildcard pattern. This function requires an element word lexicon configured for each of the specified elements in the function. If there is not an element word lexicon configured for any of the specified elements, an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="pattern" type="xs:string" optional="false">Wildcard pattern to match.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>Words should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Words should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Words from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Words from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Words from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Words from locks fragments should be included.</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>words.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Words from skipped fragments are not included. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include words in fragments selected by the
				<code>cts:query</code>. The words do not need to match the query, but the words must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending".</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>Only words that can be matched with element-word-query are included. That is, only words present in immediate text node children of the specified element as well as any text node children of child elements defined in the Admin Interface as element-word-query-throughs or phrase-throughs.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-word-match(xs:QName("animal"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</example>
	</function>
	<function name="element-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-values">
		<summary>Returns values from the specified element value lexicon(s). Value lexicons are implemented using range indexes; consequently this function requires an element range index for each element specified in the function. If there is not a range index configured for each of the specified elements, an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="start" type="xs:anyAtomicType?" optional="true">A starting value. The parameter type must match the lexicon type. If the parameter value is is not in the lexicon, then the values are returned beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:anyAtomicType* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-values(xs:QName("animal"),"aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</example>
	</function>
	<function name="field-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-values">
		<summary>Returns values from the specified field value lexicon(s). Value lexicons are implemented using range indexes; consequently this function requires an field range index for each field specified in the function. If there is not a range index configured for each of the specified fields, an exception is thrown.</summary>
		<params>
			<param name="field-names" type="xs:string*" optional="false">One or more field names.</param>
			<param name="start" type="xs:anyAtomicType?" optional="true">A starting value. The parameter type must match the lexicon type. If the parameter value is is not in the lexicon, then the values are returned beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:anyAtomicType* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:field-values("my_field","John Goldings")
  =&gt; ("John Goldings","Ooi Fu",...)
</example>
	</function>
	<function name="element-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-match">
		<summary>Returns values from the specified element value lexicon(s) that match the specified wildcard pattern. Element value lexicons are implemented using range indexes; consequently this function requires an element range index for each element specified in the function. If there is not a range index configured for each of the specified elements, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="pattern" type="xs:anyAtomicType" optional="false">A pattern to match. The parameter type must match the lexicon type. String parameters may include wildcard characters.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the range index with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:anyAtomicType* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a range index with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
		</usage>
		<example xml:space="preserve">
  cts:element-value-match(xs:QName("animal"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</example>
	</function>
	<function name="element-value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-co-occurrences">
		<summary>Returns value co-occurrences (that is, pairs of values, both of which appear in the same fragment) from the specified element value lexicon(s). The values are returned as an XML element with two children, each child containing one of the co-occurring values. You can use
			<code>cts:frequency</code>on each item returned to find how many times the pair occurs. Value lexicons are implemented using range indexes; consequently this function requires an element range index for each element specified in the function, and the range index must have range value positions set to true. If there is not a range index configured for each of the specified elements, and if the range value positions is not enabled for the any of the range indexes, an exception is thrown.</summary>
		<params>
			<param name="element-name-1" type="xs:QName" optional="false">An element QName.</param>
			<param name="element-name-2" type="xs:QName" optional="false">An element QName.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Co-occurrences should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Co-occurrences should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Co-occurrences from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Co-occurrences from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Co-occurrences from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Co-occurrences from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Co-occurrences should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Co-occurrences should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included co-occurrences. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included co-occurrence. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>For both lexicons, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"type-1=
							<em>type</em>"</dt>
						<dd>For the first lexicon, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"type-2=
							<em>type</em>"</dt>
						<dd>For the second lexicon, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>For both lexicons, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"collation-1=
							<em>URI</em>"</dt>
						<dd>For the first lexicon, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"collation-2=
							<em>URI</em>"</dt>
						<dd>For the second lexicon, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"ordered"</dt>
						<dd>Include co-occurrences only when the value from the first lexicon appears before the value from the second lexicon. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"proximity=
							<em>N</em>"</dt>
						<dd>Include co-occurrences only when the values appear within
							<em>N</em>words of each other. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>co-occurrences.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Co-occurrences from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an element(cts:co-occurrence)* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include co-occurrences in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included co-occurrences. The co-occurrences do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:co-occurrence)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included co-occurrences may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then co-occurrences from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  (:
     this query has the database fragmented on SPEECH and
     finds the first 3 SPEAKERs that co-occur in a SPEECH
  :)
  cts:element-value-co-occurrences(
    xs:QName("SPEAKER"),xs:QName("SPEAKER"),
    ("frequency-order","ordered"),
    cts:document-query("hamlet.xml"))[1 to 3]
  =&gt;
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;MARCELLUS&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;BERNARDO&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;ROSENCRANTZ&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;GUILDENSTERN&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;HORATIO&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;MARCELLUS&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;


</example>
    <example xml:space="preserve">
  (:
     this query has the database fragmented on SPEECH and
     finds SPEAKERs that co-occur in a SPEECH, returned
     as a map
  :)
  cts:element-value-co-occurrences(
    xs:QName("SPEAKER"),xs:QName("SPEAKER"),
    ("frequency-order","ordered", "map"),
    cts:document-query("hamlet.xml"))
  =&gt;
  map:map(
   &lt;map:map xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:map="http://marklogic.com/xdmp/map"&gt;
     &lt;map:entry key="HORATIO"&gt;
       &lt;map:value xsi:type="xs:string"&gt;MARCELLUS&lt;/map:value&gt;
     &lt;/map:entry&gt;
     &lt;map:entry key="CORNELIUS"&gt;
         &lt;map:value xsi:type="xs:string"&gt;VOLTIMAND&lt;/map:value&gt;
     &lt;/map:entry&gt;
     &lt;map:entry key="MARCELLUS"&gt;
         &lt;map:value xsi:type="xs:string"&gt;BERNARDO&lt;/map:value&gt;
         &lt;map:value xsi:type="xs:string"&gt;HORATIO&lt;/map:value&gt;
     &lt;/map:entry&gt;
     &lt;map:entry key="ROSENCRANTZ"&gt;
       &lt;map:value xsi:type="xs:string"&gt;GUILDENSTERN&lt;/map:value&gt;
     &lt;/map:entry&gt;
   &lt;/map:map&gt;)


</example>
	</function>
	<function name="element-attribute-value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-co-occurrences">
		<summary>Returns value co-occurrences from the specified element or element-attribute value lexicon(s). Value lexicons are implemented using range indexes; consequently this function requires a range index for each element/attribute pairs specified in the function. If there is not a range index configured for each of the specified element or element/attribute pairs, then an exception is thrown.</summary>
		<params>
			<param name="element-name-1" type="xs:QName" optional="false">An element QName.</param>
			<param name="attribute-name-1" type="xs:QName?" optional="false">An attribute QName or empty sequence. The empty sequence specifies an element lexicon.</param>
			<param name="element-name-2" type="xs:QName" optional="false">An element QName.</param>
			<param name="attribute-name-2" type="xs:QName?" optional="false">An attribute QName or empty sequence. The empty sequence specifies an element lexicon.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Co-occurrences should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Co-occurrences should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Co-occurrences from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Co-occurrences from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Co-occurrences from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Co-occurrences from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Co-occurrences should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Co-occurrences should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included co-occurrences. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included co-occurrence. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>For both lexicons, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"type-1=
							<em>type</em>"</dt>
						<dd>For the first lexicon, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"type-2=
							<em>type</em>"</dt>
						<dd>For the second lexicon, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>For both lexicons, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"collation-1=
							<em>URI</em>"</dt>
						<dd>For the first lexicon, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"collation-2=
							<em>URI</em>"</dt>
						<dd>For the second lexicon, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"ordered"</dt>
						<dd>Include co-occurrences only when the value from the first lexicon appears before the value from the second lexicon. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"proximity=
							<em>N</em>"</dt>
						<dd>Include co-occurrences only when the values appear within
							<em>N</em>words of each other. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>co-occurrences.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Co-occurrences from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an element(cts:co-occurrence)* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include co-occurrences in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included co-occurrences. The co-occurrences do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:co-occurrence)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included co-occurrences may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then co-occurrences from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
	</function>
	<function name="element-value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-ranges">
		<summary>
			<p>Returns value ranges from the specified element value lexicon(s). Value lexicons are implemented using range indexes; consequently this function requires an element range index for each element specified in the function. If there is not a range index configured for each of the specified elements, an exception is thrown.</p>
			<p>The values are divided into buckets. The $bounds parameter specifies the number of buckets and the size of each bucket. All included values are bucketed, even those less than the lowest bound or greater than the highest bound. An empty sequence for $bounds specifies one bucket, a single value specifies two buckets, two values specify three buckets, and so on.</p>
			<p>If you have string values and you pass a $bounds parameter as in the following call:</p>
			<pre xml:space="preserve">
cts:element-value-ranges(xs:QName("myElement"), ("f", "m"))
</pre>
			<p>The first bucket contains string values that are less than the string
				<code>f</code>, the second bucket contains string values greater than or equal to
				<code>f</code>but less than
				<code>m</code>, and the third bucket contains string values that are greater than or equal to
				<code>m</code>.</p>
			<p>For each non-empty bucket, a
				<code>cts:range</code>element is returned. Each
				<code>cts:range</code>element has a
				<code>cts:minimum</code>child and a
				<code>cts:maximum</code>child. If a bucket is bounded, its
				<code>cts:range</code>element will also have a
				<code>cts:lower-bound</code>child if it is bounded from below, and a
				<code>cts:upper-bound</code>element if it is bounded from above. Empty buckets return nothing unless the "empties" option is specified.</p>
		</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="bounds" type="xs:anyAtomicType*" optional="true">A sequence of range bounds. The types must match the lexicon type. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Ranges should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Ranges should be returned in descending order.</dd>
						<dt>"empties"</dt>
						<dd>Include fully-bounded ranges whose frequency is 0. These ranges will have no minimum or maximum value. Only empty ranges that have both their upper and lower bounds specified in the $bounds options are returned; any empty ranges that are less than the first bound or greater than the last bound are not returned. For example, if you specify 4 bounds and there are no results for any of the bounds, 3 elements are returned (not 5 elements).</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Ranges should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Ranges should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>ranges.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only ranges for buckets with at least one value from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:range)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then ranges with all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
(: Run the following to load data for this example.
   Make sure you have an int element range index on
   number. :)
for $x in  (1 to 10)
return
xdmp:document-insert(fn:concat("/doc", fn:string($x), ".xml"),
 &lt;root&gt;&lt;number&gt;{$x}&lt;/number&gt;&lt;/root&gt;) ;

(: The following is based on the above setup :)
cts:element-value-ranges(xs:QName("number"),
  (5, 10, 15, 20), "empties")
=&gt;

&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;1&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;4&lt;/cts:maximum&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;5&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;5&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;9&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;5&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;10&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;10&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;10&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;10&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;15&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;15&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;20&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;20&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;


</example>
    <example xml:space="preserve">
  (: this query has the database fragmented on SPEECH and
     finds four ranges of SPEAKERs :)
  cts:element-value-ranges(xs:QName("SPEAKER"),("F","N","S"));
  =&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;All&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;Danes&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;F&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;First Ambassador&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;Messenger&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;F&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;N&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;OPHELIA&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;ROSENCRANTZ&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;N&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;S&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;Second Clown&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;VOLTIMAND&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;S&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;


</example>
    <example xml:space="preserve">
  (: this is the same query has above, but it is getting the counts
     of the number of SPEAKERs for each bucket :)
  for $bucket in cts:element-value-ranges(xs:QName("SPEAKER"),("F","N","S"))
  return cts:frequency($bucket);
  =&gt;
  9602
  11329
  5167
  4983

</example>
	</function>
	<function name="field-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-value-match">
		<summary>Returns values from the specified field value lexicon(s) that match the specified wildcard pattern. Field value lexicons are implemented using range indexes; consequently this function requires a field range index for each field specified in the function. If there is not a range index configured for each of the specified fields, then an exception is thrown.</summary>
		<params>
			<param name="field-names" type="xs:string*" optional="false">One or more field names.</param>
			<param name="pattern" type="xs:anyAtomicType" optional="false">A pattern to match. The parameter type must match the lexicon type. String parameters may include wildcard characters.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the range index with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:anyAtomicType* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a range index with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
		</usage>
		<example xml:space="preserve">
 cts:field-value-match("aname","Jim *")
  =&gt; "Jim Kurla"
</example>
	</function>
	<function name="field-value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-value-co-occurrences">
		<summary>Returns value co-occurrences (that is, pairs of values, both of which appear in the same fragment) from the specified field value lexicon(s). The values are returned as an XML element with two children, each child containing one of the co-occurring values. You can use
			<code>cts:frequency</code>on each item returned to find how many times the pair occurs. Value lexicons are implemented using range indexes; consequently this function requires an field range index for each field specified in the function, and the range index must have range value positions set to true. If there is not a range index configured for each of the specified fields, and if the range value positions is not enabled for the any of the range indexes, an exception is thrown.</summary>
		<params>
			<param name="field-name-1" type="xs:string" optional="false">An a string.</param>
			<param name="field-name-2" type="xs:string" optional="false">An a string.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Co-occurrences should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Co-occurrences should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Co-occurrences from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Co-occurrences from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Co-occurrences from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Co-occurrences from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Co-occurrences should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Co-occurrences should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included co-occurrences. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included co-occurrence. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>For both lexicons, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"type-1=
							<em>type</em>"</dt>
						<dd>For the first lexicon, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"type-2=
							<em>type</em>"</dt>
						<dd>For the second lexicon, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>For both lexicons, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"collation-1=
							<em>URI</em>"</dt>
						<dd>For the first lexicon, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"collation-2=
							<em>URI</em>"</dt>
						<dd>For the second lexicon, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"ordered"</dt>
						<dd>Include co-occurrences only when the value from the first lexicon appears before the value from the second lexicon. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"proximity=
							<em>N</em>"</dt>
						<dd>Include co-occurrences only when the values appear within
							<em>N</em>words of each other. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>co-occurrences.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Co-occurrences from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an element(cts:co-occurrence)* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include co-occurrences in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included co-occurrences. The co-occurrences do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:co-occurrence)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included co-occurrences may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then co-occurrences from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  (: Suppose we insert these two documents in the database.

  Document 1:
  &lt;doc&gt;
  &lt;name1&gt;
    &lt;i11&gt;John&lt;/i11&gt;&lt;e12&gt;Smith&lt;/e12&gt;&lt;i13&gt;Griffith&lt;/i13&gt;
  &lt;/name1&gt;
  &lt;name2&gt;
    &lt;i21&gt;Will&lt;/i21&gt;&lt;e22&gt;Tim&lt;/e22&gt;&lt;i23&gt;Shields&lt;/i23&gt;
  &lt;/name2&gt;
 &lt;/doc&gt;

  Document 2:
  &lt;doc&gt;
  &lt;name1&gt;
    &lt;i11&gt;Will&lt;e12&gt;Frank&lt;/e12&gt;Shields&lt;/i11&gt;
  &lt;/name1&gt;
  &lt;name2&gt;
    &lt;i21&gt;John&lt;e22&gt;Tim&lt;/e22&gt;Griffith&lt;/i21&gt;
  &lt;/name2&gt;
&lt;/doc&gt;
:)

 (: Now suppose we have two fields aname1 and aname2 defined on the database.
    The field aname1 includes element "name1" and excludes "e12".
    The field aname2 includes element "name2" and excludes "e22".
    Both the fields have field range indexes configures with positions ON.
 :)

  cts:field-value-co-occurrences("aname1","aname2")
=&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;John Griffith&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Will Shields&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Will Shields&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;John Griffith&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;



</example>
    <example xml:space="preserve">
  (: Here is another example that finds co-occurence between field value
     and an element-value using cts:element-value-co-occurences() API. :)

  (: Suppose we have the following document in  the database/fragment. :)
&lt;doc&gt;
 &lt;person&gt;
  &lt;name&gt;
    &lt;first-name&gt;Will&lt;/first-name&gt;
    &lt;middle-name&gt;Frank&lt;/middle-name&gt;
    &lt;last-name&gt;Shields&lt;/last-name&gt;
  &lt;/name&gt;
  &lt;address&gt;
    &lt;ZIP&gt;92341&lt;/ZIP&gt;
  &lt;/address&gt;
  &lt;phoneNumber&gt;650-472-4444&lt;/phoneNumber&gt;
 &lt;/person&gt;
 &lt;person&gt;
  &lt;name&gt;
    &lt;first-name&gt;John&lt;/first-name&gt;
    &lt;middle-name&gt;Tim&lt;/middle-name&gt;
    &lt;last-name&gt;Hearst&lt;/last-name&gt;
  &lt;/name&gt;
  &lt;address&gt;
    &lt;ZIP&gt;96345&lt;/ZIP&gt;
  &lt;/address&gt;
  &lt;phoneNumber&gt;750-947-5555&lt;/phoneNumber&gt;
 &lt;/person&gt;
&lt;/doc&gt;
  (: This database has element range indexes defined on elements
     ZIP and phoneNumber. Positions are set true on the range indexes.

     There is a field, named "aname" defined on this database
     which excludes element middle-name.

     A string range index is configured on the field "aname".
     Position is set true on the database.

     In the following query we are using lexicons on field values of
     "aname" and element value "ZIP" to determine value co-occurences.
     However, notice the the field is being treated as if it were an
     element with a MarkLogic predefined namespace
     "http://marklogic.com/fields".
  :)
declare namespace my="http://marklogic.com/fields";
cts:element-value-co-occurrences(xs:QName("ZIP"),xs:QName("my:aname"))
  =&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;68645&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Jill Tom Lawless&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;68645&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Nancy Smith Finkman&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;92341&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;John Tim Hearst&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;92341&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Will Frank Shields&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;93452&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Jill Tom Lawless&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
   xmlns:cts="http://marklogic.com/cts"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;93452&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Nancy Smith Finkman&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;96345&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;John Tim Hearst&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence
  xmlns:cts="http://marklogic.com/cts"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:value xsi:type="xs:int"&gt;96345&lt;/cts:value&gt;
  &lt;cts:value xsi:type="xs:string"&gt;Will Frank Shields&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;


</example>
	</function>
	<function name="field-value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-value-ranges">
		<summary>
			<p>Returns value ranges from the specified field value lexicon(s). Value lexicons are implemented using range indexes; consequently this function requires a field range index for each element specified in the function. If there is not a range index configured for each of the specified fields, an exception is thrown.</p>
			<p>The values are divided into buckets. The $bounds parameter specifies the number of buckets and the size of each bucket. All included values are bucketed, even those less than the lowest bound or greater than the highest bound. An empty sequence for $bounds specifies one bucket, a single value specifies two buckets, two values specify three buckets, and so on.</p>
			<p>If you have string values and you pass a $bounds parameter as in the following call:</p>
			<pre xml:space="preserve">
cts:field-value-ranges("myField", ("f", "m"))
</pre>
			<p>The first bucket contains string values that are less than the string
				<code>f</code>, the second bucket contains string values greater than or equal to
				<code>f</code>but less than
				<code>m</code>, and the third bucket contains string values that are greater than or equal to
				<code>m</code>.</p>
			<p>For each non-empty bucket, a
				<code>cts:range</code>element is returned. Each
				<code>cts:range</code>element has a
				<code>cts:minimum</code>child and a
				<code>cts:maximum</code>child. If a bucket is bounded, its
				<code>cts:range</code>element will also have a
				<code>cts:lower-bound</code>child if it is bounded from below, and a
				<code>cts:upper-bound</code>element if it is bounded from above. Empty buckets return nothing unless the "empties" option is specified.</p>
		</summary>
		<params>
			<param name="field-names" type="xs:string*" optional="false">One or more element QNames.</param>
			<param name="bounds" type="xs:anyAtomicType*" optional="true">A sequence of range bounds. The types must match the lexicon type. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Ranges should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Ranges should be returned in descending order.</dd>
						<dt>"empties"</dt>
						<dd>Include fully-bounded ranges whose frequency is 0. These ranges will have no minimum or maximum value. Only empty ranges that have both their upper and lower bounds specified in the $bounds options are returned; any empty ranges that are less than the first bound or greater than the last bound are not returned. For example, if you specify 4 bounds and there are no results for any of the bounds, 3 elements are returned (not 5 elements).</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Ranges should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Ranges should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>ranges.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only ranges for buckets with at least one value from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included co-occurrences. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:range)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then ranges with all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
(: Run the following to load data for this example.
   Make sure you have a string field range index on
   field aname. :)

let $content1 := &lt;name&gt;&lt;fname&gt;John&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Goldings&lt;/lname&gt;&lt;/name&gt;
let $content2 := &lt;name&gt;&lt;fname&gt;Jim&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Kurla&lt;/lname&gt;&lt;/name&gt;
let $content3 := &lt;name&gt;&lt;fname&gt;Ooi&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Fu&lt;/lname&gt;&lt;/name&gt;
let $content4 := &lt;name&gt;&lt;fname&gt;James&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Tod&lt;/lname&gt;&lt;/name&gt;
let $content5 := &lt;name&gt;&lt;fname&gt;Anthony&lt;/fname&gt;&lt;mname&gt;Rob&lt;/mname&gt;&lt;lname&gt;Flemings&lt;/lname&gt;&lt;/name&gt;
let $content6 := &lt;name&gt;&lt;fname&gt;Charles&lt;/fname&gt;&lt;mname&gt;Ken&lt;/mname&gt;&lt;lname&gt;Winter&lt;/lname&gt;&lt;/name&gt;
let $content7 := &lt;name&gt;&lt;fname&gt;Nancy&lt;/fname&gt;&lt;mname&gt;Ben&lt;/mname&gt;&lt;lname&gt;Schmidt&lt;/lname&gt;&lt;/name&gt;
let $content8 := &lt;name&gt;&lt;fname&gt;Robert&lt;/fname&gt;&lt;mname&gt;Rick&lt;/mname&gt;&lt;lname&gt;Hanson&lt;/lname&gt;&lt;/name&gt;
return (
xdmp:document-insert("/aname1.xml",$content1),
xdmp:document-insert("/aname2.xml",$content2),
xdmp:document-insert("/aname3.xml",$content3),
xdmp:document-insert("/aname4.xml",$content4),
xdmp:document-insert("/aname5.xml",$content5),
xdmp:document-insert("/aname6.xml",$content6),
xdmp:document-insert("/aname7.xml",$content7),
xdmp:document-insert("/aname8.xml",$content8)
)

(: The following is based on the above setup :)
cts:field-value-ranges("aname",("A","J","O"));
=&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;cts:minimum xsi:type="xs:string"&gt;Anthony Flemings&lt;/cts:minimum&gt;
&lt;cts:maximum xsi:type="xs:string"&gt;Charles Winter&lt;/cts:maximum&gt;
&lt;cts:lower-bound xsi:type="xs:string"&gt;A&lt;/cts:lower-bound&gt;
&lt;cts:upper-bound xsi:type="xs:string"&gt;J&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;cts:minimum xsi:type="xs:string"&gt;James Tod&lt;/cts:minimum&gt;
&lt;cts:maximum xsi:type="xs:string"&gt;Nancy Schmidt&lt;/cts:maximum&gt;
&lt;cts:lower-bound xsi:type="xs:string"&gt;J&lt;/cts:lower-bound&gt;
&lt;cts:upper-bound xsi:type="xs:string"&gt;O&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;cts:minimum xsi:type="xs:string"&gt;Ooi Fu&lt;/cts:minimum&gt;
&lt;cts:maximum xsi:type="xs:string"&gt;Robert Hanson&lt;/cts:maximum&gt;
&lt;cts:lower-bound xsi:type="xs:string"&gt;O&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;
</example>
	</function>
	<function name="frequency" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:frequency">
		<summary>Returns an integer representing the number of times in which a particular value occurs in a value lexicon lookup (for example,
			<code>cts:element-values</code>). When using the
			<code>fragment-frequency</code>lexicon option,
			<code>cts:frequency</code>returns the number of fragments in which the lexicon value occurs. When using the
			<code>item-frequency</code>lexicon option,
			<code>cts:frequency</code>returns the total number of times in which the lexicon value occurs in each item.</summary>
		<params>
			<param name="value" type="item()" optional="false">A value from a value lexicon lookup. The value should be one returned from the
				<a href="#cts:element-values">
					<code>cts:element-values</code>
				</a>,
				<a href="#cts:element-attribute-values">
					<code>cts:element-attribute-values</code>
				</a>, or the corresponding
				<code>value-match</code>lexicon APIs.</param>
		</params>
		<return>xs:integer</return>
		<usage>
			<p>You must have a Range index configured to use the value lexicon APIs (
				<code>cts:element-values</code>,
				<code>cts:element-value-match</code>,
				<code>cts:element-attribute-values</code>, or
				<code>cts:element-attribute-value-match</code>).</p>
			<p>If the value specified is not from a value lexicon lookup,
				<code>cts:frequency</code>returns a frequency of 0.</p>
			<p>The frequency returned from
				<code>cts:frequency</code>is fragment-based by default (using the default
				<code>fragment-frequency</code>option in the lexicon API). If there are multiple occurences of the value in any given fragment, the frequency is still one per fragment when using
				<code>fragment-frequency</code>. Therefore, if the value returned is 13, it means that the value occurs in 13 fragments.</p>
			<p>If you want the total frequency instead of the fragment-based frequency (that is, the total number of occurences of the value in the items specified in the
				<code>cts:query</code>option of the lexicon API), you must specify the
				<code>item-frequency</code>option to the lexicon API value input to
				<code>cts:frequency</code>. For example, the second example below specifies an
				<code>item-frequency</code>and a
				<code>cts:document-query</code>in the lexicon API, so the item frequency is how many times each speaker speaks in the play (because the constraining query is a document query of hamlet.xml, which contains the whole play).</p>
		</usage>
		<example xml:space="preserve">
&lt;results&gt;{
let $x := cts:element-values(xs:QName("SPEAKER"),"",(),
  cts:document-query("/shakespeare/plays/hamlet.xml"))
for $speaker in $x
return
(
&lt;result&gt;
  &lt;SPEAKER&gt;{$speaker}&lt;/SPEAKER&gt;
  &lt;NUMBER-OF-SPEECHES&gt;{cts:frequency($speaker)}&lt;/NUMBER-OF-SPEECHES&gt;
&lt;/result&gt;
)
}&lt;/results&gt;

=&gt; Returns the names of the speakers in Hamlet
   with the number of times they speak. If the
   play is fragmented at the SCENE level, then
   it returns the number of scenes in which each
   speaker speaks.
</example>
    <example xml:space="preserve">
&lt;results&gt;{
let $x := cts:element-values(xs:QName("SPEAKER"),
  "", "item-frequency",
  cts:document-query("/shakespeare/plays/hamlet.xml"))
for $speaker in $x
return
(
&lt;result&gt;
  &lt;SPEAKER&gt;{$speaker}&lt;/SPEAKER&gt;
  &lt;NUMBER-OF-SPEECHES&gt;
    {cts:frequency($speaker)}
  &lt;/NUMBER-OF-SPEECHES&gt;
&lt;/result&gt;
)
}&lt;/results&gt;

=&gt; Returns the names of the speakers in Hamlet
   with the number of times they speak. Returns
   the total times they speak, regardless
   of fragmentation.
</example>
	</function>
	<function name="sum" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:sum">
		<summary>Returns a frequency-weighted sum of a sequence. This function works like
			<code>fn:sum</code>except each item in the sequence is multiplied by
			<code>cts:frequency</code>before summing.</summary>
		<params>
			<param name="arg" type="xs:anyAtomicType*" optional="false">The sequence of values to be summed. The values should be the result of a lexicon lookup.</param>
			<param name="zero" type="xs:anyAtomicType?" optional="true">The value to return as zero if the input sequence is the empty sequence.</param>
		</params>
		<return>xs:anyAtomicType?</return>
		<usage>
			<p>The
				<code>cts:frequency</code>of the result is the sum of the frequencies of the sequence.</p>
			<p>This function is designed to take a sequence of values returned by a lexicon function (for example,
				<code>cts:element-values</code>); if you input non-lexicon values, the result will always be 0.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:sum(cts:element-values(xs:QName("int"), (),
           ("type=int", "item-frequency"))),
cts:sum(cts:element-values(xs:QName("int"), (),
           ("type=int", "fragment-frequency")))
=&gt;
385
55


</example>
	</function>
	<function name="count" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:count">
		<summary>Returns a frequency-weighted count of a sequence. This function works like
			<code>fn:count</code>except the count of each item is multiplied by
			<code>cts:frequency</code>.</summary>
		<params>
			<param name="arg" type="item()*" optional="false">The sequence of items to count. The items should be the result of a lexicon lookup.</param>
			<param name="maximum" type="xs:double" optional="true">The maximum value of the count to return. MarkLogic Server will stop counting when the $maximum value is reached and return the $maximum value.</param>
		</params>
		<return>xs:integer</return>
		<usage>
			<p>This function is designed to take a sequence of values returned by a lexicon function (for example,
				<code>cts:element-values</code>); if you input non-lexicon values, the result will always be 0.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:count(cts:element-values(xs:QName("int"), (),
           ("type=int", "item-frequency"))),
cts:count(cts:element-values(xs:QName("int"), (),
           ("type=int", "fragment-frequency")))
=&gt;
55
10


</example>
	</function>
	<function name="avg" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:avg">
		<summary>Returns a frequency-weighted average of a sequence. This function works like
			<code>fn:avg</code>except each item in the sequence is multiplied by
			<code>cts:frequency</code>before summing.</summary>
		<params>
			<param name="arg" type="xs:anyAtomicType*" optional="false">The sequence of values to be averaged. The values should be the result of a lexicon lookup.</param>
		</params>
		<return>xs:anyAtomicType?</return>
		<usage>
			<p>This function is designed to take a sequence of values returned by a lexicon function (for example,
				<code>cts:element-values</code>); if you input non-lexicon values, the result will always be 0.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(:
   This query assumes an int range index
   is configured in the database. It
   generates some sample data and then
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:avg(cts:element-values(xs:QName("int"), (),
           ("type=int", "item-frequency"))),
cts:avg(cts:element-values(xs:QName("int"), (),
           ("type=int", "fragment-frequency")))
=&gt;
7
5.5


</example>
	</function>
	<function name="uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:uris">
		<summary>Returns values from the URI lexicon. This function requires the uri-lexicon database configuration parameter to be enabled. If the uri-lexicon database-configuration parameter is not enabled, an exception is thrown.</summary>
		<params>
			<param name="start" type="xs:string?" optional="true">A starting value. Return only this value and following values. If the empty string, return all values. If the parameter is is not in the lexicon, then it returns the values beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>URIs should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>URIs should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>URIs from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>URIs from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>URIs from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>URIs from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>URIs should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>URIs should be returned ordered by item.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>URIs.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. URIs from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dd>Return only URIs from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dd>Include only URIs from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include URIs from fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included URIs. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included URIs may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then URIs from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:uris("http://foo.com/")
  =&gt; ("http://foo.com/", "http://foo.com/bar.html", ...)
</example>
	</function>
	<function name="uri-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:uri-match">
		<summary>Returns values from the URI lexicon that match the specified wildcard pattern. This function requires the uri-lexicon database configuration parameter to be enabled. If the uri-lexicon database-configuration parameter is not enabled, an exception is thrown.</summary>
		<params>
			<param name="pattern" type="xs:string" optional="false">Wildcard pattern to match.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>URIs should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>URIs should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>URIs from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>URIs from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>URIs from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>URIs from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>URIs should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>URIs should be returned ordered by item.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>URIs.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. URIs from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only URIs from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dd>Include only URIs from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include URIs from fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included URIs. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included URIs may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then URIs from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
		</usage>
		<example xml:space="preserve">
  cts:uri-match("http://foo.com/*.html")
  =&gt; ("http://foo.com/bar.html", "http://foo.com/baz/bork.html", ...)
</example>
	</function>
	<function name="collections" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:collections">
		<summary>Returns values from the collection lexicon. This function requires the collection-lexicon database configuration parameter to be enabled. If the collection-lexicon database-configuration parameter is not enabled, an exception is thrown.</summary>
		<params>
			<param name="start" type="xs:string?" optional="true">A starting value. Return only this value and following values. If the parameter is is not in the lexicon, then it returns the values beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>URIs should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>URIs should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>URIs from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>URIs from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>URIs from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>URIs from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>URIs should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>URIs should be returned ordered by item.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>URIs.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. URIs from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only URIs from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only URIs from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include URIs from fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included URIs. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:collections("aardvark")
  =&gt; ("aardvark", "aardvarks", ...)
</example>
	</function>
	<function name="collection-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:collection-match">
		<summary>Returns values from the collection lexicon that match the specified wildcard pattern. This function requires the collection-lexicon database configuration parameter to be enabled. If the uri-lexicon database-configuration parameter is not enabled, an exception is thrown.</summary>
		<params>
			<param name="pattern" type="xs:string" optional="false">Wildcard pattern to match.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>URIs should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>URIs should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>URIs from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>URIs from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>URIs from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>URIs from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>URIs should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>URIs should be returned ordered by item.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>URIs.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. URIs from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only URIs from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only URIs from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include URIs from fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included URIs. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included URIs may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then URIs from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
		</usage>
		<example xml:space="preserve">
  cts:collection-match("collection*")
  =&gt; ("collection1", "collection2", ...)
</example>
	</function>
	<function name="element-attribute-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-words">
		<summary>Returns words from the specified element-attribute word lexicon(s). This function requires an element-attribute word lexicon for each of the element/attribute pairs specified in the function. If there is not an element/attribute word lexicon configured for any of the specified element/attribute pairs, then an exception is thrown. The words are returned in collation order.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="attribute-names" type="xs:QName*" optional="false">One or more attribute QNames.</param>
			<param name="start" type="xs:string?" optional="true">A starting word. Returns only this word and any following words from the lexicon. If the parameter is not in the lexicon, then it returns the words beginning with the next word.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Words should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Words should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Words from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Words from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Words from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Words from locks fragments should be included.</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>words.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Words from skipped fragments are not included. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include words in fragments selected by the
				<code>cts:query</code>. The words do not need to match the query, but the words must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending".</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>When multiple element and/or attribute QNames are specified, then all possible element/attribute QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-attribute-words(xs:QName("animal"),
                              xs:QName("name"),
                              "aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</example>
	</function>
	<function name="element-attribute-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-word-match">
		<summary>Returns words from the specified element-attribute word lexicon(s) that match a wildcard pattern. This function requires an element-attribute word lexicon for each of the element/attribute pairs specified in the function. If there is not an element-attribute word lexicon configured for any of the specified element/attribute pairs, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="attribute-names" type="xs:QName*" optional="false">One or more attribute QNames.</param>
			<param name="pattern" type="xs:string" optional="false">Wildcard pattern to match.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>Words should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Words should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Words from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Words from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Words from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Words from locks fragments should be included.</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>words.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Words from skipped fragments are not included. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include words in fragments selected by the
				<code>cts:query</code>. The words do not need to match the query, but the words must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending".</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>When multiple element and/or attribute QNames are specified, then all possible element/attribute QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-word-match(xs:QName("animals"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</example>
	</function>
	<function name="element-attribute-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-values">
		<summary>Returns values from the specified element-attribute value lexicon(s). Element-attribute value lexicons are implemented using indexes; consequently this function requires an attribute range index of for each of the element/attribute pairs specified in the function. If there is not a range index configured for each of the specified element/attribute pairs, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="attribute-names" type="xs:QName*" optional="false">One or more attribute QNames.</param>
			<param name="start" type="xs:anyAtomicType?" optional="true">A starting value. The parameter type must match the lexicon type. If the parameter value is is not in the lexicon, then the values are returned beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the range index with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:anyAtomicType* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a range index with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>When multiple element and/or attribute QNames are specified, then all possible element/attribute QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-attribute-values(xs:QName("animal"),
                               xs:QName("name"),
                               "aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</example>
	</function>
	<function name="element-attribute-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-match">
		<summary>Returns values from the specified element-attribute value lexicon(s) that match the specified pattern. Element-attribute value lexicons are implemented using range indexes; consequently this function requires an attribute range index for each of the element/attribute pairs specified in the function. If there is not a range index configured for each of the specified element/attribute pairs, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="attribute-names" type="xs:QName*" optional="false">One or more attribute QNames.</param>
			<param name="pattern" type="xs:anyAtomicType" optional="false">A pattern to match. The parameter type must match the lexicon type. String parameters may include wildcard characters.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the range index with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:anyAtomicType* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a range index with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>When multiple element and/or attribute QNames are specified, then all possible element/attribute QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-attribute-value-match(xs:QName("animals"),
                     xs:QName("name"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</example>
	</function>
	<function name="element-attribute-value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-ranges">
		<summary>
			<p>Returns value ranges from the specified element-attribute value lexicon(s). Element-attribute value lexicons are implemented using indexes; consequently this function requires an attribute range index of for each of the element/attribute pairs specified in the function. If there is not a range index configured for each of the specified element/attribute pairs, then an exception is thrown.</p>
			<p>The values are divided into buckets. The $bounds parameter specifies the number of buckets and the size of each bucket. All included values are bucketed, even those less than the lowest bound or greater than the highest bound. An empty sequence for $bounds specifies one bucket, a single value specifies two buckets, two values specify three buckets, and so on.</p>
			<p>If you have string values and you pass a $bounds parameter as in the following call:</p>
			<pre xml:space="preserve">
cts:element-value-ranges(xs:QName("myElement"), ("f", "m"))
</pre>
			<p>The first bucket contains string values that are less than the string
				<code>f</code>, the second bucket contains string values greater than or equal to
				<code>f</code>but less than
				<code>m</code>, and the third bucket contains string values that are greater than or equal to
				<code>m</code>.</p>
			<p>For each non-empty bucket, a
				<code>cts:range</code>element is returned. Each
				<code>cts:range</code>element has a
				<code>cts:minimum</code>child and a
				<code>cts:maximum</code>child. If a bucket is bounded, its
				<code>cts:range</code>element will also have a
				<code>cts:lower-bound</code>child if it is bounded from below, and a
				<code>cts:upper-bound</code>element if it is bounded from above. Empty buckets return nothing unless the "empties" option is specified.</p>
		</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="attribute-names" type="xs:QName*" optional="false">One or more attribute QNames.</param>
			<param name="bounds" type="xs:anyAtomicType*" optional="true">A sequence of range bounds. The types must match the lexicon type. The values must be in strictly ascending order.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Ranges should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Ranges should be returned in descending order.</dd>
						<dt>"empties"</dt>
						<dd>Include fully-bounded ranges whose frequency is 0. These ranges will have no minimum or maximum value. Only empty ranges that have both their upper and lower bounds specified in the $bounds options are returned; any empty ranges that are less than the first bound or greater than the last bound are not returned. For example, if you specify 4 bounds and there are no results for any of the bounds, 3 elements are returned (not 5 elements).</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Ranges should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Ranges should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>Use the lexicon with the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the range index with the collation specified by
							<em>URI</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>ranges.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only ranges for buckets with at least one value from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option also affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:range)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a range index with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then ranges with all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>When multiple element and/or attribute QNames are specified, then all possible element/attribute QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
(: Run the following to load data for this example.
   Make sure you have an int element attribute
   range index on my-node/@number. :)
for $x in  (1 to 10)
return
xdmp:document-insert(fn:concat("/doc", fn:string($x), ".xml"),
 &lt;root&gt;&lt;my-node number={$x}/&gt;&lt;/root&gt;) ;

(: The following is based on the above setup :)
cts:element-attribute-value-ranges(xs:QName("my-node"),
  xs:QName("number"), (5, 10, 15, 20), "empties")
=&gt;

&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;1&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;4&lt;/cts:maximum&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;5&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;5&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;9&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;5&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;10&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;10&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;10&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;10&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;15&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;15&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;20&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;20&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;


</example>
	</function>
	<function name="field-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-words">
		<summary>Returns words from the specified field word lexicon. This function requires an field lexicon for each of the field specified in the function. If there is not an field word lexicon configured for any of the specified fields, an exception is thrown. The words are returned in collation order.</summary>
		<params>
			<param name="field-names" type="xs:string*" optional="false">One or more field names.</param>
			<param name="start" type="xs:string?" optional="true">A starting word. Returns only this word and any following words from the lexicon. If the parameter is not in the lexicon, then it returns the words beginning with the next word.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Words should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Words should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Words from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Words from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Words from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Words from locks fragments should be included.</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>words.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>fragment as the first fragment. Words from skipped fragments are not included. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include words in fragments selected by the
				<code>cts:query</code>. The words do not need to match the query, but the words must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending".</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>Only words that can be matched with field-word-query are included. That is, only words present in immediate text node children of the specified field as well as any text node children of child fields defined in the Admin Interface as field-word-query-throughs or phrase-throughs.</p>
		</usage>
		<example xml:space="preserve">
  cts:field-words("animal","aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</example>
	</function>
	<function name="field-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:field-word-match">
		<summary>Returns words from the specified field word lexicon(s) that match a wildcard pattern. This function requires an field word lexicon configured for each of the specified fields in the function. If there is not an field word lexicon configured for any of the specified fields, an exception is thrown.</summary>
		<params>
			<param name="field-names" type="xs:string*" optional="false">One or more field names.</param>
			<param name="pattern" type="xs:string" optional="false">Wildcard pattern to match.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"case-sensitive"</dt>
						<dd>A case-sensitive match.</dd>
						<dt>"case-insensitive"</dt>
						<dd>A case-insensitive match.</dd>
						<dt>"diacritic-sensitive"</dt>
						<dd>A diacritic-sensitive match.</dd>
						<dt>"diacritic-insensitive"</dt>
						<dd>A diacritic-insensitive match.</dd>
						<dt>"ascending"</dt>
						<dd>Words should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Words should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Words from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Words from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Words from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Words from locks fragments should be included.</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the collation specified by
							<em>URI</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>words.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Words from skipped fragments are not included. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only words from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an xs:string* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include words in fragments selected by the
				<code>cts:query</code>. The words do not need to match the query, but the words must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations. If a string is entered, the string is treated as a
				<code>cts:word-query</code>of the specified string.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending".</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included words may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then words from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>If neither "case-sensitive" nor "case-insensitive" is present, $pattern is used to determine case sensitivity. If $pattern contains no uppercase, it specifies "case-insensitive". If $pattern contains uppercase, it specifies "case-sensitive".</p>
			<p>If neither "diacritic-sensitive" nor "diacritic-insensitive" is present, $pattern is used to determine diacritic sensitivity. If $pattern contains no diacritics, it specifies "diacritic-insensitive". If $pattern contains diacritics, it specifies "diacritic-sensitive".</p>
			<p>Only words that can be matched with field-word-query are included. That is, only words present in immediate text node children of the specified field as well as any text node children of child fields defined in the Admin Interface as field-word-query-throughs or phrase-throughs.</p>
		</usage>
		<example xml:space="preserve">
  cts:field-word-match("animal","aardvark*")
  =&gt; ("aardvark","aardvarks")
</example>
	</function>
	<function name="reverse-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:reverse-query">
		<summary>Returns a query matching the model nodes. Use with a
			<code>cts:search</code>or a
			<code>cts:contains</code>over serialized
			<code>cts:query</code>nodes. The serialized
			<code>cts:query</code>nodes can be either stored in the database or passed in as XML.</summary>
		<return>cts:reverse-query</return>
		<params>
			<param name="nodes" type="node()*" optional="false">Some model nodes that contain serialized
				<code>cts:query</code>constructors.</param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. Higher weights move search results up in the relevance order. The default is 1.0. The weight should be less than or equal to the absolute value of 16 (between -16 and 16); weights greater than 16 will have the same effect as a weight of 16. Weights less than the absolute value of 0.0625 (between -0.0625 and 0.0625) are rounded to 0, which means that they do not contribute to the score.</param>
		</params>
		<usage>When performing a
			<code>cts:reverse-query</code>on a set of nodes, the
			<code>cts:similar-query</code>or
			<code>cts:registered-query</code>components of any stored query will match all nodes.</usage>
		<example xml:space="preserve">
let $query := &lt;query&gt;{cts:word-query("hello")}&lt;/query&gt;
let $x := &lt;bar&gt;hello&lt;/bar&gt;
return
cts:contains($query, cts:reverse-query($x))
(:
   returns true because the cts:word-query for "hello"
   would match the document in $x
:)


</example>
	</function>
	<function name="reverse-query-nodes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:reverse-query-nodes">
		<summary>Returns the nodes used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:reverse-query" optional="false">A query.</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">
  cts:reverse-query-nodes($query)
  =&gt; //function
</example>
	</function>
	<function name="reverse-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:reverse-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:reverse-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  cts:similar-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="document-fragment-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:document-fragment-query">
		<summary>Returns a query that matches all documents where
			<code>$query</code>matches any document fragment. When searching documents, document-properties, or document-locks,
			<code>cts:document-fragment-query</code>provides a convenient way to additionally constrain the search against any document fragment.</summary>
		<params>
			<param name="query" type="cts:query" optional="false">A query to be matched against any document fragment.</param>
		</params>
		<return>cts:document-fragment-query</return>
		<usage>
			<p>A query that uses
				<code>cts:document-fragment-query</code>allows you to cross fragment boundaries in a
				<code>cts:and-query</code>, as shown in the second example below.</p>
		</usage>
		<example xml:space="preserve">
cts:search(
xdmp:document-properties(),
  cts:document-fragment-query(
    cts:word-query("hello")))

=&gt;  All properties documents whose corresponding document
    (that is, the document at the same URI as the
    proerties document) contain the word "hello".
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
(:
 Given a document with a fragment root of &lt;fragment&gt;
 created as follows:

xdmp:document-insert("fragmented.xml",
   &lt;root&gt;
     &lt;author&gt;bob&lt;/author&gt;
     &lt;fragment&gt;dog&lt;/fragment&gt;
     &lt;fragment&gt;cat&lt;/fragment&gt;
     &lt;fragment&gt;fish&lt;/fragment&gt;
  &lt;/root&gt;);

:)

cts:search(fn:doc("fragmented.xml"),
  cts:and-query((
    cts:document-fragment-query("bob"),
    "dog"
  ))
)
=&gt; returns the fragmented.xml document
</example>
	</function>
	<function name="document-fragment-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:document-fragment-query-query">
		<summary>Returns the query used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:document-fragment-query" optional="false">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  cts:document-fragment-query-query(cts:document-fragment-query(cts:word-query("word")))
  =&gt; cts:word-query("word")
</example>
	</function>
	<function name="properties-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:properties-query">
		<summary>Returns a query that matches all documents where
			<code>$query</code>matches document-properties. When searching documents or document-locks,
			<code>cts:properties-query</code>provides a convenient way to additionally constrain the search against document-properties fragments.</summary>
		<params>
			<param name="query" type="cts:query" optional="false">A query to be matched against the properties fragment.</param>
		</params>
		<return>cts:properties-query</return>
		<usage></usage>
		<example xml:space="preserve">
cts:search(
  fn:collection(),
  cts:properties-query(
    cts:element-range-query(
        xs:QName("prop:last-modified"),"&gt;",
        current-dateTime() - xs:dayTimeDuration("P1D"))))

=&gt; All documents modified up to one day in the past.
    Note that this example requires a dateTime range index on:
    namespace: http://marklogic.com/xdmp/property
    local name: last-modified
</example>
	</function>
	<function name="properties-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:properties-query-query">
		<summary>Returns the query used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:properties-query" optional="false">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  cts:properties-query-query(cts:properties-query(cts:word-query("word")))
  =&gt; cts:word-query("word")
</example>
	</function>
	<function name="locks-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:locks-query">
		<summary>Returns a query that matches all documents where
			<code>$query</code>matches document-locks. When searching documents or document-properties,
			<code>cts:locks-query</code>provides a convenient way to additionally constrain the search against document-locks fragments.</summary>
		<params>
			<param name="query" type="cts:query" optional="false">A query to be matched against the locks fragment.</param>
		</params>
		<return>cts:locks-query</return>
		<usage></usage>
		<example xml:space="preserve">
cts:search(
  fn:collection(),
  cts:locks-query(
    cts:element-range-query(
        xs:QName("prop:last-modified"),"&gt;",
        current-dateTime() - xs:dayTimeDuration("P1D"))))

=&gt; All documents modified up to one day in the past.
    Note that this example requires a dateTime range index on:
    namespace: http://marklogic.com/xdmp/property
    local name: last-modified
</example>
	</function>
	<function name="locks-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:locks-query-query">
		<summary>Returns the query used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:locks-query" optional="false">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
  cts:locks-query-query(cts:locks-query(cts:word-query("word")))
  =&gt; cts:word-query("word")
</example>
	</function>
	<function name="query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:query">
		<summary>Creates a query.</summary>
		<params>
			<param name="query" type="element()" optional="true">A query.</param>
		</params>
		<return>cts:query</return>
		<example xml:space="preserve">
cts:query(
  &lt;cts:word-query xmlns:cts="http://marklogic.com/cts"&gt;
    &lt;cts:text&gt;word&lt;/cts:text&gt;
  &lt;/cts:word-query&gt;
)


</example>
	</function>
	<function name="distinctive-terms" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:distinctive-terms">
		<summary>Return the most "relevant" terms in the model nodes (that is, the terms with the highest scores).</summary>
		<params>
			<param name="nodes" type="node()*" optional="false">Some model nodes.</param>
			<param name="options" type="element()?" optional="true">
				<a id="db-term-options" />An XML representation of the options for defining which terms to generate and how to evaluate them. The options node must be in the
				<code>cts:distinctive-terms</code>namespace. The following is a sample options node:
				<pre xml:space="preserve">
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
    &lt;/options&gt;
</pre>
				<p>The
					<code>cts:distinctive-terms</code>options (which are also valid for
					<code>cts:similar-query</code>,
					<code>cts:train</code>, and
					<code>cts:cluster</code>) include:</p>
				<dl>
					<dt>
						<p>&lt;
							<code>max-terms</code>&gt;</p>
					</dt>
					<dd>An integer defining the maximum number of distinctive terms to list in the
						<code>cts:distinctive-terms</code>output. The default is 16.</dd>
					<dt>
						<p>&lt;
							<code>min-val</code>&gt;</p>
					</dt>
					<dd>A double specifying the minimum value a term can have and still be considered a distinctive term. The default is 0.</dd>
					<dt>
						<p>&lt;
							<code>min-weight</code>&gt;</p>
					</dt>
					<dd>A number specifying the minimum weighted term frequency a term can have and still be considered a distinctive term. In general this value will be either 0 (include unweighted terms) or 1 (don't include unweighted terms). The default is 1.</dd>
					<dt>
						<p>&lt;
							<code>score</code>&gt;</p>
					</dt>
					<dd>A string defining which scoring method to use in comparing the values of the terms. The default is
						<code>logtfidf</code>. See the description of scoring methods in the cts:search function for more details. Possible values are:
						<dl>
							<dt>
								<p>
									<code>logtfidf</code>
								</p>
							</dt>
							<dd>Compute scores using the logtfidf method.</dd>
							<dt>
								<p>
									<code>logtf</code>
								</p>
							</dt>
							<dd>Compute scores using the logtf method.</dd>
							<dt>
								<p>
									<code>simple</code>
								</p>
							</dt>
							<dd>Compute scores using the simple method.</dd>
						</dl></dd>
					<dt>
						<p>&lt;
							<code>use-db-config</code>&gt;</p>
					</dt>
					<dd>A boolean value indicating whether to use the current DB configuration for determining which terms to use. The default is
						<code>true</code>. Setting the value to
						<code>false</code>means that the indexing options in the options node will be used, as well as the default value for any of the options not specified. This may be used to easily target a small set of terms.</dd>
					<dt>
						<p>&lt;
							<code>complete</code>&gt;</p>
					</dt>
					<dd>A boolean value indicating whether to return terms even if there is no query associated with them. The default is false.</dd>
				</dl>
				<p>The options element also includes indexing options in the
					<code>http://marklogic.com/xdmp/database</code>namespace. These control which terms to use.</p>
				<p>These database options include the following (shown here with a
					<code>db</code>prefix to denote the
					<code>http://marklogic.com/xdmp/database</code>namespace. The default given below is the default value if
					<code>use-db-config</code>is set to
					<code>false</code>:</p>
				<dl>
					<dt>
						<p>&lt;
							<code>db:word-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for the words in the node. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:stemmed-searches</code>&gt;</p>
					</dt>
					<dd>Define whether to include terms for the stems in the node, and at what level of stemming:
						<code>off</code>,
						<code>basic</code>,
						<code>advanced</code>, or
						<code>decompounding</code>. The default is 'basic'.</dd>
					<dt>
						<p>&lt;
							<code>db:fast-case-sensitive-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for case-sensitive variations of the words in the node. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:fast-diacritic-sensitive-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for diacritic-sensitive variations of the words in the node. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:fast-phrase-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for two-word phrases in the node. The default is 'true'.</dd>
					<dt>
						<p>&lt;
							<code>db:phrase-throughs</code>&gt;</p>
					</dt>
					<dd>If phrase terms are included, include terms for phrases that cross the given elements. The default is to have no such elements.</dd>
					<dt>
						<p>&lt;
							<code>db:phrase-arounds</code>&gt;</p>
					</dt>
					<dd>If phrase terms are included, include terms for phrases that skip over the given elements. The default is to have no such elements.</dd>
					<dt>
						<p>&lt;
							<code>db:fast-element-word-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for words in particular elements. The default is 'true'.</dd>
					<dt>
						<p>&lt;
							<code>db:fast-element-phrase-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for phrases in particular elements. The default is 'true'.</dd>
					<dt>
						<p>&lt;
							<code>db:element-word-query-throughs</code>&gt;</p>
					</dt>
					<dd>Include terms for words in sub-elements of the given elements. The default is to have no such elements.</dd>
					<dt>
						<p>&lt;
							<code>db:fast-element-character-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for characters in particular elements. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:range-element-indexes</code>&gt;</p>
					</dt>
					<dd>Include terms for data values in specific elements. The default is to have no such indexes.</dd>
					<dt>
						<p>&lt;
							<code>db:range-field-indexes</code>&gt;</p>
					</dt>
					<dd>Include terms for data values in specific fields. The default is to have no such indexes.</dd>
					<dt>
						<p>&lt;
							<code>db:range-element-attribute-indexes</code>&gt;</p>
					</dt>
					<dd>Include terms for data values in specific attributes. The default is to have no such indexes.</dd>
					<dt>
						<p>&lt;
							<code>db:one-character-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for single character. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:two-character-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for two-character sequences. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:three-character-searches</code>&gt;</p>
					</dt>
					<dd>Include terms three-character sequences. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:trailing-wildcard-searches</code>&gt;</p>
					</dt>
					<dd>Include terms for trailing wildcards. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:fast-element-trailing-wildcard-searches</code>&gt;</p>
					</dt>
					<dd>If trailing wildcard terms are included, include terms for trailing wildcards by element. The default is 'false'.</dd>
					<dt>
						<p>&lt;
							<code>db:fields</code>&gt;</p>
					</dt>
					<dd>Include terms for the defined fields. The default is to have no fields.</dd>
				</dl></param>
		</params>
		<return>element(cts:class)</return>
		<usage>
			<a id="output_format">
				<b>Output Format</b>
			</a>The output of the function is a
			<code>cts:class</code>element containing a sequence of
			<code>cts:term</code>elements. (This is the same as the weights form of a class for the SVM classifier; see cts:train.) Each
			<code>cts:term</code>element identifies the term ID as well as a score, confidence, and fitness measure for the term, in addition to a
			<code>cts:query</code>that corresponds to the term. The correspondence of terms to queries is not precise: queries typically make use of multiple terms, and not all terms correspond to a query. However, a search using the query given for a term will match the model node that gave rise to it.</usage>
		<example xml:space="preserve">
cts:distinctive-terms( fn:doc("book.xml"),
   &lt;options xmlns="cts:distinctive-terms"&gt;&lt;max-terms&gt;3&lt;/max-terms&gt;&lt;/options&gt; )
== &gt;
&lt;cts:class name="dterms book.xml" offset="0" xmlns:cts="http://marklogic.com/cts"&gt;
  &lt;cts:term id="1230725848944963443" val="482" score="372" confidence="0.686441" fitness="0.781011"&gt;
    &lt;cts:element-word-query&gt;
      &lt;cts:element&gt;title&lt;/cts:element&gt;
      &lt;cts:text xml:lang="en"&gt;the&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:element-word-query&gt;
  &lt;/cts:term&gt;
  &lt;cts:term id="2859044029148442125" val="435" socre="662" confidence="0.922555" fitness="0.971371"&gt;
    &lt;cts:word-query&gt;
      &lt;cts:text xml:lang="en"&gt;text&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:word-query&gt;
  &lt;/cts:term&gt;
  &lt;cts:term id="17835615465481541363" val="221" score="237" confidence="0.65647" fitness="0.781263"&gt;
    &lt;cts:word-query&gt;
      &lt;cts:text xml:lang="en"&gt;of&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:word-query&gt;
  &lt;/cts:term&gt;
&lt;/cts:class&gt;
</example>
    <example xml:space="preserve">
cts:distinctive-terms(//title,
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;use-db-config&gt;true&lt;/use-db-config&gt;
    &lt;/options&gt;)

=&gt; a cts:class element contianing the 16 most distinctive query terms
</example>
    <example xml:space="preserve">
cts:distinctive-terms(&lt;foo&gt;hello there you&lt;/foo&gt;,
    &lt;options xmlns="cts:distinctive-terms"
             xmlns:db="http://marklogic.com/xdmp/database"&gt;
            &lt;db:word-positions&gt;true&lt;/db:word-positions&gt;
    &lt;/options&gt;)

=&gt; a cts:class element contianing the 16 most distinctive query terms
</example>
	</function>
	<function name="point" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:point">
		<summary>Returns a point value.</summary>
		<params>
			<param name="latitude" type="xs:float" optional="false">The latitude of the point.</param>
			<param name="longitude" type="xs:float" optional="false">The longitude of the point.</param>
		</params>
		<return>cts:point</return>
		<example xml:space="preserve">
  cts:point(0.373899653086420E+02, -0.122078578406509E+03)
</example>
	</function>
	<function name="point-latitude" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:point-latitude">
		<summary>Returns a point's latitude value.</summary>
		<params>
			<param name="point" type="cts:point" optional="false">The point.</param>
		</params>
		<return>xs:float</return>
		<example xml:space="preserve">
  let $point := cts:point(37.270556, -118.672778)
  return
  cts:point-latitude($point)
</example>
	</function>
	<function name="point-longitude" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:point-longitude">
		<summary>Returns a point's longitude value.</summary>
		<params>
			<param name="point" type="cts:point" optional="false">The point.</param>
		</params>
		<return>xs:float</return>
		<example xml:space="preserve">
  let $point := cts:point(37.270556, -118.672778)
  return
  cts:point-longitude($point)
</example>
	</function>
	<function name="box" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:box">
		<summary>Returns a geospatial box value.</summary>
		<params>
			<param name="south" type="xs:float" optional="false">The southern boundary of the box.</param>
			<param name="west" type="xs:float" optional="false">The western boundary of the box.</param>
			<param name="north" type="xs:float" optional="false">The northern boundary of the box.</param>
			<param name="east" type="xs:float" optional="false">The eastern boundary of the box.</param>
		</params>
		<return>cts:box</return>
		<example xml:space="preserve">
cts:box(-122, 78, 30, 45)
=&gt; [-122, 78, 30, 45] (as a cts:box)
</example>
	</function>
	<function name="box-south" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:box-south">
		<summary>Returns a box's southern boundary.</summary>
		<params>
			<param name="box" type="cts:box" optional="false">The box.</param>
		</params>
		<return>xs:float</return>
		<example xml:space="preserve">
cts:box-south(cts:box(-122, 78, 30, 45))
=&gt; -122
</example>
	</function>
	<function name="box-west" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:box-west">
		<summary>Returns a box's western boundary.</summary>
		<params>
			<param name="box" type="cts:box" optional="false">The box.</param>
		</params>
		<return>xs:float</return>
		<example xml:space="preserve">
cts:box-west(cts:box(-122, 78, 30, 45))
=&gt; 78
</example>
	</function>
	<function name="box-north" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:box-north">
		<summary>Returns a box's northern boundary.</summary>
		<params>
			<param name="box" type="cts:box" optional="false">The box.</param>
		</params>
		<return>xs:float</return>
		<example xml:space="preserve">
cts:box-north(cts:box(-122, 78, 30, 45))
=&gt; 30
</example>
	</function>
	<function name="box-east" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:box-east">
		<summary>Returns a box's eastern boundary.</summary>
		<params>
			<param name="box" type="cts:box" optional="false">The box.</param>
		</params>
		<return>xs:float</return>
		<example xml:space="preserve">
cts:box-east(cts:box(-122, 78, 30, 45))
=&gt; 45
</example>
	</function>
	<function name="circle" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:circle">
		<summary>Returns a geospatial circle value.</summary>
		<params>
			<param name="radius" type="xs:float" optional="false">The radius of the circle. The units for the radius is determined at runtime by the
				<code>cts:query</code>options (miles is currently the only option).</param>
			<param name="center" type="cts:point" optional="false">A point representing the center of the circle.</param>
		</params>
		<return>cts:circle</return>
		<example xml:space="preserve">
cts:circle(20, cts:point(37.655983, -122.425525))
=&gt; @20 37.655983,-122.42552 (as a cts:circle)
</example>
	</function>
	<function name="circle-radius" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:circle-radius">
		<summary>Returns a circle's radius.</summary>
		<params>
			<param name="circle" type="cts:circle" optional="false">The circle.</param>
		</params>
		<return>xs:float</return>
		<example xml:space="preserve">
cts:circle-radius(cts:circle(20, cts:point(37.655983, -122.425525)))
=&gt; 20
</example>
	</function>
	<function name="circle-center" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:circle-center">
		<summary>Returns a circle's center point.</summary>
		<params>
			<param name="circle" type="cts:circle" optional="false">The circle.</param>
		</params>
		<return>cts:point</return>
		<example xml:space="preserve">
cts:circle-center(cts:circle(20, cts:point(37.655983, -122.425525)))
=&gt; 37.655983, -122.425525 (as a cts:point)
</example>
	</function>
	<function name="polygon" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:polygon">
		<summary>Returns a geospatial polygon value.</summary>
		<params>
			<param name="vertices" type="cts:point*" optional="false">The vertices of the polygon, given in order. No edge may cover more than 180 degrees of either latitude or longitude. The polygon as a whole may not encompass both poles. These constraints are necessary to ensure an unambiguous interpretation of the polygon. There must be at least three vertices. The first vertex should be identical to the last vertex to close the polygon. vertexes.</param>
		</params>
		<return>cts:polygon</return>
		<example xml:space="preserve">
  (: this polygon approximates the 94041 zip code :)
  let $points := (cts:point(0.373899653086420E+02, -0.122078578406509E+03),
    cts:point(0.373765400000000E+02, -0.122063772000000E+03),
    cts:point(0.373781400000000E+02, -0.122067972000000E+03),
    cts:point(0.373825650000000E+02, -0.122068365000000E+03),
    cts:point(0.373797400000000E+02, -0.122072172000000E+03),
    cts:point(0.373899400000000E+02, -0.122092573000000E+03),
    cts:point(0.373941400000000E+02, -0.122095573000000E+03),
    cts:point(0.373966400000000E+02, -0.122094173000000E+03),
    cts:point(0.373958400000000E+02, -0.122092373000000E+03),
    cts:point(0.374004400000000E+02, -0.122091273000000E+03),
    cts:point(0.374004400000000E+02, -0.122091273000000E+03),
    cts:point(0.373873400000000E+02, -0.122057872000000E+03),
    cts:point(0.373873400000000E+02, -0.122057872000000E+03),
    cts:point(0.373854400000000E+02, -0.122052672000000E+03),
    cts:point(0.373833400000000E+02, -0.122053372000000E+03),
    cts:point(0.373819400000000E+02, -0.122057572000000E+03),
    cts:point(0.373775400000000E+02, -0.122060872000000E+03),
    cts:point(0.373765400000000E+02, -0.122063772000000E+03) )
  return
  cts:polygon($points)
</example>
	</function>
	<function name="polygon-vertices" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:polygon-vertices">
		<summary>Returns a polygon's vertices. The first vertex and last vertex will always be the same.</summary>
		<params>
			<param name="polygon" type="cts:polygon" optional="false">The polygon.</param>
		</params>
		<return>cts:point*</return>
		<example xml:space="preserve">
  let $node :=
    &lt;polygon zip="94041"&gt;
       0.373899653086420E+02,       -0.122078578406509E+03
       0.373765400000000E+02,       -0.122063772000000E+03
       0.373781400000000E+02,       -0.122067972000000E+03
       0.373825650000000E+02,       -0.122068365000000E+03
       0.373797400000000E+02,       -0.122072172000000E+03
       0.373899400000000E+02,       -0.122092573000000E+03
       0.373941400000000E+02,       -0.122095573000000E+03
       0.373966400000000E+02,       -0.122094173000000E+03
       0.373958400000000E+02,       -0.122092373000000E+03
       0.374004400000000E+02,       -0.122091273000000E+03
       0.374004400000000E+02,       -0.122091273000000E+03
       0.373873400000000E+02,       -0.122057872000000E+03
       0.373873400000000E+02,       -0.122057872000000E+03
       0.373854400000000E+02,       -0.122052672000000E+03
       0.373833400000000E+02,       -0.122053372000000E+03
       0.373819400000000E+02,       -0.122057572000000E+03
       0.373775400000000E+02,       -0.122060872000000E+03
       0.373765400000000E+02,       -0.122063772000000E+03
    &lt;/polygon&gt;
    return
    cts:polygon-vertices(cts:polygon(fn:data($node)))
</example>
	</function>
	<function name="linestring" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:linestring">
		<summary>Returns a geospatial linestring value.</summary>
		<params>
			<param name="vertices" type="cts:point*" optional="false">The waypoints of the linestring, given in order. vertexes.</param>
		</params>
		<return>cts:linestring</return>
		<example xml:space="preserve">
  let $points := (cts:point(0.373899653086420E+02, -0.122078578406509E+03),
    cts:point(0.373765400000000E+02, -0.122063772000000E+03),
    cts:point(0.373781400000000E+02, -0.122067972000000E+03),
    cts:point(0.373825650000000E+02, -0.122068365000000E+03),
    cts:point(0.373797400000000E+02, -0.122072172000000E+03),
    cts:point(0.373899400000000E+02, -0.122092573000000E+03) )
  return
  cts:linestring($points)
</example>
	</function>
	<function name="linestring-vertices" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:linestring-vertices">
		<summary>Returns a linestring's vertices.</summary>
		<params>
			<param name="linestring" type="cts:linestring" optional="false">The linestring.</param>
		</params>
		<return>cts:point*</return>
		<example xml:space="preserve">
  let $linestring :=
    "LINESTRING(
       0.373899653086420E+02 -0.122078578406509E+03,
       0.373765400000000E+02 -0.122063772000000E+03,
       0.373781400000000E+02 -0.122067972000000E+03,
       0.373825650000000E+02 -0.122068365000000E+03,
       0.373797400000000E+02 -0.122072172000000E+03,
       0.373899400000000E+02 -0.122092573000000E+03,
       0.373941400000000E+02 -0.122095573000000E+03,
       0.373966400000000E+02 -0.122094173000000E+03,
       0.373958400000000E+02 -0.122092373000000E+03,
       0.374004400000000E+02 -0.122091273000000E+03)"
    return
    cts:linestring-vertices(cts:linestring($linestring))
</example>
	</function>
	<function name="complex-polygon" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:complex-polygon">
		<summary>Returns a geospatial complex polygon value.</summary>
		<params>
			<param name="outer" type="cts:polygon" optional="false">The outer polygon.</param>
			<param name="inner" type="cts:polygon*" optional="false">The innner (hole) polygons.</param>
		</params>
		<return>cts:complex-polygon</return>
		<example xml:space="preserve">
cts:complex-polygon(
  cts:polygon("0,0 10,0 10,10 0,10 0,0"),
  cts:polygon("5,0 7,0 7,5 5,5 5,0"))
</example>
	</function>
	<function name="complex-polygon-outer" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:complex-polygon-outer">
		<summary>Returns a complex polygon's outer polygon.</summary>
		<params>
			<param name="complexPolygon" type="cts:complex-polygon" optional="false">The complex polygon.</param>
		</params>
		<return>cts:polygon?</return>
		<example xml:space="preserve">
  let $node :=
    &lt;complexPolygon name="Arapahoe"&gt;POLYGON((
      0.396982870000000E+02 -0.104935135000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.397110870000000E+02 -0.104931634000000E+03,
      0.397066870000000E+02 -0.104926934000000E+03,
      0.397012870000000E+02 -0.104932834000000E+03,
      0.396971870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104931534000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
      ),
       (
      0.396981250000000E+02 -0.104934109000000E+03,
      0.397001130000000E+02 -0.104931652000000E+03,
      0.397001870000000E+02 -0.104934034000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
       )
    &lt;/complexPolygon&gt;
    return
    cts:complex-polygon-outer(cts:parse-wkt(fn:data($node)))
</example>
	</function>
	<function name="complex-polygon-inner" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:complex-polygon-inner">
		<summary>Returns a complex polygon's inner polygons.</summary>
		<params>
			<param name="complexPolygon" type="cts:complex-polygon" optional="false">The complex polygon.</param>
		</params>
		<return>cts:polygon*</return>
		<example xml:space="preserve">
  let $node :=
    &lt;complexPolygon name="Arapahoe"&gt;POLYGON((
      0.396982870000000E+02 -0.104935135000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.396965870000000E+02 -0.104938635000000E+03,
      0.397110870000000E+02 -0.104931634000000E+03,
      0.397066870000000E+02 -0.104926934000000E+03,
      0.397012870000000E+02 -0.104932834000000E+03,
      0.396971870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104928134000000E+03,
      0.396965870000000E+02 -0.104931534000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396966870000000E+02 -0.104934335000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
      ),

       (
      0.396981250000000E+02 -0.104934109000000E+03,
      0.397001130000000E+02 -0.104931652000000E+03,
      0.397001870000000E+02 -0.104934034000000E+03,
      0.396981250000000E+02 -0.104934109000000E+03
       ))
    &lt;/complexPolygon&gt;
    return
    cts:complex-polygon-inner(cts:parse-wkt(fn:data($node)))
</example>
	</function>
	<function name="element-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-geospatial-query">
		<summary>Returns a
			<code>cts:query</code>matching elements by name whose content represents a point contained within the given geographic box, circle, or polygon, or equal to the given point. Points that lie between the southern boundary and the northern boundary of a box, travelling northwards, and between the western boundary and the eastern boundary of the box, travelling eastwards, will match. Points contained within the given radius of the center point of a circle will match, using the curved distance on the surface of the Earth. Points contained within the given polygon will match, using great circle arcs over a spherical model of the Earth as edges. An error may result if the polygon is malformed in some way. Points equal to the a given point will match, taking into account the fact that longitudes converge at the poles. Using the geospatial query constructors requires a valid geospatial license key; without a valid license key, searches that include geospatial queries will throw an exception.</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, polygons, or points. Where multiple regions are specified, the query matches if any region matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
						<dt>"cached"</dt>
						<dd>Cache the results of this query in the list cache.</dd>
						<dt>"uncached"</dt>
						<dd>Do not cache the results of this query in the list cache.</dd>
						<dt>"type=long-lat-point"</dt>
						<dd>Specifies the format for the point in the data as longitude first, latitude second.</dd>
						<dt>"type=point"</dt>
						<dd>Specifies the format for the point in the data as latitude first, longitude second. This is the default format.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0. This option is currently ignored; geospatial queries do not contribute to the score.</param>
		</params>
		<return>cts:element-geospatial-query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
			<p>If neither "cached" nor "uncached" is present, it specifies "cached".</p>
		</usage>
		<example xml:space="preserve">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;5.11, 40.55&lt;/point&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:element-geospatial-query(xs:QName("point"), cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point&gt;15.35, 35.34&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-geospatial-query(xs:QName("point"), cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point&gt;10.5, 30.0&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-geospatial-query(xs:QName("point"), cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</example>
	</function>
	<function name="element-geospatial-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-geospatial-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-geospatial-query(xs:QName("point"), cts:box(10.1, 10.2, 20.1, 20.2))
return
cts:element-geospatial-query-element-name($query)
  =&gt; xs:QName("point")
</example>
	</function>
	<function name="element-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-geospatial-query-region">
		<summary>Returns the geographical regions with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-geospatial-query" optional="false">A query.</param>
		</params>
		<return>cts:box*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-geospatial-query(xs:QName("point"),
       cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-geospatial-query-region($query)
  =&gt; cts:box(10.1, 10.2, 20.1, 20.2)
</example>
	</function>
	<function name="element-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-geospatial-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-geospatial-query(xs:QName("point"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-geospatial-query-options($query)
  =&gt; "coordinate-system=wgs84"
</example>
	</function>
	<function name="element-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-geospatial-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
let $query :=
   cts:element-geospatial-query(xs:QName("point"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-geospatial-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-child-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-query">
		<summary>Returns a
			<code>cts:query</code>matching elements by name which has specific element children representing latitude and longitude values for a point contained within the given geographic box, circle, or polygon, or equal to the given point. Points that lie between the southern boundary and the northern boundary of a box, travelling northwards, and between the western boundary and the eastern boundary of the box, travelling eastwards, will match. Points contained within the given radius of the center point of a circle will match, using the curved distance on the surface of the Earth. Points contained within the given polygon will match, using great circle arcs over a spherical model of the Earth as edges. An error may result if the polygon is malformed in some way. Points equal to the a given point will match, taking into account the fact that longitudes converge at the poles. Using the geospatial query constructors requires a valid geospatial license key; without a valid license key, searches that include geospatial queries will throw an exception.</summary>
		<params>
			<param name="parent-element-name" type="xs:QName*" optional="false">One or more parent element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="child-element-names" type="xs:QName*" optional="false">One or more child element QNames to match. When multiple QNames are specified, the query matches if any QName matches; however, only the first matching latitude child in any point instance will be checked. The element must specify both latitude and longitude coordinates.</param>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, polygons, or points. Where multiple regions are specified, the query matches if any region matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
						<dt>"cached"</dt>
						<dd>Cache the results of this query in the list cache.</dd>
						<dt>"uncached"</dt>
						<dd>Do not cache the results of this query in the list cache.</dd>
						<dt>"type=long-lat-point"</dt>
						<dd>Specifies the format for the point in the data as longitude first, latitude second.</dd>
						<dt>"type=point"</dt>
						<dd>Specifies the format for the point in the data as latitude first, longitude second. This is the default format.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0. This option is currently ignored; geospatial queries do not contribute to the score.</param>
		</params>
		<return>cts:element-child-geospatial-query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a child of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
			<p>If neither "cached" nor "uncached" is present, it specifies "cached".</p>
		</usage>
		<example xml:space="preserve">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;10.5 30.0&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;15.35 35.34&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;5.11 40.55&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
    cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;15.35 35.34&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
    cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point&gt;&lt;pos&gt;10.5 30.0&lt;/pos&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
    cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</example>
	</function>
	<function name="element-child-geospatial-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-child-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-element-name($query)
  =&gt; xs:QName("point")
</example>
	</function>
	<function name="element-child-geospatial-query-child-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-query-child-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-child-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-child-name($query)
  =&gt; xs:QName("pos")
</example>
	</function>
	<function name="element-child-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-query-region">
		<summary>Returns the geographical regions with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-child-geospatial-query" optional="false">A query.</param>
		</params>
		<return>cts:region*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-region($query)
  =&gt; cts:box(10.1, 10.2, 20.1, 20.2)
</example>
	</function>
	<function name="element-child-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-child-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-options($query)
  =&gt; "coordinate-system=wgs84"
</example>
	</function>
	<function name="element-child-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-child-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
let $query :=
   cts:element-child-geospatial-query(xs:QName("point"), xs:QName("pos"),
     cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-child-geospatial-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-pair-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-query">
		<summary>Returns a
			<code>cts:query</code>matching elements by name which has specific element children representing latitude and longitude values for a point contained within the given geographic box, circle, or polygon, or equal to the given point. Points that lie between the southern boundary and the northern boundary of a box, travelling northwards, and between the western boundary and the eastern boundary of the box, travelling eastwards, will match. Points contained within the given radius of the center point of a circle will match, using the curved distance on the surface of the Earth. Points contained within the given polygon will match, using great circle arcs over a spherical model of the Earth as edges. An error may result if the polygon is malformed in some way. Points equal to the a given point will match, taking into account the fact that longitudes converge at the poles. Using the geospatial query constructors requires a valid geospatial license key; without a valid license key, searches that include geospatial queries will throw an exception.</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more parent element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="latitude-element-names" type="xs:QName*" optional="false">One or more latitude element QNames to match. When multiple QNames are specified, the query matches if any QName matches; however, only the first matching latitude child in any point instance will be checked.</param>
			<param name="longitude-element-names" type="xs:QName*" optional="false">One or more longitude element QNames to match. When multiple QNames are specified, the query matches if any QName matches; however, only the first matching longitude child in any point instance will be checked.</param>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, polygons, or points. Where multiple regions are specified, the query matches if any region matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
						<dt>"cached"</dt>
						<dd>Cache the results of this query in the list cache.</dd>
						<dt>"uncached"</dt>
						<dd>Do not cache the results of this query in the list cache.</dd>
						<dt>"cached"</dt>
						<dd>Cache the results of this query in the list cache.</dd>
						<dt>"uncached"</dt>
						<dd>Do not cache the results of this query in the list cache.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0. This option is currently ignored; geospatial queries do not contribute to the score.</param>
		</params>
		<return>cts:element-pair-geospatial-query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
			<p>If neither "cached" nor "uncached" is present, it specifies "cached".</p>
		</usage>
		<example xml:space="preserve">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;10.5&lt;/lat&gt;&lt;long&gt;30.0&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;15.35&lt;/lat&gt;&lt;long&gt;35.34&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;5.11&lt;/lat&gt;&lt;long&gt;40.55&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:element-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;15.35&lt;/lat&gt;&lt;long&gt;35.34&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point&gt;&lt;lat&gt;10.5&lt;/lat&gt;&lt;long&gt;30.0&lt;/long&gt;&lt;/point&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</example>
	</function>
	<function name="element-pair-geospatial-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-element-name($query)
  =&gt; xs:QName("point")
</example>
	</function>
	<function name="element-pair-geospatial-query-latitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-query-latitude-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-latitude-name($query)
  =&gt; xs:QName("lat")
</example>
	</function>
	<function name="element-pair-geospatial-query-longitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-query-longitude-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-longitude-name($query)
  =&gt; xs:QName("lat")
</example>
	</function>
	<function name="element-pair-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-query-region">
		<summary>Returns the geographical regions with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>cts:region*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-region($query)
  =&gt; cts:box(10.1, 10.2, 20.1, 20.2)
</example>
	</function>
	<function name="element-pair-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-options($query)
  =&gt; "coordinate-system=wgs84"
</example>
	</function>
	<function name="element-pair-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
let $query :=
   cts:element-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-pair-geospatial-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-attribute-pair-geospatial-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-query">
		<summary>Returns a
			<code>cts:query</code>matching elements by name which has specific attributes representing latitude and longitude values for a point contained within the given geographic box, circle, or polygon, or equal to the given point. Points that lie between the southern boundary and the northern boundary of a box, travelling northwards, and between the western boundary and the eastern boundary of the box, travelling eastwards, will match. Points contained within the given radius of the center point of a circle will match, using the curved distance on the surface of the Earth. Points contained within the given polygon will match, using great circle arcs over a spherical model of the Earth as edges. An error may result if the polygon is malformed in some way. Points equal to the a given point will match, taking into account the fact that longitudes converge at the poles. Using the geospatial query constructors requires a valid geospatial license key; without a valid license key, searches that include geospatial queries will throw an exception.</summary>
		<params>
			<param name="element-name" type="xs:QName*" optional="false">One or more parent element QNames to match. When multiple QNames are specified, the query matches if any QName matches.</param>
			<param name="latitude-attribute-names" type="xs:QName*" optional="false">One or more latitude attribute QNames to match. When multiple QNames are specified, the query matches if any QName matches; however, only the first matching latitude attribute in any point instance will be checked.</param>
			<param name="longitude-attribute-names" type="xs:QName*" optional="false">One or more longitude attribute QNames to match. When multiple QNames are specified, the query matches if any QName matches; however, only the first matching longitude attribute in any point instance will be checked.</param>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, polygons, or points. Where multiple regions are specified, the query matches if any region matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
						<dt>"cached"</dt>
						<dd>Cache the results of this query in the list cache.</dd>
						<dt>"uncached"</dt>
						<dd>Do not cache the results of this query in the list cache.</dd>
						<dt>"synonym"</dt>
						<dd>Specifies that all of the terms in the $text parameter are considered synonyms for scoring purposes. The result is that occurances of more than one of the synonyms are scored as if there are more occurance of the same term (as opposed to having a separate term that contributes to score).</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0. This option is currently ignored; geospatial queries do not contribute to the score.</param>
		</params>
		<return>cts:element-attribute-pair-geospatial-query</return>
		<usage>
			<p>The point value is expressed as the numerical values in the textual content of the named attributes.</p>
			<p>The point values and the boundary specifications are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary (that is, if the value of 'w' is greater than the value of 'e'), then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
			<p>If neither "cached" nor "uncached" is present, it specifies "cached".</p>
		</usage>
		<example xml:space="preserve">
(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root&gt;
  &lt;item&gt;&lt;point lat="10.5" long="30.0"/&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point lat="15.35" long="35.34"/&gt;&lt;/item&gt;
  &lt;item&gt;&lt;point lat="5.11" long="40.55"/&gt;&lt;/item&gt;
&lt;/root&gt; );

cts:search(doc("/points.xml")//item,
  cts:element-attribute-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;point lat="15.35" long="35.34"/&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-attribute-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;point lat="10.5" long="30.0"/&gt;&lt;/item&gt;
:)
;

cts:search(doc("/points.xml")//item,
  cts:element-attribute-pair-geospatial-query(xs:QName("point"),
    xs:QName("lat"), xs:QName("long"), cts:box(20.0, 35.0, 10.0, 40.0)))
(:
  throws an error (latitudes do not wrap)
:)
;
</example>
	</function>
	<function name="element-attribute-pair-geospatial-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-query-element-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-element-name($query)
  =&gt; xs:QName("point")
</example>
	</function>
	<function name="element-attribute-pair-geospatial-query-latitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-query-latitude-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-latitude-name($query)
  =&gt; xs:QName("lat")
</example>
	</function>
	<function name="element-attribute-pair-geospatial-query-longitude-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-query-longitude-name">
		<summary>Returns the QNames used to construct the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:QName*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-longitude-name($query)
  =&gt; xs:QName("lat")
</example>
	</function>
	<function name="element-attribute-pair-geospatial-query-region" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-query-region">
		<summary>Returns the geographical regions with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-attribute-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>cts:region*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-region($query)
  =&gt; cts:box(10.1, 10.2, 20.1, 20.2)
</example>
	</function>
	<function name="element-attribute-pair-geospatial-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-query-options">
		<summary>Returns the options for the specified query.</summary>
		<params>
			<param name="query" type="cts:element-attribute-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
let $query :=
   cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-options($query)
  =&gt; "coordinate-system=wgs84"
</example>
	</function>
	<function name="element-attribute-pair-geospatial-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-query-weight">
		<summary>Returns the weight with which the specified query was constructed.</summary>
		<params>
			<param name="query" type="cts:element-attribute-pair-geospatial-query" optional="false">A query.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
let $query :=
   cts:element-attribute-pair-geospatial-query(xs:QName("point"),
     xs:QName("lat"), xs:QName("long"), cts:box(10.1, 10.2, 20.1, 20.2))
return cts:element-attribute-pair-geospatial-query-weight($query)
  =&gt; 1
</example>
	</function>
	<function name="element-geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-geospatial-boxes">
		<summary>
			<p>Returns boxes derived from the specified element point lexicon(s). Element point lexicons are implemented using geospatial indexes; consequently this function requires an element geospatial index for each element specified in the function. If there is not a geospatial index configured for each of the specified elements, an exception is thrown.</p>
			<p>The points are divided into box-shaped buckets. The $latitude-bounds and $longitude-bounds parameters specify the number and the size of each box-shaped bucket. All included points are bucketed, even those outside the bounds. An empty sequence for both $latitude-bounds and $longitude-bounds specifies one bucket, a single value for both specifies four buckets, two values for both specify nine buckets, and so on.</p>
			<p>For each non-empty bucket, a
				<code>cts:box</code>value is returned. By default, the
				<code>cts:box</code>value is the minimum bounding box of all the points in the bucket. If the "gridded" option is specified, then if a bucket is bounded on a side, its corresponding
				<code>cts:box</code>side is the bound. Empty buckets return nothing unless the "empties" option is specified.</p>
		</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-bounds" type="xs:double*" optional="true">A sequence of latitude bounds. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="longitude-bounds" type="xs:double*" optional="true">A sequence of longitude bounds. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Boxes should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Boxes should be returned in descending order.</dd>
						<dt>"gridded"</dt>
						<dd>For each side that a bucket is bounded, return the corresponding bound as the edge of the box, instead of the extremum from the points in the bucket.</dd>
						<dt>"empties"</dt>
						<dd>Include fully-bounded ranges whose frequency is 0. Only empty ranges that have both their upper and lower bounds specified in the $bounds options are returned; any empty ranges that are less than the first bound or greater than the last bound are not returned. For example, if you specify 4 bounds and there are no results for any of the bounds, 3 elements are returned (not 5 elements).</dd>
						<dt>"any"</dt>
						<dd>Points from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Points from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Points from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Points from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Boxes should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Boxes should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included point. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included point. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>boxes.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Points from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only boxes for buckets with at least one point from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only points from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"type=long-lat-point"</dt>
						<dd>Specifies the format for the point in the data as longitude first, latitude second.</dd>
						<dt>"type=point"</dt>
						<dd>Specifies the format for the point in the data as latitude first, longitude second. This is the default format.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:box* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include points in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included points. The points do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:box*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all boxes with included points may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then points from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
	</function>
	<function name="element-child-geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-boxes">
		<summary>
			<p>Returns boxes derived from the specified element point lexicon(s). Element point lexicons are implemented using geospatial indexes; consequently this function requires an element child geospatial index for each element specified in the function. If there is not a geospatial index configured for each of the specified element/child combinations, an exception is thrown.</p>
			<p>The points are divided into box-shaped buckets. The $latitude-bounds and $longitude-bounds parameters specify the number and the size of each box-shaped bucket. All included points are bucketed, even those outside the bounds. An empty sequence for both $latitude-bounds and $longitude-bounds specifies one bucket, a single value for both specifies four buckets, two values for both specify nine buckets, and so on.</p>
			<p>For each non-empty bucket, a
				<code>cts:box</code>value is returned. By default, the
				<code>cts:box</code>value is the minimum bounding box of all the points in the bucket. If the "gridded" option is specified, then if a bucket is bounded on a side, its corresponding
				<code>cts:box</code>side is the bound. Empty buckets return nothing unless the "empties" option is specified.</p>
		</summary>
		<params>
			<param name="parent-element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="child-element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-bounds" type="xs:double*" optional="true">A sequence of latitude bounds. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="longitude-bounds" type="xs:double*" optional="true">A sequence of longitude bounds. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Boxes should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Boxes should be returned in descending order.</dd>
						<dt>"gridded"</dt>
						<dd>For each side that a bucket is bounded, return the corresponding bound as the edge of the box, instead of the extremum from the points in the bucket.</dd>
						<dt>"empties"</dt>
						<dd>Include fully-bounded ranges whose frequency is 0. Only empty ranges that have both their upper and lower bounds specified in the $bounds options are returned; any empty ranges that are less than the first bound or greater than the last bound are not returned. For example, if you specify 4 bounds and there are no results for any of the bounds, 3 elements are returned (not 5 elements).</dd>
						<dt>"any"</dt>
						<dd>Points from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Points from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Points from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Points from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Boxes should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Boxes should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included point. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included point. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>boxes.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Points from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only boxes for buckets with at least one point from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only points from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"type=long-lat-point"</dt>
						<dd>Specifies the format for the point in the data as longitude first, latitude second.</dd>
						<dt>"type=point"</dt>
						<dd>Specifies the format for the point in the data as latitude first, longitude second. This is the default format.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:box* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include points in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included points. The points do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:box*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all boxes with included points may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then points from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
	</function>
	<function name="element-pair-geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-boxes">
		<summary>
			<p>Returns boxes derived from the specified element point lexicon(s). Element point lexicons are implemented using geospatial indexes; consequently this function requires a geospatial element pair index for each parent and pair of child elements specified in the function. If there is not a geospatial index configured for each of the specified combinations, an exception is thrown.</p>
			<p>The points are divided into box-shaped buckets. The $latitude-bounds and $longitude-bounds parameters specify the number and the size of each box-shaped bucket. All included points are bucketed, even those outside the bounds. An empty sequence for both $latitude-bounds and $longitude-bounds specifies one bucket, a single value for both specifies four buckets, two values for both specify nine buckets, and so on.</p>
			<p>For each non-empty bucket, a
				<code>cts:box</code>value is returned. By default, the
				<code>cts:box</code>value is the minimum bounding box of all the points in the bucket. If the "gridded" option is specified, then if a bucket is bounded on a side, its corresponding
				<code>cts:box</code>side is the bound. Empty buckets return nothing unless the "empties" option is specified.</p>
		</summary>
		<params>
			<param name="parent-element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="longitude-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-bounds" type="xs:double*" optional="true">A sequence of latitude bounds. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="longitude-bounds" type="xs:double*" optional="true">A sequence of longitude bounds. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Boxes should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Boxes should be returned in descending order.</dd>
						<dt>"gridded"</dt>
						<dd>For each side that a bucket is bounded, return the corresponding bound as the edge of the box, instead of the extremum from the points in the bucket.</dd>
						<dt>"empties"</dt>
						<dd>Include fully-bounded ranges whose frequency is 0. Only empty ranges that have both their upper and lower bounds specified in the $bounds options are returned; any empty ranges that are less than the first bound or greater than the last bound are not returned. For example, if you specify 4 bounds and there are no results for any of the bounds, 3 elements are returned (not 5 elements).</dd>
						<dt>"any"</dt>
						<dd>Points from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Points from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Points from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Points from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Boxes should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Boxes should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included point. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included point. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>boxes.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Points from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only boxes for buckets with at least one point from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only points from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:box* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include points in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included points. The points do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:box*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all boxes with included points may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then points from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
	</function>
	<function name="element-attribute-pair-geospatial-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-boxes">
		<summary>
			<p>Returns boxes derived from the specified element point lexicon(s). Element point lexicons are implemented using geospatial indexes; consequently this function requires a geospatial element attribute pair index for each prarent element and attribute pair specified in the function. If there is not a geospatial index configured for each of the specified combinations, an exception is thrown.</p>
			<p>The points are divided into box-shaped buckets. The $latitude-bounds and $longitude-bounds parameters specify the number and the size of each box-shaped bucket. All included points are bucketed, even those outside the bounds. An empty sequence for both $latitude-bounds and $longitude-bounds specifies one bucket, a single value for both specifies four buckets, two values for both specify nine buckets, and so on.</p>
			<p>For each non-empty bucket, a
				<code>cts:box</code>value is returned. By default, the
				<code>cts:box</code>value is the minimum bounding box of all the points in the bucket. If the "gridded" option is specified, then if a bucket is bounded on a side, its corresponding
				<code>cts:box</code>side is the bound. Empty buckets return nothing unless the "empties" option is specified.</p>
		</summary>
		<params>
			<param name="parent-element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="longitude-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-bounds" type="xs:double*" optional="true">A sequence of latitude bounds. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="longitude-bounds" type="xs:double*" optional="true">A sequence of longitude bounds. The values must be in strictly ascending order, otherwise an exception is thrown.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Boxes should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Boxes should be returned in descending order.</dd>
						<dt>"gridded"</dt>
						<dd>For each side that a bucket is bounded, return the corresponding bound as the edge of the box, instead of the extremum from the points in the bucket.</dd>
						<dt>"empties"</dt>
						<dd>Include fully-bounded ranges whose frequency is 0. Only empty ranges that have both their upper and lower bounds specified in the $bounds options are returned; any empty ranges that are less than the first bound or greater than the last bound are not returned. For example, if you specify 4 bounds and there are no results for any of the bounds, 3 elements are returned (not 5 elements).</dd>
						<dt>"any"</dt>
						<dd>Points from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Points from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Points from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Points from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Boxes should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Boxes should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included point. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included point. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>boxes.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Points from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only boxes for buckets with at least one point from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only points from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:box* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include points in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included points. The points do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:box*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all boxes with included points may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then points from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
	</function>
	<function name="element-geospatial-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-geospatial-values">
		<summary>Returns values from the specified element geospatial value lexicon(s). Geospatial value lexicons are implemented using geospatial indexes; consequently this function requires an element geospatial index for each element specified in the function. If there is not a geospatial index configured for each of the specified elements, an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="start" type="cts:point?" optional="true">A starting value. If the parameter value is is not in the lexicon, then the values are returned beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"type=long-lat-point"</dt>
						<dd>Specifies the format for the point in the data as longitude first, latitude second.</dd>
						<dt>"type=point"</dt>
						<dd>Specifies the format for the point in the data as latitude first, longitude second. This is the default format.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:point* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:point*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-geospatial-values(xs:QName("point"),cts:point(0,0))
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</example>
	</function>
	<function name="element-child-geospatial-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-values">
		<summary>Returns values from the specified element-child geospatial value lexicon(s). Element-child geospatial value lexicons are implemented using geospatial indexes; consequently this function requires an element-child geospatial index of for each of the element/child pairs specified in the function. If there is not a range index configured for each of the specified element/child pairs, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="child-names" type="xs:QName*" optional="false">One or more child element QNames.</param>
			<param name="start" type="cts:point?" optional="true">A starting value. If the parameter value is is not in the lexicon, then the values are returned beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"type=long-lat-point"</dt>
						<dd>Specifies the format for the point in the data as longitude first, latitude second.</dd>
						<dt>"type=point"</dt>
						<dd>Specifies the format for the point in the data as latitude first, longitude second. This is the default format.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:point* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:point*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>When multiple element and/or child QNames are specified, then all possible element/child QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-child-geospatial-values(
     xs:QName("location"), xs:QName("position"), cts:point(0,0) )
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</example>
	</function>
	<function name="element-pair-geospatial-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-values">
		<summary>Returns values from the specified element-pair geospatial value lexicon(s). element-pair geospatial value lexicons are implemented using geospatial indexes; consequently this function requires an element-pair geospatial index of for each of the combinatation specified in the function. If there is not a geospatial index configured for each of the specified combinations, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-names" type="xs:QName*" optional="false">One or more latitude element QNames.</param>
			<param name="longitude-names" type="xs:QName*" optional="false">One or more longitude element QNames.</param>
			<param name="start" type="cts:point?" optional="true">A starting value. If the parameter value is is not in the lexicon, then the values are returned beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:point* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:point*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>When multiple element and/or child QNames are specified, then all possible element/child QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-pair-geospatial-values(
     xs:QName("location"), xs:QName("position"), cts:point(0,0) )
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</example>
	</function>
	<function name="element-attribute-pair-geospatial-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-values">
		<summary>Returns values from the specified element-attribute-pair geospatial value lexicon(s). element-attribute-pair geospatial value lexicons are implemented using geospatial indexes; consequently this function requires an element-attribute-pair geospatial index of for each of the combinatation specified in the function. If there is not a geospatial index configured for each of the specified combinations, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-names" type="xs:QName*" optional="false">One or more latitude element QNames.</param>
			<param name="longitude-names" type="xs:QName*" optional="false">One or more longitude element QNames.</param>
			<param name="start" type="cts:point?" optional="true">A starting value. If the parameter value is is not in the lexicon, then the values are returned beginning with the next value.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:point* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:point*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
			<p>When multiple element and/or child QNames are specified, then all possible element/child QName combinations are used to select the matching values.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-attribute-pair-geospatial-values(
     xs:QName("location"), xs:QName("position"), cts:point(0,0) )
  =&gt; (cts:point(0,0),cts:point(0,10),cts:point(0,20),...)
</example>
	</function>
	<function name="element-geospatial-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-geospatial-value-match">
		<summary>Returns values from the specified element geospatial value lexicon(s) that match the specified wildcard pattern. Element geospatial value lexicons are implemented using geospatial indexes; consequently this function requires an element geospatial index for each element specified in the function. If there is not a geospatial index configured for each of the specified elements, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="pattern" type="xs:anyAtomicType" optional="false">A pattern to match. The parameter type must match the lexicon type.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"type=long-lat-point"</dt>
						<dd>Specifies the format for the point in the data as longitude first, latitude second.</dd>
						<dt>"type=point"</dt>
						<dd>Specifies the format for the point in the data as latitude first, longitude second. This is the default format.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:point* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:point*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-geospatial-value-match(xs:QName("point"),cts:point(10,20))
  =&gt; 10,20
</example>
	</function>
	<function name="element-child-geospatial-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-child-geospatial-value-match">
		<summary>Returns values from the specified element child geospatial value lexicon(s) that match the specified wildcard pattern. Element child geospatial value lexicons are implemented using geospatial indexes; consequently this function requires an element child geospatial index for each element and child specified in the function. If there is not a geospatial index configured for each of the specified elements/child combinations, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="child-names" type="xs:QName*" optional="false">One or more child element QNames.</param>
			<param name="pattern" type="xs:anyAtomicType" optional="false">A pattern to match. The parameter type must match the lexicon type.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"type=long-lat-point"</dt>
						<dd>Specifies the format for the point in the data as longitude first, latitude second.</dd>
						<dt>"type=point"</dt>
						<dd>Specifies the format for the point in the data as latitude first, longitude second. This is the default format.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:point* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:point*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-child-geospatial-value-match(
     xs:QName("location"),xs:QName("pos"),cts:point(10,20))
  =&gt; 10,20
</example>
	</function>
	<function name="element-pair-geospatial-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-pair-geospatial-value-match">
		<summary>Returns values from the specified element pair geospatial value lexicon(s) that match the specified wildcard pattern. Element pair geospatial value lexicons are implemented using geospatial indexes; consequently this function requires an element pair geospatial index for each combination of elements specified in the function. If there is not a geospatial index configured for each of the specified combinations, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-names" type="xs:QName*" optional="false">One or more latitude element QNames.</param>
			<param name="longitude-names" type="xs:QName*" optional="false">One or more longitude element QNames.</param>
			<param name="pattern" type="xs:anyAtomicType" optional="false">A pattern to match. The parameter type must match the lexicon type.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:point* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:point*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-pair-geospatial-value-match(
     xs:QName("location"),xs:QName("lat"),xs:QName("long"),cts:point(10,20))
  =&gt; 10,20
</example>
	</function>
	<function name="element-attribute-pair-geospatial-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-pair-geospatial-value-match">
		<summary>Returns values from the specified element attribute pair geospatial value lexicon(s) that match the specified wildcard pattern. Element attribute pair geospatial value lexicons are implemented using geospatial indexes; consequently this function requires an element attribute pair geospatial index for each combination of elements and attributes specified in the function. If there is not a geospatial index configured for each of the specified combinations, then an exception is thrown.</summary>
		<params>
			<param name="element-names" type="xs:QName*" optional="false">One or more element QNames.</param>
			<param name="latitude-names" type="xs:QName*" optional="false">One or more latitude element QNames.</param>
			<param name="longitude-names" type="xs:QName*" optional="false">One or more longitude element QNames.</param>
			<param name="pattern" type="xs:anyAtomicType" optional="false">A pattern to match. The parameter type must match the lexicon type.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"ascending"</dt>
						<dd>Values should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Values should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Values from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Values from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Values from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Values from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Values should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Values should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included value. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>Use the lexicon with the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>values.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Values from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only values from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as a cts:point* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include values in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included values. The values do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>cts:point*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included values may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then values from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
		<example xml:space="preserve">
  cts:element-attribute-pair-geospatial-value-match(
     xs:QName("location"),xs:QName("lat"),xs:QName("long"),cts:point(10,20))
  =&gt; 10,20
</example>
	</function>
	<function name="element-value-geospatial-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-value-geospatial-co-occurrences">
		<summary>Returns value co-occurrences from the specified element value lexicon with the specified geospatial lexicon. Value lexicons are implemented using range indexes; consequently this function requires a range index for the element specified in the function. If there is not a range index configured for the specified element, then an exception is thrown. Geospatial lexicons are implemented using geospatial indexes; consequently this function requires a geospatial index for the element/attribute combination specified in the function. If there is not a geospatial index configured for the specified element/attribute combination, then an exception is thrown.</summary>
		<params>
			<param name="element-name-1" type="xs:QName" optional="false">An element QName.</param>
			<param name="geo-element-name" type="xs:QName" optional="false">An element QName.</param>
			<param name="child-name-1" type="xs:QName?" optional="false">An element or attribute QName or empty sequence. The empty sequence specifies an element geospatial lexicon.</param>
			<param name="child-name-2" type="xs:QName?" optional="false">An element or attribute QName or empty sequence. The empty sequence specifies either an element lexicon or an element-child geospatial lexicon.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"geospatial-format=
							<em>format</em>"</dt>
						<dd>Use the kind of geospatial lexicon specified by
							<em>format</em>(element, element-child, element-pair, or element-attribute-pair). If neither of the child QNames is specified, the default is "element"; if only the first of the child QNames is specified, the default is "element-child:; if both child QNames are specified, the default is "element-pair". If the selection is not compatible with the number of geospatial QNames specified, an error is raised.</dd>
						<dt>"ascending"</dt>
						<dd>Co-occurrences should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Co-occurrences should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Co-occurrences from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Co-occurrences from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Co-occurrences from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Co-occurrences from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Co-occurrences should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Co-occurrences should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included co-occurrences. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included co-occurrence. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>For the non-geospatial lexicon, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"type-2=
							<em>type</em>"</dt>
						<dd>For the geospatial lexicon, use the type specified by
							<em>type-2</em>(point or long-lat-point)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>For the non-geospatial lexicon, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>For the geospatial lexicons, use the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"ordered"</dt>
						<dd>Include co-occurrences only when the value from the first lexicon appears before the value from the second lexicon. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"reversed"</dt>
						<dd>Consider the second lexicon as the first and vice versa.</dd>
						<dt>"proximity=
							<em>N</em>"</dt>
						<dd>Include co-occurrences only when the values appear within
							<em>N</em>words of each other. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>co-occurrences.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Co-occurrences from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an element(cts:co-occurrence)* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include co-occurrences in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included co-occurrences. The co-occurrences do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:co-occurrence)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included co-occurrences may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then co-occurrences from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
	</function>
	<function name="element-attribute-value-geospatial-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:element-attribute-value-geospatial-co-occurrences">
		<summary>Returns value co-occurrences from the specified element-attribute value lexicon with the specified geospatial lexicon. Value lexicons are implemented using range indexes; consequently this function requires a range index for the element and attribute pair specified in the function. If there is not a range index configured for the specified element and attribute pair, then an exception is thrown. Geospatial lexicons are implemented using geospatial indexes; consequently this function requires a geospatial index for the element/attribute combination specified in the function. If there is not a geospatial index configured for the specified element/attribute combination, then an exception is thrown.</summary>
		<params>
			<param name="element-name-1" type="xs:QName" optional="false">An element QName.</param>
			<param name="attribute-name-1" type="xs:QName?" optional="false">An attribute QName.</param>
			<param name="geo-element-name" type="xs:QName" optional="false">An element QName.</param>
			<param name="child-name-1" type="xs:QName?" optional="false">An element or attribute QName or empty sequence. The empty sequence specifies an element geospatial lexicon.</param>
			<param name="child-name-2" type="xs:QName?" optional="false">An element or attribute QName or empty sequence. The empty sequence specifies either an element lexicon or an element-child geospatial lexicon.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"geospatial-format=
							<em>format</em>"</dt>
						<dd>Use the kind of geospatial lexicon specified by
							<em>format</em>(element, element-child, element-pair, or element-attribute-pair). If neither of the child QNames is specified, the default is "element"; if only the first of the child QNames is specified, the default is "element-child:; if both child QNames are specified, the default is "element-pair". If the selection is not compatible with the number of geospatial QNames specified, an error is raised.</dd>
						<dt>"ascending"</dt>
						<dd>Co-occurrences should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Co-occurrences should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Co-occurrences from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Co-occurrences from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Co-occurrences from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Co-occurrences from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Co-occurrences should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Co-occurrences should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included co-occurrences. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included co-occurrence. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"type=
							<em>type</em>"</dt>
						<dd>For the non-geospatial lexicon, use the type specified by
							<em>type</em>(int, unsignedInt, long, unsignedLong, float, double, decimal, dateTime, time, date, gYearMonth, gYear, gMonth, gDay, yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
						<dt>"collation=
							<em>URI</em>"</dt>
						<dd>For the non-geospatial lexicon, use the collation specified by
							<em>URI</em>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>For the geospatial lexicons, use the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"timezone=
							<em>TZ</em>"</dt>
						<dd>Return timezone sensitive values (dateTime, time, date, gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone specified by
							<em>TZ</em>. Example timezones: Z, -08:00, +01:00.</dd>
						<dt>"ordered"</dt>
						<dd>Include co-occurrences only when the value from the first lexicon appears before the value from the second lexicon. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"reversed"</dt>
						<dd>Consider the second lexicon as the first and vice versa.</dd>
						<dt>"proximity=
							<em>N</em>"</dt>
						<dd>Include co-occurrences only when the values appear within
							<em>N</em>words of each other. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>co-occurrences.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Co-occurrences from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an element(cts:co-occurrence)* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include co-occurrences in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included co-occurrences. The co-occurrences do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:co-occurrence)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "collation=
				<em>URI</em>" is not specified in the options parameter, then the default collation is used. If a lexicon with that collation does not exist, an error is thrown.</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included co-occurrences may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then co-occurrences from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
	</function>
	<function name="geospatial-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial Lexicon" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:geospatial-co-occurrences">
		<summary>Returns value co-occurrences from the geospatial lexicons. Geospatial lexicons are implemented using geospatial indexes; consequently this function requires a geospatial index for each combination of elements and attributes specified in the function. If there is not a geospatial index configured for the specified element/attribute combination, then an exception is thrown.</summary>
		<params>
			<param name="geo-element-name-1" type="xs:QName" optional="false">An element QName.</param>
			<param name="child-1-name-1" type="xs:QName?" optional="false">An element or attribute QName or empty sequence. The empty sequence specifies an element geospatial lexicon.</param>
			<param name="child-1-name-2" type="xs:QName?" optional="false">An element or attribute QName or empty sequence. The empty sequence specifies either an element lexicon or an element-child geospatial lexicon.</param>
			<param name="geo-element-name-2" type="xs:QName" optional="false">An element QName.</param>
			<param name="child-2-name-1" type="xs:QName?" optional="false">An element or attribute QName or empty sequence. The empty sequence specifies an element geospatial lexicon.</param>
			<param name="child-2-name-2" type="xs:QName?" optional="false">An element or attribute QName or empty sequence. The empty sequence specifies either an element lexicon or an element-child geospatial lexicon.</param>
			<param name="options" type="xs:string*" optional="true">Options. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"geospatial-format=
							<em>format</em>"</dt>
						<dd>For both geospatial lexicons, use the kind of geospatial lexicon specified by
							<em>format</em>(element, element-child, element-pair, or element-attribute-pair). If neither of the child QNames is specified, the default is "element"; if only the first of the child QNames is specified, the default is "element-child:; if both child QNames are specified, the default is "element-pair". If the selection is not compatible with the number of geospatial QNames specified, an error is raised.</dd>
						<dt>"geospatial-format-1=
							<em>format</em>"</dt>
						<dd>For the first geospatial lexicon, use the kind of geospatial lexicon specified by
							<em>format</em>(element, element-child, element-pair, or element-attribute-pair). If neither of the child QNames is specified, the default is "element"; if only the first of the child QNames is specified, the default is "element-child:; if both child QNames are specified, the default is "element-pair". If the selection is not compatible with the number of geospatial QNames specified, an error is raised.</dd>
						<dt>"geospatial-format-2=
							<em>format</em>"</dt>
						<dd>For the second geospatial lexicons, use the kind of geospatial lexicon specified by
							<em>format</em>(element, element-child, element-pair, or element-attribute-pair). If neither of the child QNames is specified, the default is "element"; if only the first of the child QNames is specified, the default is "element-child:; if both child QNames are specified, the default is "element-pair". If the selection is not compatible with the number of geospatial QNames specified, an error is raised.</dd>
						<dt>"ascending"</dt>
						<dd>Co-occurrences should be returned in ascending order.</dd>
						<dt>"descending"</dt>
						<dd>Co-occurrences should be returned in descending order.</dd>
						<dt>"any"</dt>
						<dd>Co-occurrences from any fragment should be included.</dd>
						<dt>"document"</dt>
						<dd>Co-occurrences from document fragments should be included.</dd>
						<dt>"properties"</dt>
						<dd>Co-occurrences from properties fragments should be included.</dd>
						<dt>"locks"</dt>
						<dd>Co-occurrences from locks fragments should be included.</dd>
						<dt>"frequency-order"</dt>
						<dd>Co-occurrences should be returned ordered by frequency.</dd>
						<dt>"item-order"</dt>
						<dd>Co-occurrences should be returned ordered by item.</dd>
						<dt>"fragment-frequency"</dt>
						<dd>Frequency should be the number of fragments with an included co-occurrences. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"item-frequency"</dt>
						<dd>Frequency should be the number of occurences of an included co-occurrence. This option is used with
							<code>cts:frequency</code>.</dd>
						<dt>"coordinate-system=
							<em>URI</em>"</dt>
						<dd>For both geospatial lexicons, use the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"coordinate-system-1=
							<em>URI</em>"</dt>
						<dd>For the first geospatial lexicon, use the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"coordinate-system-2=
							<em>URI</em>"</dt>
						<dd>For the second geospatial lexicons, use the coordinate system specified by
							<em>name</em>.</dd>
						<dt>"ordered"</dt>
						<dd>Include co-occurrences only when the value from the first lexicon appears before the value from the second lexicon. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"reversed"</dt>
						<dd>Consider the second lexicon as the first and vice versa.</dd>
						<dt>"proximity=
							<em>N</em>"</dt>
						<dd>Include co-occurrences only when the values appear within
							<em>N</em>words of each other. Requires that word positions be enabled for both lexicons.</dd>
						<dt>"limit=
							<em>N</em>"</dt>
						<dd>Return no more than
							<em>N</em>co-occurrences.</dd>
						<dt>"skip=
							<em>N</em>"</dt>
						<dd>Skip over fragments selected by the
							<code>cts:query</code>to treat the
							<em>Nth</em>matching fragment as the first fragment. Co-occurrences from skipped fragments are not included. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"sample=
							<em>N</em>"</dt>
						<dd>Return only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option does not affect the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"truncate=
							<em>N</em>"</dt>
						<dd>Include only co-occurrences from the first
							<em>N</em>fragments after skip selected by the
							<code>cts:query</code>. This option affects the number of fragments selected by the
							<code>cts:query</code>to calculate frequencies. Only applies when a
							<code>$query</code>parameter is specified.</dd>
						<dt>"score-logtfidf"</dt>
						<dd>Compute scores using the logtfidf method.</dd>
						<dt>"score-logtf"</dt>
						<dd>Compute scores using the logtf method.</dd>
						<dt>"score-simple"</dt>
						<dd>Compute scores using the simple method.</dd>
						<dt>"score-random"</dt>
						<dd>Compute scores using the random method.</dd>
						<dt>"checked"</dt>
						<dd>Word positions should be checked when resolving the query.</dd>
						<dt>"unchecked"</dt>
						<dd>Word positions should not be checked when resolving the query.</dd>
						<dt>"concurrent"</dt>
						<dd>Perform the work concurrently in another thread. This is a hint to the query optimizer to help parallelize the lexicon work, allowing the calling query to continue performing other work while the lexicon processing occurs. This is especially useful in cases where multiple lexicon calls occur in the same query (for example, resolving many facets in a single query).</dd>
						<dt>"map"</dt>
						<dd>Return results as a single map:map value instead of as an element(cts:co-occurrence)* sequence.</dd>
					</dl>
				</blockquote></param>
			<param name="query" type="cts:query?" optional="true">Only include co-occurrences in fragments selected by the
				<code>cts:query</code>, and compute frequencies from this set of included co-occurrences. The co-occurrences do not need to match the query, but they must occur in fragments selected by the query. The fragments are not filtered to ensure they match the query, but instead selected in the same manner as
				<a href="cts:search#unfiltered">"unfiltered"
					<code>cts:search</code></a>operations.</param>
			<param name="quality-weight" type="xs:double?" optional="true">A document quality weight to use when computing scores. The default is 1.0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">A sequence of IDs of forests to which the search will be constrained. An empty sequence means to search all forests in the database. The default is ().</param>
		</params>
		<return>element(cts:co-occurrence)*</return>
		<usage>
			<p>Only one of "frequency-order" or "item-order" may be specified in the options parameter. If neither "frequency-order" nor "item-order" is specified, then the default is "item-order".</p>
			<p>Only one of "fragment-frequency" or "item-frequency" may be specified in the options parameter. If neither "fragment-frequency" nor "item-frequency" is specified, then the default is "fragment-frequency".</p>
			<p>Only one of "ascending" or "descending" may be specified in the options parameter. If neither "ascending" nor "descending" is specified, then the default is "ascending" if "item-order" is specified, and "descending" if "frequency-order" is specified.</p>
			<p>Only one of "any", "document", "properties", or "locks" may be specified in the options parameter. If none of "any", "document", "properties", or "locks" are specified and there is a $query parameter, then the default is "document". If there is no $query parameter then the default is "any".</p>
			<p>Only one of the "score-logtfidf", "score-logtf", "score-simple", or "score-random" options may be specified in the options parameter. If none of "score-logtfidf", "score-logtf", "score-simple", or "score-random" are specified, then the default is "score-logtfidf".</p>
			<p>Only one of the "checked" or "unchecked" options may be specified in the options parameter. If neither "checked" nor "unchecked" are specified, then the default is "checked".</p>
			<p>If "coordinate-system=
				<em>name</em>" is not specified in the options parameter, then the default coordinate system is used. If a lexicon with that coordinate system does not exist, an error is thrown.</p>
			<p>If "sample=
				<em>N</em>" is not specfied in the options parameter, then all included co-occurrences may be returned. If a
				<code>$query</code>parameter is not present, then "sample=
				<em>N</em>" has no effect.</p>
			<p>If "truncate=
				<em>N</em>" is not specfied in the options parameter, then co-occurrences from all fragments selected by the
				<code>$query</code>parameter are included. If a
				<code>$query</code>parameter is not present, then "truncate=
				<em>N</em>" has no effect.</p>
		</usage>
	</function>
	<function name="distance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:distance">
		<summary>Returns the distance (in miles) between two points.</summary>
		<params>
			<param name="p1" type="cts:point" optional="false">The first point.</param>
			<param name="p2" type="cts:point" optional="false">The second point.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance is measured in miles.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
let $sf := cts:point(37, -122)
let $ny := cts:point(40, -73)
return
cts:distance($sf, $ny)

=&gt; 2626.42211914063
</example>
	</function>
	<function name="shortest-distance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:shortest-distance">
		<summary>Returns the great circle distance (in miles) between a point and an region. The region is defined by a
			<code>cts:region</code>.</summary>
		<params>
			<param name="p1" type="cts:point" optional="false">The first point.</param>
			<param name="region" type="cts:region+" optional="false">A region such as a circle, box, polygon, linestring, or complex-polygon. For compatibility with previous versions, a sequence of points is interpreted as a sequence of arcs (defined pairwise) and the distance returned is the shortest distance to one of those points. If the first parameter is a point within the region specified in this parameter, then
				<code>cts:shortest-distance</code>returns 0. If the point specified in the first parameter in not in the region specified in this parameter, then
				<code>cts:shortest-distance</code>returns the shortest distance to the boundary of the region.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance is measured in miles.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
cts:shortest-distance(
  cts:point(37.494965, -122.267654),
  cts:linestring((cts:point(40.720921, -74.008878),
                  cts:point(38.950224, -77.019714)))
)
=&gt; 2431.82739813132, which is the shortest distance (in miles)
   between San Carlos, CA and an arc between New York City and
   Washington DC.
</example>
	</function>
	<function name="bearing" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:bearing">
		<summary>Returns the true bearing in radians of the path from the first point to the second. An error is raised if the two points are the same.</summary>
		<params>
			<param name="p1" type="cts:point" optional="false">The first point.</param>
			<param name="p2" type="cts:point" optional="false">The second point.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
let $sf := cts:point(37, -122)
let $ny := cts:point(40, -73)
return
cts:bearing($sf, $ny)

=&gt; 1.22100904274442
</example>
	</function>
	<function name="destination" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:destination">
		<summary>Returns the point at the given distance (in miles) along the given bearing (in radians) from the starting point.</summary>
		<params>
			<param name="p" type="cts:point" optional="false">The starting point.</param>
			<param name="bearing" type="xs:double" optional="false">The bearing, in radians.</param>
			<param name="distance" type="xs:double" optional="false">The distance, in miles.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance is measured in miles.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>cts:point</return>
		<example xml:space="preserve">
let $sf := cts:point(37, -122)
let $ny := cts:point(40, -73)
return
cts:destination($sf,1.22100904274442,2626.42211914063)

=&gt;
</example>
	</function>
	<function name="arc-intersection" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:arc-intersection">
		<summary>Returns the point at the intersection of two arcs. If the arcs do not intersect, or lie on the same great circle, or if either arc covers more than 180 degrees, an error is raised.</summary>
		<params>
			<param name="p1" type="cts:point" optional="false">The starting point of the first arc.</param>
			<param name="p2" type="cts:point" optional="false">The ending point of the first arc.</param>
			<param name="q1" type="cts:point" optional="false">The starting point of the second arc.</param>
			<param name="q2" type="cts:point" optional="false">The ending point of the second arc.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>cts:point</return>
		<example xml:space="preserve">
let $sf := cts:point(37, -122)
let $ny := cts:point(40, -73)
let $a := cts:point(35,-100)
let $b := cts:point(41,-70)
return
cts:arc-intersection($sf,$ny,$a,$b)

=&gt; 40.458347,-76.203682
</example>
	</function>
	<function name="box-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:box-intersects">
		<summary>Returns true if the box intersects with a region.</summary>
		<params>
			<param name="box" type="cts:box" optional="false">A geographic box.</param>
			<param name="region" type="cts:region*" optional="false">One or more geographic regions (boxes, circles, polygons, or points). Where multiple regions are specified, return true if any region intersects the box.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">


</example>
	</function>
	<function name="circle-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:circle-intersects">
		<summary>Returns true if the circle intersects with a region.</summary>
		<params>
			<param name="circle" type="cts:circle" optional="false">A geographic circle.</param>
			<param name="region" type="cts:region*" optional="false">One or more geographic regions (boxes, circles, polygons, or points). Where multiple regions are specified, return true if any region intersects the target circle.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">


</example>
	</function>
	<function name="polygon-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:polygon-intersects">
		<summary>Returns true if the polygon intersects with a region.</summary>
		<params>
			<param name="polygon" type="cts:polygon" optional="false">A geographic polygon.</param>
			<param name="region" type="cts:region*" optional="false">One or more geographic regions (boxes, circles, polygons, or points). Where multiple regions are specified, return true if any region intersects the target polygon.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">


</example>
	</function>
	<function name="polygon-contains" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:polygon-contains">
		<summary>Returns true if the polygon contains a region.</summary>
		<params>
			<param name="polygon" type="cts:polygon" optional="false">A geographic polygon.</param>
			<param name="region" type="cts:region*" optional="false">One or more geographic regions (boxes, circles, polygons, or points). Where multiple regions are specified, return true if any region contains the target polygon.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">


</example>
	</function>
	<function name="complex-polygon-intersects" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:complex-polygon-intersects">
		<summary>Returns true if the complex-polygon intersects with a region.</summary>
		<params>
			<param name="complex-polygon" type="cts:complex-polygon" optional="false">A geographic complex-polygon.</param>
			<param name="region" type="cts:region*" optional="false">One or more geographic regions (boxes, circles, complex-polygons, or points). Where multiple regions are specified, return true if any region intersects the target complex-polygon.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and complex-polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and complex-polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">


</example>
	</function>
	<function name="complex-polygon-contains" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:complex-polygon-contains">
		<summary>Returns true if the complex-polygon contains a region.</summary>
		<params>
			<param name="complex-polygon" type="cts:complex-polygon" optional="false">A geographic complex polygon.</param>
			<param name="region" type="cts:region*" optional="false">One or more geographic regions (boxes, circles, polygons, or points). Where multiple regions are specified, return true if any region intersects the target polygon.</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and complex-polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and complex-polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
let $cp :=
  cts:complex-polygon(
    cts:polygon("0,0 10,0 10,10 0,10 0,0"),
    cts:polygon("5,0 7,0 7,5 5,5 5,0"))
let $poly :=
  cts:polygon("6,8 6.5,8 6.5,9 6,9 6,8")
return cts:complex-polygon-contains($cp, $poly)
(: returns true :)
</example>
	</function>
	<function name="bounding-boxes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:bounding-boxes">
		<summary>Returns a sequence of boxes that bound the given region.</summary>
		<params>
			<param name="region" type="cts:region" optional="false">A geographic region (box, circle, polygon, or point).</param>
			<param name="options" type="xs:string*" optional="true">Options for the operation. The default is ().
				<p>Options include:</p>
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<dt>"units=miles"</dt>
						<dd>Distance (for circles) is measured in miles.</dd>
						<dt>"box-percent=n"</dt>
						<dd>An integer between 0 and 100 (default is 100) that indicates what percentage of a polygon's bounding box slivers should be returned. Lower numbers give fewer, less accurate boxes; larger numbers give more, more accurate boxes.</dd>
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes', circles', and polygons' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>cts:box*</return>
		<example xml:space="preserve">
cts:bounding-boxes(
  cts:polygon("0,0 20,20 -10,18 5,5 0,0")
)
(: Returns two boxes:
   [-10, 0, 5, 18.976505]
   [5, 4.7157488, 20, 20]
:)
;
cts:bounding-boxes(
  cts:polygon("0,0 20,20 -10,18 5,5 0,0"),
  "box-percent=50"
)
(: Returns one box:
   [-10, 0, 20, 20]
:)
</example>
	</function>
	<function name="parse-wkt" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:parse-wkt">
		<summary>Returns a sequence of geospatial regions parsed from Well-Known Text format.</summary>
		<params>
			<param name="wtk" type="xs:string*" optional="false">A sequence of strings in Well-Known Text format.</param>
		</params>
		<return>cts:region*</return>
		<example xml:space="preserve">


</example>
	</function>
	<function name="to-wkt" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Geospatial" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:to-wkt">
		<summary>Returns a sequence of strings in Well-Known Text format.</summary>
		<params>
			<param name="wtk" type="cts:region*" optional="false">A sequence of geospatial regions.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

cts:to-wkt(cts:point(36, 71))
=&gt;
POINT(71 36)
</example>
	</function>
	<function name="train" type="builtin" lib="cts" category="Classifier" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:train">
		<summary>Produces a set of classifiers from a list of labeled training documents.</summary>
		<params>
			<param name="training-nodes" type="node()*" optional="false">The sequence of training nodes. These are nodes that represent members of the classes.</param>
			<param name="labels" type="element(cts:label)*" optional="false">A sequence of labels for the training nodes, in the order corresponding to the training nodes.</param>
			<param name="options" type="element()?" optional="true">An XML representation of the options for defining the training parameters. The options node must be in the
				<code>cts:train</code>namespace. The following is a sample options node:
				<pre xml:space="preserve">
    &lt;options xmlns="cts:train"&gt;
      &lt;classifier-type&gt;supports&lt;/classifier-type&gt;
      &lt;kernel&gt;geodesic&lt;/kernel&gt;
    &lt;/options&gt;
</pre>
				<p>The
					<code>cts:train</code>options include:</p>
				<dl>
					<dt>
						<p>&lt;
							<code>classifier-type</code>&gt;</p>
					</dt>
					<dd>A string defining the kind of classifier to produce, either
						<code>weights</code>or
						<code>supports</code>. The default is
						<code>weights</code>.</dd>
					<dt>
						<p>&lt;
							<code>kernel</code>&gt;</p>
					</dt>
					<dd>A string defining which function to use for comparing documents. The default is
						<code>sqrt</code>. Normalization (the values that end in
						<code>-normalized</code>) brings document vectors into the unit sphere, which may improve the mathematical properties of the calculations. Possible values are:
						<dl>
							<dt>
								<p>
									<code>simple</code>
								</p>
							</dt>
							<dd>Model documents as 1 or 0 for presence or absence of each term.</dd>
							<dt>
								<p>
									<code>simple-normalized</code>
								</p>
							</dt>
							<dd>Like
								<code>simple</code>, but normalized by square root of document length.</dd>
							<dt>
								<p>
									<code>sqrt</code>
								</p>
							</dt>
							<dd>Model documents using the square root of the term frequencies.</dd>
							<dt>
								<p>
									<code>sqrt-normalized</code>
								</p>
							</dt>
							<dd>Like
								<code>sqrt</code>, but normalized by the sum of the term frequencies.</dd>
							<dt>
								<p>
									<code>linear-normalized</code>
								</p>
							</dt>
							<dd>Model documents as the term frequencies normalized by the square root of the sum of the squares of the term frequencies.</dd>
							<dt>
								<p>
									<code>gaussian</code>
								</p>
							</dt>
							<dd>Compare documents using the Gaussian of the term frequencies. Requires a
								<code>classifier-type</code>of
								<code>supports</code>.</dd>
							<dt>
								<p>
									<code>geodesic</code>
								</p>
							</dt>
							<dd>Compare documents using the Riemann geodesic distance over term frequencies. Requires a
								<code>classifier-type</code>of
								<code>supports</code>.</dd>
						</dl></dd>
					<dt>
						<p>&lt;
							<code>max-terms</code>&gt;</p>
					</dt>
					<dd>An integer defining the maximum number of terms to use to represent each document. If a positive number M is given, then the M most discriminating terms are used; other terms are dropped. The default is 0 (unlimited).</dd>
					<dt>
						<p>&lt;
							<code>max-support</code>&gt;</p>
					</dt>
					<dd>A double specifying the maximum influence a single training node can have. This parameter has a strong influence on performance. The default value of 1.0 should work well in most cases. Larger values means greater sensitivity and may improve accuracy on small datasets, but give longer running times. Smaller values mean less sensitivity and better resistance to mis-classified documents, and shorter running times.</dd>
					<dt>
						<p>&lt;
							<code>min-weight</code>&gt;</p>
					</dt>
					<dd>A double specifying the minimum weight a term can have and still be considered for inclusion in the term vector. This parameter only applies to the term weight form of the classifier. Smaller values mean longer term vectors and as a consequence longer running times and greater memory consumption during classification, but may also improve accuracy. The default is is 0.01.</dd>
					<dt>
						<p>&lt;
							<code>tolerance</code>&gt;</p>
					</dt>
					<dd>How close the final solutions to the constraint equations must be. Smaller values lead to a greater number of iterations and longer running times. Larger values lead to less precise classification. The default is 0.01.</dd>
					<dt>
						<p>&lt;
							<code>epsilon</code>&gt;</p>
					</dt>
					<dd>How close a value must be to 0 to be counted as equal to 0. Since double arithmetic is not precise, setting this value to exactly 0 will likely lead to non-convergence of the algorithm. Smaller values lead to a greater number of iterations and longer running times. Larger values lead to less precise classification. The default is 0.01.</dd>
					<dt>
						<p>&lt;
							<code>max-iterations</code>&gt;</p>
					</dt>
					<dd>The maximum number of iterations of the constraint satisfaction algorithm to run. The algorithm usually converges very quickly, so this parameter usually has no effect unless it is set very low. The default is 500.</dd>
					<dt>
						<p>
							<code>&lt;thresholds&gt;</code>
						</p>
					</dt>
					<dd>A definition of the thresholds to use in classification. This is a complex element with one or more
						<code>&lt;threshold&gt;</code>children. You can specify both a global value and per-class values (as computed from
						<code>cts:thresholds</code>). The global value will apply to any classes for which a per-class value is not specified. For example:
						<pre xml:space="preserve">
    &lt;options xmlns="cts:train"&gt;
      &lt;thresholds&gt;
        &lt;threshold&gt;-1.0&lt;/threshold&gt;
        &lt;threshold class="Example 1"&gt;-2.42&lt;/threshold&gt;
      &lt;/thresholds&gt;
    &lt;/options&gt;

</pre>
						<p>For the initial tuning phase of training your data, leave the value of this parameter at its default value which is a very large negative number (-10E30). This will allow you to accurately compute the threshold values when you run
							<code>cts:thresholds</code>on the initial training data. Then you can use the calculated thresholds values when you run the secondary pass through the second part of your training data.</p></dd>
					<dt>
						<p>&lt;
							<code>use-db-config</code>&gt;</p>
					</dt>
					<dd>A boolean value indicating whether to use the current DB configuration for determining which terms to use. The default is
						<code>false</code>, which means that only the indexing options in the options node will be used for calculating the classifier.</dd>
				</dl>
				<p>The options element also includes indexing options in the
					<code>http://marklogic.com/xdmp/database</code>namespace. These control which terms to use. Note that the use of certain options, such as
					<code>fast-case-sensitive-searches</code>, will not impact final results unless the term vector size is limited with the
					<code>max-terms</code>option. Other options, such as
					<code>phrase-throughs</code>, will only generate terms if some other option is also enabled (in this case
					<code>fast-phrase-searches</code>).</p>
				<p>The database options are the same as the database options shown for
					<a href="cts:distinctive-terms#db-term-options">
						<code>cts:distinctive-terms</code>
					</a>.</p></param>
		</params>
		<return>element(cts:classifier)?</return>
		<usage>
			<p>The elements in the label sequence should match one for one with the nodes in the training node sequence. The first label element describes the first node in the training node sequence, the second label element describes the second node in the training node sequence, and so on. If there are more labels than training nodes or more training nodes than labels, an error is raised.</p>
			<p>The format of each label element is:</p>
			<pre xml:space="preserve">
  &lt;cts:label name="Node1"&gt;
    &lt;cts:class name="Example1"/&gt;
    &lt;cts:class name="Example2" val="-1"/&gt;
        :   :
  &lt;/cts:label&gt;
</pre>
			<p>Each class listed indicates whether the corresponding node in the training sequence is in the given class. Examples are taken to be positive examples unless specified otherwise (with a
				<code>val</code>attribute of -1). The document is assumed to be a negative example of any classes that are not explicitly listed. The name attribute on the label element is an optional name for the labelled node. It is purely for human consumption to help in tuning the classification parameters.</p>
			<a id="outputformats">
				<b>Output Formats</b>
			</a>
			<p>A linear classifier is defined by a weight vector w on terms, and an offset value b. The &lt;weights/&gt; node encodes the weight vector directly. Its children are the classes, and each class includes a list of terms. The term node uses an internal id to identify the term and a term weight:</p>
			<pre xml:space="preserve">
&lt;weights&gt;
  &lt;class name="Example1" offset="2.04"&gt;
    &lt;term id="43587329645324245" val="0.3423432"/&gt;
    &lt;term id="47893427895432534" val="-0.12345556"/&gt;
      :                           :
  &lt;/class&gt;
      :
&lt;/weights&gt;
</pre>
			<p>The weight vector w is a linear combination of the documents themselves, and it may be more convenient to express the classifier in this way. For instance, if the number of terms is not limited, the &lt;weights/&gt; node will be extremely large. The weight vector form may not be used if the classifier kernel is non-linear, that is, with the Gaussian or geodesic kernel.</p>
			<p>The support vector representation of the classifier includes a supports node that has &lt;class/&gt; children for each class. Here the class elements contain a list of doc elements which identify the specific training nodes using an internal key. This internal key is valid across queries only for nodes in the database. Each doc element has an attribute encoding the weight of that document and an error attribute which shows how well the document fit the classifier. Large positive or negative errors (greater than about 1.5) are potentially mis-classified documents.</p>
			<pre xml:space="preserve">
&lt;supports&gt;
  &lt;class name="Example1" offset="2.04"&gt;
    &lt;doc id="155584958759" name="Node102" val="-0.00334163" err="1.4"/&gt;
    &lt;doc id="594064848864" name="Node57" val="0.025341234" err="-2.3"/&gt;
      :                             :
  &lt;/class&gt;
      :
&lt;/supports&gt;
</pre>
			<p>Each class is identified by a unique name.</p>
		</usage>
		<example xml:space="preserve">
let $firsthalf := xdmp:directory("/shakespeare/plays/", "1")[1 to 19]
let $labels := for $x in $firsthalf
         return
         &lt;cts:label&gt;
           &lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
                //playtype/text()}/&gt;
          &lt;/cts:label&gt;
return
cts:train($firsthalf, $labels,
       &lt;options xmlns="cts:train"&gt;
         &lt;classifier-type&gt;supports&lt;/classifier-type&gt;
       &lt;/options&gt;)

  =&gt;  &lt;cts:classifier&gt;...


</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

(:
   this is the same as the previous example, except it uses the
   use-db-config option
:)
let $firsthalf :=
  xdmp:directory("/shakespeare/plays/", "1")[1 to 19]
let $labels := for $x in $firsthalf
         return
         &lt;cts:label&gt;
           &lt;cts:class name={xdmp:document-properties(
                                       xdmp:node-uri($x))
                //playtype/text()}/&gt;
          &lt;/cts:label&gt;
return
cts:train($firsthalf, $labels,
       &lt;options xmlns="cts:train"&gt;
         &lt;classifier-type&gt;supports&lt;/classifier-type&gt;
         &lt;use-db-config&gt;true&lt;/use-db-config&gt;
       &lt;/options&gt;)

  =&gt;  &lt;cts:classifier&gt;...


</example>
	</function>
	<function name="classify" type="builtin" lib="cts" category="Classifier" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:classify">
		<summary>Classifies a sequence of nodes based on training data. The training data is in the form of a classifier specification, which is generated from the output of
			<code>cts:train</code>. Returns labels for each of the input documents in the same order as the input document.</summary>
		<params>
			<param name="data-nodes" type="node()*" optional="false">The sequence of nodes to be classified.</param>
			<param name="classifier" type="element(cts:classifier)" optional="false">An element node containing the classifier specification. This is typically the output of
				<code>cts:train</code>, either run directly or saved in an XML document in the database.</param>
			<param name="options" type="element()?" optional="false">
				<p>An options element. The options for classification are passed automatically from
					<code>cts:train</code>to the
					<code>cts:classifier</code>specification as part of the classifier element so that they are consistent with the parameters used in training. The following option may be separately passed to
					<code>cts:classify</code>and is in the
					<code>cts:classify</code>namespace:</p>
				<dl>
					<dt>
						<p>
							<code>&lt;thresholds&gt;</code>
						</p>
					</dt>
					<dd>A definition of the thresholds to use in classification. This is a complex element with one or more
						<code>&lt;threshold&gt;</code>children. You can specify both a global value and per-class values (as computed from
						<code>cts:thresholds</code>). The global value will apply to any classes for which a per-class value is not specified. For example:
						<pre xml:space="preserve">
   &lt;options xmlns="cts:classify"&gt;
     &lt;thresholds&gt;
       &lt;threshold&gt;-1.0&lt;/threshold&gt;
       &lt;threshold class="Example 1"&gt;-2.42&lt;/threshold&gt;
     &lt;/thresholds&gt;
   &lt;/options&gt;

</pre></dd>
				</dl>
			</param>
			<param name="training-nodes" type="node()*" optional="false">The sequence of training nodes used to train the classifier. Required if the
				<code>supports</code>form of the classifier is used; ignored if the
				<code>weights</code>form of the classifier is used.</param>
		</params>
		<return>element(cts:label)*</return>
		<usage>
			<p>
				<code>cts:classify</code>classifies a sequence of nodes using the output from
				<code>cts:train</code>. The
				<code>$data-nodes</code>and
				<code>$classifier</code>parameters are respectively the nodes to be classified and the specification output from
				<code>cts:train</code>.
				<code>cts:classify</code>can use either
				<code>supports</code>or
				<code>weights</code>forms of the
				<code>$classifier</code>output from
				<code>cts:train</code>(see
				<a href="#outputformats">Output Formats</a>). If the
				<code>supports</code>form is used, the training nodes must be passed as the 4th parameter. The
				<code>$options</code>parameter is an options element in the
				<code>cts:classify</code>namespace.</p>
			<p>The output is a sequence of label elements of the form:</p>
			<pre xml:space="preserve">
&lt;cts:label&gt;
  &lt;cts:class name="Example 1" val="-0.003"/&gt;
  &lt;cts:class name="Example 2" val="1.4556"/&gt;
  ...
&lt;/cts:label&gt;
</pre>
			<p>Each label corresponds to the data node in the corresponding position in the input sequence. There will be a
				<code>&lt;class&gt;</code>child for each class where the document passed the class threshold. The
				<code>val</code>attribute gives the class membership value for the data node in the given class. Values greater than zero indicate likely class membership, values less than zero indicate likely non-membership. Adjusting thresholds can give more or less selective classification. Increasing the threshold leads to a more selective classification (that is, decreases the likelihood of classification in the class). Decreasing the threshold gives less selective classification.</p>
		</usage>
		<example xml:space="preserve">
let $firsthalf := xdmp:directory("/shakespeare/plays/", "1")[1 to 19]
let $secondhalf := xdmp:directory("/shakespeare/plays/", "1")[20 to 37]
let $classifier :=
  let $labels := for $x in $firsthalf
         return
         &lt;cts:label&gt;
           &lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
                 //playtype/text()}/&gt;
         &lt;/cts:label&gt;
  return
  cts:train($firsthalf, $labels,
          &lt;options xmlns="cts:train"&gt;
            &lt;classifier-type&gt;supports&lt;/classifier-type&gt;
          &lt;/options&gt;)
return
cts:classify($secondhalf, $classifier,
             &lt;options xmlns="cts:classify"/&gt;,
             $firsthalf)

  =&gt; ( &lt;label&gt;...&lt;/label&gt;,... )


</example>
	</function>
	<function name="thresholds" type="builtin" lib="cts" category="Classifier" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:thresholds">
		<summary>Compute precision, recall, the F measure, and thresholds for the classes computed by the classifier, by comparing with the labels for the same set.</summary>
		<params>
			<param name="computed-labels" type="element(cts:label)*" optional="false">A sequence of element nodes containing the labels from classification (the output from
				<code>cts:classify</code>) for a set of documents.</param>
			<param name="known-labels" type="element(cts:label)*" optional="false">A sequence of element nodes containing the known labels for the same set of documents.</param>
			<param name="recall-weight" type="xs:double?" optional="true">The factor to use in the calculation of the F measure. The number should be non-negative. A value of 0 means F is just precision and a value of +INF means F is just recall. The default is 1, which gives the harmonic mean between precision and recall.</param>
		</params>
		<return>element(cts:thresholds)?</return>
		<usage>
			<p>You use the output of
				<code>cts:thresholds</code>to determine the best thresholds values for your data, based on the first pass through the first part of your training data. The output of
				<code>cts:thresholds</code>provides you with precision and recall measurements at the calculated thresholds for each class. The following are the definitions of the attributes of the
				<code>thresholds</code>element returned by
				<code>cts:thresholds</code>:</p>
			<dl>
				<dt>
					<p>
						<code>name</code>
					</p>
				</dt>
				<dd>The name of the class.</dd>
				<dt>
					<p>
						<code>threshold</code>
					</p>
				</dt>
				<dd>The threshold that is computed by the classifier to give the best results. The threshold is used by
					<code>cts:classify</code>when classifying documents, and is defined to be the positive or negative distance from the hyperplane which represents the edge of the class.</dd>
				<dt>
					<p>
						<code>precision</code>
					</p>
				</dt>
				<dd>A number which represents the fraction of nodes identified in a class that are actually in that class. As this aproaches 1, there is a higher probability that you over-classified.</dd>
				<dt>
					<p>
						<code>recall</code>
					</p>
				</dt>
				<dd>A number which represents the the fraction of nodes in a class that were identified by the classifier as being in that class. As this aproaches 1, there is a higher probability that you under-classified.</dd>
				<dt>
					<p>
						<code>F</code>(the F-measure)</p>
				</dt>
				<dd>A measure which represents if the classification at the given threshold is closer to recall or closer to precision. A value of 1 indicates that precision and recall have equal weight. A value of 0.5 indicates that precision is weighted 2x recall. A value of 2 indicates that recall is weighted 2x prcision. A value of 0 indicates that the weighting is precision only, and a value of +INF (
					<code>xs:double('+INF')</code>) indicates that weighting is recall only.</dd>
			</dl>
		</usage>
		<example xml:space="preserve">
let $firsthalf := xdmp:directory("/shakespeare/plays/", "1")[1 to 19]
let $secondhalf := xdmp:directory("/shakespeare/plays/", "1")[20 to 37]
let $firstlabels := for $x in $firsthalf
        return
        &lt;cts:label&gt;
          &lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
                                     //playtype/text()}/&gt;
        &lt;/cts:label&gt;
let $secondlabels := for $x in $secondhalf
        return
        &lt;cts:label&gt;
          &lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
                                     //playtype/text()}/&gt;
        &lt;/cts:label&gt;
let $classifier :=
    cts:train($firsthalf, $firstlabels,
      &lt;options xmlns="cts:train"&gt;
        &lt;classifier-type&gt;supports&lt;/classifier-type&gt;
      &lt;/options&gt;)
let $classifysecond :=
  cts:classify($secondhalf, $classifier,
        &lt;options xmlns="cts:classify"/&gt;,
        $firsthalf)
return
cts:thresholds($classifysecond, $secondlabels)
(:
   This returns the computed thresholds for the second half of
   the plays in a Shakespeare database, based on a classifier
   trained with the first half of the plays.  For example:

&lt;thresholds xmlns="http://marklogic.com/cts"&gt;
  &lt;class name="TRAGEDY" threshold="0.221948" precision="1"
         recall="0.666667" f="0.8" count="3"/&gt;
  &lt;class name="COMEDY" threshold="0.114389" precision="0.916667"
         recall="1" f="0.956522" count="11"/&gt;
  &lt;class name="HISTORY" threshold="0.567648" precision="1"
         recall="1" f="1" count="4"/&gt;
&lt;/thresholds&gt;
:)
</example>
	</function>
	<function name="cluster" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search Clustering" hidden="false" bucket="MarkLogic Built-In Functions" fullname="cts:cluster">
		<summary>Produces a set of clusters from a sequence of nodes. The nodes can be any set of nodes, and are typically the result of a
			<code>cts:search</code>operation.</summary>
		<params>
			<param name="nodes" type="node()*" optional="false">The sequence of nodes to cluster.</param>
			<param name="options" type="element()?" optional="true">An XML representation of the options for defining the clustering parameters. The options node must be in the
				<code>cts:cluster</code>namespace. The following is a sample options node:
				<pre xml:space="preserve">
    &lt;options xmlns="cts:cluster"&gt;
      &lt;label-max-terms&gt;4&lt;/label-max-terms&gt;
      &lt;max-clusters&gt;6&lt;/max-clusters&gt;
      &lt;use-db-config&gt;true&lt;/use-db-config&gt;
    &lt;/options&gt;
</pre>
				<!-- Not documented on purpose:
         initialization, k-threshold, score -->
				<p>The
					<code>cts:cluster</code>options include:</p>
				<pre xml:space="preserve">
       &lt;xs:element ref="opt:overlapping"/&gt;
       &lt;xs:element ref="opt:max-terms"/&gt;

</pre>
				<dl>
					<dt>
						<p>&lt;
							<code>hierarchical-levels</code>&gt;</p>
					</dt>
					<dd>An integer specifying how many hierarchical cluster levels the clusterer should return. The default is
						<code>1</code>, which means no hierarchical clusters are returned.</dd>
					<dt>
						<p>&lt;
							<code>label-max-terms</code>&gt;</p>
					</dt>
					<dd>An integer specifying the maximum number of terms to use in constructing a cluster label. The default is
						<code>3</code>.</dd>
					<dt>
						<p>&lt;
							<code>label-ignore-words</code>&gt;</p>
					</dt>
					<dd>A space-separated list of words that are to be excluded from cluster label. The default is to not exclude any words.</dd>
					<dt>
						<p>&lt;
							<code>label-ignore-attributes</code>&gt;</p>
					</dt>
					<dd>A boolean that indicates whether attribute terms should be excluded from the cluster label. The default is to include terms from attributes.</dd>
					<dt>
						<p>&lt;
							<code>details</code>&gt;</p>
					</dt>
					<dd>A boolean that indicates whether additional details on the terms used in label generation are to be included in the output. See the documentation on cts:distinctive-terms for details on the format of the terms returned. The default
						<code>false</code>, meaning no such details are given.</dd>
					<dt>
						<p>&lt;
							<code>min-clusters</code>&gt;</p>
					</dt>
					<dd>An integer specifying a minimum number of desired clusters returned (at any hierarchical level). However, if no satisfactory clustering can be produced at a given level, only one cluster will be returned, regardless of this setting. The default is
						<code>3</code>.</dd>
					<dt>
						<p>&lt;
							<code>max-clusters</code>&gt;</p>
					</dt>
					<dd>An integer specifying a maximum number of clusters that can be returned (at any hierarchical level). The default is
						<code>15</code>.</dd>
					<dt>
						<p>&lt;
							<code>overlapping</code>&gt;</p>
					</dt>
					<dd>A boolean indicating whether it is acceptable for nodes to be assigned to more than one cluster. The default is
						<code>false</code>.</dd>
					<dt>
						<p>&lt;
							<code>max-terms</code>&gt;</p>
					</dt>
					<dd>An integer value specifying the maximum number of distinct terms to use in calculating the cluster. The default is
						<code>200</code>. Increasing the value will increase the cost (in terms of both time and memory) of calculating the clusters, but may improve the quality of the clusters.</dd>
					<dt>
						<p>&lt;
							<code>algorithm</code>&gt;</p>
					</dt>
					<dd>A value indicating which clustering algorithm to use, either
						<code>k-means</code>or
						<code>lsi</code>. The default is
						<code>k-means</code>. The LSI algorithm is significantly more expensive to compute, both in terms of time and space.</dd>
					<dt>
						<p>&lt;
							<code>num-tries</code>&gt;</p>
					</dt>
					<dd>Specifies the number of times to run the clusterer against the specified data. The default is 1. Because of the way the algorithms work, running the cluster multiple times will increase the number of terms, and tends to improve the accuratacy of the clusters. It does so at the cost of performance, as each time it runs, it has to do more work.</dd>
					<dt>
						<p>&lt;
							<code>use-db-config</code>&gt;</p>
					</dt>
					<dd>A boolean value indicating whether to use the current DB configuration for determining which terms to use. The default is
						<code>false</code>, which means that the default set of options, as well as any indexing options you specify in the options node, will be used for calculating the clusters and their labels. When set to
						<code>true</code>, any indexing options set in the context database configuration (including any field settings) are used, as well as any default settings that you have not explicitly turned off in the options node.</dd>
				</dl>
				<p>The options element also includes indexing options in the
					<code>http://marklogic.com/xdmp/database</code>namespace. These control which terms to use. Note that the use of certain options, such as
					<code>fast-case-sensitive-searches</code>, will not impact final results unless the term vector size is limited with the
					<code>max-terms</code>option. Other options, such as
					<code>phrase-throughs</code>, will only generate terms if some other option is also enabled (in this case
					<code>fast-phrase-searches</code>).</p>
				<p>The database options are the same as the database options shown for
					<a href="cts:distinctive-terms#db-term-options">
						<code>cts:distinctive-terms</code>
					</a>.</p></param>
		</params>
		<return>element(cts:clustering)</return>
		<example xml:space="preserve">

cts:cluster(
  cts:search(//MILITARY, cts:word-query("apache"))[1 to 100],
  &lt;options xmlns="cts:cluster" xmlns:db="http://marklogic.com/xdmp/database"&gt;
    &lt;hierarchical-levels&gt;2&lt;/hierarchical-levels&gt;
    &lt;overlapping&gt;false&lt;/overlapping&gt;
    &lt;label-max-terms&gt;3&lt;/label-max-terms&gt;
    &lt;max-clusters&gt;100&lt;/max-clusters&gt;
    &lt;label-ignore-words&gt;of the on in at a an for from by and&lt;/label-ignore-words&gt;
    &lt;db:stemmed-searches&gt;advanced&lt;/db:stemmed-searches&gt;
    &lt;db:fast-phrase-searches&gt;true&lt;/db:fast-phrase-searches&gt;
    &lt;db:fast-element-word-searches&gt;true&lt;/db:fast-element-word-searches&gt;
    &lt;db:fast-element-phrase-searches&gt;true&lt;/db:fast-element-phrase-searches&gt;
  &lt;/options&gt;)
==&gt;
 &lt;clustering xmlns="http://marklogic.com/cts"&gt;
  &lt;cluster id="123456" label="apache helicopters" count="7" nodes="3 34 31 98 34 23 39"/&gt;
  &lt;cluster id="374632" label="apache linux" count="6" nodes="1 378 56 23 93 6"/&gt;
  &lt;cluster id="3452231" label="navajo codetalkers" count="8" nodes="44 87 32 77 50 12 13 15"/&gt;
  ...
  &lt;cluster id="2234" parent="123456" label="AH-64" count="2" nodes="3 39"/&gt;
  &lt;cluster id="34321" parent="123456" label="air force" count="5" nodes="34 31 98 34 23"/&gt;
  &lt;cluster id="34523" parent="374632" label="HTTP" count="3" nodes="1 56 23"/&gt;
  &lt;cluster id="968" parent="374632" label="LAMP" count="3" nodes="378 93 6"/&gt;
  &lt;options xmlns="cts:cluster" xmlns:db="http://marklogic.com/xdmp/database"&gt;
    &lt;algorithm&gt;k-means&lt;/algorithm&gt;
    &lt;db:stemmed-searches&gt;advanced&lt;/db:stemmed-searches&gt;
    &lt;db:fast-element-word-searches&gt;true&lt;/db:fast-element-word-searches&gt;
    &lt;db:fast-element-phrase-searches&gt;true&lt;/db:fast-element-phrase-searches&gt;
    &lt;db:language&gt;en&lt;/db:language&gt;
    &lt;max-clusters&gt;100&lt;/max-clusters&gt;
    &lt;min-clusters&gt;2&lt;/min-clusters&gt;
    &lt;hierarchical-levels&gt;2&lt;/hierarchical-levels&gt;
    &lt;initialization&gt;smart&lt;/initialization&gt;
    &lt;label-max-terms&gt;3&lt;/label-max-terms&gt;
    &lt;num-tries&gt;1&lt;/num-tries&gt;
    &lt;score&gt;logtfidf&lt;/score&gt;
    &lt;use-db-config&gt;false&lt;/use-db-config&gt;
  &lt;/options&gt;
&lt;/clustering&gt;


</example>
    <example xml:space="preserve">
cts:cluster(
   cts:search(//function, "foo"),
   &lt;options xmlns="cts:cluster"&gt;
     &lt;use-db-config&gt;true&lt;/use-db-config&gt;
   &lt;/options&gt;)
=&gt; The cts:clustering element


</example>
	</function>
	<function name="basepath" type="convert" lib="cvt" category="Generic Conversion" bucket="CPF Functions" hidden="false" fullname="cvt:basepath">
		<summary>Return the base path of the URI, cutting off the filename.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to manipulate.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cvt = "http://marklogic.com/cpf/convert"
	         at "/MarkLogic/conversion/convert.xqy";

  cvt:basepath( "http://example.com/a.path/myfile.doc" )

  =&gt; "http://example.com/a.path"

</example>
	</function>
	<function name="basename" type="convert" lib="cvt" category="Generic Conversion" bucket="CPF Functions" hidden="false" fullname="cvt:basename">
		<summary>Return the filename part of the URI, cutting off any query strings or fragments.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to manipulate.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cvt = "http://marklogic.com/cpf/convert"
	         at "/MarkLogic/conversion/convert.xqy";

  cvt:basename( "http://example.com/a.path/myfile.doc" )

  =&gt; "myfile.doc"

</example>
	</function>
	<function name="destination-uri" type="convert" lib="cvt" category="Generic Conversion" bucket="CPF Functions" hidden="false" fullname="cvt:destination-uri">
		<summary>Construct the destination URI from the source URI using the following rules: The path prefix of the destination URI is the same as the source URI's. The filename in the destination maps '.' to '_' and appends the given extension.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to manipulate.</param>
			<param name="extension" type="xs:string" optional="false">The extension to add, such as ".xml"</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cvt = "http://marklogic.com/cpf/convert"
	         at "/MarkLogic/conversion/convert.xqy";

  cvt:destination-uri("http://example.com/a.path/myfile.doc", ".xml")

  =&gt; "http://example.com/a.path/myfile_doc.xml"

</example>
	</function>
	<function name="part-uri" type="convert" lib="cvt" category="Generic Conversion" bucket="CPF Functions" hidden="false" fullname="cvt:part-uri">
		<summary>Construct the URI for the part using the following rules: The path prefix of the part URI is the same source URI's, followed by a subdirectory name. The subdirectory name is formed by mapping '.' to '_' in the source filename and appending '_parts' to it. The part's filename is unchanged, but any part path is removed.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to manipulate.</param>
			<param name="part" type="xs:string" optional="false">The part to append to the URI. Only the filename is appended; any subdirectories preceding the filename are removed.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cvt = "http://marklogic.com/cpf/convert"
	         at "/MarkLogic/conversion/convert.xqy";

  cvt:part-uri("http://example.com/a.path/myfile.doc",
               "images/image1.jpg")

  =&gt; "http://example.com/a.path/myfile_doc_parts/image1.jpg"

</example>
	</function>
	<function name="save-converted-documents" type="convert" lib="cvt" category="Generic Conversion" bucket="CPF Functions" hidden="false" fullname="cvt:save-converted-documents">
		<summary>Save a set of converted documents, with appropriate links. If there is a main document, it must be the first listed in the manifest. The order in the manifest (as in xdmp:xxx-convert) must match the order of document nodes. Any cleaning or other preprocessing of the documents must already have been done. If certain parts should have been created in a certain state or with other initial properties, that must be done after the call to this function.</summary>
		<params>
			<param name="source-uri" type="xs:string" optional="false">The URI of the source document.</param>
			<param name="destination-uri" type="xs:string" optional="false">The URI of the root destination (converted) document.</param>
			<param name="manifest" type="element()" optional="false">The parts list of all the conversion products, as returned by xdmp:pdf-convert, xdmp:word-convert, etc. The main or root document should be the first on the list, if there is one.</param>
			<param name="docs" type="document-node()*" optional="false">The documents produced by conversion, in the same order as in the manifest.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace cvt = "http://marklogic.com/cpf/convert"
	         at "/MarkLogic/conversion/convert.xqy";

  let $results := xdmp:word-convert( doc("myfile.doc"), "myfile.doc" )
  return
     cvt:save-converted-documents("myfile.doc", "myfile.doc",
        $results[1], $results[2 to last()] )

</example>
	</function>
	<function name="invoke" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:invoke">
		<summary>Invoke a module for debugging. Module evaluation will be stopped at the start of the first expression. Returns the request-id after creating the request.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The path of the module to be executed. The path is resolved against the root of the request server evaluating the query. The path must resolve to a main module (not a library module).</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node for the
				<code>dbg:eval</code>options must be in the
				<code>xdmp:eval</code>namespace. See the
				<a href="#xdmp:eval">
					<code>xdmp:eval</code>
				</a>section for a list of options.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  dbg:invoke("http://example.com/modules/foo.xqy")
  =&gt; 6423840

</example>
	</function>
	<function name="eval" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:eval">
		<summary>Evaluate a string as an XQuery for debugging. Module evaluation will be stopped at the start of the first expression. Returns the request ID after creating the request. Requests evaluated for debugging with
			<code>dbg:eval</code>are evaluated on the task server, not on the App Server in which they are initiated.</summary>
		<params>
			<param name="xquery" type="xs:string" optional="false">The XQuery string to be evaluated. If the XQuery string contains double quotes ("), surround the string with single quotes (').</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node for the
				<code>dbg:eval</code>options must be in the
				<code>xdmp:eval</code>namespace. See the
				<a href="#xdmp:eval">
					<code>xdmp:eval</code>
				</a>section for a list of options.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  dbg:eval("1+1")

=&gt; The ID of the request stopped for debugging
   (for example, 1767394036047154157).  The
   request is evaluated on the task server, and
   you can use the ID to pass into one of the other
   debug functions (for example, dbg:continue or
   dbg:step) to debug the request.

</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

dbg:eval("xdmp:log(xs:string(xdmp:estimate(doc())))", (),
  &lt;options xmlns="xdmp:eval"&gt;
    &lt;database&gt;{xdmp:database("Documents")}&lt;/database&gt;
  &lt;/options&gt;
)

=&gt; The ID of the request stopped for debugging
   (for example, 13942194686892174312).  The
   request is evaluated on the task server, and
   this request will use the "Documents" database
   as its context database.  You can use the ID to
   pass into one of the other debug functions
   (for example, dbg:continue or dbg:step) to
   debug the request.


</example>
	</function>
	<function name="attach" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:attach">
		<summary>Attach to a request and stop it for debugging.</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong" optional="false">A request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:attach(204928402983)
  =&gt; ()

</example>
	</function>
	<function name="detach" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:detach">
		<summary>Detach from a stopped request. All breakpoints set will be cancelled and the request will continue evaluating.</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong" optional="false">A request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:detach(204928402983)
  =&gt; ()

</example>
	</function>
	<function name="connect" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:connect">
		<summary>Connect to a Server (http, xdbc, or task) for debugging. Any running requests will be stopped and new requests will stop at the first expression.</summary>
		<params>
			<param name="server" type="xs:unsignedLong" optional="false">A server ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:connect(4928402983)
  =&gt; ()

</example>
	</function>
	<function name="connected" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:connected">
		<summary>Return the ID's of servers that are connected by the debugger.</summary>
		<privilege>http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  dbg:connected()
  =&gt; (2298273928472, 20384203948)

</example>
	</function>
	<function name="disconnect" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:disconnect">
		<summary>End the debugging of a server. Already stopped requests will remain stopped. New requests will evaluate without stopping at first expression.</summary>
		<params>
			<param name="server" type="xs:unsignedLong" optional="false">A server ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:disconnect(204928402983)
  =&gt; ()

</example>
	</function>
	<function name="status" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:status">
		<summary>Return the debugging status of given requests.</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong*" optional="false">Request id's.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>element(dbg:requests)?</return>
		<example xml:space="preserve">
  dbg:status(14096214104959794818)
  =&gt;
   &lt;requests xmlns="http://marklogic.com/xdmp/debug"&gt;
     &lt;request&gt;
       &lt;request-id&gt;14096214104959794818&lt;/request-id&gt;
       &lt;server-id&gt;13141894694259521076&lt;/server-id&gt;
       &lt;request-status&gt;stopped&lt;/request-status&gt;
       &lt;debugging-status&gt;attached&lt;/debugging-status&gt;
       &lt;expr-id&gt;16429173930674134530&lt;/expr-id&gt;
       &lt;where-stopped&gt;begin&lt;/where-stopped&gt;
     &lt;/request&gt;
   &lt;/requests&gt;

</example>
	</function>
	<function name="stopped" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:stopped">
		<summary>Return the request ID's of stopped requests in a given server. If server isn't supplied, returns a list of all stopped requests on host.</summary>
		<params>
			<param name="server" type="xs:unsignedLong" optional="true">Server ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  dbg:stopped(204928402983)
  =&gt; (2298273928472, 20384203948)

</example>
	</function>
	<function name="attached" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:attached">
		<summary>Return the request ID's of attached requests in a given server. If server isn't supplied, returns a list of all attached requests on host.</summary>
		<params>
			<param name="server" type="xs:unsignedLong" optional="true">Server ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  dbg:attached(204928402983)
  =&gt; (2298273928472, 20384203948)

</example>
	</function>
	<function name="stack" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:stack">
		<summary>Return the stack trace for a given request.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>element(dbg:stack)</return>
		<example xml:space="preserve">
  dbg:stack(204928402983)
  =&gt;
    &lt;stack xmlns="http://marklogic.com/xdmp/debug"&gt;
      &lt;expr&gt;
        &lt;expr-id&gt;16429173930674134530&lt;/expr-id&gt;
        &lt;expr-source&gt;xdmp:sleep(1000)&lt;/expr-source&gt;
        &lt;uri&gt;/long.xqy&lt;/uri&gt;
        &lt;line&gt;11&lt;/line&gt;
      &lt;/expr&gt;
      &lt;frame&gt;
        &lt;uri&gt;/long.xqy&lt;/uri&gt;
        &lt;line&gt;11&lt;/line&gt;
        &lt;operation&gt;fn:sleep(18)&lt;/operation&gt;
        &lt;variables&gt;
          &lt;variable&gt;
            &lt;name xmlns=""&gt;x&lt;/name&gt;
            &lt;value&gt;18&lt;/value&gt;
          &lt;/variable&gt;
        &lt;/variables&gt;
      &lt;/frame&gt;
      &lt;frame&gt;
        &lt;uri&gt;/long.xqy&lt;/uri&gt;
        &lt;line&gt;18&lt;/line&gt;
        &lt;operation&gt;fn:foo(18)&lt;/operation&gt;
        &lt;variables&gt;
          &lt;variable&gt;
            &lt;name xmlns=""&gt;x&lt;/name&gt;
            &lt;value&gt;18&lt;/value&gt;
            &lt;/variable&gt;&lt;/variables&gt;
            &lt;/frame&gt;&lt;frame&gt;
            &lt;uri&gt;/long.xqy&lt;/uri&gt;
            &lt;line&gt;26&lt;/line&gt;
            &lt;operation&gt;fn:bar()&lt;/operation&gt;
            &lt;variables&gt;&lt;variable&gt;
            &lt;name xmlns=""&gt;x&lt;/name&gt;
            &lt;value&gt;18&lt;/value&gt;
          &lt;/variable&gt;
        &lt;/variables&gt;
      &lt;/frame&gt;
      &lt;frame&gt;
        &lt;uri&gt;/long.xqy&lt;/uri&gt;
        &lt;line&gt;29&lt;/line&gt;
      &lt;/frame&gt;
    &lt;/stack&gt;

</example>
	</function>
	<function name="out" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:out">
		<summary>Continue evaluation of the request until the end of the current expression.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:out(204928402983)
  =&gt; ()

</example>
	</function>
	<function name="finish" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:finish">
		<summary>Continue evaluation of the request until the end of the current function. If evaluation is not inside of a function, this request is equivalent to continue().</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:finish(204928402983)
  =&gt; ()

</example>
	</function>
	<function name="step" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:step">
		<summary>Continue evaluation of the request until the beginning or end of an expression.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:step(204928402983)
  =&gt; ()

</example>
	</function>
	<function name="next" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:next">
		<summary>Continue evaluation of the request until the beginning or end of an expression that is not a descendant of the current expression.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:next(204928402983)
  =&gt; ()

</example>
	</function>
	<function name="continue" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:continue">
		<summary>Continue evaluation of the request.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:continue(204928402983)
  =&gt; ()

</example>
	</function>
	<function name="wait" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:wait">
		<summary>Wait until at least one of the given requests stops or all complete evaluating. Wait will return the empty sequence after a requested timeout if none of the requests have stopped. Otherwise, it returns the request-id of a stopped (or finished) request.</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong*" optional="false">Request id's.</param>
			<param name="timeout" type="xs:unsignedLong" optional="false">Requested timeout (in seconds).</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:unsignedLong?</return>
		<example xml:space="preserve">
  dbg:wait((23424324342, 843285285))
  =&gt; ()

</example>
	</function>
	<function name="break" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:break">
		<summary>Set a breakpoint at the given expression ID. If no expression ID is given, then the identified request is stopped.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
			<param name="expression" type="xs:unsignedLong" optional="true">Expression ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:break(204928402983, 28042309)
  =&gt; ()

</example>
	</function>
	<function name="clear" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:clear">
		<summary>Clear a breakpoint at the given expression ID.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
			<param name="expression" type="xs:unsignedLong" optional="false">Expression ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:clear(204928402983, 28042309)
  =&gt; ()

</example>
	</function>
	<function name="breakpoints" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:breakpoints">
		<summary>Returns a sequence of expression ID's representing existing breakpoints for the given request.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:usngignedLong*</return>
		<example xml:space="preserve">
  dbg:breakpoints(204928402983)
  =&gt; 28042309

</example>
	</function>
	<function name="stop" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:stop">
		<summary>Placing this call in XQuery will instruct the evaluator to stop a request for debugging.</summary>
		<params />
		<privilege></privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  dbg:stop()
  =&gt; ()

</example>
	</function>
	<function name="value" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:value">
		<summary>Evaluate an expression in the context of the identified stopped request. If no expression is given and the request is stopped at the end of an expression, then the expression's value is returned.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
			<param name="expr" type="xs:string" optional="true">Expression string.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>item()*</return>
		<example xml:space="preserve">
  dbg:value(13334971433974783708, "$var")
  =&gt; 5
  where 5 is the value of the $var variable for the stopped request

</example>
	</function>
	<function name="line" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:line">
		<summary>Returns a sequence of expression ID's found on a given line of a stopped request.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
			<param name="uri" type="xs:string" optional="false">Module URI.</param>
			<param name="line" type="xs:unsigned" optional="false">Line number.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  dbg:line(20293482, "/security.xqy", 512)
  =&gt; (5032942, 9103982, 30802938)

</example>
	</function>
	<function name="function" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:function">
		<summary>Returns the expression ID representing the function defined in a module with a given name.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
			<param name="uri" type="xs:string" optional="false">Module URI.</param>
			<param name="function" type="xs:QName" optional="false">function name.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  dbg:function(20293482, "/security.xqy", $function)
  =&gt; 5032942

</example>
	</function>
	<function name="expr" type="builtin" lib="dbg" category="DebugBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="dbg:expr">
		<summary>Returns a description/representation of a given expression.</summary>
		<params>
			<param name="request" type="xs:unsignedLong" optional="false">Request ID.</param>
			<param name="expression" type="xs:unsignedLong" optional="false">Expression ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/debug-my-requests or http://marklogic.com/xdmp/privileges/debug-any-requests</privilege>
		<return>element(dbg:expression)</return>
		<example xml:space="preserve">
  dbg:expr(20293482, 2348239487)
  =&gt; the dbg:expression element for this expression

</example>
	</function>
	<function name="convert" type="docbook" lib="dbk" category="DocBook Conversion" bucket="CPF Functions" hidden="false" fullname="dbk:convert">
		<summary>Convert XHTML to DocBook lite vocabulary, if possible. The section structuring depends on the presence of div elements with mlsection markers, as produced by xhtml:restructure.</summary>
		<params>
			<param name="doc" type="node()?" optional="false">The contents of the XHTML document.</param>
			<param name="options" type="element()?" optional="false">Conversion options in the "dbk:docbook" namespace. There are two options are defined: "wrap-text", a boolean value which causes "phrase" elements to be inserted where XHTML "span" elements were found. The default is false. "preserve-styles", a boolean value which causes the XHTML "class" attributes to be mapped to "role" attributes in the output. The default is false.</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dbk = "http://marklogic.com/cpf/docbook"
	         at "/MarkLogic/conversion/docbook.xqy";

  let $options :=
     &lt;options xmlns="dbk:convert"&gt;
       &lt;wrap-text&gt;false&lt;/wrap-text&gt;
       &lt;preserve-styles&gt;true&lt;/preserve-styles&gt;
     &lt;/options&gt;
  return dbk:convert(fn:doc("http://example.com/mydoc.xhtml"), $options)

</example>
	</function>
	<function name="document-history" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-history">
		<summary>Returns the version history of the document located at the specified URI.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<return>element(dls:document-history)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
   xquery version "1.0-ml";
   import module namespace dls = "http://marklogic.com/xdmp/dls"
	         at "/MarkLogic/dls.xqy";

   dls:document-history("/foo/bar/baz.xml")

   =&gt;

   &lt;dls:document-history uri="/foo/bar/baz.xml" xmlns:dls="http://marklogic.com/xdmp/dls"&gt;
   &lt;dls:version&gt;
    &lt;dls:version-id&gt;1&lt;/dls:version-id&gt;
    &lt;dls:document-uri&gt;/foo/bar/baz.xml&lt;/dls:document-uri&gt;
    &lt;dls:latest&gt;false&lt;/dls:latest&gt;
    &lt;dls:created&gt;2009-04-07T13:54:26.721-07:00&lt;/dls:created&gt;
    &lt;dls:replaced&gt;2009-04-14T13:52:21.674-07:00&lt;/dls:replaced&gt;
    &lt;dls:author&gt;10677693687367813363&lt;/dls:author&gt;
    &lt;dls:annotation&gt;part insert&lt;/dls:annotation&gt;
    &lt;dls:deleted&gt;false&lt;/dls:deleted&gt;
  &lt;/dls:version&gt;&lt;dls:version&gt;
    &lt;dls:version-id&gt;2&lt;/dls:version-id&gt;
    &lt;dls:document-uri&gt;/foo/bar/baz.xml&lt;/dls:document-uri&gt;
    &lt;dls:latest&gt;true&lt;/dls:latest&gt;
    &lt;dls:created&gt;2009-04-14T13:52:21.674-07:00&lt;/dls:created&gt;
    &lt;dls:author&gt;10677693687367813363&lt;/dls:author&gt;
    &lt;dls:annotation&gt;Changed the title from Baz Gets Down&lt;/dls:annotation&gt;
    &lt;dls:deleted&gt;false&lt;/dls:deleted&gt;
  &lt;/dls:version&gt;
  &lt;/dls:document-history&gt;

</pre>
</example>
	</function>
	<function name="document-manage" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-manage">
		<summary>This function places a document under management. A document must first be managed before it can be checked out. The document at the specified URI will become version 1 of this managed document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="deep" type="xs:boolean" optional="false">Specifies whether to manage this document as well as any documents for which this document has XInclude references to. Specify
				<code>true</code>to manage all XInclude references or
				<code>false</code>to not manage any included documents. The default is
				<code>false</code>.</param>
			<param name="annotation" type="item()*" optional="true">Any comments you want to add to the properties.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-manage("/foo/bar/baz.xml",
                      fn:false(),
                      "Baz is now a managed document")

  (: Makes 'baz.xml' a managed document, but not its referenced documents. :)

</pre>

</example>
	</function>
	<function name="document-unmanage" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-unmanage">
		<summary>Removes the specified document from management. You must have update permissions on the document to unmanage the document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="deep" type="xs:boolean" optional="false">Specifies whether to unmanage this document as well as any documents for which this document has XInculde references to. Specify
				<code>true</code>to unmanage all XInclude references or
				<code>false</code>to leave any included documents as managed documents. The default is
				<code>false</code>.</param>
			<param name="remove-versions" type="xs:boolean" optional="false">Specify
				<code>true</code>to delete all but the latest version during the unmanage operation,
				<code>false</code>to leave any older versions in the database as unmanaged documents.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">

  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-unmanage("/foo/bar/baz.xml", fn:false(), fn:true())

  (: Unmanages 'baz.xml', but maintains management of its referenced
     documents. All versions but the latest version of this document
     are deleted. :)

</pre>

</example>
	</function>
	<function name="document-checkout" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-checkout">
		<summary>This function checks out (locks) the document at the specified URI to prevent other users from modifying the document. An exception is thrown if the document does not yet exist or does exist but is not managed.
			<p />This function must be called in a separate transaction from the
			<code>dls:document-update</code>and
			<code>dls:document-checkin</code>functions.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to check out.</param>
			<param name="deep" type="xs:boolean" optional="false">If set to
				<code>true</code>, then any documents directly or indirectly included by the specified document are also checked out.</param>
			<param name="annotation" type="item()?" optional="true">Any comments you want to add to the document's
				<code>active-lock</code>element.</param>
			<param name="timeout" type="xs:unsignedLong?" optional="true">The duration of the checkout, in seconds. For infinite, omit this parameter or specify ().</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-checkout("/foo/bar/baz.xml", fn:true(), "updating doc", 3600)

  (: Checks out the 'baz'xml' document, and all of its included documents,
     for one hour. :)

</pre>

</example>
	</function>
	<function name="document-checkin" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-checkin">
		<summary>This function checks in (unlocks) the document at the specified URI to allow other users to modify the document. This function does not create a new version of the document. You must explicitly use
			<code>dls:document-update</code>to create new versions of a document.
			<p />This function must be called in a separate transaction from the
			<code>dls:document-checkout</code>and
			<code>dls:document-update</code>functions.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="deep" type="xs:boolean" optional="false">If set to
				<code>true</code>, then any documents directly or indirectly included by the specified document are also checked in.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-checkin("/foo/bar/baz.xml", fn:true())

  (: Checks in 'baz.xml' and all of its included documents. :)

</pre>

</example>
	</function>
	<function name="document-version-as-of" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-version-as-of">
		<summary>This function returns the most recent version of a document as of a point in time.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="as-of" type="xs:dateTime" optional="false">The date and time from which you want to retrieve the most recent version of the document.</param>
		</params>
		<return>document-node()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-version-as-of(
                   "/foo/bar/baz.xml",
                    xs:dateTime("2009-04-07T09:43:16.531-07:00"))

  (: Returns the most recent version of the 'baz.xml' document since the
     specified date and time. :)

</pre>

</example>
	</function>
	<function name="document-version" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-version">
		<summary>This function returns a particular version of a managed document. An error is thrown if there is no such version.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="version-number" type="xs:unsignedInt" optional="false">The version of the document to be returned.</param>
		</params>
		<return>document-node()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-update(
           "/foo/bar/baz.xml",
            dls:document-version( "/foo/bar/baz.xml", 1),
            "restoring from version 1",
            fn:true() )

  (: Restores version 1 of the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-version-uris" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-version-uris">
		<summary>This function returns the URIs of all versions of a managed document. No URIs of deleted versions are returned.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>xs:string*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-version-uris("/foo/bar/baz.xml")

  (: Returns the URIs of all versions of the '/foo/bar/baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-version-delete" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-version-delete">
		<summary>This function removes the specified version of the managed document at the specified URI. This overrides any configured retention policies and should be used with care. You must have update permissions on the document version in order to delete it.
			<p />If you set
			<code>$retain-history</code>to
			<code>true</code>, you can use
			<code>xdmp:document-properties</code>to view the deleted document's properties fragment in the database. For example, if you had deleted version 1 of
			<code>/foo/bar/baz.xml</code>, you can view its properties by calling:
			<p />
			<code>xdmp:document-properties("/foo/bar/baz.xml_versions/1-baz.xml")</code></summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="version" type="xs:integer" optional="false">The version of the document to be deleted.</param>
			<param name="retain-history" type="xs:boolean" optional="false">Determines whether or not to retain the document's properties fragment in the database. Set to
				<code>true</code>to retain the deleted document's properties in order to track when the document was deleted and by whom. Otherwise, set to
				<code>false</code>.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-version-delete("/foo/bar/baz.xml", 1, fn:true())

  (: Deletes version 1 of the 'baz.xml' document and records it in the document
     history. :)

</pre>

</example>
	</function>
	<function name="document-versions-query" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="cts:query Constructor" hidden="false" fullname="dls:document-versions-query">
		<summary>This function returns a query that matches any version of the specified URI. If the URI contains either of the wildcard characters '?' or '*', then the search is wildcarded. Specifying '*' matches any numbered version of any managed document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>cts:properties-query</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  cts:search(fn:doc(), dls:document-versions-query("/foo/bar/baz.xml"))

  (: Returns the contents of all versions of the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-version-uri" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-version-uri">
		<summary>This function returns the URI of the specified version of the document located at the specified URI. The specified version of the document may, or may not, actually exist.</summary>
		<params>
			<param name="document-uri" type="xs:string" optional="false">The URI of the latest version of the document.</param>
			<param name="version" type="xs:integer" optional="false">The version of the document for which to return the URI.</param>
		</params>
		<return>xs:string</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-version-uri("/foo/bar/baz.xml", 2)

  =&gt;

  /foo/bar/baz.xml_versions/2-baz.xml

</pre>

</example>
	</function>
	<function name="document-delete" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-delete">
		<summary>This function removes the specified managed document. You must have update permissions on the document to delete it.
			<p />If you set
			<code>$retain-history</code>to
			<code>true</code>, you can use
			<code>xdmp:document-properties</code>to view the deleted document's properties fragment in the database.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="keep-old-versions" type="xs:boolean" optional="false">Determines whether to keep old versions of the document. Set to
				<code>false</code>to delete all of the versions of the document.</param>
			<param name="retain-history" type="xs:boolean" optional="false">Determines whether to retain the deleted document's property fragment in the database. Set to
				<code>true</code>to retain the property fragment, or
				<code>false</code>to delete.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-delete("/foo/bar/baz.xml", fn:false(), fn:true())

  (: Deletes all versions of the 'baz.xml' document and retains the
     property fragment for each version. :)

</pre>

</example>
	</function>
	<function name="document-is-managed" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-is-managed">
		<summary>This function determines whether or not the document at the specified URI is managed. This function returns
			<code>true</code>if the document at the URI is either a managed document or a numbered version of a managed document. Otherwise
			<code>false</code>is returned.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to test.</param>
		</params>
		<return>xs:boolean</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-is-managed("/foo/bar/baz.xml")

  (: Returns true if document is managed.  Otherwise false. :)

</pre>

</example>
	</function>
	<function name="retention-rule" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Retention Policy" hidden="false" fullname="dls:retention-rule">
		<summary>This function creates and returns a retention rule element. Use
			<code>dls:insert-retention-rule</code>to insert the retention rule into the database.
			<p />Specifying multiple constraints implies AND between them. For example, specifying both
			<code>$num-versions</code>and
			<code>$duration</code>retains a numbered version only if it is both one of the N most recent versions and it was created more recently than "now - duration." If neither
			<code>$num-versions</code>or
			<code>$duration</code>is specified, then any numbered version matching the document query is kept forever.
			<p />The
			<code>$document-query-text</code>parameter is intended to be used for the human readable form of a query that was used to produce the corresponding
			<code>cts:query</code>. This may be the text that a user typed into a search text field in the UI. This parameter does NOT affect the retention policy.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the retention rule. The name must be unique to this rule.</param>
			<param name="comment" type="item()*" optional="false">Comment that describes this retention rule.</param>
			<param name="num-versions" type="xs:unsignedInt?" optional="false">The number of most recent versions to be retained. This means to keep versions greater than (but not equal to) num-versions - current-version, if they still exist.</param>
			<param name="duration" type="xs:duration?" optional="false">Retain all versions that were created on or after the duration date/time.</param>
			<param name="document-query-text" type="xs:string?" optional="false">Comment that describes the document query.</param>
			<param name="document-query" type="cts:query?" optional="false">The document query. Typically returned by a Query Constructor Function.</param>
		</params>
		<return>element(dls:retention-rule)</return>
		<privilege>The
			<code>dls-admin</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-admin</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dls="http://marklogic.com/xdmp/dls"
              at "/MarkLogic/dls.xqy";

  dls:retention-rule(
      "All Versions Retention Rule",
      "Retain all versions of all documents",
      (),
      (),
      "Locate all of the documents",
      cts:and-query(()))

  (: Returns a retention rule in XML format. :)

</pre>

</example>
    <example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:retention-rule(
      "Rule1",
      "Keep the five most recent versions of Jim's documents that are
         15 days old or newer",
      5,
      xs:duration("P15D"),
      "Locate documents authored by Jim",
      dls:author-query(xdmp:user("Jim")))

  (: Returns a retention rule in XML format. :)

</pre>

</example>
    <example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:retention-rule(
      "Rule2",
      "Keep the five most recent versions of Jim's documents in the 'foo'
         collection that are 15 days old or newer",
      5,
      xs:duration("P15D"),
      "Locate documents in the 'foo' collection authored by Jim",
       cts:and-query((
          cts:collection-query("http://marklogic.com/documents/foo"),
          dls:author-query(xdmp:user("Jim")) )) )

  (: Returns a retention rule in XML format. :)

</pre>

</example>
	</function>
	<function name="retention-rule-insert" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Retention Policy" hidden="false" fullname="dls:retention-rule-insert">
		<summary>This function inserts retention rules into the database. They will be readable by the dls-user role and modifiable/deletable by the dls-admin role.</summary>
		<params>
			<param name="rules" type="element(dls:retention-rule)*" optional="false">The retention rule to be inserted.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-admin</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-admin</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:retention-rule-insert((
    dls:retention-rule(
      "Rule1",
      "Keep the five most recent versions of Jim's documents that are 15 days old or newer",
      5,
      xs:duration("P15D"),
      "Locate all documents authored by Jim",
      dls:author-query(xdmp:user("Jim"))),

   dls:retention-rule(
     "Rule2",
     "Retain the five most recent versions of documents that match the query below",
      5,
      (),
      "Locate only docs that include 'Baz' and 'Disco'" ,
      cts:and-query((
        cts:word-query("Baz"),
        cts:word-query("Disco"))) ) ))

  (: Inserts the retention rules, 'Rule1' and 'Rule2', into the database. :)

</pre>

</example>
	</function>
	<function name="retention-rules" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Retention Policy" hidden="false" fullname="dls:retention-rules">
		<summary>This function returns the specified retention rules from the database.</summary>
		<params>
			<param name="names" type="xs:string*" optional="false">The names of the retention rules to be returned. The name can include wild cards. For example, a
				<code>*</code>can be used to retrieve all of the retention rules.</param>
		</params>
		<return>element(dls:retention-rule)*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code>
			<p />You must have
			<code>read</code>permissions on the rentention-rule document to see the rules.</privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:retention-rules("Rule1")

  (: Returns the 'Rule1' retention rule in XML format. :)

</pre>

</example>
	</function>
	<function name="retention-rule-remove" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Retention Policy" hidden="false" fullname="dls:retention-rule-remove">
		<summary>This function removes the specified retention rules from the database.</summary>
		<params>
			<param name="names" type="xs:string*" optional="false">The names of the retention rules to be removed.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-admin</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-admin</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:retention-rule-remove(("Rule1", "Rule2"))

  (: Removes the retention rules, 'Rule1' and 'Rule2'. :)

</pre>

</example>
    <example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:retention-rule-remove(fn:data(dls:retention-rules("*")//dls:name))

  (: Removes all of the retention rules. :)

</pre>

</example>
	</function>
	<function name="document-retention-rules" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Retention Policy" hidden="false" fullname="dls:document-retention-rules">
		<summary>This function returns the retention rules that apply to the document at the specified URI. This allows users to determine why a version of a document is being retained.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document. The URI must identify a numbered version of a managed document or an error is thrown.</param>
		</params>
		<return>element(dls:retention-rule)*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-retention-rules("/foo/bar/baz.xml")

  (: Returns all of the retention rules that apply to the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="purge" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Retention Policy" hidden="false" fullname="dls:purge">
		<summary>This function deletes all numbered versions of managed documents and its referenced documents (such as
			<code>/foo/bar.xml_versions/1-bar.xml</code>), as specified by the rention policy set by one or more
			<code>dls:retention-rule</code>functions. Documents are deleted if they have no retention rule causing them to be kept and if they are not included by some document that cannot yet be deleted. If
			<code>$delete</code>is
			<code>false</code>, the document versions are not actually deleted and instead a list of the documents that would have been deleted is returned. This function returns a list of URIs that it would/did delete.
			<p />If you set
			<code>$retain-history</code>to
			<code>true</code>, you can use
			<code>xdmp:document-properties</code>to view the deleted document's properties fragment in the database.</summary>
		<params>
			<param name="delete" type="xs:boolean" optional="false">Determines whether or not to delete the documents. Set to
				<code>true</code>to delete the documents or
				<code>false</code>to list which documents would have been deleted.</param>
			<param name="retain-history" type="xs:boolean" optional="false">Determines whether to retain the deleted documents' property fragments in the database. Set to
				<code>true</code>to retain the property fragments, or
				<code>false</code>to delete.</param>
		</params>
		<return>xs:string*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-purge(fn:true(), fn:true())

  (: Deletes all of the versions of the 'baz.xml' document and its
     referenced documents. :)

</pre>

</example>
	</function>
	<function name="document-purge" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Retention Policy" hidden="false" fullname="dls:document-purge">
		<summary>This function deletes all numbered versions of the specified managed document and its referenced documents, as specified by the rention policies set by
			<code>dls:retention-rule</code>. The document versions are deleted if they have no retention rule causing them to be kept and if they are not included by documents that cannot yet be deleted. If
			<code>$delete</code>is
			<code>false</code>, the document's versions are not actually deleted and instead a list of the documents that would have been deleted is returned.
			<p />If you set
			<code>$retain-history</code>to
			<code>true</code>, you can use
			<code>xdmp:document-properties</code>to view the deleted document's properties fragment in the database.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to be purged.</param>
			<param name="delete" type="xs:boolean" optional="false">Determines whether or not to delete the documents. Set to
				<code>true</code>to remove the documents or
				<code>false</code>to list which documents would have been deleted.</param>
			<param name="retain-history" type="xs:boolean" optional="false">Determines whether to retain the deleted document's property fragment in the database. Set to
				<code>true</code>to retain the property fragment, or
				<code>false</code>to delete.</param>
		</params>
		<return>xs:string*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-purge("/foo/bar/baz.xml", fn:false(), fn:true())

  (: Returns the versions of the 'baz.xml' document and its referenced
     documents, as specified by the rention policy. :)

</pre>

</example>
	</function>
	<function name="as-of-query" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="cts:query Constructor" hidden="false" fullname="dls:as-of-query">
		<summary>This function returns a query that matches the most recent numbered version of documents that were created before the specified date and time.</summary>
		<params>
			<param name="when" type="xs:dateTime" optional="false">The date and time before which the documents were created.</param>
		</params>
		<return>cts:properties-query</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  cts:search(fn:doc(), dls:as-of-query(xs:dateTime(fn:current-dateTime())))

  (: Returns the versions of the managed documents that were created before the
     specified date and time. :)

</pre>

</example>
	</function>
	<function name="author-query" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="cts:query Constructor" hidden="false" fullname="dls:author-query">
		<summary>This function returns a query that matches documents authored by the specified user.</summary>
		<params>
			<param name="author" type="xs:unsignedLong" optional="false">The id of the user who authored the documents.</param>
		</params>
		<return>cts:properties-query</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  cts:search(fn:doc(), dls:author-query(xdmp:user("Jim")))

  (: Returns all of the documents authored by 'Jim'. :)

</pre>

</example>
	</function>
	<function name="document-version-query" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="cts:query Constructor" hidden="false" fullname="dls:document-version-query">
		<summary>This function returns a query that matches the specified version of the managed documents.</summary>
		<params>
			<param name="version" type="xs:unsignedLong" optional="false">The version of the managed documents.</param>
		</params>
		<return>cts:properties-query</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  cts:search(fn:doc(), dls:document-version-query(3))

  (: Returns Version 3 of all of the managed documents in the database. :)

</pre>

</example>
	</function>
	<function name="documents-query" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="cts:query Constructor" hidden="false" fullname="dls:documents-query">
		<summary>This function returns a query that matches the latest versions of the managed documents in the database.</summary>
		<params />
		<return>cts:properties-query</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  cts:search(fn:doc(), dls:documents-query())

  (: Returns the latest versions of the managed documents in the database. :)

</pre>

</example>
	</function>
	<function name="link-expand" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="XInclude" hidden="false" fullname="dls:link-expand">
		<summary>This function performs a single level expansion of a single XInclude reference. Any XInclude references in the referenced node are not expanded.</summary>
		<params>
			<param name="context" type="node()" optional="false">The node that contains the XInclude reference.</param>
			<param name="ref" type="element(xi:include)" optional="false">The XInclude reference to be expanded.</param>
			<param name="restriction" type="cts:query?" optional="false">Restriction that control which documents may be considered for inclusion. An exact URI match is first considered if it matches the specified restrictions, followed by the most recent numbered version of that URI that matches the restrictions.</param>
		</params>
		<return>node()*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  declare namespace xi="http://www.w3.org/2001/XInclude";

  let $node := fn:doc("/foo/bar/baz.xml")

  return dls:link-expand($node,
                         $node/BOOK/xi:include[1],
                         dls:documents-query())

  (: Returns the first referenced node in the 'BOOK' element in the
     latest version of the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="link-references" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="XInclude" hidden="false" fullname="dls:link-references">
		<summary>This function returns a list of all the distinct URIs of documents referenced (either directly or indirectly) in the expansion of the node. The URIs are mapped according to the specified restrictions.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node to be expanded.</param>
			<param name="restriction" type="cts:query?" optional="false">Restriction that control which documents may be considered for inclusion. An exact URI match is first considered if it matches the specified restrictions, followed by the most recent numbered version of that URI that matches the restrictions.</param>
		</params>
		<return>xs:string*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  let $node := fn:doc("/foo/bar/baz.xml")

  return dls:link-references($node, dls:document-version-query(4))

  (: Returns the URIs of the referenced nodes in Version 4 of the 'baz.xml'
     document and all of the referenced nodes referenced from its referenced
     nodes. :)

</pre>

</example>
	</function>
	<function name="node-expand" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="XInclude" hidden="false" fullname="dls:node-expand">
		<summary>This function recursively examines the node for XInclude references and expands them, following the rules of the XInclude specification. The result is a node in which all the XInclude references have been resolved, or an error if there were unresolvable references with no fallback specifications. The URIs are mapped according to the specified restrictions.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node to be expanded.</param>
			<param name="restriction" type="cts:query?" optional="false">Restriction that control which documents may be considered for inclusion. An exact URI match is first considered if it matches the specified restrictions, followed by the most recent numbered version of that URI that matches the restrictions.</param>
		</params>
		<return>node()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<usage>This function cannot expand root node documents that contain XInclude links to specific versioned documents. You must use
			<code>xinc:node-expand</code>to expand such documents.</usage>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  let $node := fn:doc("/foo/bar/baz.xml")

  return dls:node-expand(
               $node,
               dls:as-of-query(xs:dateTime("2009-04-06T09:39:33.576-07:00")))

  (: Returns the contents of the 'baz.xml' document version that was created
     before the specified date, along with all of its referenced nodes. :)

</pre>

</example>
	</function>
	<function name="document-add-collections" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-add-collections">
		<summary>This function adds the named document to the specified collections.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to be added to the collection.</param>
			<param name="collections" type="xs:string*" optional="false">A set of collection URIs.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code>
			<p />For each collection that is protected, the user must have permissions to update that collection or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/any-collection</code>
			<p />For each unprotected collection, the user must have the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/unprotected-collections</code>
			<p />The document must specify
			<code>dls-user(update)</code>permission.</privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-add-collections(
        "/foo/bar/baz.xml",
        "http://marklogic.com/documents/foo")

  (: Adds 'bax.xml' to the 'foo' collection. :)

</pre>

</example>
	</function>
	<function name="document-add-permissions" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-add-permissions">
		<summary>This function adds the specified permissions for the named document. Any permissions that were previously set for the document are retained.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">The permissions to be added for the document.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code>
			<p />The document must specify
			<code>dls-user(update)</code>permission.</privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-add-permissions("/foo/bar/baz.xml",
                               (xdmp:permission("dls-user", "read"),
                                xdmp:permission("dls-user", "update")))

  (: Adds the specified permissions to the list of permissions for the 'baz.xml'
     document. :)

</pre>

</example>
	</function>
	<function name="document-get-permissions" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-get-permissions">
		<summary>This function gets the permissions for the specified document from the point of view of the Library Services API.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>element(sec:permission)*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-get-permissions("/foo/bar/baz.xml")

  (: Returns the permissions for the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-add-properties" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-add-properties">
		<summary>This function adds the specified properties to any existing properties associated with the named document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="properties" type="element()*" optional="false">The properties to add.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<usage>You cannot add any property nodes to the DLS namespace.</usage>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-add-properties(
              "/foo/bar/baz.xml",
              (&lt;priority&gt;1&lt;/priority&gt;,
               &lt;status&gt;unedited&lt;/status&gt;))

  (: The &lt;priority&gt; and &lt;status&gt; properties are added to the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-set-collections" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-set-collections">
		<summary>This function sets the named document to the specified collections. Any previously set collections for the document that are not specified are removed.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to be set to the collection.</param>
			<param name="collections" type="xs:string*" optional="false">A set of collection URIs.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-set-collections(
          "/foo/bar/baz.xml",
          "http://marklogic.com/documents/foo")

  (: Sets 'bax.xml' to the 'foo' collection. :)

</pre>

</example>
	</function>
	<function name="document-set-permissions" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-set-permissions">
		<summary>This function sets the specified permissions for the named document. Any unspecified permissions that were previously set for the document are removed.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">The permissions to be set for the document.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code>
			<p />The document must specify
			<code>dls-user(update)</code>permission.</privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-set-permissions("/foo/bar/baz.xml",
                               (xdmp:permission("dls-user", "read"),
                                xdmp:permission("dls-user", "update"),
                                xdmp:permission("Developer", "read"),
                                xdmp:permission("Developer", "update")))

  (: Sets the permissions on the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-set-properties" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-set-properties">
		<summary>This function sets the properties of a document to the given sequence of elements. With the exception of the Library Services properties, any properties that already exist on the document are replaced. To preserve existing document properties, use
			<code>dls:document-add-properties</code>. Each element QName is the property name and the element value is the property value.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="properties" type="element()*" optional="false">The properties to be set for the document.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code>
			<P />Modifying properties requires update permissions on a document.</privilege>
		<usage>You cannot set any property nodes in the DLS namespace.</usage>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-set-properties(
              "/foo/bar/baz.xml",
              (&lt;priority&gt;1&lt;/priority&gt;,
               &lt;status&gt;unedited&lt;/status&gt;))

  (: The &lt;priority&gt; and &lt;status&gt; properties are set to the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-set-property" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-set-property">
		<summary>This function sets a property on a document. If any properties with the same property QName exist, they are replaced with the new property. If no properties exist with the same QName, the new property is added.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="property" type="element()" optional="false">The property to set.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<usage>You cannot set any property nodes in the DLS namespace.</usage>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-set-property(
              "/foo/bar/baz.xml",
              &lt;priority&gt;1&lt;/priority&gt;)

  (: The &lt;priority&gt; property is set to the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-set-quality" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-set-quality">
		<summary>This function sets the quality of the document with the given URI. If the quality of the document is positive, the relevance score of the document is increased in text search functions. The converse is true for "negative" quality.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="quality" type="xs:int" optional="false">The quality to which to set the document.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-set-quality("/foo/bar/baz.xml", 10)

  (: Sets the quality of the 'baz.xml' document to 10. :)

</pre>

</example>
	</function>
	<function name="document-remove-collections" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-remove-collections">
		<summary>This function removes the named document from the specified collection.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="collections" type="xs:string*" optional="false">The collection from which to remove the document.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
  at "/MarkLogic/dls.xqy";

    dls:document-remove-collections(
        "/foo/bar/baz.xml",
        "http://marklogic.com/documents/foo")

  (: Removes 'bax.xml' from the 'foo' collection. :)

</pre>

</example>
	</function>
	<function name="document-remove-permissions" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-remove-permissions">
		<summary>This function removes the specified permissions from the named document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">The permissions to be removed from the document.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-remove-permissions(
                   "/foo/bar/baz.xml",
                   (xdmp:permission("Developer", "read"),
                    xdmp:permission("Developer", "update")))

  (: Removes the specified permissions from the list of permissions for
     the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-remove-properties" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-remove-properties">
		<summary>This function removes the specified properties from the named document</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="property-names" type="xs:QName*" optional="false">The properties to be removed.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<usage>You cannot remove any property nodes from the DLS namespace.</usage>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-remove-properties(
         "/foo/bar/baz.xml",
         (fn:QName("http://marklogic.com/xdmp/property", "priority"),
          fn:QName("http://marklogic.com/xdmp/property", "status")))

  (: The &lt;priority&gt; and &lt;status&gt; properties are removed from the
     'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-update" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Update" hidden="false" fullname="dls:document-update">
		<summary>This function updates the managed document at the specified URI with the specified contents. This function does an implicit
			<code>dls:document-purge</code>and returns the URI of any version of the document purged as the result of the established retention policy.
			<p />This function must be called in a separate transaction from the
			<code>dls:document-checkout</code>and
			<code>dls:document-checkin</code>functions.
			<p />You must first check out the document with
			<code>dls:document-checkout</code>before you can update, otherwise an exception is thrown. If the document does not exist, then an exception is thrown.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="doc" type="node()" optional="false">The new contents of the document.</param>
			<param name="annotation" type="item()*" optional="false">Any comments you want to add to the new versions of the documents.</param>
			<param name="retain-history" type="xs:boolean" optional="false">Determines whether or not to retain the document's properties fragment in the database. Set to
				<code>true</code>to retain the original document's properties in order to track when the document was updated and by whom. Otherwise, set to
				<code>false</code>.</param>
			<param name="permissions" type="element(sec:permission)*" optional="true">The permissions to be set on the updated document. If not supplied, then the existing permissions set for the document remain.</param>
			<param name="collections" type="xs:string*" optional="true">The collection URIs for the collections to which the updated document is to belong. If not supplied, then the existing collections set for the document remain.</param>
			<param name="quality" type="xs:integer?" optional="true">Specifies the quality of the updated document. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Specifies the ID of the forest in which the updated document is inserted. If this parameter is not specified, the updated document will remain in the original document's forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the document is inserted into one of the specifed forests. If the document exists and the forest in which it is stored is set to delete-only, then you must set this parameter to include one or more forests that allow updates, otherwise an exception is thrown.</param>
		</params>
		<return>xs:string*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  let $bazbook :=
  &lt;BOOK&gt;
    &lt;TITLE&gt;Baz Goes to the Disco&lt;/TITLE&gt;
    &lt;CHAPTER1&gt;
      &lt;TITLE&gt;Baz Wakes Up&lt;/TITLE&gt;
      &lt;PARA&gt;
        Baz woke up this afternoon to the sound of James Brown.  Soon
        Baz was feeling a little funky, so he put on his cleanest
        propeller hat and headed out in search of a Disco.
      &lt;/PARA&gt;
    &lt;/CHAPTER1&gt;
  &lt;/BOOK&gt;

  return
    dls:document-update(
	"/foo/bar/baz.xml",
	$bazbook,
	"Changed the title from Baz Feelin' Funky",
	fn:true())

  (: Updates the contents of 'baz.xml'. :)

</pre>

</example>
	</function>
	<function name="break-checkout" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:break-checkout">
		<summary>This function breaks (unlocks) a checked-out document</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the checked out document.</param>
			<param name="deep" type="xs:boolean" optional="false">If set to
				<code>true</code>, then the checkout is broken for any checked-out documents that are directly or indirectly included by the specified document.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>The
			<code>dls-admin</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-admin</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:break-checkout("/foo/bar/baz.xml", fn:true())

  (: This breaks the checkout of the 'baz.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-extract-part" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="XInclude" hidden="false" fullname="dls:document-extract-part">
		<summary>This function extracts an element from an existing document and creates a new document from the extracted element. The extracted element is removed from the root node document and replaced by an XInclude to the new document. A new version of the root node document is created. You must have already performed a
			<code>dls:document-checkout</code>of the document that contains the element to be extracted.
			<p />The
			<code>$new-uri</code>must be an absolute path and is initially not checked out. This will create a new version of both the original document and the newly included document, with
			<code>$annotation</code>being used to create a
			<code>dls:annotation</code>property on each of them.</summary>
		<params>
			<param name="new-uri" type="xs:string" optional="false">The URI for the new document.</param>
			<param name="element" type="element()" optional="false">The element to be extracted and used to create the new document. This element can be one of XML format, binary (BLOB) format, or text (CLOB) format.</param>
			<param name="annotation" type="item()*" optional="false">Any comments you want to add to the new versions of the documents.</param>
			<param name="retain-history" type="xs:boolean" optional="false">Determines whether or not to retain the document's properties fragment in the database. Set to
				<code>true</code>to retain the original document's properties in order to track when the document was updated and by whom. Otherwise, set to
				<code>false</code>.</param>
			<param name="permissions" type="element(sec:permission)*" optional="true">The permissions to be set on the new document. If not supplied, default permissions are applied. The default value used for this parameter can be obtained by calling
				<code>xdmp:default-collections()</code>. A document that is created by a non-admin user (that is, by any user who does not have the admin role) must have at least one update permission, otherwise the creation will throw an
				<code>XDMP-MUSTHAVEUPDATE</code>exception.</param>
			<param name="collections" type="xs:string*" optional="true">The collection URIs for the collections to which the new document is to belong. If not supplied, the document is added to your current default collections. For each collection that is protected, you must have permissions to update that collection or have the any-collection privilege. For each unprotected collection, you must have the unprotected-collections privilege. The default value used for this parameter can be obtained by calling
				<code>xdmp:default-collections()</code>.</param>
			<param name="quality" type="xs:integer?" optional="true">Specifies the quality of the document created from the extracted element. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Specifies the ID of the forest in which the document created from the extracted element is inserted. If the document already exists in the database and if this parameter is not specified, it will remain in its existing forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the document is inserted into one of the specifed forests. If the document exists and the forest in which it is stored is set to delete-only, then you must set this parameter to include one or more forests that allow updates, otherwise an exception is thrown.</param>
		</params>
		<return>xs:string*</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-extract-part("/foo/bar/baz-chapter1.xml",
      fn:doc("/foo/bar/baz.xml")//CHAPTER1,
      "part insert",
      fn:true(),
      (xdmp:permission("dls-user","insert"),
       xdmp:permission("dls-user","read"),
       xdmp:permission("dls-user","update"),
       xdmp:permission("admin","insert"),
       xdmp:permission("admin","read"),
       xdmp:permission("admin","update")))

  (: Extracts the &lt;CHAPTER1&gt; element from the 'baz.xml' file and creates a new document,
     named 'baz-chapter1.xml', containing the extracted element. :)

</pre>

</example>
	</function>
	<function name="document-checkout-status" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-checkout-status">
		<summary>This function returns a
			<code>checkout</code>element containing the checkout status of the specified document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>element(dls:checkout)?</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  dls:document-checkout-status("/foo/bar/baz.xml")

  =&gt;

  &lt;dls:checkout xmlns:dls="http://marklogic.com/xdmp/dls"&gt;
    &lt;dls:document-uri&gt;/foo/bar/baz.xml&lt;/dls:document-uri&gt;
    &lt;dls:annotation&gt;updating doc&lt;/dls:annotation&gt;
    &lt;dls:timeout&gt;3600&lt;/dls:timeout&gt;
    &lt;dls:timestamp&gt;1239057381&lt;/dls:timestamp&gt;
    &lt;sec:user-id xmlns:sec="http://marklogic.com/xdmp/security"&gt;10677693687367813363&lt;/sec:user-id&gt;
  &lt;/dls:checkout&gt;

</pre>

</example>
	</function>
	<function name="document-include-query" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="cts:query Constructor" hidden="false" fullname="dls:document-include-query">
		<summary>This function returns a query that matches any managed document that has an XInclude link that exactly matches the specified URI.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the linked-to document.</param>
		</params>
		<return>cts:query</return>
		<privilege>The
			<code>dls-user</code>role is required to run this function, or the privilege:
			<br />
			<code>http://marklogic.com/xdmp/privileges/dls-user</code></privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  cts:search(fn:doc(), dls:document-include-query("/foo.xml"))

  (: Returns the contents of the documents that contain an XInclude to the
     '/foo.xml' document. :)

</pre>

</example>
	</function>
	<function name="document-insert-and-manage" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-insert-and-manage">
		<summary>This function inserts a document into the database and places the document under management.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="deep" type="xs:boolean" optional="false">Specifies whether to manage this document as well as any documents for which this document has XInclude references to. Specify
				<code>true</code>to manage all XInclude references or
				<code>false</code>to not manage any included documents. The default is
				<code>false</code>.</param>
			<param name="doc" type="node()" optional="false">The contents of the document (root node). The document root node can be one of XML format, binary (BLOB) format, or text (CLOB) format.</param>
			<param name="annotation" type="item()*" optional="true">Any comments you want to add to the properties.</param>
			<param name="permissions" type="element(sec:permission)*" optional="true">Security permission elements corresponding to the permissions for the document. If not supplied, the current user's default permissions are applied. The default value used for
				<code>$permissions</code>can be obtained by calling
				<code>xdmp:default-permissions</code>. A document that is created by a non-admin user (that is, by any user who does not have the
				<code>admin</code>role) must have at least one update permission, otherwise the creation will throw an
				<code>XDMP-MUSTHAVEUPDATE</code>exception.</param>
			<param name="collections" type="xs:string*" optional="true">The collection URIs for collections to which this document belongs. If not supplied, the document is added to the current user's default collections. For each collection that is protected, the user must have permissions to update that collection or have the
				<code>any-collection</code>privilege. For each unprotected collection, the user must have the
				<code>unprotected-collections</code>privilege. The default value used for $collections can be obtained by calling
				<code>xdmp:default-collections</code>.</param>
			<param name="quality" type="xs:integer?" optional="true">The quality of this document. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Specifies the ID of the forest in which this document is inserted. If the document already exists in the database and if $forest-ids is not specified, it will remain in its existing forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the document is inserted into one of the specifed forests. If the document exists and the forest in which it is stored is set to delete-only, then you must set $forest-ids to include one or more forests that allow updates, otherwise an exception is thrown.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  let $contents :=
    &lt;BOOK&gt;
      &lt;TITLE&gt;Baz Goes to the Disco&lt;/TITLE&gt;
      &lt;CHAPTER1&gt;
         &lt;TITLE&gt;Baz Wakes Up to James Brown and Feels Funky&lt;/TITLE&gt;
      &lt;/CHAPTER1&gt;
    &lt;/BOOK&gt;

   return
      dls:document-insert-and-manage(
         "/foo/bar/baz.xml",
         fn:true(),
         $contents)

   (: Inserts 'baz.xml' into the database and places the document under management. :)

</pre>

</example>
	</function>
	<function name="document-checkout-update-checkin" lib="dls" category="Library Services" bucket="XQuery Library Modules" subcategory="Document Management" hidden="false" fullname="dls:document-checkout-update-checkin">
		<summary>This function allows you to checkout, update, and checkin a managed document in a single transaction.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to be updated.</param>
			<param name="doc" type="node()" optional="false">The new contents of the document.</param>
			<param name="annotation" type="item()*" optional="false">Any comments you want to add to the new versions of the documents.</param>
			<param name="retain-history" type="xs:boolean" optional="false">Determines whether or not to retain the document's properties fragment in the database. Set to
				<code>true</code>to retain the original document's properties in order to track when the document was updated and by whom. Otherwise, set to
				<code>false</code>.</param>
			<param name="permissions" type="element(sec:permission)*" optional="true">The permissions to be set on the updated document. If not supplied, default permissions are applied. The default value used for this parameter can be obtained by calling
				<code>xdmp:default-permissions</code>. A document that is updated by a non-admin user (that is, by any user who does not have the admin role) must have at least one update permission.</param>
			<param name="collections" type="xs:string*" optional="true">The collection URIs for the collections to which the updated document is to belong. If not supplied, the document maintains its current collections. For each collection that is protected, you must have permissions to update that collection or have the any-collection privilege. For each unprotected collection, you must have the unprotected-collections privilege. The default value used for this parameter can be obtained by calling
				<code>xdmp:default-collections</code>.</param>
			<param name="quality" type="xs:integer?" optional="true">Specifies the quality of the updated document. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Specifies the ID of the forest in which the updated document is inserted. If this parameter is not specified, the updated document will remain in the original document's forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the document is inserted into one of the specifed forests. If the document exists and the forest in which it is stored is set to delete-only, then you must set this parameter to include one or more forests that allow updates, otherwise an exception is thrown.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace dls = "http://marklogic.com/xdmp/dls"
      at "/MarkLogic/dls.xqy";

  let $bazbook :=
  &lt;BOOK&gt;
    &lt;TITLE&gt;Baz Goes to the Disco&lt;/TITLE&gt;
    &lt;CHAPTER1&gt;
      &lt;TITLE&gt;Baz Wakes Up&lt;/TITLE&gt;
      &lt;PARA&gt;
        Baz woke up this afternoon to the sound of James Brown.  Soon
        Baz was feeling a little funky, so he put on his cleanest
        propeller hat and headed out in search of a Disco.
      &lt;/PARA&gt;
    &lt;/CHAPTER1&gt;
  &lt;/BOOK&gt;

  return
    dls:document-checkout-update-checkin(
	"/foo/bar/baz.xml",
	$bazbook,
	"Changed the title from Baz Feelin' Funky",
	fn:true())

  (: Checks out 'baz.xml', updates the content, and checks it back in. :)

</pre>

</example>
	</function>
	<function name="create" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:create">
		<summary>Create a new content processing domain, along with the triggers that perform work in that domain.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the domain. It must be unique.</param>
			<param name="description" type="xs:string" optional="false">A description of the domain.</param>
			<param name="scope" type="element(dom:domain-scope)" optional="false">The scope of the domain. Create using dom:domain-scope.</param>
			<param name="context" type="element(dom:evaluation-context)" optional="false">The evaluation context for processing actions. Create using dom:evaluation-context.</param>
			<param name="pipelines" type="xs:unsignedLong*" optional="false">The unique identifiers of the pipelines to bind to this domain. The same pipeline can be bound to different domains. Until at least one pipeline is bound to the domain, no processing is defined for that domain.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Permissions.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:create( "Incoming", "Handling incoming documents",
              dom:domain-scope( "directory",
                    "/incoming/",
	           "infinity" ),
	      dom:evaluation-context( xdmp:database("Modules"),
	                            "/" ),
              (), () )

</example>
	</function>
	<function name="remove" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:remove">
		<summary>Remove the domain and any associated triggers. An error is raised if no such domain exists.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to remove.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:remove( "Incoming" )

</example>
	</function>
	<function name="get" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:get">
		<summary>Find a particular domain.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to get. An error is raised if no such domain exists.</param>
		</params>
		<return>element(dom:domain)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:get( "Incoming" )

</example>
	</function>
	<function name="set-name" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:set-name">
		<summary>Set the name of the domain to something else. An error is raised if a domain with the new name already exists or if the domain cannot be found.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain whose name will be changed.</param>
			<param name="new-name" type="xs:string" optional="false">The new name for this domain.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:set-name( "Test", "Incoming" )

</example>
	</function>
	<function name="set-description" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:set-description">
		<summary>Set the description of the domain. An error is raised if the domain cannot be found.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="description" type="xs:string" optional="false">The new description of the domain.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:set-description( "Incoming",
	              "Incoming document processing area" )

</example>
	</function>
	<function name="set-domain-scope" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:set-domain-scope">
		<summary>Set the scope of the domain. An error is raised if the domain cannot be found. If the domain already has triggers associated with it, the triggers will be modified to act on the new scope as well.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="scope" type="element(dom:domain-scope)" optional="false">The new scope of the domain. Create using dom:domain-scope.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:set-domain-scope( "Incoming",
       dom:domain-scope( "directory", "/incoming/", "0" )
  )

</example>
	</function>
	<function name="set-evaluation-context" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:set-evaluation-context">
		<summary>Set the evaluation context of the domain. An error is raised if the domain cannot be found. If the domain already has triggers associated with it, the triggers will be modified to act in the new evaluation context.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="context" type="element(dom:evaluation-context)" optional="false">The new evaluation context of the domain. Create using dom:evaluation-context.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:set-evaluation-context( "Incoming",
       dom:evaluation-context( xdmp:database("Modules"), "/apps/" )
  )

</example>
	</function>
	<function name="set-permissions" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:set-permissions">
		<summary>Set the permissions of the domain. An error is raised if the domain cannot be found. If the triggers associated with the domain will be modified also.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">New permissions for the domain.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:set-permissions( "Incoming", xdmp:default-permissions() )


</example>
	</function>
	<function name="add-permissions" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:add-permissions">
		<summary>Add permissions to the domain. An error is raised if the domain cannot be found. The triggers associated with the domain will be modified also.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Additional permissions for the domain.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:add-permissions( "Incoming",
	              xdmp:permission("development", "read") )

</example>
	</function>
	<function name="remove-permissions" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:remove-permissions">
		<summary>Remove permissions to the domain. An error is raised if the domain cannot be found. The triggers associated with the domain will be modified also.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Permissions to remove.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:remove-permissions( "Incoming",
	                 xdmp:permission("development", "read") )

</example>
	</function>
	<function name="add-pipeline" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:add-pipeline">
		<summary>Add another pipeline to the set of pipelines bound to the domain. An error is raised if the domain cannot be found or the pipeline does not exist.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="pipeline-id" type="xs:unsignedLong" optional="false">The unique id of the pipeline.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  dom:add-pipeline( "Incoming",
	         p:get("Entity Extraction")/p:pipeline-id )

</example>
	</function>
	<function name="set-pipelines" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:set-pipelines">
		<summary>Bind a new set of pipelines to the domain. An error is raised if the domain cannot be found or any of the pipelines does not exist. If the domain already has pipelines associated with it, those existing pipelines will not be deleted; only the association will be broken.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="pipelines" type="xs:unsignedLong*" optional="false">The unique ids of the pipelines.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  dom:set-pipelines( "Incoming", (
     p:get("Status Change Handling")/p:pipeline-id,
     p:get("Basic Conversion")/p:pipeline-id ) )

</example>
	</function>
	<function name="remove-pipeline" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:remove-pipeline">
		<summary>Remove the association between a pipeline and the domain. An error is raised if the domain cannot be found. Only the association between the domain and the pipeline will be broken: the existing pipeline will not be deleted and may still be active in other domains.</summary>
		<params>
			<param name="domain-name" type="xs:string" optional="false">The name of the domain to be changed.</param>
			<param name="pipeline-id" type="xs:unsignedLong" optional="false">The pipeline to be removed from the domain.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  dom:remove-pipeline("Incoming", p:get("My Pipeline")/p:pipeline-id)

</example>
	</function>
	<function name="collection" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:collection">
		<summary>Return the name of the collection in which domains are stored.</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:collection()
      ==&gt; returns "http://marklogic.com/cpf/domains"

</example>
	</function>
	<function name="domains" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:domains">
		<summary>Return all the domains.</summary>
		<params />
		<return>element(dom:domain)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  for $domain in dom:domains()
  return $domain/dom:domain-name

</example>
	</function>
	<function name="domain-scope" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:domain-scope">
		<summary>Create a domain scope element.</summary>
		<params>
			<param name="document-scope" type="xs:string" optional="false">The way in which this domain scope is defined: "collection", "directory", or "document".</param>
			<param name="uri" type="xs:string" optional="false">The URI defining the scoping. For a "collection" scope this will be the collection URI; for a "directory" scope this will be the URI of the directory (and must therefore end with a trailing slash); for a "document" scope this will be the URI of the document.</param>
			<param name="depth" type="xs:string?" optional="false">This parameter applies only to "directory" scopes and defines whether the scope is recursive ("infinity") or not ("0").</param>
		</params>
		<return>element(dom:domain-scope)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:set-domain-scope( "Test",
                       dom:domain-scope( "document",
                          "http://example.com/test.xml",
	                 () )
  )

</example>
	</function>
	<function name="evaluation-context" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:evaluation-context">
		<summary>Create an evaluation context element.</summary>
		<params>
			<param name="database" type="xs:unsignedLong" optional="false">The unique identifier of the database in which the content processing actions will be executed. All the modules used in the content processing application must be in this database.</param>
			<param name="root" type="xs:string" optional="false">A root path under which modules are located.</param>
		</params>
		<return>element(dom:evaluation-context)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  dom:set-evaluation-context( "Test",
     dom:evaluation-context( xdmp:database("Modules"), "/" )
  )

</example>
	</function>
	<function name="configuration-set-evaluation-context" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:configuration-set-evaluation-context">
		<summary>Set a new context for the CPF configuration. This will ripple down to the restart trigger as well.</summary>
		<params>
			<param name="context" type="element(dom:evaluation-context)" optional="false">An evaluation-context element (for example, from the output of
				<code>dom:evaluation-context</code>.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

dom:configuration-set-evaluation-context(
     dom:evaluation-context( xdmp:database("Modules"), "/" ) )

</example>
	</function>
	<function name="configuration-set-restart-user" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:configuration-set-restart-user">
		<summary>Set a new restart user for the CPF configuration. This will ripple down to the restart trigger as well.</summary>
		<params>
			<param name="restart-user" type="xs:string" optional="false">The username for the restart user.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

dom:configuration-set-restart-user( "admin" )

</example>
	</function>
	<function name="configuration-set-default-domain" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:configuration-set-default-domain">
		<summary>Set a new default domain for the CPF configuration.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The domain ID of the default domain.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

dom:configuration-set-default-domain(
   fn:data(dom:get("my-domain")/dom:domain-id) )

</example>
	</function>
	<function name="configuration-set-permissions" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:configuration-set-permissions">
		<summary>Set new permissions for the CPF configuration. This will ripple down to the restart trigger as well.</summary>
		<params>
			<param name="permissions" type="element(sec:permission)*" optional="false">The permissions for the configuration.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

dom:configuration-set-permissions( (xdmp:permission('my-role', 'read'),
   xdmp:permission('my-role', 'execute') ) )

</example>
	</function>
	<function name="configuration-create" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:configuration-create">
		<summary>Create a new CPF configuration.</summary>
		<params>
			<param name="restart-user" type="xs:string" optional="false">The username for the user who runs the restart trigger.</param>
			<param name="evaluation-context" type="element(dom:evaluation-context)" optional="false">The evaluation-context element (for example, from the output of
				<code>dom:evaluation-context</code>for the domain.</param>
			<param name="default-domain" type="xs:unsignedLong" optional="false">The ID of the default domain.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Zero or more permissions elements.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

dom:configuration-create( "admin",
   dom:evaluation-context( xdmp:database("Modules"), "/" ),
   fn:data(dom:get("my-domain")/dom:domain-id),
   (xdmp:permission('my-role', 'read'),
   xdmp:permission('my-role', 'execute') )
)

</example>
	</function>
	<function name="configuration-get" type="domain" lib="dom" category="Domains" bucket="CPF Functions" hidden="false" fullname="dom:configuration-get">
		<summary>Returns the CPF configuration.</summary>
		<return>element(dom:configuration)</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

dom:configuration-get()

</example>
	</function>
	<function name="describe-images" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-images">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeImages.html">DescribeImages</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="image-ids" type="xs:string*" optional="true">Sets the ImageId parameter on the Amazon function.</param>
			<param name="executable-by" type="xs:string*" optional="true">Sets the ExecutableBy parameter on the Amazon function.</param>
			<param name="owners" type="xs:string*" optional="true">Sets the Owner parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-availability-zones" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-availability-zones">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeAvailabilityZones.html">DescribeAvailabilityZones</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="zone-name" type="xs:string*" optional="true">Sets the ZoneName parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-regions" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-regions">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeRegions.html">DescribeRegions</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="region-names" type="xs:string*" optional="true">Sets the RegionName.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="attach-volume" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:attach-volume">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AttachVolume.html">AttachVolume</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="volume-id" type="xs:string" optional="false">Sets the VolumeId parameter on the Amazon function.</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="device" type="xs:string" optional="false">Sets the Device parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="create-snapshot" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:create-snapshot">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateSnapshot.html">CreateSnapshot</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="volume-id" type="xs:string" optional="false">Sets the VolumeId parameter on the Amazon function.</param>
			<param name="description" type="xs:string?" optional="true">Sets the Description parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="create-volume" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:create-volume">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateVolume.html">CreateVolume</a>function without a SnapshotId parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="availability-zone" type="xs:string" optional="false">Sets the AvailabilityZone parameter on the Amazon function.</param>
			<param name="size" type="xs:integer" optional="false">Sets the Size parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="create-volume-from-snapshot" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:create-volume-from-snapshot">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateVolume.html">CreateVolume</a>function with a
			<code>$snapshot-id</code>parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="availability-zone" type="xs:string" optional="false">Sets the AvailabilityZone parameter on the Amazon function.</param>
			<param name="snapshot-id" type="xs:string" optional="false">Sets the SnapshotId parameter on the Amazon function.</param>
			<param name="size" type="xs:integer?" optional="true">Sets the Size parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="delete-snapshot" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:delete-snapshot">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteSnapshot.html">DeleteSnapshot</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="snapshot-id" type="xs:string" optional="false">Sets the SnapshotId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="delete-volume" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:delete-volume">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteVolume.html">DeleteVolume</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="volume-id" type="xs:string" optional="false">Sets the VolumeId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-snapshot-create-volume-permission" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-snapshot-create-volume-permission">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshotAttribute.html">DescribeSnapshotAttribute</a>function and passes
			<code>createVolumePermission</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="snapshot-ids" type="xs:string*" optional="false">Sets the SnapshotId.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-snapshots" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-snapshots">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="snapshot-ids" type="xs:string*" optional="true">Sets the SnapshotId.n parameter on the Amazon function.</param>
			<param name="owners" type="xs:string*" optional="true">Sets the Owner parameter on the Amazon function.</param>
			<param name="restorable-bys" type="xs:string*" optional="true">Sets the RestorableBy parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-volumes" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-volumes">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeVolumes.html">DescribeVolumes</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="volume-ids" type="xs:string*" optional="true">Sets the VolumeId.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="detach-volume" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:detach-volume">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DetachVolume.html">DetachVolume</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="volume-id" type="xs:string" optional="false">Sets the VolumeId parameter on the Amazon function.</param>
			<param name="instance-id" type="xs:string?" optional="true">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="device" type="xs:string?" optional="true">Sets the Device parameter on the Amazon function.</param>
			<param name="force" type="xs:boolean?" optional="true">Sets the Force parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="add-snapshot-create-volume-permission-users" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:add-snapshot-create-volume-permission-users">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifySnapshotAttribute.html">ModifySnapshotAttribute</a>function and passes the IDs of the users to be given permission to create the snapshot. This function sets
			<code>add</code>as the OperationType parameter and
			<code>createVolumePermission</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="snapshot-ids" type="xs:string*" optional="false">Sets the SnapshotId parameter on the Amazon function.</param>
			<param name="user-ids" type="xs:string*" optional="false">Sets the UserId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="add-snapshot-create-volume-permission-groups" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:add-snapshot-create-volume-permission-groups">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifySnapshotAttribute.html">ModifySnapshotAttribute</a>function and passes the the names of the groups to be given permission to create the snapshot. This function sets
			<code>add</code>as the OperationType parameter and
			<code>createVolumePermission</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="snapshot-ids" type="xs:string*" optional="false">Sets the SnapshotId parameter on the Amazon function.</param>
			<param name="user-groups" type="xs:string*" optional="false">Sets the UserGroup parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="remove-snapshot-create-volume-permission-users" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:remove-snapshot-create-volume-permission-users">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifySnapshotAttribute.html">ModifySnapshotAttribute</a>function and passes the IDs of the users to be denied permission to create the snapshot. This function sets
			<code>remove</code>as the OperationType parameter and
			<code>createVolumePermission</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="snapshot-ids" type="xs:string*" optional="false">Sets the SnapshotId parameter on the Amazon function.</param>
			<param name="user-ids" type="xs:string*" optional="false">Sets the UserId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="remove-snapshot-create-volume-permission-groups" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:remove-snapshot-create-volume-permission-groups">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifySnapshotAttribute.html">ModifySnapshotAttribute</a>function and passes the the names of the groups to be denied permission to create the snapshot. This function sets
			<code>remove</code>as the OperationType parameter and
			<code>createVolumePermission</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="snapshot-ids" type="xs:string*" optional="false">Sets the SnapshotId parameter on the Amazon function.</param>
			<param name="user-groups" type="xs:string*" optional="false">Sets the UserGroup parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="reset-snapshot-create-volume-permission" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:reset-snapshot-create-volume-permission">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ResetSnapshotAttribute.html">ResetSnapshotAttribute</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="snapshot-ids" type="xs:string*" optional="false">Sets the SnapshotId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="allocate-address" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:allocate-address">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AllocateAddress.html">AllocateAddress</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
		</params>
		<return>node()</return>
	</function>
	<function name="associate-address" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:associate-address">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AssociateAddress.html">AssociateAddress</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="public-ip" type="xs:string" optional="false">Sets the PublicIp parameter on the Amazon function.</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-addresses" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-addresses">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeAddresses.html">DescribeAddresses</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="public-ips" type="xs:string*" optional="true">Sets the PublicIp.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="disassociate-address" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:disassociate-address">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DisassociateAddress.html">DisassociateAddress</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="public-ip" type="xs:string" optional="false">Sets the PublicIp parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="release-address" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:release-address">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ReleaseAddress.html">ReleaseAddress</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="public-ip" type="xs:string" optional="false">Sets the PublicIp parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="get-console-output" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:get-console-output">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-GetConsoleOutput.html">GetConsoleOutput</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instance-block-device-mapping" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instance-block-device-mapping">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstanceAttribute.html">DescribeInstanceAttribute</a>function and passes
			<code>blockDeviceMapping</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instance-disable-api-termination" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instance-disable-api-termination">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstanceAttribute.html">DescribeInstanceAttribute</a>function and passes
			<code>disableApiTermination</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instance-initiated-shutdown-behavior" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instance-initiated-shutdown-behavior">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstanceAttribute.html">DescribeInstanceAttribute</a>function and passes
			<code>instanceInitiatedShutdownBehavior</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instance-kernel" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instance-kernel">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstanceAttribute.html">DescribeInstanceAttribute</a>function and passes
			<code>kernel</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instance-ramdisk" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instance-ramdisk">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstanceAttribute.html">DescribeInstanceAttribute</a>function and passes
			<code>ramdisk</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instance-root-device-name" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instance-root-device-name">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstanceAttribute.html">DescribeInstanceAttribute</a>function and passes
			<code>rootDeviceName</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instance-type" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instance-type">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstanceAttribute.html">DescribeInstanceAttribute</a>function and passes
			<code>instanceType</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instance-user-data" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instance-user-data">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstanceAttribute.html">DescribeInstanceAttribute</a>function and passes
			<code>userData</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-instances" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-instances">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstances.html">DescribeInstances</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string*" optional="true">Sets the InstanceId.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="modify-instance-block-device-mapping" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:modify-instance-block-device-mapping">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>function and passes
			<code>blockDeviceMapping</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="value" type="xs:string" optional="false">Sets the Value parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="modify-instance-disable-api-termination" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:modify-instance-disable-api-termination">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>function and passes
			<code>disableApiTermination</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="value" type="xs:boolean" optional="false">Sets the Value parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="modify-instance-initiated-shutdown-behavior" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:modify-instance-initiated-shutdown-behavior">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>function and passes
			<code>instanceInitiatedShutdownBehavior</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="value" type="xs:string" optional="false">Sets the Value parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="modify-instance-kernel" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:modify-instance-kernel">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>function and passes
			<code>kernel</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="value" type="xs:string" optional="false">Sets the Value parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="modify-instance-ramdisk" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:modify-instance-ramdisk">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>function and passes
			<code>ramdisk</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="value" type="xs:string" optional="false">Sets the Value parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="modify-instance-root-device-name" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:modify-instance-root-device-name">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>function and passes
			<code>rootDeviceName</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="value" type="xs:string" optional="false">Sets the Value parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="modify-instance-type" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:modify-instance-type">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>function and passes
			<code>instanceType</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="value" type="xs:string" optional="false">Sets the Value parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="modify-instance-user-data" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:modify-instance-user-data">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>function and passes
			<code>userData</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-id" type="xs:string" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="value" type="xs:string" optional="false">Sets the Value parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="reboot-instances" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:reboot-instances">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RebootInstances.html">RebootInstances</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string+" optional="false">Sets the InstanceId.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="reset-instance-kernel" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:reset-instance-kernel">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ResetInstanceAttribute.html">ResetInstanceAttribute</a>function and passes
			<code>kernel</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string*" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="reset-instance-ramdisk" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:reset-instance-ramdisk">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ResetInstanceAttribute.html">ResetInstanceAttribute</a>function and passes
			<code>ramdisk</code>as the Attribute parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string*" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="run-instances" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:run-instances">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RunInstances.html">RunInstances</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="image-id" type="xs:string" optional="false">Sets the ImageId parameter on the Amazon function.</param>
			<param name="min-count" type="xs:integer" optional="false">Sets the MinCount parameter on the Amazon function.</param>
			<param name="max-count" type="xs:integer" optional="false">Sets the MaxCount parameter on the Amazon function.</param>
			<param name="instance-type" type="xs:string?" optional="false">Sets the InstanceType parameter on the Amazon function.</param>
			<param name="key-pair" type="xs:string?" optional="false">Sets the KeyName parameter on the Amazon function.</param>
			<param name="security-group" type="xs:string*" optional="false">Sets the SecurityGroup.n parameter on the Amazon function.</param>
			<param name="instance-options" type="xs:string*" optional="false">Sets the any number of optional parameters on the Amazon function. Specify using the form: ("name=value", "name=value").</param>
		</params>
		<return>node()</return>
	</function>
	<function name="start-instances" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:start-instances">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-StartInstances.html">StartInstances</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string+" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="stop-instances" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:stop-instances">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-StopInstances.html">StopInstances</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string+" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
			<param name="force" type="xs:boolean" optional="false">Sets the Force parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="terminate-instances" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:terminate-instances">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-TerminateInstances.html">TerminateInstances</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string+" optional="false">Sets the InstanceId parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="create-key-pair" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:create-key-pair">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateKeyPair.html">CreateKeyPair</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="key-name" type="xs:string" optional="false">Sets the KeyName parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="delete-key-pair" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:delete-key-pair">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteKeyPair.html">DeleteKeyPair</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="key-name" type="xs:string" optional="false">Sets the KeyName parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-key-pairs" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-key-pairs">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeKeyPairs.html">DescribeKeyPairs</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="key-names" type="xs:string*" optional="true">Sets the KeyName.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="monitor-instances" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:monitor-instances">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-MonitorInstances.html">MonitorInstances</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string+" optional="false">Sets the InstanceId.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="unmonitor-instances" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:unmonitor-instances">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-UnmonitorInstances.html">UnmonitorInstances</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="instance-ids" type="xs:string+" optional="false">Sets the InstanceId.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="authorize-group-ingress" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:authorize-group-ingress">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AuthorizeSecurityGroupIngress.html">AuthorizeSecurityGroupIngress</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="source-group-owner-id" type="xs:string" optional="false">Sets the IpPermissions.n.Groups.m.UserId parameter on the Amazon function.</param>
			<param name="source-group-name" type="xs:string" optional="false">Sets the IpPermissions.n.Groups.m.GroupName parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="authorize-icmp-ingress" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:authorize-icmp-ingress">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AuthorizeSecurityGroupIngress.html">AuthorizeSecurityGroupIngress</a>function and passes
			<code>icmp</code>as the IpPermissions.n.IpProtocol parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="icmp-type" type="xs:integer" optional="false">Sets the IpPermissions.n.FromPort parameter on the Amazon function.</param>
			<param name="icmp-code" type="xs:integer" optional="false">Sets the IpPermissions.n.ToPort parameter on the Amazon function.</param>
			<param name="cidr-ip" type="xs:string" optional="false">Sets the IpPermissions.n.IpRanges.m.CidrIp parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="authorize-tcp-ingress" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:authorize-tcp-ingress">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AuthorizeSecurityGroupIngress.html">AuthorizeSecurityGroupIngress</a>function and passes
			<code>tcp</code>as the IpPermissions.n.IpProtocol parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="port-range" type="xs:integer+" optional="false">Sets both the IpPermissions.n.FromPort and IpPermissions.n.ToPort parameters on the Amazon function. Specify value as (FromPort, ToPort).</param>
			<param name="cidr-ip" type="xs:string" optional="false">Sets the CidrIp parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="authorize-udp-ingress" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:authorize-udp-ingress">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AuthorizeSecurityGroupIngress.html">AuthorizeSecurityGroupIngress</a>function and passes
			<code>udp</code>as the IpPermissions.n.IpProtocol parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="port-range" type="xs:integer+" optional="false">Sets both the IpPermissions.n.FromPort and IpPermissions.n.ToPort parameters on the Amazon function. Specify value as (FromPort, ToPort).</param>
			<param name="cidr-ip" type="xs:string" optional="false">Sets the CidrIp parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="create-security-group" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:create-security-group">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateSecurityGroup.html">CreateSecurityGroup</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="group-description" type="xs:string" optional="false">Sets the GroupDescription parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="delete-security-group" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:delete-security-group">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteSecurityGroup.html">DeleteSecurityGroup</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="describe-security-groups" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:describe-security-groups">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSecurityGroups.html">DescribeSecurityGroups</a>function.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-names" type="xs:string*" optional="true">Sets the GroupName.n parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="revoke-group-ingress" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:revoke-group-ingress">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RevokeSecurityGroupIngress.html">RevokeSecurityGroupIngress</a>function and sets the UserId and GroupName parameters.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="source-group-owner-id" type="xs:string" optional="false">Sets the UserId parameter on the Amazon function.</param>
			<param name="source-group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="revoke-icmp-ingress" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:revoke-icmp-ingress">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RevokeSecurityGroupIngress.html">RevokeSecurityGroupIngress</a>function, passes
			<code>icmp</code>as the IpProtocol parameter, and sets the FromPort, ToPort, and CidrIp parameters.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="icmp-type" type="xs:integer" optional="false">Sets the FromPort parameter on the Amazon function.</param>
			<param name="icmp-code" type="xs:integer" optional="false">Sets the ToPort parameter on the Amazon function.</param>
			<param name="cidr-ip" type="xs:string" optional="false">Sets the CidrIp parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="revoke-tcp-ingress" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:revoke-tcp-ingress">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RevokeSecurityGroupIngress.html">RevokeSecurityGroupIngress</a>function, passes
			<code>tcp</code>as the IpProtocol parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="port-range" type="xs:integer+" optional="false">Sets both the FromPort and ToPort parametersr on the Amazon function. Specify value as (FromPort, ToPort).</param>
			<param name="cidr-ip" type="xs:string" optional="false">Sets the CidrIp parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="revoke-udp-ingress" lib="ec2" category="Elastic Compute Cloud" bucket="XQuery Library Modules" hidden="false" fullname="ec2:revoke-udp-ingress">
		<summary>This function calls the Amazon
			<a href="http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RevokeSecurityGroupIngress.html">RevokeSecurityGroupIngress</a>function, passes
			<code>udp</code>as the IpProtocol parameter.</summary>
		<params>
			<param name="access-key" type="xs:string" optional="false">Your Amazon Access Key ID obtained from your account's Security Credentials.</param>
			<param name="secret-key" type="xs:string" optional="false">Your Amazon Secret Access Key obtained from your account's Security Credentials.</param>
			<param name="ec2-region" type="xs:string" optional="false">The EC2 region you wish to manage. Determines the web service endpoint to be used. Example: "us-east-1"</param>
			<param name="group-name" type="xs:string" optional="false">Sets the GroupName parameter on the Amazon function.</param>
			<param name="port-range" type="xs:integer+" optional="false">Sets both the FromPort and ToPort parameters on the Amazon function. Specify value as (FromPort, ToPort).</param>
			<param name="cidr-ip" type="xs:string" optional="false">Sets the CidrIp parameter on the Amazon function.</param>
		</params>
		<return>node()</return>
	</function>
	<function name="enrich" type="entity" lib="entity" category="Entity Enrichment" bucket="XQuery Library Modules" hidden="false" fullname="entity:enrich">
		<summary>Returns the entity-enriched XML for the given XML node. The entities conform to the MarkLogic-recommended entity markup. If a text node that is being enriched has a parent element with a schema definition that does not allow element children, then that text node is not enriched (for example,
			<code>style</code>elements in an xhtml document).</summary>
		<params>
			<param name="node" type="node()" optional="false">The XML node to be enriched.</param>
		</params>
		<usage>
			<p>The elements that are returned are in the
				<code>http://marklogic.com/entity</code>namespace, bound to the prefix
				<code>e</code>. The names and descriptions of the marked-up elements are as follows:</p>
			<dl>
				<dt>
					<code>e:credit-card-number</code>
				</dt>
				<dd>A number representing a credit card number.</dd>
				<dt>
					<code>e:coordinate</code>
				</dt>
				<dd>Latitude and longitude coordinates.</dd>
				<dt>
					<code>e:date</code>
				</dt>
				<dd>Date-related.</dd>
				<dt>
					<code>e:distance</code>
				</dt>
				<dd>A distance.</dd>
				<dt>
					<code>e:email</code>
				</dt>
				<dd>Identifies an email address.</dd>
				<dt>
					<code>e:gpe</code>
				</dt>
				<dd>Geo-political entity. Differs from location because it has a person-made aspect to it (for example, California is a GPE because its boundaries were defined by a government).</dd>
				<dt>
					<code>e:facility</code>
				</dt>
				<dd>A place used as a facility.</dd>
				<dt>
					<code>e:id</code>
				</dt>
				<dd>A number identifying a social security number or other ID number.</dd>
				<dt>
					<code>e:location</code>
				</dt>
				<dd>A geographic location (Mount Everest, for example).</dd>
				<dt>
					<code>e:money</code>
				</dt>
				<dd>Identifies currency (dollars, euros, and so on).</dd>
				<dt>
					<code>e:nationality</code>
				</dt>
				<dd>The nationality of someone or something (for example, American).</dd>
				<dt>
					<code>e:number</code>
				</dt>
				<dd>A number.</dd>
				<dt>
					<code>e:organization</code>
				</dt>
				<dd>An organization.</dd>
				<dt>
					<code>e:person</code>
				</dt>
				<dd>A person.</dd>
				<dt>
					<code>e:phone-number</code>
				</dt>
				<dd>A number identifying a telephone number.</dd>
				<dt>
					<code>e:religion</code>
				</dt>
				<dd>A religion.</dd>
				<dt>
					<code>e:title</code>
				</dt>
				<dd>A title or honorific.</dd>
				<dt>
					<code>e:url</code>
				</dt>
				<dd>A URL on the world wide web.</dd>
				<dt>
					<code>e:utm</code>
				</dt>
				<dd>A point in the Universal Transverse Mercator (UTM) coordinate system.</dd>
				<dt>
					<code>e:time</code>
				</dt>
				<dd>Time-related.</dd>
			</dl>
		</usage>
		<return>node()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

import module namespace entity="http://marklogic.com/entity"
    at "/MarkLogic/entity.xqy";

let $myxml := &lt;node&gt;George Washington never visited Norway.&lt;/node&gt;
return
entity:enrich($myxml)

=&gt; &lt;node xmlns:e="http://marklogic.com/entity"&gt;
	&lt;e:person&gt;George Washington&lt;/e:person&gt; never visited
	&lt;e:gpe&gt;Norway&lt;/e:gpe&gt;.
   &lt;/node&gt;

</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

import module namespace entity="http://marklogic.com/entity"
    at "/MarkLogic/entity.xqy";

let $myxhtml :=
  &lt;p xmlns="http://www.w3.org/1999/xhtml"&gt;George
   Washington never visited
   &lt;style&gt;Norway&lt;/style&gt;.
  &lt;/p&gt;
return
entity:enrich($myxhtml)
(:
   The text inside the style tag is not enriched because
   the xhtml schema does not allow element children
   inside style tags.
:)

=&gt;
&lt;p xmlns="http://www.w3.org/1999/xhtml"&gt;
   &lt;e:person xmlns:e="http://marklogic.com/entity"&gt;George
   Washington&lt;/e:person&gt; never visited
  &lt;style&gt;Norway&lt;/style&gt;.
&lt;/p&gt;

</example>
	</function>
	<function name="clean" type="excel" lib="excel" category="Excel Conversion" bucket="CPF Functions" hidden="false" fullname="excel:clean">
		<summary>Clean up any conversion artifacts or other infelicities, putting each sheet into its own div element.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The source URI of the converted spreadsheet.</param>
			<param name="doc" type="node()?" optional="false">The XHTML produced by conversion of a Microsoft Excel spreadsheet.</param>
		</params>
		<return>node()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace excel = "http://marklogic.com/cpf/excel"
	         at "/MarkLogic/conversion/excel.xqy";

  excel:clean("my_xls.xhtml", fn:doc("my_xls.xhtml"))

</example>
	</function>
	<function name="node-set" type="builtin" lib="exsl" category="Extension" subcategory="XSLT" hidden="false" bucket="MarkLogic Built-In Functions" fullname="exsl:node-set">
		<summary>Returns a sequence of nodes based on the input object. If the input is a sequence of nodes, it is returned as it is. If it is a node, it is simply returned as a singleton sequence. For all other atomic types, a text node is returned based on the string-value of the type. This was a useful function in XSLT 1.0 where "Result Tree Fragments" are returned as a result of xslt instruction. In XSLT 2.0, however, xslt instructions return sequences. This function is simply being provided for backward compatibility to existing applications.</summary>
		<params>
			<param name="value" type="xs:anyAtomicType*" optional="false">The given object
				<code>$value</code>which needs to be converted into sequence.</param>
		</params>
		<return>xs:string</return>
		<usage>This function is based on the EXSLT functions (
			<a href="http://www.exslt.org/" target="_blank">http://www.exslt.org/</a>).</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

xdmp:xslt-eval(
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                   xmlns:exsl="http://exslt.org/common"
                   extension-element-prefixes="exsl"
                   version="2.0"&gt;
     &lt;xsl:template match="/"&gt;
       &lt;xsl:value-of select="count(exsl:node-set(//element()))" /&gt;
     &lt;/xsl:template&gt;
   &lt;/xsl:stylesheet&gt;
,
document{
 &lt;doc&gt;
   &lt;one /&gt;
   &lt;two /&gt;
   &lt;three /&gt;
   &lt;four /&gt;
&lt;/doc&gt;})

=&gt; 5

</example>
	</function>
	<function name="object-type" type="builtin" lib="exsl" category="Extension" subcategory="XSLT" hidden="false" bucket="MarkLogic Built-In Functions" fullname="exsl:object-type">
		<summary>Returns a string that contains the type-name of the object passed as the argument.</summary>
		<params>
			<param name="value" type="atomic type" optional="false">The given object
				<code>$value</code>whose type needs to be found.</param>
		</params>
		<return>xs:string</return>
		<usage>This function is based on the EXSLT functions (
			<a href="http://www.exslt.org/" target="_blank">http://www.exslt.org/</a>).</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

xdmp:xslt-eval(
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                   xmlns:exsl="http://exslt.org/common"
                   extension-element-prefixes="exsl"
                   version="2.0"&gt;
     &lt;xsl:variable name="string" select="'fred'" /&gt;
     &lt;xsl:variable name="number" select="93.7" /&gt;
     &lt;xsl:variable name="boolean" select="true()" /&gt;
     &lt;xsl:variable name="node-set" select="//element()" /&gt;
     &lt;xsl:template match="/"&gt;
        ;
        &lt;xsl:value-of select="exsl:object-type($string)" /&gt;;
        &lt;xsl:value-of select="exsl:object-type($number)" /&gt;;
        &lt;xsl:value-of select="exsl:object-type($boolean)" /&gt;;
        &lt;xsl:value-of select="exsl:object-type($node-set)" /&gt;
     &lt;/xsl:template&gt;
   &lt;/xsl:stylesheet&gt;
,
document{&lt;doc/&gt;})

=&gt;
     ;
     string;
     number;
     boolean;
     node-set

</example>
	</function>
	<function name="configuration-domain-ids" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-domain-ids">
		<summary>This function returns the IDs of the domains configured for the Master database.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  flexrep:configuration-domain-ids  ( )

  (: Returns the IDs of the domains used by the database on which the query
     is executed. )

</pre>

</example>
	</function>
	<function name="configuration-create" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-create">
		<summary>This function creates a new replication configuration element. The returned element must be subsequently inserted to the database with
			<code>flexrep:configuration-insert</code>.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: This query must be executed on the Master database. :)

  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the ID of the replicated CPF domain from the Triggers database. :)
  let $domain:= xdmp:eval(
    'xquery version "1.0-ml";
     import module namespace dom = "http://marklogic.com/cpf/domains"
       at "/MarkLogic/cpf/domains.xqy";
     fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
     (),
     &lt;options xmlns="xdmp:eval"&gt;
       &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
     &lt;/options&gt;)

   (: Create a replication configuration for the Replicated Content domain. :)
   let $cfg := flexrep:configuration-create($domain)

   (: Insert the replication configuration element into the database. :)
   return flexrep:configuration-insert($cfg)

   (: Create a new replication configuration element for the Replication
      Content domain and insert it into the Master database. :)

</pre>

</example>
	</function>
	<function name="configuration-insert" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-insert">
		<summary>This function inserts a replication configuration to the database.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $cfg := flexrep:configuration-target-set-enabled(
	 $cfg,
	 $target-id,
	 fn:false())

  return flexrep:configuration-insert($cfg)

  (: Disables push replication on the Master database. :)

</pre>

</example>
	</function>
	<function name="configuration-get" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-get">
		<summary>This function gets the replication configuration for a CPF domain.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="assert" type="xs:boolean" optional="true">Set to
				<code>true</code>to throw an exception if the configuration does not exist. The default value is
				<code>false</code>.</param>
		</params>
		<return>element(flexrep:configuration)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  return
      flexrep:configuration-get($domain, fn:true())

  (: Returns the replication configuration element for the "Replicated Content"
     domain. :)

</pre>

</example>
	</function>
	<function name="configuration-delete" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-delete">
		<summary>This function deletes a replication configuration. This removes the configuration document as well as any other documents that were created to track replication state. The properties that track state within individual documents are not removed.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain := xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  return flexrep:configuration-delete($domain)

  (: Deletes the replication configuration for the "Replicated Content" domain. :)

</pre>

</example>
	</function>
	<function name="target-create" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:target-create">
		<summary>This function creates a new target and add it to the specified configuration. A random ID is chosen for the target. You must subsequently use
			<code>flexrep:configuration-insert</code>to write the modified configuration into the database.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The configuration to which to add the target.</param>
			<param name="name" type="xs:string" optional="false">The name of the target.</param>
			<param name="urls" type="xs:string*" optional="false">The URLs to be used to push replicated content to, with the load spread across them if there is more than one. If none are specified, the target is expected to do a pull.</param>
			<param name="retry-seconds-min" type="xs:unsignedInt?" optional="false">The minimum time to wait before scheduling a push retry.</param>
			<param name="retry-seconds-max" type="xs:unsignedInt?" optional="false">The maximum time to wait before scheduling a push retry.</param>
			<param name="documents-per-batch" type="xs:unsignedInt?" optional="false">The number of documents to attempt to replicate from a single invocation of the scheduled replication task.</param>
			<param name="enabled" type="xs:boolean?" optional="false">Specifies whether or not this target is enabled.</param>
			<param name="http-options" type="element(flexrep:http-options)?" optional="false">The HTTP options in XML format.</param>
			<param name="replicate-cpf" type="xs:boolean?" optional="false">Determines whether to replicate CPF. Set to
				<code>fn:true</code>to replicate CPF. Otherwise set to
				<code>fn:false</code>. In most circumstances, you will not want to replicate CPF.</param>
			<param name="filter-module" type="xs:string?" optional="false">A main module to filter replication attempts.</param>
			<param name="filter-options" type="element(flexrep:filter-options)?" optional="false">The options to pass to the filter module.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the ID of the replicated CPF domain from the Triggers database. :)
  let $domain:= xdmp:eval(
    'xquery version "1.0-ml";
    import module namespace dom = "http://marklogic.com/cpf/domains"
      at "/MarkLogic/cpf/domains.xqy";
    fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
    (),
    &lt;options xmlns="xdmp:eval"&gt;
      &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
    &lt;/options&gt;)

  (: Obtain the replication configuration. :)
  let $cfg := flexrep:configuration-get($domain, fn:true())

  (: Specify the HTTP options for the replication target. :)
  let $http-options :=
    &lt;flexrep:http-options
      xmlns:flexrep="http://marklogic.com/xdmp/flexible-replication"&gt;
      &lt;http:authentication xmlns:http="xdmp:http"&gt;
        &lt;http:username&gt;admin&lt;/http:username&gt;
        &lt;http:password&gt;admin&lt;/http:password&gt;
      &lt;/http:authentication&gt;
      &lt;http:client-cert xmlns:http="xdmp:http"/&gt;
      &lt;http:client-key xmlns:http="xdmp:http"/&gt;
      &lt;http:pass-phrase xmlns:http="xdmp:http"/&gt;
    &lt;/flexrep:http-options&gt;

  (: Create the replication target. :)
  let $cfg := flexrep:target-create(
    $cfg,
    "Replica",
    "http://localhost:8011/",
    60,
    300,
    10,
    fn:true(),
    $http-options,
    fn:false(),
    (),
    () )

  (: Insert the changes to the replication configuration. :)
  return flexrep:configuration-insert($cfg)

  (: Creates a replication target, named "Replica." :)

</pre>

</example>
	</function>
	<function name="target-delete" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:target-delete">
		<summary>This function deletes a target from a replication configuration. You must use the
			<code>flexrep:configuration-insert</code>function to insert the configuration for the delete to take place. When the configuration is inserted, any additional documents created to track state for the target will be removed.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The target ID.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute on the Master database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $cfg := flexrep:target-delete(
        $cfg,
        $target-id)

  return flexrep:configuration-insert($cfg)

  (: Deletes the target, named "Replica," from the Master database. :)

</pre>

</example>
	</function>
	<function name="configuration-targets" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-targets">
		<summary>This function returns the replication targets for a configuration.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
		</params>
		<return>element(flexrep:target)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  return flexrep:configuration-targets($cfg)

  (: Returns the replication targets configured for the Default Master domain. :)

</pre>

</example>
	</function>
	<function name="configuration-target" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target">
		<summary>This function returns a specified target for a configuration, or throws an error if it does not exist.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The target ID.</param>
			<param name="assert" type="xs:boolean" optional="true">Set to
				<code>true</code>to throw an exception if the configuration does not exist. The default value is
				<code>false</code>.</param>
		</params>
		<return>element(flexrep:target)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return flexrep:configuration-target($cfg, $target-id, fn:true())

  (: Returns the configuration for the "Replica" target. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-id" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-id">
		<summary>This function returns the ID of the named replicaiton target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-name" type="xs:string" optional="false">The name of the replication target.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  return
      flexrep:configuration-target-get-id($cfg, "Replica")

  (: Returns the ID of the target named "Replica." :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-name" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-name">
		<summary>This function returns the name of the specified target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  return
      flexrep:configuration-target-get-name($cfg, 5840231460767636990)

  (: Returns the name of the specified target. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-urls" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-urls">
		<summary>This function returns the URLs for the specified targets.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-urls($cfg, $target-id)

  (: Returns the URLs associated with the "Replica" target. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-retry-seconds-min" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-retry-seconds-min">
		<summary>This function returns the value of the minimum retry setting for the replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-retry-seconds-min($cfg, $target-id)

  (: Returns the retry value set for the target configuration. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-documents-per-batch" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-documents-per-batch">
		<summary>This function returns the value of the documents-per-batch setting for the replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-documents-per-batch($cfg, $target-id)

  (: Returns the number of replicated documents set to be sent in each batch. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-enabled" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-enabled">
		<summary>This function returns
			<code>true</code>if the specified replication target is enabled, otherwise it returns
			<code>false</code>.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-enabled($cfg, $target-id)

  (: Returns True if the replication target is enabled.  Otherwise, False is
     returned. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-replicate-cpf" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-replicate-cpf">
		<summary>This function returns
			<code>true</code>if CFG replcation is enabled for the specified replication target, otherwise it returns
			<code>false</code>.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-replicate-cpf($cfg, $target-id)

   (: Returns True if CPF replication is enabled for the target.  Otherwise,
      False is returned. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-http-options" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-http-options">
		<summary>This function returns the HTTP options configured for the specified replcation target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>element(flexrep:http-options)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

      let $domain := flexrep:configuration-domain-ids( )

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target_id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-http-options($cfg, $target_id)

  (: Returns the HTTP options for the "Replica" target. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-filter-module" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-filter-module">
		<summary>This function returns the filter module used by the specified replcation target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>element(flexrep:filter-module)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-filter-module($cfg, $target-id)

  (: Returns the name of the filter module used by the replication target. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-filter-options" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-filter-options">
		<summary>This function retunrs the filter options configured for the specified replcation target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>element(flexrep:filter-options)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target_id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-filter-options($cfg, $target_id)

  (: Returns the filter options for the "Replica" target. :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-name" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-name">
		<summary>This function sets the name of the specified replcation target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="val" type="xs:string*" optional="false">The name of the target.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $cfg :=
      flexrep:configuration-target-set-name($cfg, $target-id, "NewTarget")

  return flexrep:configuration-insert($cfg)

  (: Changes the name of the "Replica" target to "NewTarget." :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-urls" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-urls">
		<summary>This function sets the URLs for the specified replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="urls" type="xs:string*" optional="false">One or more URLs for the Replica App Servers.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $cfg := flexrep:configuration-target-set-urls(
         $cfg,
         $target-id,
         "http://server134:8005/")

  return flexrep:configuration-insert($cfg)

  (: Sets the target URL for the "Replica" target to "http://server134:8005/". :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-retry-seconds-min" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-retry-seconds-min">
		<summary>This function sets the replication retry minimum value for the specified replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="val" type="xs:integer" optional="false">The minimum retry value.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $cfg :=
      flexrep:configuration-target-set-retry-seconds-min($cfg, $target-id, 20)

  return flexrep:configuration-insert($cfg)

  (: Sets the minimum retry setting for the "Replica" target to 20. :)

</pre>

</example>
	</function>
	<function name="configuration-target-get-retry-seconds-max" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-get-retry-seconds-max">
		<summary>This function sets the replication retry maximum value for the specified replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:configuration-target-get-retry-seconds-max($cfg, $target-id)

  (: Returns the maximum retry setting for the "Replica" target. :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-documents-per-batch" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-documents-per-batch">
		<summary>This function sets the documents-per-batch value for the specified replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="val" type="xs:integer" optional="false">The number of documents to be replicated in each batch.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $cfg :=
      flexrep:configuration-target-set-documents-per-batch($cfg, $target-id, 20)

  return flexrep:configuration-insert($cfg)

  (: Sets the replicated documents-per-batch setting for the "Replica"
     target to 20. :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-enabled" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-enabled">
		<summary>This function enables or disables the specified replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="val" type="xs:boolean" optional="false">A value of
				<code>true</code>enables the replcation target and a value of
				<code>false</code>disables the replication target.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id(
	$cfg,
	"Replica")

  let $cfg := flexrep:configuration-target-set-enabled(
	 $cfg,
	 $target-id,
	 fn:false())

  return flexrep:configuration-insert($cfg)

  (: Disables push replication on the Master database. :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-replicate-cpf" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-replicate-cpf">
		<summary>This function enables and disables CPF replication.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="val" type="xs:boolean" optional="false">A value of
				<code>true</code>enables CPF replcation on the target and a value of
				<code>false</code>disables CPF replication on the target.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  return flexrep:configuration-get($domain, fn:true())

  (: Returns the current replication configuration. :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-http-options" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-http-options">
		<summary>This function sets the HTTP options on the specified replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="val" type="element(flexrep:http-options)" optional="false">The HTTP options in XML format.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against the Master database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $http-options :=
    &lt;flexrep:http-options
     xmlns:flexrep="http://marklogic.com/xdmp/flexible-replication"&gt;
      &lt;http:authentication xmlns:http="xdmp:http"&gt;
        &lt;http:username&gt;replicator&lt;/http:username&gt;
        &lt;http:password&gt;admin&lt;/http:password&gt;
      &lt;/http:authentication&gt;
      &lt;http:client-cert xmlns:http="xdmp:http"/&gt;
      &lt;http:client-key xmlns:http="xdmp:http"/&gt;
      &lt;http:pass-phrase xmlns:http="xdmp:http"/&gt;
    &lt;/flexrep:http-options&gt;

  let $cfg :=
      flexrep:configuration-target-set-http-options($cfg, $target-id, $http-options)

  return flexrep:configuration-insert($cfg)

  (: Resets the username and password used to access the Replica App Server. :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-filter-module" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-filter-module">
		<summary>This function sets the specified filter for this replication configuration.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="uri" type="xs:string" optional="false">The URI for the filter module.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	    at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $cfg :=
      flexrep:configuration-target-set-filter-module($cfg, $target-id, "test.xqy")

  return flexrep:configuration-insert($cfg)

  (: Resets the filter module used by the target to "test.xqy." :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-filter-options" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-filter-options">
		<summary>This function sets the specified filter options for this replication configuration. The options specified in the
			<code>$val</code>parameter are passed to the
			<code>xdmp:invoke</code>of the filter module, so any of the options you would specify in the
			<code>xdmp:eval</code>function are recognized.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="val" type="element(flexrep:filter-options)" optional="false">The filter options in XML format.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	   at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $filter-opts :=
     &lt;flexrep:filter-options&gt;
       &lt;user-id xmlns="xdmp:eval"&gt;{xdmp:user("John")}&lt;/user-id&gt;
     &lt;/flexrep:filter-options&gt;

  let $cfg :=
    flexrep:configuration-target-set-filter-options(
       $cfg,
       $target-id,
       $filter-opts)

  return flexrep:configuration-insert($cfg)

  (: Sets the filter user to "John". :)

</pre>

</example>
	</function>
	<function name="pull-create" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-create">
		<summary>This function creates a configuration on a Replica database to pull updates from the Master database.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the pull configuration.</param>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the domain containing the replicated content. This value is obtained from the Trigger database used by the Master database.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target. This value is obtained from the Master database.</param>
			<param name="urls" type="xs:string+" optional="false">The URL of the Master App Server.</param>
			<param name="http-options" type="element(flexrep:http-options)?" optional="false">The HTTP options in XML format.</param>
		</params>
		<return>element(flexrep:pull)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: This query must be executed on a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Specify the ID of the replicated CPF domain obtained from the Master's
     Triggers database. :)
  let $domain:= 9535475951259984368

  (: Specify the ID of the replication target obtained from the Master database. :)
  let $target-id := 18130470845627037840

  (: Specify the HTTP options for the replication target. :)
  let $http-options :=
    &lt;flexrep:http-options
     xmlns:flexrep="http://marklogic.com/xdmp/flexible-replication"&gt;
      &lt;http:authentication xmlns:http="xdmp:http"&gt;
        &lt;http:username&gt;admin&lt;/http:username&gt;
        &lt;http:password&gt;admin&lt;/http:password&gt;
      &lt;/http:authentication&gt;
      &lt;http:client-cert xmlns:http="xdmp:http"/&gt;
      &lt;http:client-key xmlns:http="xdmp:http"/&gt;
      &lt;http:pass-phrase xmlns:http="xdmp:http"/&gt;
    &lt;/flexrep:http-options&gt;

  let $pullconfig := flexrep:pull-create(
    "Master",
    $domain,
    $target-id,
    "http://localhost:8010/",
    $http-options)

  (: Insert the pull configuration into the Replica database. :)
  return flexrep:pull-insert($pullconfig)

  (: Creates a pull replication configuration element for the specified domain. :)

</pre>

</example>
	</function>
	<function name="pull-insert" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-insert">
		<summary>This function inserts the specified pull configuration into the Replica database.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration obtained by the
				<code>flexrep:pull-get</code>function.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: This query must be executed on a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Specify the ID of the replicated CPF domain obtained from the Master's
     Triggers database. :)
  let $domain:= 9535475951259984368

  (: Specify the ID of the replication target obtained from the Master database. :)
  let $target-id := 18130470845627037840

  (: Specify the HTTP options for the replication target. :)
  let $http-options :=
    &lt;flexrep:http-options
     xmlns:flexrep="http://marklogic.com/xdmp/flexible-replication"&gt;
      &lt;http:authentication xmlns:http="xdmp:http"&gt;
        &lt;http:username&gt;admin&lt;/http:username&gt;
        &lt;http:password&gt;admin&lt;/http:password&gt;
      &lt;/http:authentication&gt;
      &lt;http:client-cert xmlns:http="xdmp:http"/&gt;
      &lt;http:client-key xmlns:http="xdmp:http"/&gt;
      &lt;http:pass-phrase xmlns:http="xdmp:http"/&gt;
    &lt;/flexrep:http-options&gt;

  let $pullconfig := flexrep:pull-create(
    "Master",
    $domain,
    $target-id,
    "http://localhost:8010/",
    $http-options)

  (: Insert the pull configuration into the Replica database. :)
  return flexrep:pull-insert($pullconfig)

  (: Inserts a pull replication configuration element into the Replica database. :)

</pre>

</example>
	</function>
	<function name="pull-delete" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-delete">
		<summary>This function deletes the pull configuration from the Replica database.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the domain containing the replicated content. This value is obtained from the Trigger database used by the Master database.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $domain := 9535475951259984368

  return  flexrep:pull-delete($domain)

  (: Removes the Pull Replication configuration element from the Replica database. :)

</pre>

</example>
	</function>
	<function name="pull-get" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get">
		<summary>This function returns the pull replication configuration for the specified domain.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the domain containing the replicated content. This value is obtained from the Trigger database used by the Master database.</param>
			<param name="assert" type="xs:boolean" optional="true">Set to
				<code>true</code>to throw an exception if the configuration does not exist. The default value is
				<code>false</code>.</param>
		</params>
		<return>element(flexrep:pull)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
    at "/MarkLogic/flexrep.xqy";

  flexrep:pull-get(9535475951259984368,  fn:true())

  (: Returns the Pull Configuration for the specified domain. :)

</pre>

</example>
	</function>
	<function name="pull-get-all" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get-all">
		<summary>This function returns the pull replication configurations for all of the domains.</summary>
		<params />
		<return>element(flexrep:pull)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against a Master database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  flexrep:pull-get-all()

  (: Returns the Pull Configurations for all of the domains. :)

</pre>

</example>
	</function>
	<function name="pull-get-domain-id" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get-domain-id">
		<summary>This function returns the ID of the domain associated with the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull configuration.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  for $pull-config in flexrep:pull-get-all()

  return flexrep:pull-get-domain-id($pull-config)

  (: Returns the domain IDs associated with each pull configuration. :)

</pre>

</example>
	</function>
	<function name="pull-get-target-id" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get-target-id">
		<summary>This function returns the ID of the target associated with the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  for $pull-config in flexrep:pull-get-all()

  return flexrep:pull-get-target-id($pull-config)

  (: Returns the target IDs associated with each pull configuration. :)

</pre>

</example>
	</function>
	<function name="pull-get-urls" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get-urls">
		<summary>This function returns the URLs associated with the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull configuration.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())

  return flexrep:pull-get-urls($pull-config)

  (: Returns the target URLs associated with the specified pull configuration. :)

</pre>

</example>
	</function>
	<function name="pull-get-http-options" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get-http-options">
		<summary>This function returns the HTTP options associated with the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
		</params>
		<return>element(flexrep:http-options)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())

  return flexrep:pull-get-http-options($pull-config)

  (: Returns the HTTP options associated with the specified pull configuration. :)

</pre>

</example>
	</function>
	<function name="pull-set-urls" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-set-urls">
		<summary>This function sets the URLs for the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
			<param name="urls" type="xs:string+" optional="false">THe URLs to set for the pull configuration.</param>
		</params>
		<return>element(flexrep:pull)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute against a Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())
  let $pull-config := flexrep:pull-set-urls($pull-config, "http://server321:8010/")

  return flexrep:pull-insert($pull-config)

  (: Sets the URL for the specified Pull Configuration to "http://server321:8010/". :)

</pre>

</example>
	</function>
	<function name="pull-set-http-options" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-set-http-options">
		<summary>This function sets the HTTP options for the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
			<param name="http-options" type="element(flexrep:http-options)" optional="false">The HTTP options in XML format to set for the pull configuration.</param>
		</params>
		<return>element(flexrep:pull)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $http-options :=
    &lt;flexrep:http-options
     xmlns:flexrep="http://marklogic.com/xdmp/flexible-replication"&gt;
      &lt;http:authentication xmlns:http="xdmp:http"&gt;
        &lt;http:username&gt;replicator&lt;/http:username&gt;
        &lt;http:password&gt;admin&lt;/http:password&gt;
      &lt;/http:authentication&gt;
      &lt;http:client-cert xmlns:http="xdmp:http"/&gt;
      &lt;http:client-key xmlns:http="xdmp:http"/&gt;
      &lt;http:pass-phrase xmlns:http="xdmp:http"/&gt;
    &lt;/flexrep:http-options&gt;

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())
  let $pull-config := flexrep:pull-set-http-options($pull-config, $http-options)

  return flexrep:pull-insert($pull-config)

  (: Sets the specified HTTP options for the specified Pull Configuration. :)

</pre>

</example>
	</function>
	<function name="configure-database" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configure-database">
		<summary>This function creates any indexes needed for CPF based replication. The input configuration is returned from
			<code>admin:get-configuration</code>and the configuration returned from this function must be inserted again with
			<code>admin:save-confguration</code>for the changes to take effect. This function may be called multiple times for the same database with no ill effect.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">The server configuration returned from
				<code>admin:get-configuration</code></param>
			<param name="dbid" type="xs:unsignedLong" optional="false">The ID of the database to configure.</param>
		</params>
		<return>element(configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()

  let $config := flexrep:configure-database(
	$config,
	xdmp:database("Master"))

  return admin:save-configuration($config)

  (: Creates the indexes needed by the Master database for CPF based replication. :)

</pre>

</example>
	</function>
	<function name="apply" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:apply">
		<summary>This function applies an update element to the current database.</summary>
		<params>
			<param name="update" type="element(flexrep:update)" optional="false">The update element to apply to the database.</param>
			<param name="content" type="document-node()?" optional="false">The updated document node.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $update :=
    &lt;flexrep:update xmlns:flexrep=
      "http://marklogic.com/xdmp/flexible-replication"&gt;
        &lt;doc:uri xmlns:doc="xdmp:document-load"&gt;/content/foo.xml&lt;/doc:uri&gt;
        &lt;flexrep:last-updated&gt;2010-03-04T14:30:16.56-08:00&lt;/flexrep:last-updated&gt;
        &lt;doc:format xmlns:doc="xdmp:document-load"&gt;xml&lt;/doc:format&gt;
        &lt;doc:permissions xmlns:doc="xdmp:document-load"/&gt;
        &lt;doc:collections xmlns:doc="xdmp:document-load"/&gt;
        &lt;doc:document-quality xmlns:doc="xdmp:document-load"&gt;0&lt;/doc:document-quality&gt;
        &lt;prop:properties xmlns:prop="http://marklogic.com/xdmp/property"/&gt;
    &lt;/flexrep:update&gt;

    let $doc := fn:doc("/content/foo.xml")

    return flexrep:apply($update, $doc)

   (: Applies the specified update element to /content/foo.xml. :)

</pre>

</example>
	</function>
	<function name="delete" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:delete">
		<summary>This function applies a delete element to the current database.</summary>
		<params>
			<param name="delete" type="element(flexrep:delete)" optional="false">The delete element to apply to the database.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $delete :=
    &lt;flexrep:delete xmlns:flexrep="http://marklogic.com/xdmp/flexible-replication"&gt;
        &lt;doc:uri xmlns:doc="xdmp:document-load"&gt;/content/foo.xml&lt;/doc:uri&gt;
        &lt;flexrep:last-updated&gt;2010-03-04T14:35:12.714-08:00&lt;/flexrep:last-updated&gt;
    &lt;/flexrep:delete&gt;

   return flexrep:delete($delete)

   (: Applies the specified delete element to /content/foo.xml.  This effectively
      deletes the document from both the Master and Replica databases. :)

</pre>

</example>
	</function>
	<function name="poll" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:poll">
		<summary>This function is used on the master to determine which documents need to be replicated. This function could be used to customize the way pull polling is done (e.g. multiple hosts on the target are polling the master for updates and you want to either have some hosts poll specific forests or you want to have them process different parts of the list of pending documents.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="start" type="xs:integer?" optional="false">Parameter description...</param>
			<param name="size" type="xs:integer?" optional="false">Parameter description...</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="false">Parameter description...</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep =
     "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="process" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:process">
		<summary>This function processes one or more replicated updates for the specified domain ID, ordered by oldest changes first, and returns the results.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="size" type="xs:unsignedInt?" optional="true">The maximum number of replications. If not specified, the maximum is one.</param>
			<param name="targets" type="xs:unsignedLong*" optional="true">The IDs of the replication targets.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">The forest IDs from which to process replications. If none are specified, replications from all forests are considered.</param>
			<param name="uris" type="xs:string*" optional="true">The URIs of specific documents to process.</param>
		</params>
		<return>element(flexrep:results)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain := xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  return flexrep:process($domain)

  (: Processes the replicated updates for the "Replicated Content" domain. :)

</pre>

</example>
	</function>
	<function name="do-pull" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:do-pull">
		<summary>This function is used by a Replica to pull updates from the Master. It returns a list of elements; the first element is the response element that was set back to the master, followed by one or more
			<code>flexrep:ack</code>elements that were posted back to the master.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
		</params>
		<return>element()*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull := flexrep:pull-get(8720056888183458895)

  return flexrep:do-pull($pull)

  (: Returns the response and ACK elements last sent to the master. :)

</pre>

</example>
	</function>
	<function name="domain-status" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:domain-status">
		<summary>This function returns the replication status for the specified replicated CPF domain.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="with-targets" type="xs:boolean" optional="true">Set to
				<code>true</code>to include status information for each target. Otherwise set to
				<code>false</code>.</param>
			<param name="terse" type="xs:boolean" optional="true">Set to
				<code>true</code>to prevent counts from being returned for each of the individual states (deleted, error, updated, and so on). Otherwise set to
				<code>false</code>.</param>
		</params>
		<return>element(flexrep:domain-status)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain := xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return flexrep:domain-status($domain, fn:true(), fn:false())

  (: Returns the status of the domain and its targets. :)

</pre>

</example>
	</function>
	<function name="target-status" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:target-status">
		<summary>This function returns the replication status for the specified targets within the specified replicated domain.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="target-ids" type="xs:unsignedLong*" optional="false">The IDs of the replication targets.</param>
		</params>
		<return>element(flexrep:target-status)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain := xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return flexrep:target-status($domain, $target-id)

  (: Returns the status of the specified target. :)

</pre>

</example>
	</function>
	<function name="remote-target-status" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:remote-target-status">
		<summary>This function returns the status of the target in a pull replication configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration containing the pull target (master database).</param>
		</params>
		<return>element(flexrep:target-status)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute on the Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pullconfig := flexrep:pull-get-by-id(2261113583548708683)

  return flexrep:remote-target-status($pullconfig)

  (: Returns the status of the master database from which replca is pulling
     updates. :)

</pre>

</example>
	</function>
	<function name="document-status" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:document-status">
		<summary>This function returns the
			<code>flexrep:document-status</code>element for the document at the specified URI in the specified domain. The returned
			<code>flexrep:document-status</code>element is extracted from the document's properties, which remain even if the document has been deleted.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
		</params>
		<return>element(flexrep:document-status)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $domain := xdmp:eval(
    'xquery version "1.0-ml";
    import module namespace dom = "http://marklogic.com/cpf/domains"
      at "/MarkLogic/cpf/domains.xqy";
    fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
    (),
    &lt;options xmlns="xdmp:eval"&gt;
      &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
    &lt;/options&gt;)

  return
    flexrep:document-status($domain, "/content/foo.xml")

  (: Returns the status of the document associated with the specified URI and domain. :)

</pre>

</example>
	</function>
	<function name="pull-get-id" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get-id">
		<summary>This function returns the ID for the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())

  return flexrep:pull-get-id($pull-config)

  (: Returns the ID for the specified pull configuration. :)

</pre>

</example>
	</function>
	<function name="pull-get-name" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get-name">
		<summary>This function returns the name of the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())

  return flexrep:pull-get-name($pull-config)

  (: Returns the name of the specified pull configuration. :)

</pre>

</example>
	</function>
	<function name="pull-set-name" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-set-name">
		<summary>This function sets the name of the specified pull configuration</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
			<param name="name" type="xs:string" optional="false">The name to be set for the pull configuration.</param>
		</params>
		<return>element(flexrep:pull)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())
  let $pull-config := flexrep:pull-set-name($pull-config, "MasterRep")

  return flexrep:pull-insert($pull-config)

  (: Sets the name of the specified pull configuration to "MasterRep." :)

</pre>

</example>
	</function>
	<function name="pull-set-domain-id" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-set-domain-id">
		<summary>This function sets the domain ID for the specified pull configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration returned by the
				<code>flexrep:pull-get</code>function.</param>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The domain ID to set for the pull configuration.</param>
		</params>
		<return>element(flexrep:pull)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())
  let $pull-config := flexrep:pull-set-domain-id($pull-config, 2235475951259984368)

  return flexrep:pull-insert($pull-config)

  (: Sets the domain ID for the pull configuration. :)

</pre>

</example>
	</function>
	<function name="pull-set-target-id" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-set-target-id">
		<summary>This function sets the ID of the replication target for the specified pull replication configuration.</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">The pull replication configuration obtained by the
				<code>flexrep:pull-get</code>function.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
		</params>
		<return>element(flexrep:pull)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  let $pull-config := flexrep:pull-get(9535475951259984368, fn:true())
  let $pull-config := flexrep:pull-set-target-id($pull-config, 11130470845627037840)

  return flexrep:pull-insert($pull-config)

  (: Sets the ID of the replication target for the specified pull configuration. :)

</pre>

</example>
	</function>
	<function name="configuration-get-id" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-get-id">
		<summary>This function returns the ID of the replication configuration.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  return flexrep:configuration-get-id($cfg)

  (: Returns the ID of the specified replication configuration. :)

</pre>

</example>
	</function>
	<function name="configuration-get-domain-name" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-get-domain-name">
		<summary>This function returns the domain name associated with the specified replication configuration.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  return flexrep:configuration-get-domain-name($cfg)

  (: Returns the domain name for the specified replication configuration. :)

</pre>

</example>
	</function>
	<function name="domain-target-statuses" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:domain-target-statuses">
		<summary>This function returns the status for each domain target.</summary>
		<params />
		<return>element(flexrep:domain-target-status)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  flexrep:domain-target-statuses()

  (: Returns the status for the targets in each domain configured for the database. :)

</pre>

</example>
	</function>
	<function name="target-error-documents" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:target-error-documents">
		<summary>This function returns status information for documents that failed to replicate for the specified domain and targets. The sequence of status elements returned is ordered in reverse chronological order of the last time replication was attempted for the document.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="target-ids" type="xs:unsignedLong*" optional="false">The ID of the replication target.</param>
		</params>
		<return>element(flexrep:document-target-status)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain := xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return flexrep:target-error-documents($domain, ($target-id))

  (: Returns the status of the documents in the "Replicated Content" domain
    that failed to replicate to the "Replica" target.  :)

</pre>

</example>
	</function>
	<function name="domain-target-reset" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:domain-target-reset">
		<summary>This function resets the URI status for the specified replication targets. A reset involves retaining any record of last success, clearing any failure status, and setting the time for the next replication attempt to the current time. The status is reset for the specified
			<code>$target-ids</code>.
			<p />Resetting the URI status for a target is useful if the document has errored out due to too many failures, or if you want to replicate the document again.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="target-ids" type="xs:unsignedLong*" optional="false">The ID of the replication target.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain := xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return flexrep:domain-target-reset($domain, ($target-id))

  (: Resets the URI status for the "Replica" target. :)

</pre>

</example>
	</function>
	<function name="document-reset" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:document-reset">
		<summary>This function resets the URI status for all replication targets. A reset involves retaining any record of last success, clearing any failure status, and setting the time for the next replication attempt to the current time. The status is reset for the specified
			<code>$target-ids</code>. If no
			<code>$target-ids</code>parameter is specified, then the URI status for all replication targets is reset.
			<p />Resetting the URI status for a target is useful if the document has errored out due to too many failures, or if you want to replicate the document again.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to be assigned the new status.</param>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="target-ids" type="xs:unsignedLong*" optional="true">The ID of the replication target.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain := xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Replicated Content" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("MyTriggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())
  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  return
      flexrep:document-reset("http://localhost:8011/", $domain, $target-id)

  (: Resets the URI status for the "Replica" target. :)

</pre>

</example>
	</function>
	<function name="configuration-target-set-retry-seconds-max" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:configuration-target-set-retry-seconds-max">
		<summary>This function sets the replication retry maximum value for the specified replication target.</summary>
		<params>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">The replication configuration.</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">The ID of the replication target.</param>
			<param name="val" type="xs:integer" optional="false">The maximum retry value.</param>
		</params>
		<return>element(flexrep:configuration)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  (: Obtain the domain ID from the database used by the Master to enable CPF. :)
  let $domain:= xdmp:eval(
        'xquery version "1.0-ml";
         import module namespace dom = "http://marklogic.com/cpf/domains"
            at "/MarkLogic/cpf/domains.xqy";
         fn:data(dom:get( "Default Master" )//dom:domain-id)',
         (),
         &lt;options xmlns="xdmp:eval"&gt;
            &lt;database&gt;{xdmp:database("Triggers")}&lt;/database&gt;
         &lt;/options&gt;)

  let $cfg := flexrep:configuration-get($domain, fn:true())

  let $target-id := flexrep:configuration-target-get-id($cfg, "Replica")

  let $cfg :=
      flexrep:configuration-target-set-retry-seconds-max($cfg, $target-id, 200)

  return flexrep:configuration-insert($cfg)

  (: Sets the minimum retry setting for the "Replica" target to 200. :)

</pre>

</example>
	</function>
	<function name="validate-url" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:validate-url">
		<summary>This function....</summary>
		<params>
			<param name="url" type="xs:string" optional="false">Parameter description...</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="apply-encoded-updates" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:apply-encoded-updates">
		<summary>This function....</summary>
		<params>
			<param name="dts" type="element(flexrep:domain-target-status)" optional="false">Parameter description...</param>
			<param name="boundary" type="xs:string" optional="false">Parameter description...</param>
			<param name="data" type="binary()" optional="false">Parameter description...</param>
		</params>
		<return>element()*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="replicate" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:replicate">
		<summary>This function....</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">Parameter description...</param>
			<param name="label" type="xs:string" optional="false">Parameter description...</param>
			<param name="cfg" type="element(flexrep:configuration)" optional="false">Parameter description...</param>
			<param name="domain" type="element(dom:domain)" optional="false">Parameter description...</param>
			<param name="doc-status" type="element(flexrep:document-status)" optional="false">Parameter description...</param>
			<param name="is-delete" type="xs:boolean" optional="false">Parameter description...</param>
			<param name="is-retry" type="xs:boolean" optional="false">Parameter description...</param>
		</params>
		<return>element(error:error)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="multipart-encode" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:multipart-encode">
		<summary>This function....</summary>
		<params>
			<param name="boundary" type="xs:string" optional="false">Parameter description...</param>
			<param name="parts" type="node()*" optional="false">Parameter description...</param>
		</params>
		<return>binary()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="ack-apply" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:ack-apply">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="acks" type="element(flexrep:ack)*" optional="false">Parameter description...</param>
		</params>
		<return>element(error:error)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="validate-name" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:validate-name">
		<summary>This function....</summary>
		<params>
			<param name="name" type="xs:string" optional="false">Parameter description...</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  flexrep:"validate-name("Master")

  (:  :)

</pre>

</example>
	</function>
	<function name="pull-get-by-id" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:pull-get-by-id">
		<summary>This function returns the pull replication configuration for the specified Pull ID.</summary>
		<params>
			<param name="pull-id" type="xs:unsignedLong" optional="false">The ID of the pull replication configuration.</param>
			<param name="assert" type="xs:boolean" optional="true">Determines whether to generate an error if the pull configuration does not exist. Set to
				<code>fn:true()</code>to generate an error, or
				<code>fn:false()</code>to return an empty sequence if the pull configuration does not exist. The default is
				<code>fn:false()</code>.</param>
		</params>
		<return>element(flexrep:pull)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  (: Execute on the Replica database. :)
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  flexrep:pull-get-by-id(2261113583548708683)

  (: Returns the pull replication configuration for the specified ID. :)

</pre>

</example>
	</function>
	<function name="push-local-forest" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:push-local-forest">
		<summary>This function pushes pending replication updates (either retries or zero-day) for the specified forest on the current host. If any updates are found, a new task is spawned to call this function again. This continues until all pending replication updates have been processed.</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">The ID of the replicated domain.</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">The ID of the replicated forest.</param>
			<param name="max-spawn" type="xs:unsignedLong" optional="false">The limit to the number of doable spawns. If a task respawns itself too many times, a spawn will eventually fail with an exception.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $forest-id :=
      admin:forest-get-id(admin:get-configuration(), "MasterForest")

  return
      flexrep:push-local-forest(5864248273900832906, $forest-id)

  (: Pushes all pending replication updates from the "MasterForest" forest on the host. :)

</pre>

</example>
	</function>
	<function name="push-local-forests" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:push-local-forests">
		<summary>This function pushes deletes and any pending replication updates (either retries or zero-day) from all of the forests on the current host. A separate task is spawned for each combination of CPF domain and local forest which in turn calls the
			<code>push-local-forest</code>to increase parallelism.</summary>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";

  flexrep:push-local-forests()

  (: Pushes all pending replication updates from all of the forests on the host. :)

</pre>

</example>
	</function>
	<function name="database-needs-configuration" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="false" fullname="flexrep:database-needs-configuration">
		<summary>This function checks the configuration of a database to see if it has all of the necessary indexes for Flexible Replication to work at its best. Returns true if the database needs configuration changes, and returns false if the configuration is as-expected.</summary>
		<params>
			<param name="config" type="element(configuration)" optional="false">A configuration specification, typically a call to
				<a href="admin:get-congiguration">admin:get-congiguration</a>.</param>
			<param name="dbid" type="xs:unsignedLong" optional="false">The database ID of the database to check.</param>
		</params>
		<return>xs:boolean</return>
		<usage>Note that this function will return when run against a database that does not have Flexible Replication configured.</usage>
		<example xml:space="preserve">
<pre xml:space="preserve">
xquery version "1.0-ml";

import module namespace flexrep =
      "http://marklogic.com/xdmp/flexible-replication"
      at "/MarkLogic/flexrep.xqy";
import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

flexrep:database-needs-configuration(
  admin:get-configuration(), xdmp:database("Documents") )

  =&gt; true

</pre>

</example>
	</function>
	<function name="push-forest-binaries" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:push-forest-binaries">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="max-spawn" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="push-binary" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:push-binary">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="key" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="push-binary-chunk" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:push-binary-chunk">
		<summary>This function....</summary>
		<params>
			<param name="status-doc" type="document-node()" optional="false">Parameter description...</param>
			<param name="use-server-field" type="xs:boolean" optional="false">Parameter description...</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="push-binary-docs" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:push-binary-docs">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="forest-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="map" type="map:map" optional="false">Parameter description...</param>
		</params>
		<return>element(flexrep:results)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="apply-binary-chunk" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:apply-binary-chunk">
		<summary>This function....</summary>
		<params>
			<param name="key" type="xs:string" optional="false">Parameter description...</param>
			<param name="offset" type="xs:string" optional="false">Parameter description...</param>
			<param name="bn" type="node()" optional="false">Parameter description...</param>
			<param name="forests" type="xs:string*" optional="false">Parameter description...</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="apply-binary-join" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:apply-binary-join">
		<summary>This function....</summary>
		<params>
			<param name="key" type="xs:string" optional="false">Parameter description...</param>
			<param name="forests" type="xs:string*" optional="false">Parameter description...</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="apply-binary-gc" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:apply-binary-gc">
		<summary>This function....</summary>
		<params>
			<param name="key" type="xs:string" optional="false">Parameter description...</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="push-binaries" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:push-binaries">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="poll-binary-chunk" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:poll-binary-chunk">
		<summary>This function....</summary>
		<return>xs:unsignedLong)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="get-update-binarydoc-uri" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:get-update-binarydoc-uri">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="key" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="pull-binaries" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:pull-binaries">
		<summary>This function....</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">Parameter description...</param>
			<param name="max-spawn" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>element()*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="pull-binary-chunk" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:pull-binary-chunk">
		<summary>This function....</summary>
		<params>
			<param name="pull" type="element(flexrep:pull)" optional="false">Parameter description...</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="ack-binary-chunk-apply" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:ack-binary-chunk-apply">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="key" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="offset" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="subsize" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>element(error:error)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="target-binary-push-status-documents" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:target-binary-push-status-documents">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-ids" type="xs:unsignedLong*" optional="false">Parameter description...</param>
		</params>
		<return>element(flexrep:binary-push-status)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="target-binary-push-status-document" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:target-binary-push-status-document">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="uri" type="xs:string" optional="false">Parameter description...</param>
		</params>
		<return>element(flexrep:binary-push-status)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="_binary-push-status-uri" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:_binary-push-status-uri">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="target-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
			<param name="key" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="coalesce-domain-statuses" lib="flexrep" category="Flexible Replication" bucket="XQuery Library Modules" hidden="true" fullname="flexrep:coalesce-domain-statuses">
		<summary>This function....</summary>
		<params>
			<param name="domain-id" type="xs:unsignedLong" optional="false">Parameter description...</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace flexrep = "http://marklogic.com/xdmp/flexrep"
      at "/MarkLogic/flexrep.xqy";


</pre>

</example>
	</function>
	<function name="abs" type="builtin" lib="fn" category="NumericBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:abs">
		<summary>
			<p>Returns the absolute value of $arg. If $arg is negative returns -$arg otherwise returns $arg. If type of $arg is one of the four numeric types xs:float, xs:double, xs:decimal or xs:integer the type of the result is the same as the type of $arg. If the type of $arg is a type derived from one of the numeric types, the result is an instance of the base numeric type.</p>
			<p>For xs:float and xs:double arguments, if the argument is positive zero (+0) or negative zero (-0), then positive zero (+0) is returned. If the argument is positive or negative infinity, positive infinity is returned.</p>
			<p>For detailed type semantics, see Section 7.2.1 The fn:abs, fn:ceiling, fn:floor, fn:round, and fn:round-half-to-even functions of [XQuery 1.0 and XPath 2.0 Formal Semantics].</p>
		</summary>
		<params>
			<param name="arg" type="numeric?" optional="false">A numeric value.</param>
		</params>
		<return>numeric?</return>
		<example xml:space="preserve">
fn:abs(10.5) returns 10.5.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:abs(-10.5) returns 10.5.
</example>
	</function>
	<function name="ceiling" type="builtin" lib="fn" category="NumericBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:ceiling">
		<summary>
			<p>Returns the smallest (closest to negative infinity) number with no fractional part that is not less than the value of $arg. If type of $arg is one of the four numeric types xs:float, xs:double, xs:decimal or xs:integer the type of the result is the same as the type of $arg. If the type of $arg is a type derived from one of the numeric types, the result is an instance of the base numeric type.</p>
			<p>For xs:float and xs:double arguments, if the argument is positive zero, then positive zero is returned. If the argument is negative zero, then negative zero is returned. If the argument is less than zero and greater than -1, negative zero is returned.</p>
			<p>For detailed type semantics, see Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and fn:round-half-to-even functions[FS].</p>
		</summary>
		<params>
			<param name="arg" type="numeric?" optional="false">A numeric value.</param>
		</params>
		<return>numeric?</return>
		<example xml:space="preserve">
fn:ceiling(10.5) returns 11.
fn:ceiling(-10.5) returns -10.
</example>
	</function>
	<function name="floor" type="builtin" lib="fn" category="NumericBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:floor">
		<summary>
			<p>Returns the largest (closest to positive infinity) number with no fractional part that is not greater than the value of $arg. If type of $arg is one of the four numeric types xs:float, xs:double, xs:decimal or xs:integer the type of the result is the same as the type of $arg. If the type of $arg is a type derived from one of the numeric types, the result is an instance of the base numeric type.</p>
			<p>For float and double arguments, if the argument is positive zero, then positive zero is returned. If the argument is negative zero, then negative zero is returned.</p>
			<p>For detailed type semantics, see Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and fn:round-half-to-even functions[FS].</p>
		</summary>
		<params>
			<param name="arg" type="numeric?" optional="false">A numeric value.</param>
		</params>
		<return>numeric?</return>
		<example xml:space="preserve">
fn:floor(10.5) returns 10.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:floor(-10.5) returns -11.
</example>
	</function>
	<function name="round" type="builtin" lib="fn" category="NumericBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:round">
		<summary>
			<p>Returns the number with no fractional part that is closest to the argument. If there are two such numbers, then the one that is closest to positive infinity is returned. If type of $arg is one of the four numeric types xs:float, xs:double, xs:decimal or xs:integer the type of the result is the same as the type of $arg. If the type of $arg is a type derived from one of the numeric types, the result is an instance of the base numeric type.</p>
			<p>For xs:float and xs:double arguments, if the argument is positive infinity, then positive infinity is returned. If the argument is negative infinity, then negative infinity is returned. If the argument is positive zero, then positive zero is returned. If the argument is negative zero, then negative zero is returned. If the argument is less than zero, but greater than or equal to -0.5, then negative zero is returned. In the cases where positive zero or negative zero is returned, negative zero or positive zero may be returned as [XML Schema Part 2: Datatypes Second Edition] does not distinguish between the values positive zero and negative zero.</p>
			<p>For the last two cases, note that the result is not the same as fn:floor(x+0.5).</p>
			<p>For detailed type semantics, see Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and fn:round-half-to-even functions[FS].</p>
		</summary>
		<params>
			<param name="arg" type="numeric?" optional="false">A numeric value to round.</param>
		</params>
		<return>numeric?</return>
		<example xml:space="preserve">
fn:round(2.5) returns 3.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:round(2.4999) returns 2.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:round(-2.5) returns -2 (not the possible alternative, -3).
</example>
	</function>
	<function name="round-half-to-even" type="builtin" lib="fn" category="NumericBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:round-half-to-even">
		<summary>
			<p>The value returned is the nearest (that is, numerically closest) numeric to $arg that is a multiple of ten to the power of minus $precision. If two such values are equally near (e.g. if the fractional part in $arg is exactly .500...), returns the one whose least significant digit is even. If type of $arg is one of the four numeric types xs:float, xs:double, xs:decimal or xs:integer the type of the result is the same as the type of $arg. If the type of $arg is a type derived from one of the numeric types, the result is an instance of the base numeric type.</p>
			<p>If no precision is specified, the result produces is the same as with $precision=0.</p>
			<p>For arguments of type xs:float and xs:double, if the argument is positive zero, then positive zero is returned. If the argument is negative zero, then negative zero is returned. If the argument is less than zero, but greater than or equal o -0.5, then negative zero is returned.</p>
			<p>If $arg is of type xs:float or xs:double, rounding occurs on the value of the mantissa computed with exponent = 0.</p>
			<p>For detailed type semantics, see Section 7.2.3 The fn:abs, fn:ceiling, fn:floor, fn:round, and fn:round-half-to-even functions[FS].</p>
		</summary>
		<params>
			<param name="arg" type="numeric?" optional="false">A numeric value to round.</param>
			<param name="precision" type="xs:integer" optional="true">The precision to which to round the value.</param>
		</params>
		<return>numeric?</return>
		<example xml:space="preserve">
fn:round-half-to-even(0.5) returns 0.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:round-half-to-even(1.5) returns 2.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:round-half-to-even(2.5) returns 2.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:round-half-to-even(3.567812E+3, 2) returns 3567.81E0.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:round-half-to-even(4.7564E-3, 2) returns 0.0E0.
<br xmlns="http://www.w3.org/1999/xhtml" />
fn:round-half-to-even(35612.25, -2) returns 35600.
<br xmlns="http://www.w3.org/1999/xhtml" />
</example>
	</function>
	<function name="years-from-duration" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:years-from-duration">
		<summary>
			<p>Returns an xs:integer representing the years component in the canonical lexical representation of the value of $arg. The result may be negative.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:duration?" optional="false">The duration whose year component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:years-from-duration(xs:duration("P20Y15M"))
returns 21
</example>
    <example xml:space="preserve">
fn:years-from-duration(xs:duration("-P15M"))
returns -1
</example>
	</function>
	<function name="months-from-duration" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:months-from-duration">
		<summary>
			<p>Returns an xs:integer representing the months component in the canonical lexical representation of the value of $arg. The result may be negative.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:duration?" optional="false">The duration whose month component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:months-from-duration(xs:duration("P20Y15M"))
returns 3
</example>
    <example xml:space="preserve">
fn:months-from-duration(xs:duration("-P20Y18M"))
returns -6
</example>
	</function>
	<function name="days-from-duration" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:days-from-duration">
		<summary>
			<p>Returns an xs:integer representing the days component in the canonical lexical representation of the value of $arg. The result may be negative.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:duration?" optional="false">The duration whose day component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:days-from-duration(xs:duration("P3DT10H"))
returns 3
</example>
    <example xml:space="preserve">
fn:days-from-duration(xs:duration("P3DT55H"))
returns 5
</example>
	</function>
	<function name="hours-from-duration" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:hours-from-duration">
		<summary>
			<p>Returns an xs:integer representing the hours component in the canonical lexical representation of the value of $arg. The result may be negative.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:duration?" optional="false">The duration whose hour component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:hours-from-duration(xs:duration("P3DT10H"))
returns 10
</example>
    <example xml:space="preserve">
fn:hours-from-duration(xs:duration("P3DT12H32M12S"))
returns 12
</example>
    <example xml:space="preserve">
fn:hours-from-duration(xs:duration("PT123H"))
returns 3
</example>
    <example xml:space="preserve">
fn:hours-from-duration(xs:duration("-P3DT10H"))
returns -10
</example>
	</function>
	<function name="minutes-from-duration" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:minutes-from-duration">
		<summary>
			<p>Returns an xs:integer representing the minutes component in the canonical lexical representation of the value of $arg. The result may be negative.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:duration?" optional="false">The duration whose minute component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:minutes-from-duration(xs:duration("P3DT10H"))
returns 0
</example>
    <example xml:space="preserve">
fn:minutes-from-duration(xs:duration("-P5DT12H30M"))
returns -30
</example>
	</function>
	<function name="seconds-from-duration" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:seconds-from-duration">
		<summary>
			<p>Returns an xs:decimal representing the seconds component in the canonical lexical representation of the value of $arg. The result may be negative.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:duration?" optional="false">The duration whose minute component will be returned.</param>
		</params>
		<return>xs:decimal?</return>
		<example xml:space="preserve">
fn:seconds-from-duration(xs:duration("P3DT10H12.5S"))
returns 12.5
</example>
    <example xml:space="preserve">
fn:seconds-from-duration(xs:duration("-P256S"))
returns -16.0
</example>
	</function>
	<function name="year-from-dateTime" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:year-from-dateTime">
		<summary>
			<p>Returns an xs:integer representing the year component in the localized value of $arg. The result may be negative.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The dateTime whose year component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:year-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
returns 1999
</example>
    <example xml:space="preserve">
fn:year-from-dateTime(xs:dateTime("1999-05-31T21:30:00-05:00"))
returns 1999
</example>
    <example xml:space="preserve">
fn:year-from-dateTime(xs:dateTime("1999-12-31T19:20:00"))
returns 1999
</example>
	</function>
	<function name="month-from-dateTime" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:month-from-dateTime">
		<summary>
			<p>Returns an xs:integer between 1 and 12, both inclusive, representing the month component in the localized value of $arg.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The dateTime whose month component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:month-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
returns 5
</example>
    <example xml:space="preserve">
fn:month-from-dateTime(xs:dateTime("1999-12-31T19:20:00-05:00"))
returns 12
</example>
    <example xml:space="preserve">
fn:month-from-dateTime(
    fn:adjust-dateTime-to-timezone(
        xs:dateTime("1999-12-31T19:20:00-05:00"),
        xs:dayTimeDuration("PT0H")))
returns 1
</example>
	</function>
	<function name="day-from-dateTime" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:day-from-dateTime">
		<summary>
			<p>Returns an xs:integer between 1 and 31, both inclusive, representing the day component in the localized value of $arg.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The dateTime whose day component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:day-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
returns 31
</example>
    <example xml:space="preserve">
fn:day-from-dateTime(
    xs:dateTime("1999-12-31T20:00:00-05:00"))
returns 31
</example>
    <example xml:space="preserve">
fn:day-from-dateTime(
    fn:adjust-dateTime-to-timezone(
        xs:dateTime("1999-12-31T19:20:00-05:00"),
        xs:dayTimeDuration("PT0H")))
returns 1
</example>
	</function>
	<function name="hours-from-dateTime" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:hours-from-dateTime">
		<summary>
			<p>Returns an xs:integer between 0 and 23, both inclusive, representing the hours component in the localized value of $arg.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The dateTime whose hours component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:hours-from-dateTime(
    xs:dateTime("1999-05-31T08:20:00-05:00"))
returns 8
</example>
    <example xml:space="preserve">
fn:hours-from-dateTime(
    xs:dateTime("1999-12-31T21:20:00-05:00"))
returns 21
</example>
    <example xml:space="preserve">
fn:hours-from-dateTime(
  fn:adjust-dateTime-to-timezone(
    xs:dateTime("1999-12-31T21:20:00-05:00"),
    xs:dayTimeDuration("PT0H")))
returns 2
</example>
    <example xml:space="preserve">
fn:hours-from-dateTime(
    xs:dateTime("1999-12-31T12:00:00"))
returns 12
</example>
	</function>
	<function name="minutes-from-dateTime" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:minutes-from-dateTime">
		<summary>
			<p>Returns an xs:integer value between 0 and 59, both inclusive, representing the minute component in the localized value of $arg.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The dateTime whose minutes component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:minutes-from-dateTime(
    xs:dateTime("1999-05-31T13:20:00-05:00"))
returns 20
</example>
    <example xml:space="preserve">
fn:minutes-from-dateTime(
    xs:dateTime("1999-05-31T13:30:00+05:30"))
returns 30
</example>
	</function>
	<function name="seconds-from-dateTime" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:seconds-from-dateTime">
		<summary>
			<p>Returns an xs:decimal value between 0 and 60.999..., both inclusive representing the seconds and fractional seconds in the localized value of $arg. Note that the value can be greater than 60 seconds to accommodate occasional leap seconds used to keep human time synchronized with the rotation of the planet.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The dateTime whose seconds component will be returned.</param>
		</params>
		<return>xs:decimal?</return>
		<example xml:space="preserve">
fn:seconds-from-dateTime(
    xs:dateTime("1999-05-31T13:20:00-05:00"))
returns 0
</example>
	</function>
	<function name="timezone-from-dateTime" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:timezone-from-dateTime">
		<summary>
			<p>Returns the timezone component of $arg if any. If $arg has a timezone component, then the result is an xs:dayTimeDuration that indicates deviation from UTC; its value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the result is the empty sequence.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The dateTime whose timezone component will be returned.</param>
		</params>
		<return>xs:dayTimeDuration?</return>
		<example xml:space="preserve">
fn:timezone-from-dateTime(
    xs:dateTime("1999-05-31T13:20:00-05:00"))
returns the xs:dayTimeDuration whose value is -PT5H
</example>
    <example xml:space="preserve">
fn:timezone-from-dateTime(
    xs:dateTime("2000-06-12T13:20:00Z"))
returns the xs:dayTimeDuration whose value is PT0S
</example>
    <example xml:space="preserve">
fn:timezone-from-dateTime(
    xs:dateTime("2004-08-27T00:00:00"))
returns ()
</example>
	</function>
	<function name="year-from-date" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:year-from-date">
		<summary>
			<p>Returns an xs:integer representing the year component in the localized value of $arg. The result may be negative.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The date whose year component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:year-from-date(xs:date("1999-05-31"))
returns 1999
</example>
    <example xml:space="preserve">
fn:year-from-date(xs:date("2000-01-01+05:00"))
returns 2000
</example>
	</function>
	<function name="month-from-date" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:month-from-date">
		<summary>
			<p>Returns an xs:integer between 1 and 12, both inclusive, representing the month component in the localized value of $arg.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The date whose month component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:month-from-date(xs:date("1999-05-31-05:00"))
returns 5
</example>
    <example xml:space="preserve">
fn:month-from-date(xs:date("2000-01-01+05:00"))
returns 1
</example>
	</function>
	<function name="day-from-date" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:day-from-date">
		<summary>
			<p>Returns an xs:integer between 1 and 31, both inclusive, representing the day component in the localized value of $arg.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The date whose day component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:day-from-date(xs:date("1999-05-31-05:00"))
returns 31
</example>
    <example xml:space="preserve">
fn:day-from-date(xs:date("2000-01-01+05:00"))
returns 1
</example>
	</function>
	<function name="timezone-from-date" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:timezone-from-date">
		<summary>
			<p>Returns the timezone component of $arg if any. If $arg has a timezone component, then the result is an xs:dayTimeDuration that indicates deviation from UTC; its value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the result is the empty sequence.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The date whose timezone component will be returned.</param>
		</params>
		<return>xs:dayTimeDuration?</return>
		<example xml:space="preserve">
fn:timezone-from-date(xs:date("1999-05-31-05:00"))
returns the xs:dayTimeDuration whose value is -PT5H
</example>
    <example xml:space="preserve">
fn:timezone-from-date(xs:date("2000-06-12Z"))
returns the xs:dayTimeDuration with value PT0H
</example>
	</function>
	<function name="hours-from-time" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:hours-from-time">
		<summary>
			<p>Returns an xs:integer between 0 and 23, both inclusive, representing the value of the hours component in the localized value of $arg.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:time?" optional="false">The time whose hours component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:hours-from-time(xs:time("11:23:00"))
returns 11
</example>
    <example xml:space="preserve">
fn:hours-from-time(xs:time("21:23:00"))
returns 21
</example>
    <example xml:space="preserve">
fn:hours-from-time(xs:time("01:23:00+05:00"))
returns 1
</example>
    <example xml:space="preserve">
fn:hours-from-time(
    fn:adjust-time-to-timezone(
         xs:time("01:23:00+05:00"),
         xs:dayTimeDuration("PT0H")))
returns 20
</example>
	</function>
	<function name="minutes-from-time" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:minutes-from-time">
		<summary>
			<p>Returns an xs:integer value between 0 to 59, both inclusive, representing the value of the minutes component in the localized value of $arg.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:time?" optional="false">The time whose minutes component will be returned.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:minutes-from-time(xs:time("13:00:00Z"))
returns 0
</example>
	</function>
	<function name="seconds-from-time" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:seconds-from-time">
		<summary>
			<p>Returns an xs:decimal value between 0 and 60.999..., both inclusive, representing the seconds and fractional seconds in the localized value of $arg. Note that the value can be greater than 60 seconds to accommodate occasional leap seconds used to keep human time synchronized with the rotation of the planet.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:time?" optional="false">The time whose seconds component will be returned.</param>
		</params>
		<return>xs:decimal?</return>
		<example xml:space="preserve">
fn:seconds-from-time(xs:time("13:20:10.5"))
returns 10.5
</example>
	</function>
	<function name="timezone-from-time" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:timezone-from-time">
		<summary>
			<p>Returns the timezone component of $arg if any. If $arg has a timezone component, then the result is an xs:dayTimeDuration that indicates deviation from UTC; its value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the result is the empty sequence.</p>
			<p>If $arg is the empty sequence, returns the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="xs:time?" optional="false">The time whose timezone component will be returned.</param>
		</params>
		<return>xs:dayTimeDuration?</return>
		<example xml:space="preserve">
fn:timezone-from-time(xs:time("13:20:00-05:00"))
returns xs:dayTimeDuration whose value is -PT5H
</example>
    <example xml:space="preserve">
fn:timezone-from-time(xs:time("13:20:00"))
returns ()
</example>
	</function>
	<function name="adjust-dateTime-to-timezone" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:adjust-dateTime-to-timezone">
		<summary>
			<p>Adjusts an xs:dateTime value to a specific timezone, or to no timezone at all. If $timezone is the empty sequence, returns an xs:dateTime without a timezone. Otherwise, returns an xs:dateTime with a timezone.</p>
			<p>If $timezone is not specified, then $timezone is the value of the implicit timezone in the dynamic context.</p>
			<p>If $arg is the empty sequence, then the result is the empty sequence.</p>
			<p>A dynamic error is raised [err:FODT0003] if $timezone is less than -PT14H or greater than PT14H or if does not contain an integral number of minutes.</p>
			<p>If $arg does not have a timezone component and $timezone is the empty sequence, then the result is $arg.</p>
			<p>If $arg does not have a timezone component and $timezone is not the empty sequence, then the result is $arg with $timezone as the timezone component.</p>
			<p>If $arg has a timezone component and $timezone is the empty sequence, then the result is the localized value of $arg without its timezone component.</p>
			<p>If $arg has a timezone component and $timezone is not the empty sequence, then the result is an xs:dateTime value with a timezone component of $timezone that is equal to $arg.</p>
		</summary>
		<params>
			<param name="arg" type="xs:dateTime?" optional="false">The dateTime to adjust to the new timezone.</param>
			<param name="timezone" type="xs:dayTimeDuration?" optional="true">The new timezone for the dateTime.</param>
		</params>
		<return>xs:dateTime?</return>
		<example xml:space="preserve">
Assume the dynamic context provides an implicit timezone
of -05:00 (-PT5H0M).
let $tz := xs:dayTimeDuration("-PT10H")

fn:adjust-dateTime-to-timezone(
    xs:dateTime("2002-03-07T10:00:00"))
returns 2002-03-07T10:00:00-05:00

fn:adjust-dateTime-to-timezone(
    xs:dateTime("2002-03-07T10:00:00-07:00"))
returns 2002-03-07T12:00:00-05:00

fn:adjust-dateTime-to-timezone(
     xs:dateTime("2002-03-07T10:00:00"), $tz)
returns 2002-03-07T10:00:00-10:00

fn:adjust-dateTime-to-timezone(
    xs:dateTime("2002-03-07T10:00:00-07:00"), $tz)
returns 2002-03-07T07:00:00-10:00

fn:adjust-dateTime-to-timezone(
    xs:dateTime("2002-03-07T10:00:00-07:00"),
    xs:dayTimeDuration("PT10H"))
returns 2002-03-08T03:00:00+10:00

fn:adjust-dateTime-to-timezone(
    xs:dateTime("2002-03-07T00:00:00+01:00"),
    xs:dayTimeDuration("-PT8H"))
returns 2002-03-06T15:00:00-08:00

fn:adjust-dateTime-to-timezone(
    xs:dateTime("2002-03-07T10:00:00"), ())
returns 2002-03-07T10:00:00

fn:adjust-dateTime-to-timezone(
    xs:dateTime("2002-03-07T10:00:00-07:00"), ())
returns 2002-03-07T10:00:00
</example>
	</function>
	<function name="adjust-date-to-timezone" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:adjust-date-to-timezone">
		<summary>
			<p>Adjusts an xs:date value to a specific timezone, or to no timezone at all. If $timezone is the empty sequence, returns an xs:date without a timezone. Otherwise, returns an xs:date with a timezone. For purposes of timezone adjustment, an xs:date is treated as an xs:dateTime with time 00:00:00.</p>
			<p>If $timezone is not specified, then $timezone is the value of the implicit timezone in the dynamic context.</p>
			<p>If $arg is the empty sequence, then the result is the empty sequence.</p>
			<p>A dynamic error is raised [err:FODT0003] if $timezone is less than -PT14H or greater than PT14H or if does not contain an integral number of minutes.</p>
			<p>If $arg does not have a timezone component and $timezone is the empty sequence, then the result is $arg.</p>
			<p>If $arg does not have a timezone component and $timezone is not the empty sequence, then the result is $arg with $timezone as the timezone component.</p>
			<p>If $arg has a timezone component and $timezone is the empty sequence, then the result is the localized value of $arg without its timezone component.</p>
			<p>If $arg has a timezone component and $timezone is not the empty sequence, then:</p>
			<p>Let $srcdt be an xs:dateTime value, with 00:00:00 for the time component and date and timezone components that are the same as the date and timezone components of $arg.</p>
			<p>Let $r be the result of evaluating fn:adjust-dateTime-to-timezone($srcdt, $timezone)</p>
			<p>The result of this function will be a date value that has date and timezone components that are the same as the date and timezone components of $r.</p>
		</summary>
		<params>
			<param name="arg" type="xs:date?" optional="false">The date to adjust to the new timezone.</param>
			<param name="timezone" type="xs:dayTimeDuration?" optional="true">The new timezone for the date.</param>
		</params>
		<return>xs:date?</return>
		<example xml:space="preserve">
Assume the dynamic context provides an implicit timezone
of -05:00 (-PT5H0M).
let $tz := xs:dayTimeDuration("-PT10H")

fn:adjust-date-to-timezone(xs:date("2002-03-07"))
returns 2002-03-07-05:00.

fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"))
returns 2002-03-07-05:00. $arg is converted to the xs:dateTime
"2002-03-07T00:00:00-07:00". This is adjusted to the implicit
timezone, giving "2002-03-07T02:00:00-05:00".

fn:adjust-date-to-timezone(
    xs:date("2002-03-07"), $tz)
returns 2002-03-07-10:00.

fn:adjust-date-to-timezone(
    xs:date("2002-03-07-07:00"), $tz)
returns 2002-03-06-10:00. $arg is converted to the xs:dateTime
"2002-03-07T00:00:00-07:00". This is adjusted to the given
timezone, giving "2002-03-06T21:00:00-10:00".

fn:adjust-date-to-timezone(xs:date("2002-03-07"), ())
returns 2002-03-07.

fn:adjust-date-to-timezone(
    xs:date("2002-03-07-07:00"), ())
returns 2002-03-07.
</example>
	</function>
	<function name="adjust-time-to-timezone" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:adjust-time-to-timezone">
		<summary>
			<p>Adjusts an xs:time value to a specific timezone, or to no timezone at all. If $timezone is the empty sequence, returns an xs:time without a timezone. Otherwise, returns an xs:time with a timezone.</p>
			<p>If $timezone is not specified, then $timezone is the value of the implicit timezone in the dynamic context.</p>
			<p>If $arg is the empty sequence, then the result is the empty sequence.</p>
			<p>A dynamic error is raised [err:FODT0003] if $timezone is less than -PT14H or greater than PT14H or if does not contain an integral number of minutes.</p>
			<p>If $arg does not have a timezone component and $timezone is the empty sequence, then the result is $arg.</p>
			<p>If $arg does not have a timezone component and $timezone is not the empty sequence, then the result is $arg with $timezone as the timezone component.</p>
			<p>If $arg has a timezone component and $timezone is the empty sequence, then the result is the localized value of $arg without its timezone component.</p>
			<p>If $arg has a timezone component and $timezone is not the empty sequence, then:</p>
			<p>Let $srcdt be an xs:dateTime value, with an arbitrary date for the date component and time and timezone components that are the same as the time and timezone components of $arg.</p>
			<p>Let $r be the result of evaluating fn:adjust-dateTime-to-timezone($srcdt, $timezone)</p>
			<p>The result of this function will be a time value that has time and timezone components that are the same as the time and timezone components of $r.</p>
		</summary>
		<params>
			<param name="arg" type="xs:date?" optional="false">The date to adjust to the new timezone.</param>
			<param name="timezone" type="xs:dayTimeDuration?" optional="true">The new timezone for the date.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
Assume the dynamic context provides an implicit timezone
of -05:00 (-PT5H0M).
let $tz := xs:dayTimeDuration("-PT10H")

fn:adjust-time-to-timezone(xs:time("10:00:00"))
returns 10:00:00-05:00

fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"))
returns 12:00:00-05:00

fn:adjust-time-to-timezone(xs:time("10:00:00"), $tz)
returns 10:00:00-10:00

fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"), $tz)
returns 07:00:00-10:00

fn:adjust-time-to-timezone(xs:time("10:00:00"), ())
returns 10:00:00

fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"), ())
returns 10:00:00

fn:adjust-time-to-timezone(
    xs:time("10:00:00-07:00"),
    xs:dayTimeDuration("PT10H"))
returns 03:00:00+10:00
</example>
	</function>
	<function name="subtract-dateTimes-yielding-yearMonthDuration" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:subtract-dateTimes-yielding-yearMonthDuration">
		<summary>
			<p>[0.9-ml only, use the minus operator ( - ) instead] Returns the
				<code>xdt:yearMonthDuration</code>that corresponds to the difference between the normalized value of $srcval1 and the normalized value of $srcval2. If either argument is the empty sequence, returns the empty sequence. If the normalized value of $srcval1 precedes in time the normalized value of $srcval2, the returned value is a negative duration.</p>
		</summary>
		<params>
			<param name="srcval1" type="xs:dateTime" optional="false">The first xs:dateTime value.</param>
			<param name="srcval1" type="xs:dateTime" optional="false">The second xs:dateTime value.</param>
		</params>
		<return>xdt:yearMonthDuration</return>
		<example xml:space="preserve">
xquery version "0.9-ml"
fn:subtract-dateTimes-yielding-yearMonthDuration(
  fn:current-dateTime(),
  xs:dateTime("2000-01-11T12:01:00.000Z"))
=&gt; the yearMonthDuration P8Y10M, or whatever is
   correct for the current date
</example>
	</function>
	<function name="subtract-dateTimes-yielding-dayTimeDuration" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:subtract-dateTimes-yielding-dayTimeDuration">
		<summary>
			<p>[0.9-ml only, use the minus operator ( - ) instead] Returns the
				<code>xdt:dayTimeDuration</code>that corresponds to the difference between the normalized value of $srcval1 and the normalized value of $srcval2. If either argument is the empty sequence, returns the empty sequence. If the normalized value of $srcval1 precedes in time the normalized value of $srcval2, then the returned value is a negative duration.</p>
		</summary>
		<params>
			<param name="srcval1" type="xs:dateTime" optional="false">The first xs:dateTime value.</param>
			<param name="srcval1" type="xs:dateTime" optional="false">The second xs:dateTime value.</param>
		</params>
		<return>xdt:dayTimeDuration</return>
		<example xml:space="preserve">
xquery version "0.9-ml"
fn:subtract-dateTimes-yielding-dayTimeDuration(
  fn:current-dateTime(),
  xs:dateTime("2000-01-11T12:01:00.000Z"))
=&gt; the dayTimeDuration P3240DT14H49M46.37S, or
   whatever is correct for the current date
</example>
	</function>
	<function name="matches" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:matches">
		<summary>Returns
			<code>true</code>if the specified $input matches the specified $pattern, otherwise returns
			<code>false</code>.</summary>
		<params>
			<param name="input" type="xs:string?" optional="false">The input from which to match.</param>
			<param name="pattern" type="xs:string" optional="false">The regular expression to match.</param>
			<param name="flags" type="xs:string" optional="true">The flag representing how to interpret the regular expression. One of "s", "m", "i", or "x", as defined in
				<a href="http://www.w3.org/TR/xpath-functions/#flags">http://www.w3.org/TR/xpath-functions/#flags</a>.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
fn:matches("this is a string", "is")

=&gt; true

fn:matches("this is a string", "zoo")

=&gt; false
</example>
	</function>
	<function name="replace" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:replace">
		<summary>Returns a string constructed by replacing the specified $pattern on the $input string with the specified $replacement string.</summary>
		<params>
			<param name="input" type="xs:string?" optional="false">The string to start with.</param>
			<param name="pattern" type="xs:string" optional="false">The regular expression pattern to match. If the pattern does not match the $input string, the function will return the $input string unchanged.</param>
			<param name="replacement" type="xs:string" optional="false">The regular expression pattern to replace the $pattern with. It can also be a capture expression (for more details, see
				<a href="http://www.w3.org/TR/xpath-functions/#func-replace" target="_blank">http://www.w3.org/TR/xpath-functions/#func-replace</a>).</param>
			<param name="flags" type="xs:string" optional="true">The flag representing how to interpret the regular expression. One of "s", "m", "i", or "x", as defined in
				<a href="http://www.w3.org/TR/xpath-functions/#flags">http://www.w3.org/TR/xpath-functions/#flags</a>.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:replace("this is a string", "this", "that")

-&gt; that is a string
</example>
	</function>
	<function name="analyze-string" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:analyze-string">
		<summary>The result of the function is a new element node whose string value is the original string, but which contains markup to show which parts of the input match the regular expression.</summary>
		<params>
			<param name="in" type="xs:string?" optional="false">The string to start with.</param>
			<param name="regex" type="xs:string" optional="false">The regular expression pattern to match.</param>
			<param name="flags" type="xs:string" optional="true">The flag representing how to interpret the regular expression. One of "s", "m", "i", or "x", as defined in
				<a href="http://www.w3.org/TR/xpath-functions/#flags">http://www.w3.org/TR/xpath-functions/#flags</a>.</param>
		</params>
		<return>element(s:results)</return>
		<example xml:space="preserve">
fn:analyze-string('Tom Jim John',"Jim")

=&gt;
&lt;s:analyze-string-result&gt;
  &lt;s:non-match&gt;Tom &lt;/s:non-match&gt;
  &lt;s:match&gt;Jim&lt;/s:match&gt;
  &lt;s:non-match&gt; John&lt;/s:non-match&gt;
&lt;/s:analyze-string-result&gt;
</example>
    <example xml:space="preserve">
fn:analyze-string('Tom Jim John',"(Jim)")

=&gt;
&lt;s:analyze-string-result&gt;
  &lt;s:non-match&gt;Tom &lt;/s:non-match&gt;
    &lt;s:match&gt;
      &lt;s:group nr="1"&gt;Jim&lt;/s:group&gt;
    &lt;/s:match&gt;
  &lt;s:non-match&gt; John&lt;/s:non-match&gt;
&lt;/s:analyze-string-result&gt;
</example>
    <example xml:space="preserve">
fn:analyze-string('Tom Jim John',"((Jim) John)")

=&gt;
&lt;s:analyze-string-result&gt;
  &lt;s:non-match&gt;Tom &lt;/s:non-match&gt;
  &lt;s:match&gt;
    &lt;s:group nr="1"&gt;
    &lt;s:group nr="2"&gt;Jim&lt;/s:group&gt;
    John
    &lt;/s:group&gt;
  &lt;/s:match&gt;
&lt;/s:analyze-string-result&gt;
</example>
    <example xml:space="preserve">
fn:analyze-string("http://example.com/", "\w+")

=&gt;
&lt;result xmlns="http://www.w3.org/2009/xpath-functions/analyze-string"&gt;
  &lt;match&gt;http&lt;/match&gt;
  &lt;non-match&gt;://&lt;/non-match&gt;
  &lt;match&gt;example&lt;/match&gt;
  &lt;non-match&gt;.&lt;/non-match&gt;
  &lt;match&gt;com&lt;/match&gt;
  &lt;non-match&gt;/&lt;/non-match&gt;
&lt;/result&gt;
</example>
	</function>
	<function name="tokenize" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:tokenize">
		<summary>Returns a sequence of strings contructed by breaking the specified input into substrings separated by the specified $pattern. The specified $pattern is not returned as part of the returned items.</summary>
		<params>
			<param name="input" type="xs:string?" optional="false">The string to tokenize.</param>
			<param name="pattern" type="xs:string" optional="false">The regular expression pattern from which to separate the tokens.</param>
			<param name="flags" type="xs:string" optional="true">The flag representing how to interpret the regular expression. One of "s", "m", "i", or "x", as defined in
				<a href="http://www.w3.org/TR/xpath-functions/#flags">http://www.w3.org/TR/xpath-functions/#flags</a>.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
fn:tokenize("this is a string", " ")

=&gt; returns the sequence ("this", "is", "a", "string")

fn:tokenize("this is a string", " ")[last()]

=&gt; string
</example>
	</function>
	<function name="boolean" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:boolean">
		<summary>
			<p>Computes the effective boolean value of the sequence $arg. See Section 2.4.3 Effective Boolean Value[XP].</p>
			<p>NOTE: NEW 1.0 SEMANTICS NOT IMPLEMENTED: STILL USES MAY 2003 SEMANTICS.</p>
			<p>If $arg is the empty sequence, fn:boolean returns false.</p>
			<p>If $arg is a sequence whose first item is a node, fn:boolean returns true.</p>
			<p>If $arg is a singleton value of type xs:boolean or a derived from xs:boolean, fn:boolean returns $arg.</p>
			<p>If $arg is a singleton value of type xs:string or a type derived from xs:string or xs:untypedAtomic, fn:boolean returns false if the operand value has zero length; otherwise it returns true.</p>
			<p>If $arg is a singleton value of any numeric type or a type derived from a numeric type, fn:boolean returns false if the operand value is NaN or is numerically equal to zero; otherwise it returns true.</p>
			<p>In all other cases, fn:boolean raises a type error [err:FORG0006].</p>
			<p>The static semantics of this function are described in
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_boolean">Section 7.2.4 The fn:boolean function[FS]</a>.</p>
			<p>Note:</p>
			<p>The result of this function is not necessarily the same as " $arg cast as xs:boolean ". For example, fn:boolean("false") returns the value "true" whereas "false" cast as xs:boolean returns false.</p>
		</summary>
		<params>
			<param name="arg" type="item()*" optional="false">A sequence of items.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
let $x := ("a", "b", "c")
return
fn:boolean($x)
=&gt; raises a type error [err:FORG0006].

let $x := ("a", "b", "c")
return
fn:boolean($x[1])
=&gt; returns true.

let $x := ("a", "b", "c")
return
fn:boolean($x[0])
=&gt; returns false.
</example>
	</function>
	<function name="index-of" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:index-of">
		<summary>
			<p>Returns a sequence of positive integers giving the positions within the sequence $seqParam of items that are equal to $srchParam.</p>
			<p>The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. The collation is used when string comparison is required.</p>
			<p>The items in the sequence $seqParam are compared with $srchParam under the rules for the eq operator. Values that cannot be compared, i.e. the eq operator is not defined for their types, are considered to be distinct. If an item compares equal, then the position of that item in the sequence $srchParam is included in the result.</p>
			<p>If the value of $seqParam is the empty sequence, or if no item in $seqParam matches $srchParam, then the empty sequence is returned.</p>
			<p>The first item in a sequence is at position 1, not position 0.</p>
			<p>The result sequence is in ascending numeric order.</p>
		</summary>
		<params>
			<param name="seqParam" type="xs:anyAtomicType*" optional="false">A sequence of values.</param>
			<param name="srchParam" type="xs:anyAtomicType" optional="false">A value to find on the list.</param>
			<param name="collationLiteral" type="xs:string" optional="false">A collation identifier.</param>
		</params>
		<return>xs:integer*</return>
		<example xml:space="preserve">
fn:index-of ((10, 20, 30, 40), 35) returns ().

fn:index-of ((10, 20, 30, 30, 20, 10), 20)
  returns (2, 5).

fn:index-of (("a", "sport", "and", "a", "pastime"), "a")
  returns (1, 4).

If @a is an attribute of type xs:NMTOKENS whose
typed value is " red green blue ", then:

fn:index-of (@a, "blue") returns 3.

This is because the function calling mechanism
atomizes the attribute node to produce a sequence of
three xs:NMTOKENs.
</example>
	</function>
	<function name="empty" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:empty">
		<summary>If the value of $arg is the empty sequence, the function returns true; otherwise, the function returns false.</summary>
		<params>
			<param name="arg" type="item()*" optional="false">A sequence to test.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:empty(fn:remove(("hello", "world"), 1))

=&gt; false
</example>
	</function>
	<function name="exists" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:exists">
		<summary>If the value of $arg is not the empty sequence, the function returns true; otherwise, the function returns false.</summary>
		<params>
			<param name="arg" type="item()*" optional="false">A sequence to test.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:exists(fn:remove(("hello"), 1))

=&gt; false
</example>
	</function>
	<function name="distinct-nodes" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:distinct-nodes">
		<summary>[0.9-ml only] Returns the sequence resulting from removing from the input sequence all but one of a set of nodes that have the same identity as one another. If the empty sequence is input,
			<code>fn:distinct-nodes</code>returns the empty sequence.</summary>
		<params>
			<param name="nodes" type="node()*" optional="false">A sequence of nodes from which to eliminate duplicate nodes (nodes with the same identity) so that only one node of each identity remains.</param>
		</params>
		<usage>
			<p>Note that for a node to have the same identity as another node, it must be exactly the same node (not an equivalent node). For example, for a node bound to the variable $x to have the same identity as a node bound to the variable $y, the following must return true:</p>
			<pre xml:space="preserve">
$x is $y
</pre>
		</usage>
		<return>node()*</return>
		<example xml:space="preserve">
  (:
    assume /mydoc.xml has the following contents:
    &lt;a&gt;hello&lt;/a&gt;
  :)

  let $x := fn:doc("/mydoc.xml")/a
  let $y := /a
  return
  fn:distinct-nodes(($x, $y))

=&gt; &lt;a&gt;hello&lt;/a&gt;
</example>
    <example xml:space="preserve">
  (:
    assume /mydoc.xml has the following contents:
    &lt;a&gt;hello&lt;/a&gt;
  :)

  let $x := fn:doc("/mydoc.xml")/a
  let $y := &lt;a&gt;hello&lt;/a&gt;
  return
  fn:distinct-nodes(($x, $y))

=&gt; (&lt;a&gt;hello&lt;/a&gt;, &lt;a&gt;hello&lt;/a&gt;)
   It returns both nodes because they do not
   have the same identity.
</example>
	</function>
	<function name="distinct-values" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:distinct-values">
		<summary>
			<p>Returns the sequence that results from removing from $arg all but one of a set of values that are eq to one other. Values that cannot be compared, i.e. the eq operator is not defined for their types, are considered to be distinct. Values of type xs:untypedAtomic are compared as if they were of type xs:string. The order in which the sequence of values is returned is implementation dependent.</p>
			<p>The static type of the result is a sequence of prime types as defined in
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_distinct_node_vals">Section 7.2.7 The fn:distinct-values function[FS]</a>.</p>
			<p>The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. The collation is used when string comparison is required.</p>
			<p>If $arg is the empty sequence, the empty sequence is returned.</p>
			<p>For xs:float and xs:double values, positive zero is equal to negative zero and, although NaN does not equal itself, if $arg contains multiple NaN values a single NaN is returned.</p>
			<p>If xs:dateTime, xs:date or xs:time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison. Note that xs:dateTime, xs:date or xs:time values can compare equal even if their timezones are different.</p>
			<p>Which value of a set of values that compare equal is returned is implementation dependent.</p>
		</summary>
		<params>
			<param name="arg" type="xs:anyAtomicType*" optional="false">A sequence of values to filter.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<example xml:space="preserve">
let $x as xs:untypedAtomic*
    := (xs:untypedAtomic("cherry"),
        xs:untypedAtomic("bar"),
        xs:untypedAtomic("bar"))
return fn:distinct-values ($x)
</example>
	</function>
	<function name="insert-before" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:insert-before">
		<summary>
			<p>Returns a new sequence constructed from the value of $target with the value of $inserts inserted at the position specified by the value of $position. (The value of $target is not affected by the sequence construction.)</p>
			<p>If $target is the empty sequence, $inserts is returned. If $inserts is the empty sequence, $target is returned.</p>
			<p>The value returned by the function consists of all items of $target whose index is less than $position, followed by all items of $inserts, followed by the remaining elements of $target, in that sequence.</p>
			<p>If $position is less than one (1), the first position, the effective value of $position is one (1). If $position is greater than the number of items in $target, then the effective value of $position is equal to the number of items in $target plus 1.</p>
			<p>For detailed semantics see,
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_insert_before">Section 7.2.15 The fn:insert-before function[FS]</a>.</p>
		</summary>
		<params>
			<param name="target" type="item()*" optional="false">The sequence of items into which new items will be inserted.</param>
			<param name="position" type="xs:integer" optional="false">The position in the target sequence at which the new items will be added.</param>
			<param name="inserts" type="item()*" optional="false">The items to insert into the target sequence.</param>
		</params>
		<return>item()*</return>
		<example xml:space="preserve">
let $x := ("a", "b", "c")

fn:insert-before($x, 0, "z") returns ("z", "a", "b", "c")

fn:insert-before($x, 1, "z") returns ("z", "a", "b", "c")

fn:insert-before($x, 2, "z") returns ("a", "z", "b", "c")

fn:insert-before($x, 3, "z") returns ("a", "b", "z", "c")

fn:insert-before($x, 4, "z") returns ("a", "b", "c", "z")
</example>
	</function>
	<function name="remove" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:remove">
		<summary>
			<p>Returns a new sequence constructed from the value of $target with the item at the position specified by the value of $position removed.</p>
			<p>If $position is less than 1 or greater than the number of items in $target, $target is returned. Otherwise, the value returned by the function consists of all items of $target whose index is less than $position, followed by all items of $target whose index is greater than $position. If $target is the empty sequence, the empty sequence is returned.</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_remove">Section 7.2.11 The fn:remove function[FS]</a>.</p>
		</summary>
		<params>
			<param name="target" type="item()*" optional="false">The sequence of items from which items will be removed.</param>
			<param name="position" type="xs:integer" optional="false">The position in the target sequence from which the items will be removed.</param>
		</params>
		<return>item()*</return>
		<example xml:space="preserve">
let $x := ("a", "b", "c")

fn:remove($x, 0) returns ("a", "b", "c")

fn:remove($x, 1) returns ("b", "c")

fn:remove($x, 6) returns ("a", "b", "c")

fn:remove((), 3) returns ()
</example>
	</function>
	<function name="reverse" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:reverse">
		<summary>
			<p>Reverses the order of items in a sequence. If $arg is the empty sequence, the empty sequence is returned.</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_reverse">Section 7.2.12 The fn:reverse function[FS]</a>.</p>
		</summary>
		<params>
			<param name="target" type="item()*" optional="false">The sequence of items to be reversed.</param>
		</params>
		<return>item()*</return>
		<usage>The sequence you specify to reverse must fit into memory, so the sequence size should not be larger than your memory cache sizes.</usage>
		<example xml:space="preserve">
let $x := ("a", "b", "c")
return
fn:reverse($x)

=&gt; ("c", "b", "a")
</example>
    <example xml:space="preserve">
fn:reverse(("hello"))

=&gt; ("hello")
</example>
    <example xml:space="preserve">
fn:reverse(())

=&gt; ()
</example>
	</function>
	<function name="subsequence" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:subsequence">
		<summary>
			<p>Returns the contiguous sequence of items in the value of $sourceSeq beginning at the position indicated by the value of $startingLoc and continuing for the number of items indicated by the value of $length.</p>
			<p>In the two-argument case, returns:</p>
			<p>$sourceSeq[fn:round($startingLoc) le $p]</p>
			<p>In the three-argument case, returns:</p>
			<p>$sourceSeq[fn:round($startingLoc) le $p and $p lt fn:round($startingLoc) + fn:round($length)]</p>
			<p>Notes:</p>
			<p>If $sourceSeq is the empty sequence, the empty sequence is returned.</p>
			<p>If $startingLoc is zero or negative, the subsequence includes items from the beginning of the $sourceSeq.</p>
			<p>If $length is not specified, the subsequence includes items to the end of $sourceSeq.</p>
			<p>If $length is greater than the number of items in the value of $sourceSeq following $startingLoc, the subsequence includes items to the end of $sourceSeq.</p>
			<p>The first item of a sequence is located at position 1, not position 0.</p>
			<p>For detailed type semantics, see Section 7.2.13 The fn:subsequence functionFS.</p>
			<p>The reason the function accepts arguments of type xs:double is that many computations on untyped data return an xs:double result; and the reason for the rounding rules is to compensate for any imprecision in these floating-point computations.</p>
		</summary>
		<params>
			<param name="sourceSeq" type="item()*" optional="false">The sequence of items from which a subsequence will be selected.</param>
			<param name="startingLoc" type="xs:double" optional="false">The starting position of the start of the subsequence.</param>
			<param name="length" type="xs:double" optional="true">The length of the subsequence.</param>
		</params>
		<return>item()*</return>
		<example xml:space="preserve">
Assume $seq = ($item1, $item2, $item3, $item4, ...)

fn:subsequence($seq, 4) returns ($item4, ...)

fn:subsequence($seq, 3, 2) returns ($item3, $item4)
</example>
	</function>
	<function name="unordered" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:unordered">
		<summary>
			<p>Returns the items of $sourceSeq in an implementation dependent order.</p>
			<p>Note:</p>
			<p>Query optimizers may be able to do a better job if the order of the output sequence is not specified. For example, when retrieving prices from a purchase order, if an index exists on prices, it may be more efficient to return the prices in index order rather than in document order.</p>
		</summary>
		<params>
			<param name="sourceSeq" type="item()*" optional="false">The sequence of items.</param>
		</params>
		<return>item()*</return>
	</function>
	<function name="zero-or-one" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:zero-or-one">
		<summary>
			<p>Returns $arg if it contains zero or one items. Otherwise, raises an error [err:FORG0003].</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_cardinality_funcs">Section 7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one functions[FS]</a>.</p>
		</summary>
		<params>
			<param name="arg" type="item()*" optional="false">The sequence of items.</param>
		</params>
		<return>item()?</return>
		<example xml:space="preserve">
fn:zero-or-one("hello")

=&gt; "hello"

fn:zero-or-one(("hello", "goodbye"))

=&gt; XDMP-MORETHANONEITEM exception (because there are two items)
</example>
	</function>
	<function name="one-or-more" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:one-or-more">
		<summary>
			<p>Returns $arg if it contains one or more items. Otherwise, raises an error [err:FORG0004].</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_cardinality_funcs">Section 7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one functions[FS]</a>.</p>
		</summary>
		<params>
			<param name="arg" type="item()*" optional="false">The sequence of items.</param>
		</params>
		<return>item()+</return>
		<example xml:space="preserve">
fn:one-or-more( () )

=&gt; XDMP-ZEROITEMS exception

fn:one-or-more("hello")

=&gt; "hello"
</example>
	</function>
	<function name="exactly-one" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:exactly-one">
		<summary>
			<p>Returns $arg if it contains exactly one item. Otherwise, raises an error [err:FORG0005].</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_cardinality_funcs">Section 7.2.16 The fn:zero-or-one, fn:one-or-more, and fn:exactly-one functions[FS]</a>.</p>
		</summary>
		<params>
			<param name="arg" type="item()*" optional="false">The sequence of items.</param>
		</params>
		<return>item()</return>
		<example xml:space="preserve">
fn:exactly-one(("hello"))

=&gt; "hello"

fn:exactly-one(("hello", "goodbye"))

=&gt; XDMP-NOTONEITEM exception (because there are 2 items)
</example>
	</function>
	<function name="deep-equal" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:deep-equal">
		<summary>
			<p>This function assesses whether two sequences are deep-equal to each other. To be deep-equal, they must contain items that are pairwise deep-equal; and for two items to be deep-equal, they must either be atomic values that compare equal, or nodes of the same kind, with the same name, whose children are deep-equal. This is defined in more detail below. The $collation argument identifies a collation which is used at all levels of recursion when strings are compared (but not when names are compared), according to the rules in 7.3.1 Collations.</p>
			<p>If the two sequences are both empty, the function returns true.</p>
			<p>If the two sequences are of different lengths, the function returns false.</p>
			<p>If the two sequences are of the same length, the function returns true if and only if every item in the sequence $parameter1 is deep-equal to the item at the same position in the sequence $parameter2. The rules for deciding whether two items are deep-equal follow.</p>
			<p>Call the two items $i1 and $i2 respectively.</p>
			<p>If $i1 and $i2 are both atomic values, they are deep-equal if and only if ($i1 eq $i2) is true. Or if both values are NaN. If the eq operator is not defined for $i1 and $i2, the function returns false.</p>
			<p>If one of the pair $i1 or $i2 is an atomic value and the other is a node, the function returns false.</p>
			<p>If $i1 and $i2 are both nodes, they are compared as described below:</p>
			<p>If the two nodes are of different kinds, the result is false.</p>
			<p>If the two nodes are both document nodes then they are deep-equal if and only if the sequence $i1/(*|text()) is deep-equal to the sequence $i2/(*|text()).</p>
			<p>If the two nodes are both element nodes then they are deep-equal if and only if all of the following conditions are satisfied:</p>
			<ol>
				<li>the two nodes have the same name, that is (node-name($i1) eq node-name($i2)).</li>
				<li>the two nodes are both annotated as having simple content or both nodes are annotated as having complex content.</li>
				<li>the two nodes have the same number of attributes, and for every attribute $a1 in $i1/@* there exists an attribute $a2 in $i2/@* such that $a1 and $a2 are deep-equal.</li>
				<li>One of the following conditions holds:
					<ul>
						<li>Both element nodes have a type annotation that is simple content, and the typed value of $i1 is deep-equal to the typed value of $i2.</li>
						<li>Both element nodes have a type annotation that is complex content with elementOnly content, and each child element of $i1 is deep-equal to the corresponding child element of $i2.</li>
						<li>Both element nodes have a type annotation that is complex content with mixed content, and the sequence $i1/(*|text()) is deep-equal to the sequence $i2/(*|text()).</li>
						<li>Both element nodes have a type annotation that is complex content with empty content.</li>
					</ul></li>
			</ol>
			<p>If the two nodes are both attribute nodes then they are deep-equal if and only if both the following conditions are satisfied:</p>
			<ol>
				<li>the two nodes have the same name, that is (node-name($i1) eq node-name($i2)).</li>
				<li>the typed value of $i1 is deep-equal to the typed value of $i2.</li>
			</ol>
			<p>If the two nodes are both processing instruction nodes or namespace bindings, then they are deep-equal if and only if both the following conditions are satisfied:</p>
			<ol>
				<li>the two nodes have the same name, that is (node-name($i1) eq node-name($i2)).</li>
				<li>the string value of $i1 is equal to the string value of $i2.</li>
			</ol>
			<p>If the two nodes are both text nodes or comment nodes, then they are deep-equal if and only if their string-values are equal.</p>
			<p>Notes:</p>
			<p>The two nodes are not required to have the same type annotation, and they are not required to have the same in-scope namespaces. They may also differ in their parent, their base URI, and the values returned by the is-id and is-idrefs accesors (see Section 5.5 is-id Accessor[DM] and Section 5.6 is-idrefs Accessor[DM]). The order of children is significant, but the order of attributes is insignificant.</p>
			<p>The following note applies to the Jan 2007 XQuery specification, but not to the May 2003 XQuery specification: The contents of comments and processing instructions are significant only if these nodes appear directly as items in the two sequences being compared. The content of a comment or processing instruction that appears as a descendant of an item in one of the sequences being compared does not affect the result. However, the presence of a comment or processing instruction, if it causes a text node to be split into two text nodes, may affect the result.</p>
			<p>The result of fn:deep-equal(1, current-dateTime()) is false; it does not raise an error.</p>
		</summary>
		<params>
			<param name="parameter1" type="item()*" optional="false">The first sequence of items.</param>
			<param name="parameter2" type="item()*" optional="false">The sequence of items to compare to the first sequence of items.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
Assume $at := &lt;attendees&gt;
             &lt;name last='Parker' first='Peter'/&gt;
	     &lt;name last='Barker' first='Bob'/&gt;
             &lt;name last='Parker' first='Peter'/&gt;
	   &lt;/attendees&gt;

Then:

fn:deep-equal($at, $at/*) returns false.

fn:deep-equal($at/name[1], $at/name[2]) returns false.

fn:deep-equal($at/name[1], $at/name[3]) returns true.

fn:deep-equal($at/name[1], 'Peter Parker') returns false.
</example>
	</function>
	<function name="count" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:count">
		<summary>
			<p>Returns the number of items in the value of $arg.</p>
			<p>Returns 0 if $arg is the empty sequence.</p>
		</summary>
		<params>
			<param name="arg" type="item()*" optional="false">The sequence of items to count.</param>
			<param name="maximum" type="xs:double?" optional="true">The maximum value of the count to return. MarkLogic Server will stop count when the $maximum value is reached and return the $maximum value. This is an extension to the W3C standard
				<code>fn:count</code>function.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
Assume:
$seq1 = ($item1, $item2)
$seq3 = (), the empty sequence

Then:

fn:count($seq1) returns 2.

fn:count($seq3) returns 0.

Assume $seq2 = (98.5, 98.3, 98.9).

Then:

fn:count($seq2) returns 3.
fn:count($seq2[. &gt; 100]) returns 0.
</example>
	</function>
	<function name="avg" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:avg">
		<summary>
			<p>Returns the average of the values in the input sequence $arg, that is, the sum of the values divided by the number of values.</p>
			<p>If $arg is the empty sequence, the empty sequence is returned.</p>
			<p>If $arg contains values of type xs:untypedAtomic they are cast to xs:double.</p>
			<p>Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values. For numeric values, the numeric promotion rules defined in 6.2 Operators on Numeric Values are used to promote all values to a single common type. After these operations, $arg must contain items of a single type, which must be one of the four numeric types,xs:yearMonthDuration or xs:dayTimeDuration or one if its subtypes.</p>
			<p>If the above conditions are not met, then a type error is raised [err:FORG0006].</p>
			<p>Otherwise, returns the average of the values computed as sum($arg) div count($arg).</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_aggregates">Section 7.2.10 The fn:min, fn:max, fn:avg, and fn:sum functions[FS]</a>.</p>
		</summary>
		<params>
			<param name="arg" type="xs:anyAtomicType*" optional="false">The sequence of values to average.</param>
		</params>
		<return>xs:anyAtomicType?</return>
		<example xml:space="preserve">
Assume:
$d1 = xs:yearMonthDuration("P20Y")
$d2 = xs:yearMonthDuration("P10M")
$seq3 = (3, 4, 5)

Then:

fn:avg($seq3) returns 4.0.

fn:avg(($d1, $d2))
returns a yearMonthDuration with value 125 months.

fn:avg(($d1, $seq3)) raises a type error [err:FORG0006].

fn:avg(()) returns ().

fn:avg((xs:float('INF')), xs:float('-INF')) returns NaN.

fn:avg(($seq3, xs:float('NaN')) returns NaN.
</example>
	</function>
	<function name="max" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:max">
		<summary>
			<p>Selects an item from the input sequence $arg whose value is greater than or equal to the value of every other item in the input sequence. If there are two or more such items, then the specific item whose value is returned is implementation dependent.</p>
			<p>The following rules are applied to the input sequence:</p>
			<ul>
				<li>Values of type xs:untypedAtomic in $arg are cast to xs:double.</li>
				<li>For numeric values, the numeric promotion rules defined in 6.2 Operators on Numeric Values are used to promote all values to a single common type.</li>
			</ul>
			<p>The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence.This function returns an item from the converted sequence rather than the input sequence.</p>
			<p>If the converted sequence is empty, the empty sequence is returned.</p>
			<p>All items in $arg must be numeric or derived from a single base type for which the ge operator is defined. In addition, the values in the sequence must have a total order. If date/time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for purposes of comparison. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values.</p>
			<p>If any of these conditions is not met, then a type error is raised [err:FORG0006].</p>
			<p>If the converted sequence contains the value NaN, the value NaN is returned.</p>
			<p>If the items in the value of $arg are of type xs:string or types derived by restriction from xs:string, then the determination of the item with the largest value is made according to the collation that is used. If the type of the items in $arg is not xs:string and $collation is specified, the collation is ignored.</p>
			<p>The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations.</p>
			<p>Otherwise, the result of the function is the result of the expression:</p>
			<pre xml:space="preserve">
   if (every $v in $c satisfies $c[1] ge $v)
   then $c[1]
   else fn:max(fn:subsequence($c, 2))
</pre>
			<p>evaluated with $collation as the default collation if specified, and with $c as the converted sequence.</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_aggregates">Section 7.2.10 The fn:min, fn:max, fn:avg, and fn:sum functions[FS]</a>.</p>
			<p>Notes:</p>
			<p>If the converted sequence contains exactly one value then that value is returned.</p>
			<p>The default type when the fn:max function is applied to xs:untypedAtomic values is xs:double. This differs from the default type for operators such as gt, and for sorting in XQuery and XSLT, which is xs:string.</p>
		</summary>
		<params>
			<param name="arg" type="xs:anyAtomicType*" optional="false">The sequence of values whose maximum will be returned.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:anyAtomicType?</return>
		<example xml:space="preserve">
fn:max((3,4,5)) returns 5.
fn:max((5, 5.0e0)) returns 5.0e0.
fn:max((3,4,"Zero")) raises a type error [err:FORG0006].
fn:max((fn:current-date(), xs:date("2001-01-01")))
typically returns the current date.
fn:max(("a", "b", "c")) returns "c" under a typical
                                default collation.
</example>
	</function>
	<function name="min" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:min">
		<summary>
			<p>Selects an item from the input sequence $arg whose value is less than or equal to the value of every other item in the input sequence. If there are two or more such items, then the specific item whose value is returned is implementation dependent.</p>
			<p>The following rules are applied to the input sequence:</p>
			<ul>
				<li>Values of type xs:untypedAtomic in $arg are cast to xs:double.</li>
				<li>For numeric values, the numeric promotion rules defined in 6.2 Operators on Numeric Values are used to promote all values to a single common type.</li>
			</ul>
			<p>The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence.This function returns an item from the converted sequence rather than the input sequence.</p>
			<p>If the converted sequence is empty, the empty sequence is returned.</p>
			<p>All items in $arg must be numeric or derived from a single base type for which the le operator is defined. In addition, the values in the sequence must have a total order. If date/time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for purposes of comparison. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values.</p>
			<p>If any of these conditions is not met, then a type error is raised [err:FORG0006].</p>
			<p>If the converted sequence contains the value NaN, the value NaN is returned.</p>
			<p>If the items in the value of $arg are of type xs:string or types derived by restriction from xs:string, then the determination of the item with the largest value is made according to the collation that is used. If the type of the items in $arg is not xs:string and $collation is specified, the collation is ignored.</p>
			<p>The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations.</p>
			<p>Otherwise, the result of the function is the result of the expression:</p>
			<pre xml:space="preserve">
   if (every $v in $c satisfies $c[1] le $v)
   then $c[1]
   else fn:min(fn:subsequence($c, 2))
</pre>
			<p>evaluated with $collation as the default collation if specified, and with $c as the converted sequence.</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_aggregates">Section 7.2.10 The fn:min, fn:max, fn:avg, and fn:sum functions[FS]</a>.</p>
			<p>Notes:</p>
			<p>If the converted sequence contains exactly one value then that value is returned.</p>
			<p>The default type when the fn:min function is applied to xs:untypedAtomic values is xs:double. This differs from the default type for operators such as gt, and for sorting in XQuery and XSLT, which is xs:string.</p>
		</summary>
		<params>
			<param name="arg" type="xs:anyAtomicType*" optional="false">The sequence of values whose minimum will be returned.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:anyAtomicType?</return>
		<example xml:space="preserve">
fn:min((3,4,5)) returns 3.

fn:min((5, 5.0e0)) returns 5.0e0.

fn:min((3,4,"Zero")) raises a type error [err:FORG0006].

fn:min(xs:float(0.0E0), xs:float(-0.0E0) can return
either positive or negative zero.
[XML Schema Part 2: Datatypes Second Edition] does
not distinguish between the values positive zero
and negative zero.
The result is implementation dependent.

fn:min((fn:current-date(), xs:date("2001-01-01")))
typically returns xs:date("2001-01-01").

fn:min(("a", "b", "c")) returns "a" under a
typical default collation.
</example>
	</function>
	<function name="sum" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:sum">
		<summary>
			<p>Returns a value obtained by adding together the values in $arg. If $zero is not specified, then the value returned for an empty sequence is the xs:integer value 0. If $zero is specified, then the value returned for an empty sequence is $zero.</p>
			<p>Any values of type xs:untypedAtomic in $arg are cast to xs:double. The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence.</p>
			<p>If the converted sequence is empty, then the single-argument form of the function returns the xs:integer value 0; the two-argument form returns the value of the argument $zero.</p>
			<p>If the converted sequence contains the value NaN, NaN is returned.</p>
			<p>All items in $arg must be numeric or derived from a single base type. In addition, the type must support addition. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values. For numeric values, the numeric promotion rules defined in 6.2 Operators on Numeric Values are used to promote all values to a single common type. The sum of a sequence of integers will therefore be an integer, while the sum of a numeric sequence that includes at least one xs:double will be an xs:double.</p>
			<p>If the above conditions are not met, a type error is raised [err:FORG0006].</p>
			<p>Otherwise, the result of the function, using the second signature, is the result of the expression:</p>
			<pre xml:space="preserve">
   if (fn:count($c) eq 0) then
       $zero
   else if (fn:count($c) eq 1) then
       $c[1]
   else
       $c[1] + fn:sum(subsequence($c, 2))
</pre>
			<p>where $c is the converted sequence.</p>
			<p>The result of the function, using the first signature, is the result of the expression:fn:sum($arg, 0).</p>
			<p>For detailed type semantics, see
				<a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_aggregates">Section 7.2.10 The fn:min, fn:max, fn:avg, and fn:sum functions[FS]</a>.</p>
			<p>Notes:</p>
			<p>The second argument allows an appropriate value to be defined to represent the sum of an empty sequence. For example, when summing a sequence of durations it would be appropriate to return a zero-length duration of the appropriate type. This argument is necessary because a system that does dynamic typing cannot distinguish "an empty sequence of integers", for example, from "an empty sequence of durations".</p>
			<p>If the converted sequence contains exactly one value then that value is returned.</p>
		</summary>
		<params>
			<param name="arg" type="xs:anyAtomicType*" optional="false">The sequence of values to be summed.</param>
			<param name="zero" type="xs:anyAtomicType?" optional="true">The value to return as zero if the input sequence is the empty sequence. This parameter is not available in the 0.9-ml XQuery dialect.</param>
		</params>
		<usage>When running this in the 0.9-ml XQuery dialect, there is no second argument to
			<code>fn:sum</code>; the second ($zero) argument is available in both the 1.0 and 1.0-ml dialects.</usage>
		<return>xs:anyAtomicType?</return>
		<example xml:space="preserve">
Assume:
$d1 = xs:yearMonthDuration("P20Y")
$d2 = xs:yearMonthDuration("P10M")
$seq1 = ($d1, $d2)
$seq3 = (3, 4, 5)

fn:sum(($d1, $d2))
returns an xs:yearMonthDuration with a value of 250 months.

fn:sum($seq1[. &gt; xs:yearMonthDuration('P3M')],
                 xs:yearMonthDuration('P0M'))
returns an xs:yearMonthDuration with a value of 0 months.

fn:sum($seq3) returns 12.

fn:sum(()) returns 0.

fn:sum((),()) returns ().

fn:sum((1 to 100)[.&gt;0], 0) returns 0.

fn:sum(($d1, 9E1)) raises an error [err:FORG0006].
</example>
	</function>
	<function name="id" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:id">
		<summary>
			<p>Returns the sequence of element nodes that have an ID value matching the value of one or more of the IDREF values supplied in $arg.</p>
		</summary>
		<params>
			<param name="arg" type="xs:string*" optional="false">The IDs of the elements to return.</param>
			<param name="node" type="node()" optional="true">The target node.</param>
		</params>
		<return>element()*</return>
		<usage>
			<p>The function returns a sequence, in document order with duplicates eliminated, containing every element node E that satisfies all the following conditions:</p>
			<ol>
				<li>E is in the target document. The target document is the document containing $node, or the document containing the context node if the second argument is omitted. An error is raised [err:FODC0001] if $node, or the context item if the second argument is omitted, is a node in a tree whose root is not a document node or if the second argument is omitted and there is no context item [err:FONC0001], or if the context item is not a node [err:FOTY0011].</li>
				<li>E has an ID value equal to one of the candidate IDREF values, where:
					<ul>
						<li>An element has an ID value equal to V if either or both of the following conditions are true:
							<ul>
								<li>The is-id property (See Section 5.5 is-id AccessorDM.) of the element node is true, and the typed value of the element node is equal to V under the rules of the eq operator using the Unicode code point collation (http://www.w3.org/2005/xpath-functions/collation/codepoint).</li>
								<li>The element has an attribute node whose is-id property (See Section 5.5 is-id AccessorDM.) is true and whose typed value is equal to V under the rules of the eq operator using the Unicode code point collation (http://www.w3.org/2005/xpath-functions/collation/codepoint).</li>
							</ul></li>
						<li>Each xs:string in $arg is parsed as if it were of type IDREFS, that is, each xs:string in $arg is treated as a space-separated sequence of tokens, each acting as an IDREF. These tokens are then included in the list of candidate IDREFs. If any of the tokens is not a lexically valid IDREF (that is, if it is not lexically an xs:NCName), it is ignored. Formally, The candidate IDREF values are the strings in the sequence given by the expression:
							<pre xml:space="preserve">
for $s in $arg
return fn:tokenize(fn:normalize-space($s), ' ')
                 [. castable as xs:IDREF]
</pre></li>
					</ul></li>
				<li>If several elements have the same ID value, then E is the one that is first in document order.</li>
			</ol>
			<p>Notes:</p>
			<p>If the data model is constructed from an Infoset, an attribute will have the is-id property if the corresponding attribute in the Infoset had an attribute type of ID: typically this means the attribute was declared as an ID in a DTD.</p>
			<p>If the data model is constructed from a PSVI, an element or attribute will have the is-id property if its schema-defined type is xs:ID or a type derived by restriction from xs:ID.</p>
			<p>No error is raised in respect of a candidate IDREF value that does not match the ID of any element in the document. If no candidate IDREF value matches the ID value of any element, the function returns the empty sequence.</p>
			<p>It is not necessary that the supplied argument should have type xs:IDREF or xs:IDREFS, or that it should be derived from a node with the is-idrefs property.</p>
			<p>An element may have more than one ID value. This can occur with synthetic data models or with data models constructed from a PSVI where an the element and one of its attributes are both typed as xs:ID.</p>
			<p>If the source document is well-formed but not valid, it is possible for two or more elements to have the same ID value. In this situation, the function will select the first such element.</p>
			<p>It is also possible in a well-formed but invalid document to have an element or attribute that has the is-id property but whose value does not conform to the lexical rules for the xs:ID type. Such a node will never be selected by this function.</p>
		</usage>
		<example xml:space="preserve">
let $x := document{
  &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;p id="myID"&gt;hello&lt;/p&gt;
  &lt;/html&gt; }
return
fn:id("myID", $x)

=&gt; &lt;p id="myID" xmlns="http://www.w3.org/1999/xhtml"&gt;hello&lt;/p&gt;
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
declare namespace xh="http://www.w3.org/1999/xhtml";

let $x := document {
  &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;p id="myID"&gt;hello&lt;/p&gt;
    &lt;p&gt;hello&lt;/p&gt;
  &lt;/html&gt; }
return
$x/xh:html/xh:p[. is fn:id("myID")]

=&gt; &lt;p id="myID" xmlns="http://www.w3.org/1999/xhtml"&gt;hello&lt;/p&gt;
</example>
	</function>
	<function name="idref" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:idref">
		<summary>
			<p>Returns the sequence of element or attribute nodes that have an IDREF value matching the value of one or more of the ID values supplied in $arg.</p>
		</summary>
		<params>
			<param name="arg" type="xs:string*" optional="false">The IDREFs of the elements and attributes to return.</param>
			<param name="node" type="node()" optional="true">The target node.</param>
		</params>
		<return>node()*</return>
		<usage>
			<p>The function returns a sequence, in document order with duplicates eliminated, containing every element or attribute node $N that satisfies all the following // conditions:</p>
			<ol>
				<li>$N is in the target document. The target document is the document containing $node, or the document containing the context node if the second argument is omitted. An error is raised [err:FODC0001] if $node, or the context item if the second argument is omitted, is a node in a tree whose root is not a document node or if the second argument is omitted and there is no context item [err:FONC0001], or if the context item is not a node [err:FOTY0011].</li>
				<li>$N has an IDREF value equal to one of the candidate ID values, where:
					<ul>
						<li>A node $N has an IDREF value equal to V if either or both of the following conditions are true:
							<ul>
								<li>The is-idrefs property (See Section 5.6 is-idref AccessorDM.) of $N is true.</li>
								<li>The sequence fn:tokenize(fn:normalize-space($N), ' ') contains a string that is equal to V under the rules of the eq operator using the Unicode code point collation (http://www.w3.org/2005/xpath-functions/collation/codepoint).</li>
							</ul></li>
						<li>Each xs:string in $arg is parsed as if it were of type xs:ID. These xs:strings are then included in the list of candidate xs:IDs. If any of the xs:strings in $arg is not a lexically valid xs:ID (that is, if it is not lexically an xs:NCName), it is ignored. More formally, The candidate ID values are the strings in the sequence
							<pre xml:space="preserve">
$arg[. castable as xs:ID]
</pre></li>
					</ul></li>
			</ol>
			<p>Notes:</p>
			<p>An element or attribute typically acquires the is-idrefs property by being validated against the schema type xs:IDREF or xs:IDREFS, or (for attributes only) by being described as of type IDREF or IDREFS in a DTD.</p>
			<p>No error is raised in respect of a candidate ID value that does not match the IDREF value of any element or attribute in the document. If no candidate ID value matches the IDREF value of any element or attribute, the function returns the empty sequence.</p>
			<p>It is possible for two or more nodes to have an IDREF value that matches a given candidate ID value. In this situation, the function will return all such nodes. However, each matching node will be returned at most once, regardless how many candidate ID values it matches.</p>
			<p>It is possible in a well-formed but invalid document to have a node whose is-idrefs property is true but that does not conform to the lexical rules for the xs:IDREF type. The effect of the above rules is that ill-formed candidate ID values and ill-formed IDREF values are ignored</p>
		</usage>
		<example xml:space="preserve">
(:
   assume /mydocs/idref.xml has an element named idrefs that is
   of type xs:IDREF or xs:IDREFS
:)
fn:idref("myID", doc("/mydocs/idref.xml"))

=&gt; &lt;idrefs&gt;myID&lt;/idrefs&gt;
</example>
	</function>
	<function name="doc" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:doc">
		<summary>Returns the document(s) stored in the database at the specified URI(s).</summary>
		<params>
			<param name="uri" type="xs:string*" optional="true">The URI of the document to retrieve. If you omit this parameter, returns all of the documents in the database - this is only allowed if you're not using xquery version 1.0 strict. If you specify a list of URIs, returns all of the documents at the URIs specified in the list.</param>
		</params>
		<usage>The
			<code>document-node()</code>returned contains an
			<code>element()</code>root node for XML documents, a
			<code>text()</code>root node for text documents, and a
			<code>binary()</code>root node for binary documents.</usage>
		<return>document-node()*</return>
		<example xml:space="preserve">
fn:doc("/mydocs/doc.xml")

=&gt; returns the document at the URI /mydocs/doc.xml
</example>
	</function>
	<function name="doc-available" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:doc-available">
		<summary>
			<p>If fn:doc($uri) returns a document node, this function returns true. If $uri is not a valid xs:anyURI, an error is raised [err:FODC0005]. Otherwise, this function returns false.</p>
			<p>If this function returns true, then calling fn:doc($uri) within the same execution scope must return a document node.</p>
		</summary>
		<params>
			<param name="uri" type="xs:string?" optional="false">The URI of the document to check.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:doc-available("/mydocs/doc.xml")

=&gt; true is /mydocs/doc.xml is a document in the database
</example>
	</function>
	<function name="collection" type="builtin" lib="fn" category="SequenceBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:collection">
		<summary>Returns all of the documents that belong to the specified collection(s).</summary>
		<params>
			<param name="uri" type="xs:string*" optional="true">The URI of the collection to retrieve. If you omit this parameter, returns all of the documents in the database. If you specify a list of URIs, returns all of the documents in all of the collections at the URIs specified in the list.</param>
		</params>
		<return>document-node()*</return>
		<example xml:space="preserve">
fn:collection("mycollection")[1]
=&gt; returns the first document in the "mycollection" collection
</example>
	</function>
	<function name="document" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:document">
		<summary>
			<p>Returns the document(s) stored in the database at the specified URI(s). The URI(s) are resolved according to the base-uri of the calling stylesheet or XQuery main module.</p>
			<p>This is an XSLT function, and it is available in both XSLT and in XQuery 1.0-ml.</p>
		</summary>
		<params>
			<param name="uris" type="item()*" optional="false">The $uris is a sequence of the URI(s) of the document(s) to be retrieved. This parameter is mandatory. However you may pass a singleton sequence with an empty string in it. In that case it will return the stylesheet that contains this function call when called from XSLT stylesheet and all the documents in the database when called from XQuery- this is allowed only when you are not using version 1.0 strict. If any URI in this sequence is an absolute URI, then it is used as is. If it is a relative URI, it is resolved against a base URI specified in the second argument.</param>
			<param name="base-node" type="node()" optional="true">If $base-node is supplied, its base URI is used to resolve relative URIs in uri-sequence. If it is not supplied, the base URI of the node that contained the fn:document() call is used.</param>
		</params>
		<return>document-node()*</return>
		<usage>
			<p>If no second argument is specified, the URI resolves using the base-uri of the calling module. This can cause surprising results if the URI you are resolving is not rooted but the module from which you call it has a base-uri. When calling
				<code>fn:document</code>from an
				<code>xdmp:eval</code>, the calling module is defined to have no base-uri. When calling from an XQuery module or an XSLT stylesheet, the base-uri is the URI of the module or stylesheet. For an example to demonstrate this , see the
				<a href="#document-resolve">second example</a>below.</p>
			<p>For the URI to be exactly what you enter, use
				<a href="#fn:doc">
					<code>fn:doc</code>
				</a>instead.</p>
		</usage>
		<example xml:space="preserve">
fn:document(("/product.xml", "/price.xml"),
            &lt; a xml:base="http://www.marklogic.com" /&gt;)
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
(:
  This module should be at the App Server root with a name test.xqy,
  so it resolves to /test.xqy from the App Server's root.
:)
xdmp:set-response-content-type("text/plain"),

xdmp:document-insert("testing.xml", &lt;foo/&gt;);
xdmp:document-insert("/testing.xml", &lt;bar/&gt;);

declare option xdmp:output "indent-untyped=yes";

&lt;root&gt;
  &lt;document-from-module&gt;
     &lt;document&gt;{fn:document("testing.xml")}&lt;/document&gt;
  &lt;/document-from-module&gt;
  &lt;document-from-eval&gt;
     &lt;document&gt;{xdmp:eval('fn:document("testing.xml")')}&lt;/document&gt;
  &lt;/document-from-eval&gt;
&lt;/root&gt;

(:
  From the module, the document cannot find the URI "testing.xml"
  because the base-uri of the module is its URI relative to the
  App Server root.  It therefore finds /testing.xml because that is what
  the URI testing.xml resolves to (testing.xml resolves to /testing.xml when
  the base-uri is /test.xqy).  From an eval, there is no base-uri, so
  it can find an unrooted URI (testing.xml resolves to testing.xml when the
  base-uri is empty).
:)

=&gt;
&lt;root&gt;
  &lt;document-from-module&gt;
    &lt;document&gt;
      &lt;bar/&gt;
    &lt;/document&gt;
  &lt;/document-from-module&gt;
  &lt;document-from-eval&gt;
    &lt;document&gt;
      &lt;foo/&gt;
    &lt;/document&gt;
  &lt;/document-from-eval&gt;
&lt;/root&gt;
</example>
	</function>
	<function name="unparsed-text" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:unparsed-text">
		<summary>Reads a file stored in the database as either text or binary file and returns its contents as a string.</summary>
		<params>
			<param name="href" type="xs:string" optional="false">The $href is a string containing a URI reference. It must identify a resource that can be read as text. If the URI is a relative URI then it is resolved relative to the base URI from the static context.</param>
			<param name="encoding" type="xs:string" optional="true">If $encoding parameter is present and the URI points to a "text" file, the encoding is ignored since all the files are in UTF-8 in the database. However, if the URI points to a binary file, then an attempt is made to convert it from the specified encoding and the string value of the results of the conversion is returned. If the conversion fails, an exception is returned. The $encoding parameter must be passed when the URI resolves to a binary resource. An automatic encoding detector will be used if the value
				<code>auto</code>is specified. If $encoding is not present, the encoding defaults to UTF-8.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:unparsed-text("http://marklogic.com/test.xml","UTF-8")
</example>
	</function>
	<function name="unparsed-text-available" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:unparsed-text-available">
		<summary>Returns true if a call to unparsed-text would succeed with identical arguments.</summary>
		<params>
			<param name="href" type="xs:string" optional="false">The $href is a string containing a URI reference. It must identify a resource that can be read as text. If the URI is a relative URI then it is resolved relative to the base URI from the static context.</param>
			<param name="encoding" type="xs:string" optional="true">If $encoding parameter is present and the URI points to a "text" file, the encoding is ignored since all the files are in UTF-8 in the database. However, if the URI points to a binary file, then an attempt will be made to convert it to the specified encoding and if the conversion succeeds it returns true. If the conversion fails, an exception is returned. The $encoding parameter must be passed when the URI resolves to a binary resource.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:unparsed-text-available("http://marklogic.com/test.xml","UTF-8")
</example>
	</function>
	<function name="node-kind" type="builtin" lib="fn" category="AccessorBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:node-kind">
		<summary>[0.9-ml only, use
			<code>xdmp:node-kind</code>in 1.0 and 1.0-ml] Returns an
			<code>xs:string</code>representing the node's kind: either "document", "element", "attribute", "text", "namespace", "processing-instruction", "binary", or "comment".</summary>
		<params>
			<param name="node" type="node()?" optional="false">The node whose kind is to be returned.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
let $x := &lt;hello&gt;&lt;goodbye&gt;1&lt;/goodbye&gt;&lt;/hello&gt;
return
fn:node-kind($x/node())

=&gt; element
</example>
	</function>
	<function name="node-kind" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:node-kind">
		<summary>
			<p>Returns an
				<code>xs:string</code>representing the node's kind: either "document", "element", "attribute", "text", "namespace", "processing-instruction", "binary", or "comment".</p>
			<p>The
				<code>fn:node-kind</code>builtin was dropped from the final XQuery 1.0 spec. This is the equivalent function in the
				<code>xdmp:</code>namespace carried over for MarkLogic 1.0 dialects.</p>
		</summary>
		<params>
			<param name="node" type="node()?" optional="false">The node whose kind is to be returned.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
let $x := &lt;hello&gt;&lt;goodbye&gt;1&lt;/goodbye&gt;&lt;/hello&gt;
return
xdmp:node-kind($x/node())

=&gt; element
</example>
	</function>
	<function name="node-name" type="builtin" lib="fn" category="AccessorBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:node-name">
		<summary>Returns an expanded-QName for node kinds that can have names. For other kinds of nodes it returns the empty sequence. If $arg is the empty sequence, the empty sequence is returned.</summary>
		<params>
			<param name="arg" type="node()?" optional="false">The node whose name is to be returned.</param>
		</params>
		<return>xs:QName?</return>
		<example xml:space="preserve">
let $x := &lt;hello&gt;&lt;goodbye&gt;1&lt;/goodbye&gt;&lt;/hello&gt;
return
fn:node-name($x/child::element())

=&gt; goodbye
</example>
	</function>
	<function name="nilled" type="builtin" lib="fn" category="AccessorBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:nilled">
		<summary>
			<p>Summary: Returns an xs:boolean indicating whether the argument node is "nilled". If the argument is not an element node, returns the empty sequence. If the argument is the empty sequence, returns the empty sequence. For element nodes, true() is returned if the element is nilled, otherwise false().</p>
			<p>Elements may be defined in a schema as nillable, which allows an empty instance of an element to a appear in a document even though its type requires that it always have some content. Nilled elements should always be empty but an element is not considered nilled just because it's empty. It must also have the type annotation attribute xsi:nil="true".</p>
		</summary>
		<params>
			<param name="arg" type="node()?" optional="false">The node to test for nilled status.</param>
		</params>
		<return>xs:boolean?</return>
		<usage></usage>
		<example xml:space="preserve">
fn:nilled(&lt;foo/&gt;)
=&gt; false

fn:nilled(&lt;foo xsi:nil="true"/&gt;)
=&gt; true

fn:nilled(&lt;foo xsi:nil="false"/&gt;)
=&gt; false

fn:nilled(())
=&gt; ()

fn:nilled(text { "foo" })
=&gt; ()
</example>
	</function>
	<function name="string" type="builtin" lib="fn" category="AccessorBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:string">
		<summary>Returns the value of $arg represented as an
			<code>xs:string</code>. If no argument is supplied, this function returns the string value of the context item (.).</summary>
		<params>
			<param name="arg" type="item()?" optional="true">The item to be rendered as a string.</param>
		</params>
		<return>xs:string?</return>
		<usage>If no argument is supplied and the context item is undefined, an error is raised.
			<p>If $arg is the empty sequence, the zero-length string is returned.</p>
			<p>If $arg is a node, the function returns the string-value of the node, as obtained using the dm:string-value accessor.</p>If $arg is an atomic value, then the function returns the same string as is returned by the expression:
			<br />
			<br />
			<code>$arg cast as xs:string</code></usage>
		<example xml:space="preserve">
let $x := &lt;hello&gt;hello&lt;goodbye&gt;goodbye&lt;/goodbye&gt;&lt;/hello&gt;
return
fn:string($x)

=&gt; hellogoodbye
</example>
	</function>
	<function name="data" type="builtin" lib="fn" category="AccessorBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:data">
		<summary>
			<p>Takes a sequence of items and returns a sequence of atomic values.</p>
			<p>The
				<code>fn:data</code>function returns the sequence of atomic values produced by applying the following rules to each item in $arg:</p>
			<ul>
				<li>If the item is an atomic value, it is returned.</li>
				<li>If the item is a node:
					<ul>
						<li>If the node does not have a typed value an error is raised [err:FOTY0012].</li>
						<li>Otherwise,
							<code>fn:data</code>returns the typed value of the node as defined by the accessor function dm:typed-value in Section 5.15 typed-value Accessor[DM].</li>
					</ul></li>
			</ul>
		</summary>
		<params>
			<param name="arg" type="item()*" optional="false">The items whose typed values are to be returned.</param>
		</params>
		<return>xs:anyAtomicType*</return>
		<example xml:space="preserve">
let $x := &lt;hello&gt;hello
            &lt;goodbye&gt;goodbye&lt;/goodbye&gt;
          &lt;/hello&gt;
return
fn:data($x)

=&gt; hello goodbye
</example>
	</function>
	<function name="base-uri" type="builtin" lib="fn" category="AccessorBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:base-uri">
		<summary>Returns the value of the base-uri property for the specified node. If the node is part of a document and does not have a base-uri attribute explicitly set,
			<code>fn:base-uri</code>typically returns the URI of the document in which the node resides.</summary>
		<params>
			<param name="arg" type="node()?" optional="true">The node whose base-uri is to be returned.</param>
		</params>
		<return>xs:anyURI?</return>
		<example xml:space="preserve">
for $x in xdmp:directory("/myDirectory/", "1")
return
base-uri($x)

=&gt; a list of URIs for all of the documents in the
   directory "/myDirectory/"
</example>
	</function>
	<function name="document-uri" type="builtin" lib="fn" category="AccessorBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:document-uri">
		<summary>Returns the value of the document-uri property for the specified node. If the node is a document node, then the value returned is the URI of the document. If the node is not a document node, then
			<code>fn:document-uri</code>returns the the empty sequence.</summary>
		<params>
			<param name="arg" type="node()?" optional="false">The node whose document-uri is to be returned.</param>
		</params>
		<usage>
			<code>fn:document-uri</code>will only return the URI of a document when a document node is passed into it. If you want to return the URI of a node that is not a document node, but has a document node ancestor, use
			<a href="#fn:base-uri">
				<code>fn:base-uri</code>
			</a>.</usage>
		<return>xs:anyURI?</return>
		<example xml:space="preserve">
for $x in xdmp:directory("/myDirectory/", "1")
return
fn:document-uri($x)

=&gt; a list of URIs for all of the documents in the
   directory "/myDirectory/"
</example>
	</function>
	<function name="codepoints-to-string" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:codepoints-to-string">
		<summary>Creates an
			<code>xs:string</code>from a sequence of Unicode code points. Returns the zero-length string if $arg is the empty sequence. If any of the code points in $arg is not a legal XML character, an error is raised.</summary>
		<params>
			<param name="arg" type="xs:integer*" optional="false">A sequence of Unicode code points.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve"></example>
	</function>
	<function name="string-to-codepoints" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:string-to-codepoints">
		<summary>
			<p>Returns the sequence of Unicode code points that constitute an xs:string. If $arg is a zero-length string or the empty sequence, the empty sequence is returned.</p>
		</summary>
		<params>
			<param name="arg" type="xs:string" optional="false">A string.</param>
		</params>
		<return>xs:integer*</return>
		<example xml:space="preserve">
fn:string-to-codepoints("Thèrése")

returns the sequence (84, 104, 233, 114, 232, 115, 101)
</example>
	</function>
	<function name="compare" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:compare">
		<summary>
			<p>Returns -1, 0, or 1, depending on whether the value of the $comparand1 is respectively less than, equal to, or greater than the value of $comparand2, according to the rules of the collation that is used.</p>
		</summary>
		<params>
			<param name="comparand1" type="xs:string?" optional="false">A string to be compared.</param>
			<param name="comparand2" type="xs:string?" optional="false">A string to be compared.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:compare("hello", "goodbye")

=&gt; 1
</example>
	</function>
	<function name="codepoint-equal" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:codepoint-equal">
		<summary>
			<p>Returns
				<code>true</code>if the specified parameters are the same Unicode code point, otherwise returns
				<code>false</code>. The codepoints are compared according to the Unicode code point collation (
				<a href="http://www.w3.org/2005/xpath-functions/collation/codepoint">http://www.w3.org/2005/xpath-functions/collation/codepoint</a>).</p>
			<p>If either argument is the empty sequence, the result is the empty sequence.</p>
		</summary>
		<params>
			<param name="comparand1" type="xs:string?" optional="false">A string to be compared.</param>
			<param name="comparand2" type="xs:string?" optional="false">A string to be compared.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
let $cp := fn:string-to-codepoints("123456")
return
fn:codepoint-equal("123456", fn:codepoints-to-string($cp) )

=&gt; true
</example>
	</function>
	<function name="concat" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:concat">
		<summary>
			<p>Returns the
				<code>xs:string</code>that is the concatenation of the values of the specified parameters. Accepts two or more
				<code>xs:anyAtomicType</code>arguments and casts them to
				<code>xs:string</code>. If any of the parameters is the empty sequence, the parameter is treated as the zero-length string.</p>
		</summary>
		<params>
			<param name="parameter1" type="xs:anyAtomicType?" optional="false">A value.</param>
			<param name="parameterN" type="xs:anyAtomicType?,..." optional="true">A value.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
fn:concat("a", "b", "c")

=&gt; abc
</example>
	</function>
	<function name="string-join" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:string-join">
		<summary>
			<p>Returns an
				<code>xs:string</code>created by concatenating the members of the $parameter1 sequence using $parameter2 as a separator. If the value of $arg2 is the zero-length string, then the members of $parameter1 are concatenated without a separator.</p>
			<p>If the value of $parameter1 is the empty sequence, the zero-length string is returned.</p>
		</summary>
		<params>
			<param name="parameter1" type="xs:string*" optional="false">A sequence of strings.</param>
			<param name="parameter2" type="xs:string" optional="false">A separator string to concatenate between the items in $parameter1.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
fn:string-join(("hello", "goodbye"), " and ")

=&gt; hello and goodbye
</example>
    <example xml:space="preserve">
let $string := "this is a string"
return
fn:string-join(fn:tokenize($string, " "),
               "-")

=&gt; this-is-a-string
</example>
	</function>
	<function name="starts-with" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:starts-with">
		<summary>Returns
			<code>true</code>if the first parameter starts with the string from the second parameter, otherwise returns
			<code>false</code>.</summary>
		<params>
			<param name="parameter1" type="xs:string?" optional="false">The string from which to test.</param>
			<param name="parameter2" type="xs:string?" optional="false">The string to test whether it is at the beginning of the first parameter.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:starts-with("abcd", "ab")

=&gt; true
</example>
	</function>
	<function name="ends-with" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:ends-with">
		<summary>Returns
			<code>true</code>if the first parameter ends with the string from the second parameter, otherwise returns
			<code>false</code>.</summary>
		<params>
			<param name="parameter1" type="xs:string?" optional="false">The parameter from which to test.</param>
			<param name="parameter2" type="xs:string?" optional="false">The string to test whether it is at the end of the first parameter.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:ends-with("this is a string", "a string")

=&gt; true
</example>
	</function>
	<function name="contains" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:contains">
		<summary>Returns
			<code>true</code>if the first parameter contains the string from the second parameter, otherwise returns
			<code>false</code>.</summary>
		<params>
			<param name="parameter1" type="xs:string?" optional="false">The string from which to test.</param>
			<param name="parameter2" type="xs:string?" optional="false">The string to test for existence in the first parameter.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:contains("this is a string", "s a s")

=&gt; true
</example>
	</function>
	<function name="substring" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:substring">
		<summary>Returns a substring starting from the $startingLoc and continuing for $length characters.</summary>
		<params>
			<param name="sourceString" type="xs:string?" optional="false">The string from which to create a substring.</param>
			<param name="startingLoc" type="xs:double" optional="false">The number of characters from the start of the $sourceString.</param>
			<param name="length" type="xs:double" optional="true">The number of characters beyond the $startingLoc.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:substring("123456", 2, 2)

=&gt; "23"
</example>
	</function>
	<function name="string-length" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:string-length">
		<summary>Returns an integer representing the length of the specified string. The length is 1-based, so a string that is one character long returns a value of 1.</summary>
		<params>
			<param name="sourceString" type="xs:string?" optional="true">The string to calculate the length.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
fn:string-length("12345")

=&gt; 5
</example>
	</function>
	<function name="substring-before" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:substring-before">
		<summary>Returns the substring created by taking all of the input characters that occur before the specified $before characters.</summary>
		<params>
			<param name="input" type="xs:string?" optional="false">The string from which to create the substring.</param>
			<param name="before" type="xs:string?" optional="false">The string before which the substring is created.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:substring-before("abcdef", "def")

=&gt; abc
</example>
	</function>
	<function name="substring-after" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:substring-after">
		<summary>Returns the substring created by taking all of the input characters that occur after the specified $after characters.</summary>
		<params>
			<param name="input" type="xs:string?" optional="false">The string from which to create the substring.</param>
			<param name="after" type="xs:string?" optional="false">The string after which the substring is created.</param>
			<param name="collation" type="xs:string" optional="true">The optional name of a valid collation URI. For information on the collation URI syntax, see the
				<em>Search Developer's Guide</em>.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:substring-after("123456", "3")

=&gt; "456"
</example>
	</function>
	<function name="normalize-space" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:normalize-space">
		<summary>Returns the specified string with normalized whitespace, which strips off any leading or trailing whitespace and replaces any other sequences of more than one whitespace characters with a single space character (#x20).</summary>
		<params>
			<param name="input" type="xs:string?" optional="true">The string from which to normalize whitespace.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:normalize-space("
this
is
  a string
  ")

=&gt; this is a string
</example>
	</function>
	<function name="normalize-unicode" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:normalize-unicode">
		<summary>Return the argument normalized according to the normalization criteria for a normalization form identified by the value of $normalizationForm. The effective value of the $normalizationForm is computed by removing leading and trailing blanks, if present, and converting to upper case.</summary>
		<params>
			<param name="arg" type="xs:string?" optional="false">The string to normalize.</param>
			<param name="normalizationForm" type="xs:string" optional="true">The form under which to normalize the specified string: NFC, NFD, NFKC, or NFKD.</param>
		</params>
		<return>xs:string?</return>
	</function>
	<function name="upper-case" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:upper-case">
		<summary>Returns the specified string converting all of the characters to upper-case characters. If a character does not have a corresponding upper-case character, then the original character is returned. The upper-case characters are determined using the
			<a href="http://www.unicode.org/unicode/reports/tr21/">Unicode Case Mappings</a>.</summary>
		<params>
			<param name="string" type="xs:string?" optional="false">The string to upper-case.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:upper-case("Abcd")

=&gt; ABCD
</example>
	</function>
	<function name="lower-case" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:lower-case">
		<summary>Returns the specified string converting all of the characters to lower-case characters. If a character does not have a corresponding lower-case character, then the original character is returned. The lower-case characters are determined using the
			<a href="http://www.unicode.org/unicode/reports/tr21/">Unicode Case Mappings</a>.</summary>
		<params>
			<param name="string" type="xs:string?" optional="false">The string to convert.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:lower-case("aBCD")

=&gt; abcd
</example>
	</function>
	<function name="translate" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:translate">
		<summary>Returns a string where every character in $src that occurs in some position in the $mapString is translated into the $transString character in the corresponding location of the $mapString character.</summary>
		<params>
			<param name="src" type="xs:string?" optional="false">The string to translate characters.</param>
			<param name="mapString" type="xs:string?" optional="false">The string representing characters to be translated.</param>
			<param name="transString" type="xs:string?" optional="false">The string representing the characters to which the $mapString characters are translated.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:translate("abcd", "abcd", "wxyz")

=&gt; wxyz
</example>
	</function>
	<function name="string-pad" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:string-pad">
		<summary>[0.9-ml only] Returns a string representing the $padString concatenated with itself the number of times specifed in $padCount.</summary>
		<params>
			<param name="padString" type="xs:string?" optional="false">The string to pad.</param>
			<param name="padCount" type="xs:integer" optional="false">The number of times to pad the string.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
fn:string-pad("abc", 3)

=&gt; abcabcabc
</example>
	</function>
	<function name="escape-uri" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:escape-uri">
		<summary>This is a May 2003 function, and is only available in compatibility mode (XQuery 0.9-ML)--it has been replaced with
			<code>fn:encode-for-uri</code>,
			<code>fn:iri-to-uri</code>, and
			<code>fn:escape-html-uri</code>. Returns a string representing the specified URI either with escaped reserved characters ($escape-reserved=true) or with the reserved characters left as specified ($escape-reserved=true). For more details, see the
			<a href="http://www.w3.org/TR/2003/WD-xpath-functions-20030502/#func-escape-uri">W3C XQuery Functions and Operators specification</a>.</summary>
		<params>
			<param name="uri-part" type="xs:string" optional="false">A string representing an unescaped URI.</param>
			<param name="escape-reserved" type="xs:boolean" optional="false">Specify a boolean value of
				<code>true</code>to return an escaped URI or a boolean value of
				<code>false</code>to return an unescaped URI.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
fn:escape-uri("http://developer.marklogic.com", fn:true())

=&gt; http%3A%2F%2Fdeveloper.marklogic.com

fn:escape-uri("http://developer.marklogic.com", fn:false())

=&gt; http://developer.marklogic.com
</example>
	</function>
	<function name="encode-for-uri" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:encode-for-uri">
		<summary>Invertible function that escapes characters required to be escaped inside path segments of URIs.</summary>
		<params>
			<param name="uri-part" type="xs:string" optional="false">A string representing an unescaped URI.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
fn:encode-for-uri("http://example.com/Weather/Los%20Angeles#ocean")
=&gt; "http%3A%2F%2Fexample.com%2FWeather%2FLos%2520Angeles%23ocean"
</example>
	</function>
	<function name="iri-to-uri" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:iri-to-uri">
		<summary>Idempotent function that escapes non-URI characters.</summary>
		<params>
			<param name="uri-part" type="xs:string" optional="false">A string representing an unescaped URI.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
fn:iri-to-uri("http://example.com/Weather/Los%20Angeles#ocean")
=&gt; "http://example.com/Weather/Los%20Angeles#ocean"
</example>
	</function>
	<function name="escape-html-uri" type="builtin" lib="fn" category="StringBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:escape-html-uri">
		<summary>%-escapes everything except printable ASCII characters.</summary>
		<params>
			<param name="uri-part" type="xs:string" optional="false">A string representing an unescaped URI.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
fn:escape-html-uri("http://example.com/Weather/Los Angeles#ocean")
=&gt; "http://example.com/Weather/Los Angeles#ocean"
</example>
	</function>
	<function name="regex-group" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:regex-group">
		<summary>
			<p>While the
				<code>xsl:matching-substring</code>instruction is active, a set of current captured substrings is available, corresponding to the parenthesized sub-expressions of the regular expression. These captured substrings are accessible using the function regex-group. This function takes an integer argument to identify the group, and returns a string representing the captured substring.</p>
			<p>This function is only available in XSLT; it is not available in XQuery.</p>
		</summary>
		<params>
			<param name="group-number" type="xs:integer" optional="false">The group number to return.</param>
		</params>
		<return>xs:string</return>
		<usage>
			<p>The function returns the zero-length string if there is no captured substring with the relevant number. This can occur for a number of reasons:</p>
			<ol>
				<li>The number is negative.</li>
				<li>The regular expression does not contain a parenthesized sub-expression with the given number.</li>
				<li>The parenthesized sub-expression exists, and did not match any part of the input string.</li>
				<li>The parenthesized sub-expression exists, and matched a zero-length substring of the input string.</li>
			</ol>
		</usage>
		<example xml:space="preserve">

<p xmlns="http://www.w3.org/1999/xhtml">See the examples in the
<code>xsl:analyze-string</code> section of
  the
<a href="http://www.w3.org/TR/xslt20/#analyze-string" target="_blank">XSLT Specification</a>.
  </p>
</example>
	</function>
	<function name="current" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:current">
		<summary>
			<p>Returns the item that was the context item at the point where the expression was invoked from the XSLT stylesheet.</p>
			<p>This function is only available in XSLT; it is not available in XQuery.</p>
		</summary>
		<return>item()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

xdmp:xslt-eval(
&lt;xsl:stylesheet version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
 &lt;xsl:template match="/"&gt;
   &lt;xsl:value-of select="node-name(current()/element())"/&gt;
 &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;,
document{&lt;foo&gt;hello there&lt;/foo&gt;})

=&gt; foo
</example>
	</function>
	<function name="current-position" type="builtin" lib="xdmp" category="Extension" subcategory="XSLT" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:current-position">
		<summary>
			<p>Returns the position of the current item.</p>
			<p>This function is only available in XSLT; it is not available in XQuery.</p>
		</summary>
		<return>xs:integer</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

xdmp:xslt-eval(
&lt;xsl:stylesheet version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xdmp="http://marklogic.com/xdmp"&gt;
 &lt;xsl:template match="/"&gt;
   &lt;xsl:value-of select="xdmp:current-position()"/&gt;
 &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;,
document{&lt;foo&gt;hello there&lt;/foo&gt;})

=&gt; 1
</example>
	</function>
	<function name="current-last" type="builtin" lib="xdmp" category="Extension" subcategory="XSLT" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:current-last">
		<summary>
			<p>Returns the size of the current node list.</p>
			<p>This function is only available in XSLT; it is not available in XQuery.</p>
		</summary>
		<return>xs:integer</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

xdmp:xslt-eval(
&lt;xsl:stylesheet version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xdmp="http://marklogic.com/xdmp"&gt;
 &lt;xsl:template match="foo"&gt;
   &lt;xsl:value-of select="xdmp:current-last()"/&gt;
 &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;,
document{&lt;foo&gt;
           &lt;a&gt;hello&lt;/a&gt;
           &lt;b&gt;there&lt;/b&gt;
         &lt;/foo&gt;})


=&gt; 1
</example>
	</function>
	<function name="system-property" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:system-property">
		<summary>
			<p>Returns a string representing the value of the system property identified by the name. If there is no such system property, the zero-length string is returned.</p>
			<p>This function is only available in XSLT; it is not available in XQuery.</p>
		</summary>
		<params>
			<param name="property-name" type="xs:string" optional="false">The name of the property whose value is to be returned. Valid names are:
				<ul>
					<li>xsl:version</li>
					<li>xsl:vendor</li>
					<li>xsl:vendor-url</li>
					<li>xsl:product-name</li>
					<li>xsl:product-version</li>
					<li>xsl:is-schema-aware</li>
					<li>xsl:supports-serialization</li>
					<li>xsl:supports-backwards-compatibility</li>
					<li>xsl:supports-namespace-axis</li>
				</ul></param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

xdmp:xslt-eval(
&lt;xsl:stylesheet version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
 &lt;xsl:template match="foo"&gt;
   &lt;xsl:value-of select="system-property('xsl:is-schema-aware')"/&gt;
 &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;,
document{&lt;foo&gt;hello there&lt;/foo&gt;})

=&gt; yes
</example>
	</function>
	<function name="element-available" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:element-available">
		<summary>
			<p />Returns true if and only if the name of an XSLT instruction is passed in.
			<p>This function is only available in XSLT; it is not available in XQuery.</p></summary>
		<params>
			<param name="element-name" type="xs:string" optional="false">The name of the element to test.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

xdmp:xslt-eval(
&lt;xsl:stylesheet version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
 &lt;xsl:template match="foo"&gt;
   &lt;xsl:value-of
        select="element-available('xsl:apply-templates')"/&gt;
 &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;,
document{&lt;foo&gt;hello there&lt;/foo&gt;})

=&gt; true
</example>
	</function>
	<function name="key" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:key">
		<summary>
			<p>The key function does for keys what the id function does for IDs.</p>
			<p>This function is only available in XSLT; it is not available in XQuery.</p>
		</summary>
		<params>
			<param name="key-name" type="xs:string" optional="false">The name of the key.</param>
			<param name="key-value" type="xs:string" optional="false">The value of the key.</param>
			<param name="top" type="node()" optional="true">The subtree to limit the results to.</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">

<p xmlns="http://www.w3.org/1999/xhtml">See the examples in the Keys section of
  the
<a href="http://www.w3.org/TR/xslt20/#key" target="_blank">XSLT Specification</a>.
  </p>
</example>
	</function>
	<function name="current-group" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:current-group">
		<summary>
			<p>Returns the current regex group.</p>
			<p>This function is only available in XSLT; it is not available in XQuery.</p>
		</summary>
		<return>item()*</return>
		<example xml:space="preserve">

<p xmlns="http://www.w3.org/1999/xhtml">See the examples in the Grouping section of
  the
<a href="http://www.w3.org/TR/xslt20/#grouping" target="_blank">XSLT Specification</a>.
  </p>
</example>
	</function>
	<function name="current-grouping-key" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:current-grouping-key">
		<summary>
			<p>Returns the current regex grouping key.</p>
			<p>This function is only available in XSLT; it is not available in XQuery.</p>
		</summary>
		<return>xs:anyAtomicType?</return>
		<example xml:space="preserve">

<p xmlns="http://www.w3.org/1999/xhtml">See the examples in the Grouping section of
  the
<a href="http://www.w3.org/TR/xslt20/#grouping" target="_blank">XSLT Specification</a>.
  </p>
</example>
	</function>
	<function name="type-available" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:type-available">
		<summary>Returns true if and only if there is a type whose name matches the value of the $type-name argument is present in the static context. This is an XSLT function, and it is available in both XSLT and in XQuery 1.0-ml.</summary>
		<params>
			<param name="type-name" type="xs:string" optional="false">The $type-name is a string containing a lexical QName. It may be a name of a builtin-type, type imported using xsl:import-schema, or an extension type. This parameter is mandatory. The lexical QName is expanded using the namespace declarations in scope for the expression. If the lexical QName is unprefixed, then the default namespace is used in the expanded QName.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:type-available(xs:integer)
</example>
	</function>
	<function name="function-available" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:function-available">
		<summary>Returns true if and only if there is a function whose name and optionally arity matches the value of the $function-name and the optional $arity arguments. This is an XSLT function, and it is available in both XSLT and in XQuery 1.0-ml.</summary>
		<params>
			<param name="function-name" type="xs:string" optional="false">The $function-name is a string containing a lexical QName. It may be a name of a builtin-type, type imported using xsl:import-schema, or an extension type. This parameter is mandatory. The lexical QName is expanded using the namespace declarations in scope for the expression. If the lexical QName is unprefixed, then the standard function namespace is used in the expanded QName.</param>
			<param name="arity" type="xs:integer" optional="true">If $arity parameter is present, then the function returns true if and only if the function specified by the first argument has a signature that takes $arity number of arguments.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:type-available(xs:integer)
</example>
	</function>
	<function name="unparsed-entity-uri" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:unparsed-entity-uri">
		<summary>Always returns the zero length string. This function is only available in XSLT; it is not available in XQuery.</summary>
		<params>
			<param name="entity-name" type="xs:string" optional="false">The entity name.</param>
		</params>
		<return>xs:anyURI</return>
		<example xml:space="preserve">

<p xmlns="http://www.w3.org/1999/xhtml">See
  the
<a href="http://www.w3.org/TR/xslt20/#unparsed-entity-uri" target="_blank">XSLT Specification</a>.
  </p>
</example>
	</function>
	<function name="unparsed-entity-public-id" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:unparsed-entity-public-id">
		<summary>Returns the public identifier of the unparsed entity specified by the $entity-name parameter. If no such entity exists or if the entity has no public identifier, this function returns the empty string. This function is only available in XSLT; it is not available in XQuery.</summary>
		<params>
			<param name="entity-name" type="xs:string" optional="false">The entity name.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">

<p xmlns="http://www.w3.org/1999/xhtml">See
  the
<a href="http://www.w3.org/TR/xslt20/#unparsed-entity-public-id" target="_blank">XSLT Specification</a>.
  </p>
</example>
	</function>
	<function name="position" type="builtin" lib="fn" category="ContextBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:position">
		<summary>Returns the context position from the dynamic context. (See
			<a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">Section C.2 Dynamic Context Components[XP]</a>.) If the context item is undefined, an error is raised [err:FONC0001].</summary>
		<params />
		<return>xs:integer</return>
		<example xml:space="preserve">
let $x := (10, 20, 30, 40, 50)
return
$x[position() eq 2]

=&gt; 20, which is in the second position in the sequence
</example>
	</function>
	<function name="last" type="builtin" lib="fn" category="ContextBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:last">
		<summary>Returns the context size from the dynamic context. (See
			<a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">Section C.2 Dynamic Context Components[XP]</a>.) If the context item is undefined, an error is raised [err:FONC0001].</summary>
		<params />
		<return>xs:integer</return>
		<example xml:space="preserve">
let $x := (10, 20, 30, 40, 50)
return
$x[last()]

=&gt; 50, which is the last item in the sequence
</example>
	</function>
	<function name="current-dateTime" type="builtin" lib="fn" category="ContextBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:current-dateTime">
		<summary>Returns the current dateTime value (with timezone) from the dynamic context. (See
			<a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">Section C.2 Dynamic Context Components[XP]</a>.) This is an
			<code>xs:dateTime</code>that is current at some time during the evaluation of a query or transformation in which
			<code>fn:current-dateTime()</code>is executed. This function is *stable*. The precise instant during the query or transformation represented by the value of
			<code>fn:current-dateTime()</code>is *implementation dependent*.</summary>
		<params />
		<return>xs:dateTime</return>
		<usage>
			<code>fn:current-dateTime()</code>returns an
			<code>xs:dateTime</code>corresponding to the current date and time. For example, an invocation of
			<code>fn:current-dateTime()</code>might return
			<code>2004-05-12T18:17:15.125Z</code>corresponding to the current time on May 12, 2004 in timezone Z.</usage>
		<example xml:space="preserve">
fn:current-dateTime()

=&gt; 2006-05-25T18:21:24.454-07:00
</example>
	</function>
	<function name="current-date" type="builtin" lib="fn" category="ContextBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:current-date">
		<summary>Returns
			<code>xs:date(fn:current-dateTime())</code>. This is an
			<code>xs:date</code>(with timezone) that is current at some time during the evaluation of a query or transformation in which
			<code>fn:current-date()</code>is executed. This function is *stable*. The precise instant during the query or transformation represented by the value of
			<code>fn:current-date()</code>is *implementation dependent*.</summary>
		<params />
		<return>xs:date</return>
		<usage>
			<code>fn:current-date()</code>returns an
			<code>xs:date</code>corresponding to the current date and time. For example, an invocation of
			<code>fn:current-date()</code>might return
			<code>2004-05-12+01:00</code>.</usage>
		<example xml:space="preserve">
fn:current-date()

=&gt; 2006-05-25-07:00
</example>
	</function>
	<function name="current-time" type="builtin" lib="fn" category="ContextBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:current-time">
		<summary>Returns
			<code>xs:time(fn:current-dateTime())</code>. This is an
			<code>xs:time</code>(with timezone) that is current at some time during the evaluation of a query or transformation in which
			<code>fn:current-time()</code>is executed. This function is *stable*. The precise instant during the query or transformation represented by the value of
			<code>fn:current-time()</code>is *implementation dependent*.</summary>
		<params />
		<return>xs:time</return>
		<usage>
			<code>fn:current-time()</code>returns an
			<code>xs:time</code>corresponding to the current date and time. For example, an invocation of
			<code>fn:current-time()</code>might return
			<code>23:17:00.000-05:00</code>.</usage>
		<example xml:space="preserve">
fn:current-time()

=&gt; 18:24:06-07:00
</example>
	</function>
	<function name="implicit-timezone" type="builtin" lib="fn" category="ContextBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:implicit-timezone">
		<summary>Returns the value of the implicit timezone property from the dynamic context. Components of the dynamic context are discussed in
			<a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">Section C.2 Dynamic Context Components[XP]</a>.</summary>
		<params />
		<return>xs:dayTimeDuration</return>
		<example xml:space="preserve">
fn:implicit-timezone()

=&gt; -PT7H
</example>
	</function>
	<function name="default-collation" type="builtin" lib="fn" category="ContextBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:default-collation">
		<summary>
			<p>Returns the value of the default collation property from the static context. Components of the static context are discussed in
				<a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">Section C.1 Static Context Components[XP]</a>.</p>
			<p>The default collation property can never be undefined. If it is not explicitly defined, a system defined default codepoint is used. In the
				<code>1.0</code>XQuery dialect, if this is not provided, the Unicode code point collation (
				<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>) is used. In the
				<code>1.0-ml</code>and
				<code>0.9-ml</code>XQuery dialects, the MarkLogic-defined codepoint URI is used (
				<code>http://marklogic.com/collation/codepoint</code>).</p>
		</summary>
		<params />
		<return>xs:string</return>
		<usage>For details about collations in MarkLogic Server, see the "Encodings and Collations" chapter of the
			<em>Developer's Guide</em>.</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
declare default collation "http://marklogic.com/collation/codepoint";
fn:default-collation()

=&gt; http://marklogic.com/collation/codepoint
</example>
    <example xml:space="preserve">
xquery version "1.0";
declare default collation "http://marklogic.com/collation/codepoint";
fn:default-collation()

=&gt; http://www.w3.org/2005/xpath-functions/collation/codepoint
</example>
	</function>
	<function name="static-base-uri" type="builtin" lib="fn" category="ContextBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:static-base-uri">
		<summary>Returns the value of the base-uri property from the static context. If the base-uri property is undefined, the empty sequence is returned. Components of the static context are discussed in
			<a href="http://www.w3.org/TR/xpath20/#id-xp-evaluation-context-components">Section C.1 Static Context Components[XP]</a>.</summary>
		<params />
		<return>xs:anyURI?</return>
	</function>
	<function name="error" type="builtin" lib="fn" category="Error and Trace" bucket="W3C-Standard Functions" hidden="false" fullname="fn:error">
		<summary>[1.0 and 1.0-ml only, 0.9-ml has a different signature] Throw the given error. When an error is thrown, the XQuery program execution is stopped. For detailed semantics, see
			<a href="http://www.w3.org/TR/xpath-functions/#func-error">http://www.w3.org/TR/xpath-functions/#func-error</a>.</summary>
		<params>
			<param name="error" type="xs:QName?" optional="true">Error code, as an
				<code>xs:QName</code>. Note that this parameter does not exist in 0.9-ml.</param>
			<param name="description" type="xs:string" optional="true">String description to be printed with the error.</param>
			<param name="data" type="item()*" optional="true">Parameters to the error message.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
let $x := xdmp:random(100)
return
(
if ( $x gt 50 )
then ( fn:error(xs:QName("ERROR"), "greater than 50") )
else ( "Less than or equal to 50" ) ,
": no error was thrown" )

=&gt; The error when the random number is greater
   than 50.
</example>
	</function>
	<function name="resolve-QName" type="builtin" lib="fn" category="QNameBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:resolve-QName">
		<summary>
			<p>Returns an
				<code>xs:QName</code>value (that is, an expanded QName) by taking an
				<code>xs:string</code>that has the lexical form of an
				<code>xs:QName</code>(a string in the form "prefix:local-name" or "local-name") and resolving it using the in-scope namespaces for a given element.</p>
		</summary>
		<params>
			<param name="qname" type="xs:string?" optional="false">A string of the form "prefix:local-name".</param>
			<param name="element" type="element()" optional="false">An element providing the in-scope namespaces to use to resolve the qualified name.</param>
		</params>
		<return>xs:QName?</return>
		<usage>
			<p>Sometimes the requirement is to construct an
				<code>xs:QName</code>without using the default namespace. This can be achieved by writing:</p>
			<pre xml:space="preserve">
     if ( fn:contains($qname, ":") )
     then ( fn:resolve-QName($qname, $element) )
     else ( fn:QName("", $qname) )
</pre>
			<p>If the requirement is to construct an
				<code>xs:QName</code>using the namespaces in the static context, then the
				<code>xs:QName</code>constructor should be used.</p>
			<p>If $qname does not have the correct lexical form for
				<code>xs:QName</code>an error is raised [err:FOCA0002].</p>
			<p>If $qname is the empty sequence, returns the empty sequence.</p>
			<p>More specifically, the function searches the namespace bindings of $element for a binding whose name matches the prefix of $qname, or the zero-length string if it has no prefix, and constructs an expanded QName whose local name is taken from the supplied $qname, and whose namespace URI is taken from the string value of the namespace binding.</p>
			<p>If the $qname has a prefix and if there is no namespace binding for $element that matches this prefix, then an error is raised [err:FONS0004].</p>
			<p>If the $qname has no prefix, and there is no namespace binding for $element corresponding to the default (unnamed) namespace, then the resulting expanded QName has no namespace part.</p>
			<p>The prefix (or absence of a prefix) in the supplied $qname argument is retained in the returned expanded QName, as discussed in Section 2.1 Terminology[DM].</p>
		</usage>
		<example xml:space="preserve">
Assume that the element bound to $element has a single
namespace binding bound to the prefix "eg".

fn:resolve-QName("hello", $element)

=&gt; a QName with local name "hello"
   that is in no namespace.

fn:resolve-QName("eg:myFunc", $element)

=&gt; an xs:QName whose namespace URI is specified
   by the namespace binding corresponding to the
   prefix "eg" and whose local name is "myFunc".
</example>
	</function>
	<function name="QName" type="builtin" lib="fn" category="QNameBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:QName">
		<summary>
			<p>Returns an
				<code>xs:QName</code>with the namespace URI given in $paramURI. If $paramURI is the zero-length string or the empty sequence, it represents "no namespace"; in this case, if the value of $paramQName contains a colon (:), an error is raised [err:FOCA0002]. The prefix (or absence of a prefix) in $paramQName is retained in the returned xs:QName value. The local name in the result is taken from the local part of $paramQName.</p>
		</summary>
		<params>
			<param name="paramURI" type="xs:string?" optional="false">A namespace URI, as a string.</param>
			<param name="paramQName" type="xs:string" optional="false">A lexical qualified name (xs:QName), a string of the form "prefix:localname" or "localname".</param>
		</params>
		<return>xs:QName</return>
		<usage>
			<p>If $paramQName does not have the correct lexical form for
				<code>xs:QName</code>an error is raised [err:FOCA0002].</p>
			<p>Note that unlike xs:QName this function does not require an
				<code>xs:string</code>literal as the argument.</p>
		</usage>
		<example xml:space="preserve">
fn:QName("http://www.example.com/example", "person")

=&gt; an xs:QName with namespace URI =
   "http://www.example.com/example",
   local name = "person", and
   prefix = "".

fn:QName("http://www.example.com/example", "ht:person")

=&gt; an xs:QName with namespace URI =
   "http://www.example.com/example",
   local name = "person",
   and prefix = "ht".
</example>
	</function>
	<function name="expanded-QName" type="builtin" lib="fn" category="QNameBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:expanded-QName">
		<summary>
			<p>[0.9-ml only, use
				<a href="#fn:QName">
					<code>fn:QName</code>
				</a>instead] Returns an
				<code>xs:QName</code>with the namespace URI given in $paramURI and the local name in $paramLocal. If $paramURI is the zero-length string or the empty sequence, it represents "no namespace".</p>
		</summary>
		<params>
			<param name="paramURI" type="xs:string?" optional="false">A namespace URI, as a string.</param>
			<param name="paramLocal" type="xs:string" optional="false">A localname, as a string.</param>
		</params>
		<return>xs:QName</return>
		<example xml:space="preserve">
(: this function only exists in 0.9-ml :)
xquery version "0.9-ml"
fn:expanded-QName("http://www.example.com/example", "person")

=&gt; an xs:QName with namespace URI =
   "http://www.example.com/example",
   local name = "person".


</example>
	</function>
	<function name="prefix-from-QName" type="builtin" lib="fn" category="QNameBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:prefix-from-QName">
		<summary>Returns an
			<code>xs:NCName</code>representing the prefix of $arg. The empty sequence is returned if $arg is the empty sequence or if the value of $arg contains no prefix.</summary>
		<params>
			<param name="arg" type="xs:QName?" optional="false">A qualified name.</param>
		</params>
		<return>xs:NCName?</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
declare namespace ex="http://www.example.com/example";

fn:prefix-from-QName(
   fn:QName("http://www.example.com/example", "person") )

=&gt; empty sequence, because the QName constructed
   by fn:QName does not have a prefix
</example>
    <example xml:space="preserve">
let $qn := fn:QName("http://www.w3.org/XML/1998/namespace", "lang")
return
fn:prefix-from-QName(fn:node-name( attribute {$qn} {"en"}))

=&gt; xml
</example>
	</function>
	<function name="local-name-from-QName" type="builtin" lib="fn" category="QNameBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:local-name-from-QName">
		<summary>Returns an
			<code>xs:NCName</code>representing the local part of $arg. If $arg is the empty sequence, returns the empty sequence.</summary>
		<params>
			<param name="arg" type="xs:QName?" optional="false">A qualified name.</param>
		</params>
		<return>xs:NCName?</return>
		<example xml:space="preserve">
fn:local-name-from-QName(
   fn:QName("http://www.example.com/example", "person") )

=&gt; person
</example>
	</function>
	<function name="namespace-uri-from-QName" type="builtin" lib="fn" category="QNameBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:namespace-uri-from-QName">
		<summary>Returns the namespace URI for $arg as an
			<code>xs:string</code>. If $arg is the empty sequence, the empty sequence is returned. If $arg is in no namespace, the zero-length string is returned.</summary>
		<params>
			<param name="arg" type="xs:QName?" optional="false">A qualified name.</param>
		</params>
		<return>xs:anyURI?</return>
		<example xml:space="preserve">
fn:namespace-uri-from-QName(
  fn:QName("http://www.example.com/example", "person") )

=&gt; the namespace URI corresponding to
   "http://www.example.com/example".
</example>
	</function>
	<function name="namespace-uri-for-prefix" type="builtin" lib="fn" category="QNameBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:namespace-uri-for-prefix">
		<summary>
			<p>Returns the namespace URI of one of the in-scope namespaces for $element, identified by its namespace prefix.</p>
			<p>If $element has an in-scope namespace whose namespace prefix is equal to $prefix, it returns the namespace URI of that namespace. If $prefix is the zero-length string or the empty sequence, it returns the namespace URI of the default (unnamed) namespace. Otherwise, it returns the empty sequence.</p>
			<p>Prefixes are equal only if their Unicode code points match exactly.</p>
		</summary>
		<params>
			<param name="prefix" type="xs:string?" optional="false">A namespace prefix to look up.</param>
			<param name="element" type="element()" optional="false">An element node providing namespace context.</param>
		</params>
		<return>xs:anyURI?</return>
		<example xml:space="preserve">
xquery version "0.9-ml"
declare namespace ex="http://www.example.com/example"

let $x := &lt;ex:hello&gt;1&lt;/ex:hello&gt;
return
fn:namespace-uri-for-prefix("ex", $x)

=&gt; the namespace URI corresponding to
   "http://www.example.com/example".
</example>
	</function>
	<function name="in-scope-prefixes" type="builtin" lib="fn" category="QNameBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:in-scope-prefixes">
		<summary>
			<p>Returns the prefixes of the in-scope namespaces for $element. For namespaces that have a prefix, it returns the prefix as an xs:NCName. For the default namespace, which has no prefix, it returns the zero-length string.</p>
		</summary>
		<params>
			<param name="element" type="element()" optional="false">The element whose in-scope prefixes will be returned.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
xquery version "0.9-ml"
declare namespace a="a"
declare namespace b="b"

let $x := &lt;a:hello&gt;hello
            &lt;b:goodbye&gt;goodbye&lt;/b:goodbye&gt;
	  &lt;/a:hello&gt;
return
fn:in-scope-prefixes($x)

=&gt; a

xquery version "0.9-ml"
declare namespace a="a"
declare namespace b="b"

let $x := &lt;a:hello&gt;hello
            &lt;b:goodbye&gt;goodbye&lt;/b:goodbye&gt;
	  &lt;/a:hello&gt;
return
fn:in-scope-prefixes($x/b:goodbye)

=&gt; b a
</example>
	</function>
	<function name="true" type="builtin" lib="fn" category="BooleanBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:true">
		<summary>Returns the
			<code>xs:boolean</code>value
			<code>true</code>. Equivalent to
			<code>xs:boolean("1")</code>.</summary>
		<params />
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:true()

=&gt; true
</example>
	</function>
	<function name="false" type="builtin" lib="fn" category="BooleanBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:false">
		<summary>Returns the
			<code>xs:boolean</code>value
			<code>false</code>. Equivalent to
			<code>xs:boolean("0")</code>.</summary>
		<params />
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:false()

=&gt; false
</example>
	</function>
	<function name="not" type="builtin" lib="fn" category="BooleanBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:not">
		<summary>Returns
			<code>true</code>if the effective boolean value is
			<code>false</code>, and
			<code>false</code>if the effective boolean value is
			<code>true</code>. The
			<code>$arg</code>parameter is first reduced to an effective boolean value by applying the
			<code>fn:boolean</code>function.</summary>
		<params>
			<param name="arg" type="item()*" optional="false">The expression to negate.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
fn:not(fn:true())

=&gt; false
</example>
    <example xml:space="preserve">
fn:not("false")

=&gt; false
</example>
	</function>
	<function name="format-dateTime" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:format-dateTime">
		<summary>Returns a formatted dateTime value based on the picture argument. This is an XSLT function, and it is available in both XSLT and in XQuery 1.0-ml.</summary>
		<params>
			<param name="value" type="xs:dateTime" optional="false">The given dateTime
				<code>$value</code>that needs to be formatted.</param>
			<param name="picture" type="xs:string" optional="false">The desired string representation of the given dateTime
				<code>$value</code>. The picture string is a sequence of characters, in which the characters represent variables such as, decimal-separator-sign, grouping-sign, zero-digit-sign, digit-sign, pattern-separator, percent sign and per-mille-sign. For details on the picture string, see
				<a href="http://www.w3.org/TR/xslt20/#date-picture-string" target="_blank">http://www.w3.org/TR/xslt20/#date-picture-string</a>.</param>
			<param name="language" type="xs:string" optional="true">The desired language for string representation of the dateTime
				<code>$value</code>.</param>
			<param name="calendar" type="xs:string" optional="true">The only calendar supported at this point is "Gregorian" or "AD".</param>
			<param name="country" type="xs:string" optional="true">$country is used the specification to take into account country specific string representation.</param>
		</params>
		<return>xs:string</return>
		<usage>
			<p>Dates before October 15, 1582 (the start of the Gregorian calendar) will not return the correct dateTime value.</p>
			<p>If the specified picture string includes a fractional second width that is three or more decimal places, then the fractional seconds are truncated (not rounded) on the third and greater width.</p>
		</usage>
		<example xml:space="preserve">
   fn:format-dateTime(fn:current-dateTime(),
                 "[Y01]/[M01]/[D01] [H01]:[m01]:[s01]:[f01]")

   fn:format-dateTime(fn:current-dateTime(),
                 "[Y01]/[M01]/[D01] [H01]:[m01]:[s01]:[f01]","en","AD","US")

</example>
	</function>
	<function name="format-date" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:format-date">
		<summary>Returns a formatted date value based on the picture argument. This is an XSLT function, and it is available in both XSLT and in XQuery 1.0-ml.</summary>
		<params>
			<param name="value" type="xs:date" optional="false">The given date
				<code>$value</code>that needs to be formatted.</param>
			<param name="picture" type="xs:string" optional="false">The desired string representation of the given date
				<code>$value</code>. The picture string is a sequence of characters, in which the characters represent variables such as, decimal-separator-sign, grouping-sign, zero-digit-sign, digit-sign, pattern-separator, percent sign and per-mille-sign. For details on the picture string, see
				<a href="http://www.w3.org/TR/xslt20/#date-picture-string" target="_blank">http://www.w3.org/TR/xslt20/#date-picture-string</a>.</param>
			<param name="language" type="xs:string" optional="true">The desired language for string representation of the date
				<code>$value</code>.</param>
			<param name="calendar" type="xs:string" optional="true">The only calendar supported at this point is "Gregorian" or "AD".</param>
			<param name="country" type="xs:string" optional="true">$country is used the specification to take into account country specific string representation.</param>
		</params>
		<return>xs:string</return>
		<usage>
			<p>Dates before October 15, 1582 (the start of the Gregorian calendar) will not return the correct date value.</p>
		</usage>
		<example xml:space="preserve">
   fn:format-date(fn:current-date(),
                 "[Y01]/[M01]/[D01]")

   fn:format-date(fn:current-date(),
                 "[Y01]/[M01]/[D01]","en","AD","US")

</example>
	</function>
	<function name="format-time" type="builtin" lib="fn" category="DurationDateTimeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:format-time">
		<summary>Returns a formatted time value based on the picture argument. This is an XSLT function, and it is available in both XSLT and in XQuery 1.0-ml.</summary>
		<params>
			<param name="value" type="time" optional="false">The given time
				<code>$value</code>that needs to be formatted.</param>
			<param name="picture" type="xs:string" optional="false">The desired string representation of the given time
				<code>$value</code>. The picture string is a sequence of characters, in which the characters represent variables such as, decimal-separator-sign, grouping-sign, zero-digit-sign, digit-sign, pattern-separator, percent sign and per-mille-sign. For details on the picture string, see
				<a href="http://www.w3.org/TR/xslt20/#date-picture-string" target="_blank">http://www.w3.org/TR/xslt20/#date-picture-string</a>.</param>
			<param name="language" type="xs:string" optional="true">The desired language for string representation of the time
				<code>$value</code>.</param>
			<param name="calendar" type="xs:string" optional="true">The only calendar supported at this point is "Gregorian" or "AD".</param>
			<param name="country" type="xs:string" optional="true">$country is used the specification to take into account country specific string representation.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
   fn:format-time(fn:current-time(),
                 "[H01]:[m01]:[s01]:[f01]")

   fn:format-time(fn:current-time(),
                 "[H01]:[m01]:[s01]:[f01]","en","AD","US")

</example>
	</function>
	<function name="parse-dateTime" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:parse-dateTime">
		<summary>Parses a string containing date, time or dateTime using the supplied picture argument and returns a dateTime value. While this function is closely related to other XSLT functions, it is available in XSLT as well as in all XQuery dialects.</summary>
		<params>
			<param name="picture" type="xs:string" optional="false">The desired string representation of the given
				<code>$value</code>. The picture string is a sequence of characters, in which the characters represent variables such as, decimal-separator-sign, grouping-sign, zero-digit-sign, digit-sign, pattern-separator, percent sign and per-mille-sign. For details on the picture string, see
				<a href="http://www.w3.org/TR/xslt20/#date-picture-string" target="_blank">http://www.w3.org/TR/xslt20/#date-picture-string</a>. This follows the specification of
				<a href="http://www.w3.org/TR/xslt20/#processing-picture-string" target="_blank">picture string</a>in the W3C XSLT 2.0 specification for the
				<code>fn:format-dateTime</code>function.
				<pre xml:space="preserve">

   Symbol         Description
  -----------------------------------
     'Y'        year(absolute value)
     'M'        month in year
     'D'        day in month
     'd'        day in year
     'F'        day of week
     'W'        week in year
     'w'        week in month
     'H'        hour in day
     'h'        hour in half-day
     'P'        am/pm marker
     'm'        minute in hour
     's'        second in minute
     'f'        fractional seconds
     'Z'        timezone as a time offset from UTC
                for example PST
     'z'        timezone as an offset using GMT,
                for example GMT+1
</pre></param>
			<param name="value" type="xs:string" optional="false">The given string
				<code>$value</code>representing the dateTime value that needs to be formatted.</param>
			<param name="language" type="xs:string" optional="true">The language used in string representation of the date, time or dateTime value.</param>
			<param name="calendar" type="xs:string" optional="true">This argument is reserved for future use. The only calendar supported at this point is "Gregorian" or "AD".</param>
			<param name="country" type="xs:string" optional="true">$country is used to take into account if there any country specific interpretation of the string while converting it into dateTime value.</param>
		</params>
		<return>xs:dateTime</return>
		<usage>Dates before October 15, 1582 (the start of the Gregorian calendar) will not return the correct dateTime value.</usage>
		<example xml:space="preserve">
   xdmp:parse-dateTime("[Y0001]-[M01]-[D01]T[h01]:[m01]:[s01].[f1][Z]","2010-01-06T17:13:50.873594-08:00")

</example>
	</function>
	<function name="parse-yymmdd" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:parse-yymmdd">
		<summary>Parses a string containing date, time or dateTime using the supplied picture argument and returns a dateTime value. While this function is closely related to other XSLT functions, it is available in XSLT as well as in all XQuery dialects.</summary>
		<params>
			<param name="picture" type="xs:string" optional="false">The desired string representation of the given
				<code>$value</code>. This follows the specification of picture string which is compatible to the format specification in icu. See "http://icu-project.org/apiref/classSimpleDateFormat.html" for more details. Here is the summary of the formatting symbols:
				<pre xml:space="preserve">

     Symbol     Description
  ----------------------------
     "y"       year(absolute value)
     "M"       month in year
     "d"       day in month
     "D"       day in year
     "E"       day of week
     "w"       week in year
     "W"       week in month
     "H"       hour in day
     "K"       hour in half-day
     "a"       am/pm marker
     "s"       second in minute
     "S"       fractional seconds
     "Z"       timezone as a time offset from UTC
               for example PST
     "ZZZZ"    timezone as an offset using GMT,
               for example GMT+1


</pre></param>
			<param name="value" type="xs:string" optional="false">The given string
				<code>$value</code>that needs to be formatted.</param>
			<param name="language" type="xs:string" optional="true">The language used in string representation of the date, time or dateTime value.</param>
			<param name="calendar" type="xs:string" optional="true">This argument is reserved for future use. The only calendar supported at this point is "Gregorian" or "AD".</param>
			<param name="country" type="xs:string" optional="true">$country is used to take into account if there any country specific interpretation of the string while converting it into dateTime value.</param>
		</params>
		<return>xs:dateTime</return>
		<usage>Dates before October 15, 1582 (the start of the Gregorian calendar) will not return the correct dateTime value.</usage>
		<example xml:space="preserve">
   xdmp:parse-yymmdd("yyyy-MM-ddThh:mm:ss.Sz","2010-01-06T17:13:50.873594-8.00")

</example>
	</function>
	<function name="format-number" type="builtin" lib="fn" category="XSLTBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:format-number">
		<summary>Returns a formatted string representation of value argument based on the supplied picture. An optional decimal format name may also be supplied for interpretation of the picture string. This is an XSLT function, and it is available in both XSLT and in XQuery 1.0-ml.</summary>
		<params>
			<param name="value" type="numeric" optional="false">The given numeric
				<code>$value</code>that needs to be formatted. The type of this argument must be a numeric type (for example, xs:integer, xs:float, xs:double, or xs:decimal).</param>
			<param name="picture" type="xs:string" optional="false">The desired string representation of the given number
				<code>$value</code>. The picture string is a sequence of characters, in which the characters represent variables such as, decimal-separator-sign, grouping-sign, zero-digit-sign, digit-sign, pattern-separator, percent sign and per-mille-sign. For details on the picture string, see
				<a href="http://www.w3.org/TR/xslt20/#date-picture-string" target="_blank">http://www.w3.org/TR/xslt20/#date-picture-string</a>.</param>
			<param name="decimal-format-name" type="xs:string" optional="true">Represents a named
				<code>&lt;xsl:decimal-format&gt;</code>instruction. It is used to assign values to the variables mentioned above based on the picture string.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

fn:format-number(xs:integer("1000000"),"#,##0.00")
=&gt;
1,000,000.00

</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

let $stylesheet :=
&lt;xsl:stylesheet version="2.0"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xsl:decimal-format name="testformat" decimal-separator="."/&gt;
    &lt;xsl:template match="foo"&gt;
      &lt;xsl:sequence select="format-number(xs:float('1234.5'), '#,##0.00',
                            'testformat')"/&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
return
xdmp:xslt-eval($s, document{&lt;foo/&gt;})
=&gt;
1,234.50

</example>
	</function>
	<function name="format-number" type="builtin" lib="xdmp" category="Extension" subcategory="XSLT" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:format-number">
		<summary>Returns a formatted number value based on the picture argument. The difference between this function and the W3C standards
			<code>fn:format-number</code>function is that this function imitates the XSLT
			<code>xsl:number</code>instruction, which has richer formatting options than the
			<code>fn:format-number</code>function. This function can be used for spelled-out and ordinal numbering in many languages. This function is available in XSLT as well as in all dialects of XQuery.</summary>
		<params>
			<param name="value" type="numeric" optional="false">The given numeric
				<code>$value</code>that needs to be formatted. The type of this argument must be a numeric type (for example, xs:integer, xs:float, xs:double, or xs:decimal).</param>
			<param name="picture" type="xs:string" optional="false">The desired string representation of the given numeric
				<code>$value</code>. The picture string is a sequence of characters, in which the characters represent variables such as, decimal-separator-sign, grouping-sign, zero-digit-sign, digit-sign, pattern-separator, percent sign and per-mille-sign. For details on the picture string, see
				<a href="http://www.w3.org/TR/xslt20/#date-picture-string" target="_blank">http://www.w3.org/TR/xslt20/#date-picture-string</a>. Unlike fn:format-number(), here the picture sting allows spelled-out (uppercase, lowercase and Capitalcase) formatting.</param>
			<param name="language" type="xs:string" optional="false">The desired language for string representation of the numeric
				<code>$value</code>. An empty sequence must be passed in even if a user doesn't want to specifiy this argument.</param>
			<param name="letter-value" type="xs:string" optional="false">Same as letter-value attribute in xsl:number. This argument is ignored during formatting as of now. It may be used in future. An empty sequence must be passed in even if a user doesn't want to specifiy this argument.</param>
			<param name="ordchar" type="xs:string" optional="false">If $ordchar is "yes" then ordinal numbering is attempted. If this is any other string, including an empty string, then then cardinal numbering is generated. An empty sequence must be passed in even if a user doesn't want to specifiy this argument.</param>
			<param name="zero-padding" type="xs:string" optional="false">Value of $zero-padding is used to pad integer part of a number on the left and fractional part on the right, if needed. An empty sequence must be passed in even if a user doesn't want to specifiy this argument.</param>
			<param name="grouping-separator" type="xs:string" optional="false">Value of $grouping-separator is a character, used to groups of digits, especially useful in making long sequence of digits more readable. For example, 10,000,000- here "," is used as a separator after each group of three digits. An empty sequence must be passed in even if a user doesn't want to specify this argument.</param>
			<param name="grouping-size" type="xs:string" optional="false">Represents size of the group, i.e. the number of digits before after which grouping separator is inserted. An empty sequence must be passed in even if a user doesn't want to specifiy this argument.</param>
		</params>
		<return>xs:string</return>
		<usage>
			<p>Most, but not all formatting combinations work. The following table shows formatting options by language, and lists what is supported and what is not.</p>
			<table border="1">
				<tr>
					<th rowspan="1" colspan="1">Language</th>
					<th rowspan="1" colspan="1">Numeric Cardinals</th>
					<th rowspan="1" colspan="1">Numeric Ordinals</th>
					<th rowspan="1" colspan="1">Spelled Out Cardinals</th>
					<th rowspan="1" colspan="1">Spelled Out Ordinals</th>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">en</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">fr</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">it</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">de</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">ru</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">es</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">ar</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">zh</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">ko</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">fa</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">nl</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">ja</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
				</tr>
				<tr>
					<td rowspan="1" colspan="1">pt</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">Yes</td>
					<td rowspan="1" colspan="1">No</td>
				</tr>
			</table>
		</usage>
		<example xml:space="preserve">
xdmp:format-number(29,"01","en","",(),'0',",",3),
xdmp:format-number(09,"W","en","",(),'"',",",3),
xdmp:format-number((5),"w","es",(),(),"0",",",3)
=&gt;
29
NINE
cinco

</example>
	</function>
	<function name="name" type="builtin" lib="fn" category="NodeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:name">
		<summary>
			<p>Returns the name of a node, as an
				<code>xs:string</code>that is either the zero-length string, or has the lexical form of an
				<code>xs:QName</code>.</p>
			<p>If the argument is omitted, it defaults to the context node. If the context item is undefined an error is raised: [err:XPDY002]. If the context item is not a node an error is raised: [err:XPTY0004].</p>
			<p>If the argument is supplied and is the empty sequence, the function returns the zero-length string.</p>
			<p>If the target node has no name (that is, if it is a document node, a comment, a text node, or a namespace node having no name), the function returns the zero-length string.</p>
			<p>If the specified node was created with a namespace prefix, that namespace prefix is returned with the element localname (for example,
				<code>a:hello</code>). Note that the namespace prefix is not always the same prefix that would be returned if you serialized the QName of the node, as the serialized QName will use the namespace from the XQuery context in which it was serialized.</p>
		</summary>
		<params>
			<param name="arg" type="node()?" optional="true">The node whose name is to be returned.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
declare namespace a="a";

let $x := &lt;a:hello/&gt;
return
fn:name($x)

=&gt; a:hello
</example>
	</function>
	<function name="local-name" type="builtin" lib="fn" category="NodeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:local-name">
		<summary>
			<p>Returns the local part of the name of $arg as an xs:string that will either be the zero-length string or will have the lexical form of an xs:NCName.</p>
			<p>If the argument is omitted, it defaults to the context node. If the context item is undefined an error is raised: [err:XPDY0002]. If the context item is not a node an error is raised: [err:XPTY0004].</p>
			<p>If the argument is supplied and is the empty sequence, the function returns the zero-length string.</p>
			<p>If the target node has no name (that is, if it is a document node, a comment, a text node, or a namespace node having no name), the function returns the zero-length string.</p>
			<p>Otherwise, the value returned will be the local part of the expanded-QName of the target node (as determined by the dm:node-name accessor in Section 5.11 node-name Accessor[DM]. This will be an xs:string whose lexical form is an xs:NCName.</p>
		</summary>
		<params>
			<param name="arg" type="node()?" optional="true">The node whose local name is to be returned.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
declare namespace a="a";

let $x := &lt;a:hello/&gt;
return
fn:local-name($x)

=&gt; hello
</example>
	</function>
	<function name="namespace-uri" type="builtin" lib="fn" category="NodeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:namespace-uri">
		<summary>
			<p>Returns the namespace URI of the xs:QName of the node specified by $arg.</p>
			<p>If the argument is omitted, it defaults to the context node. If the context item is undefined an error is raised: [err:XPDY0002]. If the context item is not a node an error is raised: [err:XPTY0004].</p>
			<p>If $arg is the empty sequence, the xs:anyURI corresponding to the zero-length string is returned.</p>
			<p>If $arg is neither an element nor an attribute node, or if it is an element or attribute node whose expanded-QName (as determined by the dm:node-name accessor in the Section 5.11 node-name Accessor[DM]) is in no namespace, then the function returns the xs:anyURI corresponding to the zero-length string.</p>
		</summary>
		<params>
			<param name="arg" type="node()?" optional="true">The node whose namespace URI is to be returned.</param>
		</params>
		<return>xs:anyURI</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
declare namespace a="aaa";

let $x := &lt;a:hello/&gt;
return
fn:namespace-uri($x)

=&gt; aaa
</example>
	</function>
	<function name="number" type="builtin" lib="fn" category="NodeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:number">
		<summary>
			<p>Returns the value indicated by $arg or, if $arg is not specified, the context item after atomization, converted to an xs:double. If $arg is the empty sequence or if $arg or the context item cannot be converted to an xs:double, the xs:double value NaN is returned. If the context item is undefined an error is raised: [err:XPDY0002].</p>
			<p>Calling the zero-argument version of the function is defined to give the same result as calling the single-argument version with an argument of ".". That is, fn:number() is equivalent to fn:number(.).</p>
			<p>If $arg is the empty sequence, NaN is returned. Otherwise, $arg, or the context item after atomization, is converted to an xs:double following the rules of 17.1.3.2 Casting to xs:double. If the conversion to xs:double fails, the xs:double value NaN is returned.</p>
		</summary>
		<params>
			<param name="arg" type="xs:anyAtomicType?" optional="true">The value to be returned as an xs:double value.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
fn:number($item1/quantity) returns 5.0.
fn:number($item2) returns NaN.

Assume that the context item is the xs:string "15".
fn:number() returns 1.5E1.
</example>
	</function>
	<function name="lang" type="builtin" lib="fn" category="NodeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:lang">
		<summary>
			<p>This function tests whether the language of $node, or the context node if the second argument is omitted, as specified by xml:lang attributes is the same as, or is a sublanguage of, the language specified by $testlang. The language of the argument node, or the context node if the second argument is omitted, is determined by the value of the xml:lang attribute on the node, or, if the node has no such attribute, by the value of the xml:lang attribute on the nearest ancestor of the node that has an xml:lang attribute. If there is no such ancestor, then the function returns false</p>
			<p>If the second argument is omitted and the context item is undefined an error is raised: [err:XPDY0002]. If the context item is not a node an error is raised [err:XPTY0004].</p>
			<p>If $testlang is the empty sequence it is interpreted as the zero-length string.</p>
			<p>The relevant xml:lang attribute is determined by the value of the XPath expression: (ancestor-or-self::* /@xml:lang)[last()]</p>
			<p>If this expression returns an empty sequence, the function returns false.</p>
			<p>Otherwise, the function returns true if and only if the string-value of the relevant xml:lang attribute is equal to $testlang based on a caseless default match as specified in section 3.13 of [The Unicode Standard], or if the string-value of the relevant testlang attribute contains a hyphen, "-" (The character "-" is HYPHEN-MINUS, #x002D) such that the part of the string-value preceding that hyphen is equal to $testlang, using caseless matching.</p>
		</summary>
		<params>
			<param name="testlang" type="xs:string?" optional="false">The language against which to test the node.</param>
			<param name="node" type="node()" optional="true">The node to test.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
<p xmlns="http://www.w3.org/1999/xhtml">
The expression fn:lang("en") would return true if the context node were any
of the following four elements:
</p>


<ol xmlns="http://www.w3.org/1999/xhtml">
  <li>&lt;para xml:lang="en"/&gt;</li>
  <li>&lt;div xml:lang="en"&gt;&lt;para&gt;And now, and forever!&lt;/para&gt;&lt;/div&gt;</li>
  <li>&lt;para xml:lang="EN"/&gt;</li>
  <li>&lt;para xml:lang="en-us"/&gt;</li>
</ol>
<p xmlns="http://www.w3.org/1999/xhtml">The expression fn:lang("fr") would return false if the context node were
&lt;para xml:lang="EN"/&gt;
</p>
</example>
	</function>
	<function name="root" type="builtin" lib="fn" category="NodeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:root">
		<summary>
			<p>Returns the root of the tree to which $arg belongs. This will usually, but not necessarily, be a document node.</p>
			<p>If $arg is the empty sequence, the empty sequence is returned.</p>
			<p>If $arg is a document node, $arg is returned.</p>
			<p>If the function is called without an argument, the context item is used as the default argument. If the context item is undefined an error is raised: [err:XPDY0002]. If the context item is not a node an error is raised: [err:XPTY0004].</p>
		</summary>
		<params>
			<param name="arg" type="node()?" optional="true">The node whose root node will be returned.</param>
		</params>
		<return>node()?</return>
		<example xml:space="preserve">
Assume the following variable definitions:
let $i := &lt;tool&gt;wrench&lt;/tool&gt;
let $o := &lt;order&gt; {$i} &lt;quantity&gt;5&lt;/quantity&gt; &lt;/order&gt;
let $odoc := document {$o}
let $newi := $o/tool

fn:root($i) returns $i
fn:root($o/quantity) returns $o
fn:root($odoc//quantity) returns $odoc
fn:root($newi) returns $o
</example>
	</function>
	<function name="generate-id" type="builtin" lib="fn" category="NodeBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:generate-id">
		<summary>
			<p>Returns a string that uniquely identifies a given node.</p>
			<p>If $arg is the empty sequence, the zero-length string is returned.</p>
			<p>If the function is called without an argument, the context item is used as the default argument. If the context item is undefined an error is raised: [err:XPDY0002]. If the context item is not a node an error is raised: [err:XPTY0004].</p>
		</summary>
		<params>
			<param name="node" type="node()?" optional="true">The node whose id will be generated.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
let $x := doc("auction.xml")
return
fn:generate-id($x)

=&gt; n965c71980e85a011
</example>
	</function>
	<function name="resolve-uri" type="builtin" lib="fn" category="AnyURIBuiltins" bucket="W3C-Standard Functions" hidden="false" fullname="fn:resolve-uri">
		<summary>Resolves a relative URI against an absolute URI. If $base is specified, the URI is resolved relative to that base. If $base is not specified, the base is set to the base-uri property from the static context, if the property exists; if it does not exist, an error is thrown.</summary>
		<params>
			<param name="relative" type="xs:string?" optional="false">A URI reference to resolve against the base.</param>
			<param name="base" type="xs:string" optional="true">An absolute URI to use as the base of the resolution.</param>
		</params>
		<return>xs:anyURI?</return>
		<usage>
			<p>If $base is specified, it is assumed to be an absolute URI and $relative is assumed to be an absolute or a relative URI reference. If $relative is a relative URI reference, it is resolved against $base, using an algorithm such as the ones described in [
				<a href="http://www.w3.org/TR/xpath-functions/#rfc2396">RFC 2396</a>] or [
				<a href="http://www.w3.org/TR/xpath-functions/#rfc3986">RFC 3986</a>], and the resulting absolute URI reference is returned.</p>
			<p>If $relative is the zero-length string,
				<code>fn:resolve-uri</code>returns the value of $base, or the base-uri property from the static context if there is no $base value specified (if the base-uri property is not initialized in the static context, an error is raised).</p>
			<p>Resolving a URI does not dereference it. This is merely a syntactic operation on two character strings.</p>
		</usage>
		<example xml:space="preserve">
fn:resolve-uri("hello/goodbye.xml",
     "http://mycompany/default.xqy")

=&gt;  http://mycompany/hello/goodbye.xml
</example>
	</function>
	<function name="trace" type="builtin" lib="fn" category="Error and Trace" bucket="W3C-Standard Functions" hidden="false" fullname="fn:trace">
		<summary>Return the input $value unchanged and, if $label is the name of an enabled server event, emit that server event to the server log file (
			<code>ErrorLog.txt</code>) with $value as its data.</summary>
		<params>
			<param name="value" type="item()*" optional="false">The values to trace.</param>
			<param name="label" type="xs:string" optional="false">A string label for the trace output.</param>
		</params>
		<return>item()*</return>
		<usage>In order for the trace event to print out in the log file, you must enable the trace event in the Diagnostics page (Groups &gt;
			<em>group_name</em>&gt; Diagnostics ) of the Admin interface for the specified label.</usage>
		<example xml:space="preserve">
fn:trace("This is a trace event.", "MY TRACE EVENT")

=&gt; If MY TRACE EVENT is defined as an enabled trace event
   in the Diagnostics page of the Admin interface, then a
   message similar to the following is added to the
   ErrorLog.txt file:

   2006-03-20 17:56:09.346 Info: [Event:id=MY TRACE EVENT]
                                 This is a trace event.
</example>
	</function>
	<function name="point" type="geo" lib="geo" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="geo:point">
		<summary>Create a cts:point value from an element representing a point in one of the supported markup vocabularies.</summary>
		<params>
			<param name="point" type="element()" optional="false">An element representing a point.</param>
		</params>
		<return>cts:point</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace geo = "http://marklogic.com/geospatial"
         at "/MarkLogic/geospatial/geospatial.xqy";
  declare namespace gml= "http://www.opengis.net/gml";

  geo:point(&lt;gml:Point&gt;&lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;&lt;/gml:Point&gt;)

</example>
	</function>
	<function name="box" type="geo" lib="geo" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="geo:box">
		<summary>Create a cts:point value from an element representing a box in one of the supported markup vocabularies.</summary>
		<params>
			<param name="box" type="element()" optional="false">An element representing a box.</param>
		</params>
		<return>cts:box</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace geo = "http://marklogic.com/geospatial"
         at "/MarkLogic/geospatial/geospatial.xqy";
  declare namespace kml= "http://earth.google.com/kml/2.0";

  geo:box(
     &lt;kml:LatLongBox&gt;
       &lt;kml:north&gt;30&lt;/kml:north&gt;
       &lt;kml:south&gt;12.5&lt;/kml:south&gt;
       &lt;kml:east&gt;-122.24&lt;/kml:east&gt;
       &lt;kml:west&gt;-127.24&lt;/kml:west&gt;
     &lt;/kml:LatLongBox&gt;)

</example>
	</function>
	<function name="circle" type="geo" lib="geo" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="geo:circle">
		<summary>Create a cts:circle value from a radius and an element representing a point in one of the supported markup vocabularies.</summary>
		<params>
			<param name="radius" type="xs:double" optional="false">The radius of the circle, in miles.</param>
			<param name="center" type="element()" optional="false">An element representing the point at the center of the circle.</param>
		</params>
		<return>cts:circle</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace geo = "http://marklogic.com/geospatial"
         at "/MarkLogic/geospatial/geospatial.xqy";

  geo:circle(47, &lt;Dot Latitude="12.5" Longitude="-127.24"/&gt;)

</example>
	</function>
	<function name="polygon" type="geo" lib="geo" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="geo:polygon">
		<summary>Create a cts:polygon value from a sequence of point elements in one of the supported markup vocabularies.</summary>
		<params>
			<param name="polygon-or-points" type="element()+" optional="false">A sequence of elements, each representing a vertex (point) of the polygon, or a polygon element. A polygon element from one of the supported markup vocabularies represents the exterior polygon for those vocabularies that include both exterior and interior polygons in their representation.</param>
		</params>
		<return>cts:polygon</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace geo = "http://marklogic.com/geospatial"
         at "/MarkLogic/geospatial/geospatial.xqy";

  geo:polygon(( &lt;Dot Latitude="12.5" Longitude="-127.24"/&gt;,
                &lt;Dot Latitude="15.25" Longitude="-127.8"/&gt;,
                &lt;Dot Latitude="13.45" Longitude="-126.1"/&gt;,
                &lt;Dot Latitude="12.5" Longitude="-127.24"/&gt;
             ))

</example>
	</function>
	<function name="interior-polygon" type="geo" lib="geo" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="geo:interior-polygon">
		<summary>Create a sequence of cts:polygon values from a polygon element in one of the supported markup vocabularies. These polygons represent the interior polygons, if any.</summary>
		<params>
			<param name="polygon" type="element()" optional="false">An elements representing the polygon.</param>
		</params>
		<return>cts:polygon*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace geo = "http://marklogic.com/geospatial"
      at "/MarkLogic/geospatial/geospatial.xqy";
  declare namespace georss= "http://www.georss.org/georss";

  (: Returns empty; no interior polygon in this format :)
  geo:interior-polygon(
    &lt;georss:polygon&gt;
      12.5,-127.24 15.25,-127.8 13.45,-126.1 12.5,-127.24
    &lt;/georss:polygon&gt;
  )

</example>
	</function>
	<function name="geospatial-query" type="geo" lib="geo" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="geo:geospatial-query">
		<summary>Returns a cts:query matching points within given regions.</summary>
		<params>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, polygons, or points. Where multiple boxes, circles, polygons, or points are specified, the query matches if any box, circle, polygon, or point matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
			<p>The query constructed will examine points in all the supported geospatial markup vocabularies. If not all these vocabularies will be in use, it may be more efficient to use the query constructors for just the vocabulary or vocabularies that are in actual use.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
(: create a document with test data :)
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";

xdmp:document-insert("/points.xml",
&lt;root xmlns:geo="http://marklogic.com/geospatial"&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;10.5 30.0&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;georss:point&gt;15.35 35.34&lt;/georss:point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;Dot Latitude="5.11" Longitude="40.55"/&gt;&lt;/item&gt;
&lt;/root&gt; );

xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
   at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";
declare namespace kml= "http://earth.google.com/kml/2.0";

cts:search(doc("/points.xml")//item,
  geo:geospatial-query(
    geo:box(
      &lt;gml:Envelope&gt;
        &lt;gml:lowerCorner&gt;10.0 35.0&lt;/gml:lowerCorner&gt;
        &lt;gml:upperCorner&gt;20.0 40.0&lt;/gml:upperCorner&gt;
      &lt;/gml:Envelope&gt;)
  ))
(:
  returns the following node:
  &lt;item&gt;&lt;georss:point&gt;15.35 35.34&lt;/georss:point&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  geo:geospatial-query(geo:box(
    &lt;kml:LatLongBox&gt;
      &lt;kml:north&gt;20.0&lt;/kml:north&gt;
      &lt;kml:south&gt;10.0&lt;/kml:south&gt;
      &lt;kml:east&gt;35.0&lt;/kml:east&gt;
      &lt;kml:west&gt;40.0&lt;/kml:west&gt;
    &lt;/kml:LatLongBox&gt;
  )))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;10.5 30.0&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  geo:geospatial-query(
    cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;georss:point&gt;15.35 35.34&lt;/georss:point&gt;&lt;/item&gt;
:)

</example>
	</function>
	<function name="geospatial-query-from-elements" type="geo" lib="geo" subcategory="GEO" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="geo:geospatial-query-from-elements">
		<summary>Returns a cts:query matching points within given regions.</summary>
		<params>
			<param name="regions" type="element()*" optional="false">One or more geographic boxes, circles, polygons, or points, represented by elements in one of the supported vocabularies. Where multiple boxes, circles, polygons, or points are specified, the query matches if any box, circle, polygon, or point matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
			<p>The query constructed will examine points in all the supported geospatial markup vocabularies. If not all these vocabularies will be in use, it may be more efficient to use the query constructors for just the vocabulary or vocabularies that are in actual use.</p>
			<p>This function will take into account interior polygons, if any, and properly construct the query to account for them.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
(: create a document with test data :)
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";

xdmp:document-insert("/points.xml",
&lt;root xmlns:geo="http://marklogic.com/geospatial"&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;10.5 30.0&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;georss:point&gt;15.35 35.34&lt;/georss:point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;Dot Latitude="5.11" Longitude="40.55"/&gt;&lt;/item&gt;
&lt;/root&gt; );

xquery version "1.0-ml";
import module namespace geo = "http://marklogic.com/geospatial"
   at "/MarkLogic/geospatial/geospatial.xqy";
declare namespace gml= "http://www.opengis.net/gml";
declare namespace georss= "http://www.georss.org/georss";
declare namespace kml= "http://earth.google.com/kml/2.0";

cts:search(doc("/points.xml")//item,
  geo:geospatial-query-from-elements(
    &lt;gml:Envelope&gt;
      &lt;gml:lowerCorner&gt;10.0 35.0&lt;/gml:lowerCorner&gt;
      &lt;gml:upperCorner&gt;20.0 40.0&lt;/gml:upperCorner&gt;
    &lt;/gml:Envelope&gt;
  ) )
(:
  returns the following node:
  &lt;item&gt;&lt;georss:point&gt;15.35 35.34&lt;/georss:point&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  geo:geospatial-query-from-elements(
    &lt;kml:LatLongBox&gt;
      &lt;kml:north&gt;20.0&lt;/kml:north&gt;
      &lt;kml:south&gt;10.0&lt;/kml:south&gt;
      &lt;kml:east&gt;35.0&lt;/kml:east&gt;
      &lt;kml:west&gt;40.0&lt;/kml:west&gt;
    &lt;/kml:LatLongBox&gt;
  ))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;georss:point&gt;15.35 35.34&lt;/georss:point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;10.5 30.0&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
:)


</example>
	</function>
	<function name="point" type="georss" lib="georss" subcategory="GeoRSS" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="georss:point">
		<summary>Create a cts:point value from a GeoRSS point element.</summary>
		<params>
			<param name="point" type="element(georss:point)" optional="false">A point element.</param>
		</params>
		<return>cts:point</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace georss = "http://www.georss.org/georss"
         at "/MarkLogic/geospatial/georss.xqy";

  georss:point(&lt;georss:point&gt;12.5 -127.24&lt;/georss:point&gt;)

</example>
	</function>
	<function name="circle" type="georss" lib="georss" subcategory="GeoRSS" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="georss:circle">
		<summary>Create a cts:circle value from a radius and GeoRSS point element.</summary>
		<params>
			<param name="radius" type="xs:double" optional="false">The radius of the circle, in miles.</param>
			<param name="center" type="element(georss:point)" optional="false">A point element representing the center of the circle.</param>
		</params>
		<return>cts:circle</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace georss = "http://www.georss.org/georss"
         at "/MarkLogic/geospatial/georss.xqy";

  georss:circle(47, &lt;georss:point&gt;12.5 -127.24&lt;/georss:point&gt;)

</example>
	</function>
	<function name="geospatial-query" type="georss" lib="georss" subcategory="GeoRSS" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="georss:geospatial-query">
		<summary>Returns a cts:query matching points within given regions.</summary>
		<params>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, or points. Where multiple boxes, circles, or points are specified, the query matches if any box, circle, or point matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root xmlns:georss="http://www.georss.org/georss"&gt;
  &lt;item&gt;&lt;georss:point&gt;10.5 30.0&lt;/georss:point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;georss:point&gt;15.35 35.34&lt;/georss:point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;georss:point&gt;5.11 40.55&lt;/georss:point&gt;&lt;/item&gt;
&lt;/root&gt; );

xquery version "1.0-ml";
import module namespace georss = "http://www.georss.org/georss"
   at "/MarkLogic/geospatial/georss.xqy";

cts:search(doc("/points.xml")//item,
  georss:geospatial-query(cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;georss:point&gt;15.35 35.34&lt;/georss:point&gt;&lt;/item&gt;
:)

</example>
	</function>
	<function name="point" type="gml" lib="gml" subcategory="GML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="gml:point">
		<summary>Create a cts:point value from a GML Point element.</summary>
		<params>
			<param name="point" type="element(gml:Point)" optional="false">A Point element.</param>
		</params>
		<return>cts:point</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace gml = "http://www.opengis.net/gml"
         at "/MarkLogic/geospatial/gml.xqy";

  gml:point(&lt;gml:Point&gt;&lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;&lt;/gml:Point&gt;)

</example>
	</function>
	<function name="box" type="gml" lib="gml" subcategory="GML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="gml:box">
		<summary>Create a
			<code>cts:box</code>value from a GML Envelope element.</summary>
		<params>
			<param name="box" type="element(gml:Envelope)" optional="false">An Envelope element.</param>
		</params>
		<return>cts:box</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace gml = "http://www.opengis.net/gml"
         at "/MarkLogic/geospatial/gml.xqy";

  gml:box(
     &lt;gml:Envelope&gt;
       &lt;gml:lowerCorner&gt;12.5 -127.24&lt;/gml:lowerCorner&gt;
       &lt;gml:upperCorner&gt;30 -122.24&lt;/gml:upperCorner&gt;
     &lt;/gml:Envelope&gt;)

</example>
	</function>
	<function name="circle" type="gml" lib="gml" subcategory="GML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="gml:circle">
		<summary>Create a
			<code>cts:circle</code>value from a radius and GML Point element.</summary>
		<params>
			<param name="radius" type="xs:double" optional="false">The radius of the circle, in miles.</param>
			<param name="center" type="element(gml:Point)" optional="false">A Point element representing the center of the circle.</param>
		</params>
		<return>cts:circle</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace gml = "http://www.opengis.net/gml"
         at "/MarkLogic/geospatial/gml.xqy";

  gml:circle(47, &lt;gml:Point&gt;&lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;&lt;/gml:Point&gt;)

</example>
	</function>
	<function name="polygon" type="gml" lib="gml" subcategory="GML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="gml:polygon">
		<summary>Create a
			<code>cts:polygon</code>value from a sequence of GML Point elements or a GML Polygon element.</summary>
		<params>
			<param name="polygon-or-points" type="element()+" optional="false">A sequence of Point elements representing the vertices of the polygon or a Polygon element..</param>
		</params>
		<return>cts:polygon</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace gml = "http://www.opengis.net/gml"
         at "/MarkLogic/geospatial/gml.xqy";

  gml:polygon((
    &lt;gml:Point&gt;&lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;&lt;/gml:Point&gt;,
    &lt;gml:Point&gt;&lt;gml:pos&gt;15.25 -127.8&lt;/gml:pos&gt;&lt;/gml:Point&gt;,
    &lt;gml:Point&gt;&lt;gml:pos&gt;13.45 -126.1&lt;/gml:pos&gt;&lt;/gml:Point&gt;,
    &lt;gml:Point&gt;&lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;&lt;/gml:Point&gt;
  ))

</example>
	</function>
	<function name="polygon" type="gml" lib="gml" subcategory="GML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="gml:polygon">
		<summary>Create a
			<code>cts:polygon</code>value from a GML Polygon element. The polygon returned represents the exterior polygon.</summary>
		<params>
			<param name="polygon-or-points" type="element()+" optional="false">A Polygon element representing the polygon.</param>
		</params>
		<return>cts:polygon</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace gml = "http://www.opengis.net/gml"
         at "/MarkLogic/geospatial/gml.xqy";

  gml:polygon(
    &lt;gml:Polygon&gt;&lt;gml:exterior&gt;&lt;gml:LinearRing&gt;
    &lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;
    &lt;gml:pos&gt;15.25 -127.8&lt;/gml:pos&gt;
    &lt;gml:pos&gt;13.45 -126.1&lt;/gml:pos&gt;
    &lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;
    &lt;/gml:LinearRing&gt;&lt;/gml:exterior&gt;&lt;/gml:Polygon&gt;
  )

</example>
	</function>
	<function name="interior-polygon" type="gml" lib="gml" subcategory="GML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="gml:interior-polygon">
		<summary>Create a sequence of
			<code>cts:polygon</code>values from a GML Polygon element. The polygons returned represent the interior polygons, if any.</summary>
		<params>
			<param name="polygon" type="element(gml:Polygon)" optional="false">A Polygon element representing the polygon.</param>
		</params>
		<return>cts:polygon*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace gml = "http://www.opengis.net/gml"
         at "/MarkLogic/geospatial/gml.xqy";

  (: Returns empty; no interior :)
  gml:interior-polygon(
    &lt;gml:Polygon&gt;&lt;gml:exterior&gt;&lt;gml:LinearRing&gt;
    &lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;
    &lt;gml:pos&gt;15.25 -127.8&lt;/gml:pos&gt;
    &lt;gml:pos&gt;13.45 -126.1&lt;/gml:pos&gt;
    &lt;gml:pos&gt;12.5 -127.24&lt;/gml:pos&gt;
    &lt;/gml:LinearRing&gt;&lt;/gml:exterior&gt;&lt;/gml:Polygon&gt;
  )

</example>
	</function>
	<function name="geospatial-query" type="gml" lib="gml" subcategory="GML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="gml:geospatial-query">
		<summary>Returns a
			<code>cts:query</code>matching points within given regions.</summary>
		<params>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, polygons, or points. Where multiple boxes, circles, polygons, or points are specified, the query matches if any box, circle, polygon, or point matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root xmlns:gml="http://www.opengis.net/gml"&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;10.5 30.0&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;15.35 35.34&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;5.11 40.55&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
&lt;/root&gt; );

xquery version "1.0-ml";
import module namespace gml = "http://www.opengis.net/gml"
   at "/MarkLogic/geospatial/gml.xqy";

cts:search(doc("/points.xml")//item,
  gml:geospatial-query(
    gml:box(
      &lt;gml:Envelope&gt;
        &lt;gml:lowerCorner&gt;10.0 35.0&lt;/gml:lowerCorner&gt;
        &lt;gml:upperCorner&gt;20.0 40.0&lt;/gml:upperCorner&gt;
      &lt;/gml:Envelope&gt;) ))
(:
  returns the following node:
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;15.35 35.34&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  gml:geospatial-query(gml:box(
    &lt;gml:Envelope&gt;
      &lt;gml:lowerCorner&gt;10.0 40.0&lt;/gml:lowerCorner&gt;
      &lt;gml:upperCorner&gt;20.0 35.0&lt;/gml:upperCorner&gt;
    &lt;/gml:Envelope&gt;
  )))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;10.5 30.0&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
:)

</example>
	</function>
	<function name="geospatial-query-from-elements" type="gml" lib="gml" subcategory="GML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="gml:geospatial-query-from-elements">
		<summary>Returns a
			<code>cts:query</code>matching points within given regions.</summary>
		<params>
			<param name="regions" type="element()*" optional="false">One or more geographic boxes, circles, polygons, or points, represented as GML elements. Where multiple boxes, circles, polygons, or points are specified, the query matches if any box, circle, polygon, or point matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
			<p>This function will take into account interior polygons, if any, and properly construct the query to account for them.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root xmlns:gml="http://www.opengis.net/gml"&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;10.5 30.0&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;15.35 35.34&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;5.11 40.55&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
&lt;/root&gt; );

xquery version "1.0-ml";
import module namespace gml = "http://www.opengis.net/gml"
   at "/MarkLogic/geospatial/gml.xqy";

cts:search(doc("/points.xml")//item,
  gml:geospatial-query-from-elements(
      &lt;gml:Envelope&gt;
        &lt;gml:lowerCorner&gt;10.0 35.0&lt;/gml:lowerCorner&gt;
        &lt;gml:upperCorner&gt;20.0 40.0&lt;/gml:upperCorner&gt;
      &lt;/gml:Envelope&gt;) )
(:
  returns the following node:
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;15.35 35.34&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  gml:geospatial-query-from-elements(
    &lt;gml:Envelope&gt;
      &lt;gml:lowerCorner&gt;10.0 40.0&lt;/gml:lowerCorner&gt;
      &lt;gml:upperCorner&gt;20.0 35.0&lt;/gml:upperCorner&gt;
    &lt;/gml:Envelope&gt;) )
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;gml:Point&gt;&lt;gml:pos&gt;10.5 30.0&lt;/gml:pos&gt;&lt;/gml:Point&gt;&lt;/item&gt;
:)


</example>
	</function>
	<function name="get-splits" lib="hadoop" category="Hadoop Library" bucket="XQuery Library Modules" hidden="false" fullname="hadoop:get-splits">
		<summary>This function returns (forest_id, record_count, host_name) tuples usable with the MarkLogic Connector for Hadoop to generate input splits in advanced input mode.</summary>
		<params>
			<param name="nsbindings" type="xs:string*" optional="false">Name space binding declaration.</param>
			<param name="doc-selector" type="xs:string" optional="false">A fully searchable path expression to define document scope for the splits.</param>
			<param name="query" type="xs:string" optional="false">A cts:query specifying the search to perform for the splits.</param>
		</params>
		<return>item()*</return>
		<usage>
			<p>Use this function to construct a split query in advanced input mode. For details, see the
				<em>MarkLogic Connector for Hadoop Developer's Guide</em>.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace hadoop= "http://marklogic.com/hadoop"
          at "/MarkLogic/openxml/hadoop.xqy";
hadoop:get-splits('', 'fn:doc()', 'cts:and-query(())')
=&gt;
8456374036761185098 97 doc.marklogic.com

</example>
	</function>
	<function name="database-create" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:database-create">
		<summary>This function creates a database with attached forests. Forests are named sequentially using the pattern of databasename-1, databasename-2 and so on. The API checks for database and forest name conflicts, throwing an INFO-DUPLICATENAME error if any name conflicts are encountered. The database is created with default index settings. If
			<code>$forests-per-host</code>is an empty sequence or omitted, only one forest (regardless of number of hosts) is created. If database creation succeeds, the database id is returned.</summary>
		<params>
			<param name="database-name" type="xs:string" optional="false">Name of this database.</param>
			<param name="forests-per-host" type="xs:positiveInteger?" optional="true">The number of forests to create per host in the group. Defaults to one forest for the database if not provided.</param>
			<param name="group" type="xs:string?" optional="true">The name of the group to which to add forests. The API determines which hosts are in the group and creates the specified number of forests for each host in the group. If not provided, the Default group is used.</param>
			<param name="data-directory" type="xs:string?" optional="true">A public data directory to use for forest creation. Default is none, resulting in a private data directory (server default).</param>
			<param name="security-db" type="xs:string?" optional="true">The name of the security database to use for database creation. Defaults to Security if not provided.</param>
			<param name="schemas-db" type="xs:string?" optional="true">The name of the schema database to use for database creation. Defaults to Schemas if not provided.</param>
			<param name="triggers-db" type="xs:string?" optional="true">The name of the triggers database to use for database creation. Defaults to Triggers if not provided.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:database-create(
	"newDB",
	2,
	"Default",
	"/foobar",
	"Security",
	"Schemas",
	"Triggers")

  (: Creates a new database, named "newDB," and attaches to it two forests. :)

</pre>

</example>
	</function>
	<function name="database-set-feature" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:database-set-feature">
		<summary>This function adds or removes the related database settings for wildcarding, word positions, and/or reverse search. Not specifying a feature will leave it in its current state.</summary>
		<params>
			<param name="database" type="xs:string" optional="false">The name of the database to add or remove support of specified database feature. If a database that comes pre-configured with the server (other than the "Documents" database) is specified, then a "Restricted Database" exception will occur.</param>
			<param name="settings" type="element(info:settings)" optional="false">Settings XML representing desired database features to configure. Valid options are "wildcard", "position", "reverse". If an element is not specified, its setting remains unchanged. Note: if the incoming XML has a detail section (from a verbose call to get-feature) it is ignored.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
     at "/MarkLogic/appservices/infostudio/info.xqy";

  info:database-set-feature("Documents",
    &lt;settings xmlns="http://marklogic.com/appservices/infostudio"&gt;
      &lt;wildcard&gt;true&lt;/wildcard&gt;
      &lt;position&gt;true&gt;&lt;/position&gt;
      &lt;reverse&gt;false&lt;/reverse&gt;
    &lt;/settings&gt; )

  (: Turn on 3 character wildcard, the codepoint word lexicon, word positions,
     and 3 character word position. It will turn off reverse search. :)

</pre>

</example>
	</function>
	<function name="database-get-feature" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:database-get-feature">
		<summary>This function returns the a node representing support for database features of wildcarding, word positions, and reverse search. Returns a boolean value for each database feature based on whether its corresponding database settings are on or off. If some settings are on for a feature but others are off, then the feature will be noted as off. A "detail" child node includes the value of each related database setting.
			<p>The optional
				<code>$preview-settings</code>and
				<code>$delta</code>arguments allow developers to pass in settings to preview the result of a given set of features. If
				<code>$delta</code>is set to
				<code>true()</code>, only values that will change are returned. If not provided,
				<code>$delta</code>is
				<code>false()</code>.</p>
			<p>This call is read-only, it does not change the state of database features supported.</p></summary>
		<params>
			<param name="database" type="xs:string" optional="false">The name of the database for which to get support information. If a database that comes pre-configured with the server (other than the "Documents" database) is specified, then a "Restricted Database" exception will occur.</param>
			<param name="preview-settings" type="element(info:settings)" optional="true">Settings XML representing a desired set of database features to preview. Note: if the incoming XML has a detail section, it is ignored.</param>
			<param name="delta" type="xs:boolean" optional="true">If this parameter is set to true, then on preview the returned information will only include settings that would change on a call to
				<code>info:database-set-feature()</code>. Defaults to false if not specified.</param>
		</params>
		<return>element(info:settings)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:database-get-feature("Documents")

  (: Returns the current state of the supported database features. :)

</pre>

</example>
	</function>
	<function name="load" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:load">
		<summary>This function does a one-time scan of the named directory path (local filesystem only), and attempts to load the files, spawning multiple transactions if necessary. This collector should be considered stateless; although some lightweight state information is passed via an external variable to the executing module, it is not persistent. Transactions are asynchronous, and order of insertions is not guaranteed.
			<p>This function returns a ticket URI that can be used to access status information for that ticket.</p></summary>
		<params>
			<param name="dir-path" type="xs:string" optional="false">Local filesystem path of a set of documents to load.</param>
			<param name="policy-name" type="xs:string?" optional="true">The name of a stored ingestion policy. If the name is provided but does not exist, an error is thrown. If no name is provided, a stored default policy is used if available. If neither exists, reasonable global defaults are used.</param>
			<param name="policy-deltas" type="element(info:options)?" optional="true">An options node with a namespace of
				<code>http://marklogic.com/appservices/infostudio</code>. If it is provided, it is merged with the stored policy, providing the ability to override or supplement stored policy at runtime. See the description of the
				<code>info:policy-set</code>function for an example options node.</param>
			<param name="database" type="xs:string" optional="true">Name of a database into which content should be inserted. If not provided, defaults to the current context database.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:load("C:\docs\mydocs", (), (), "testDB")

  (: Loads the contents of the C:\docs\mydocs directory into the testBD database using
     the default policy. :)

</pre>

</example>
    <example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  let $delta :=
      &lt;options xmlns="http://marklogic.com/appservices/infostudio"&gt;
          &lt;uri&gt;
              &lt;literal&gt;http://mydir/&lt;/literal&gt;
              &lt;filename/&gt;
              &lt;literal&gt;.&lt;/literal&gt;
              &lt;ext/&gt;
          &lt;/uri&gt;
      &lt;/options&gt;

  return info:load("C:\docs\mydocs", (), $delta, "testDB")

  (: Loads the contents of the C:\docs\mydocs directory into the testBD database at the
     URI http://mydir/, using the rest of the options specified by the default policy.
     For example, C:\docs\mydocs\mydoc.xml will be loaded into the database with the
     URI http://mydir/mydoc.xml. :)

</pre>

</example>
	</function>
	<function name="policy" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:policy">
		<summary>This function returns the stored policy matching the specified policy. If the policy does not exist, this function returns an empty sequence.</summary>
		<params>
			<param name="policy-name" type="xs:string" optional="false">Name of the policy to be returned.</param>
		</params>
		<return>element(info:options)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:policy("default")

  (: Returns the default policy. :)

</pre>

</example>
	</function>
	<function name="policy-names" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:policy-names">
		<summary>This function returns the names of all stored policies.</summary>
		<return>xs:string*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:policy-names( )

  (: Returns the names of all of the set policies. :)

</pre>

</example>
	</function>
	<function name="policy-set" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:policy-set">
		<summary>This function sets an ingestion policy, which consists of a reusable &lt;options&gt; node defining parameters for content loading and transformation.</summary>
		<params>
			<param name="policy-name" type="xs:string?" optional="true">The name of this ingestion policy. If the policy already exists, it is overwritten without warning. If no name or the empty string is provided, the new policy replaces the default policy (named 'default').</param>
			<param name="policy" type="element(info:options)?" optional="true">An options node. If provided, it will be merged with a set of global reasonable defaults and stored as the named policy. If no $policy is provided, the content is the set of global defaults.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:policy-set(
    "default",
    &lt;options name="default" xmlns="http://marklogic.com/appservices/infostudio"&gt;
      &lt;collection&gt;http://marklogic.com/appservices/infostudio&lt;/collection&gt;
      &lt;error-handling&gt;continue-with-warning&lt;/error-handling&gt;
      &lt;fab-retention-duration&gt;P30D&lt;/fab-retention-duration&gt;
      &lt;file-filter&gt;^[^\.]&lt;/file-filter&gt;
      &lt;max-docs-per-transaction&gt;100&lt;/max-docs-per-transaction&gt;
      &lt;overwrite&gt;overwrite&lt;/overwrite&gt;
      &lt;ticket-retention-duration&gt;P30D&lt;/ticket-retention-duration&gt;
      &lt;uri&gt;
        &lt;literal&gt;http://docs/mydocs&lt;/literal&gt;
        &lt;filename/&gt;
        &lt;literal&gt;.&lt;/literal&gt;
        &lt;ext/&gt;
      &lt;/uri&gt;
    &lt;/options&gt;)

  (: Defines and sets a default polcy to load all documents with the uri of
     http://docs/mydocs. :)

</pre>

</example>
	</function>
	<function name="policy-delete" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:policy-delete">
		<summary>This function deletes a named policy. If the policy is successfully deleted or does not exist, this function returns an empty sequence.</summary>
		<params>
			<param name="policy-name" type="xs:string" optional="false">The name of a stored ingestion policy.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:policy-delete("default")

  (: Deletes the default policy. :)

</pre>

</example>
	</function>
	<function name="tickets" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:tickets">
		<summary>This function returns a sequence of ticket IDs, optionally narrowed by database name.</summary>
		<params>
			<param name="database" type="xs:string*" optional="true">A database name to narrow the selection of tickets to those associated with that database.</param>
			<param name="status" type="xs:string*" optional="true">A status name to narrow the selection of tickets to those with the specified status. The valid status values are "aborted", "active", "cancelled", "cleared", "completed", "inactive", "unloading", "unloaded", and "unload-aborted".</param>
			<param name="custom-query" type="schema-element(cts:query)?" optional="true">Some custom query to further narrow down the list of tickets returned.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:tickets()

  (: Returns the IDs of all of the tickets generated from loads into all of the databases. :)

</pre>

</example>
	</function>
	<function name="ticket-delete" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:ticket-delete">
		<summary>This function deletes a ticket and all associated state information. If the ticket is successfully deleted or does not exist, returns empty-sequence(). A tickets cannot be deleted if work is in progress.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket to be deleted.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  for $ticket in info:tickets("testDB")
     return info:ticket-delete($ticket)

  (: Deletes all of the tickets associated with the testDB database. :)

</pre>

</example>
	</function>
	<function name="ticket" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:ticket">
		<summary>This function returns a ticket element containing the status information for a long-running process.</summary>
		<params>
			<param name="ticket-id" type="xs:string+" optional="false">The id of the ticket associated with the long-running process.</param>
		</params>
		<return>element(info:ticket)+</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  let $ticket := info:load("C:\docs\mydocs", (), (), "testDB")

  return (
    "Loaded the testDB database with the files from",
    fn:data(info:ticket($ticket)//directory) )

  (: Returns the directory that was loaded into the testDB database. :)

</pre>

</example>
	</function>
	<function name="ticket-errors" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:ticket-errors">
		<summary>This function returns any errors that may have occured when loading content. The load operation must be complete before any errors appear in the ticket. You can use the optional parameters,
			<code>start</code>and
			<code>page-length</code>, to paginate through a long list of errors.
			<p />By default, errors are sorted by descending time. You can set the
			<code>sort-ascending</code>parameter to
			<code>true</code>to return errors in ascending time, which can be useful when paginating on an open ticket where new errors are coming in constantly.
			<p />The
			<code>filter</code>parameter allows you to annotate errors with metadata. You can create a filter to limit results by anything in the ticket, such as time, some custom annotation, or error code.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket.</param>
			<param name="start" type="xs:unsignedInt?" optional="true">Which error in a list from which to begin the returned list. For example, if dealing with hundreds of errors, you might want to display them in increments of 50. So you would call this function with
				<code>start</code>set to 1, then 50, then 100, and so on.</param>
			<param name="page-length" type="xs:unsignedInt?" optional="true">The number of errors returned in each page. In the example described for the
				<code>start</code>parameter, this would be set to 50.</param>
			<param name="sort-ascending" type="xs:boolean?" optional="true">By default, errors are sorted by descending time. Set to
				<code>true</code>to return errors in ascending time.</param>
			<param name="filter" type="schema-element(cts:query)?" optional="true">Any customer query written to filter the list of errors.</param>
		</params>
		<return>element(info:errors)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:ticket-errors("/tickets/ticket/8850539794189994434")

  (: Returns any errors associated with the specified ticket. :)

</pre>

</example>
	</function>
	<function name="database-delete" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:database-delete">
		<summary>This function deletes the specified database and its forest.</summary>
		<params>
			<param name="database-name" type="xs:string" optional="false">The name of the database to delete.</param>
			<param name="delete-data" type="xs:boolean?" optional="true">Determines whether to delete the database data. If set to
				<code>fn:true()</code>, both the configuration and the data directory containing all of the documents in the forest are deleted. If set to
				<code>fn:false()</code>, only the configuration information is deleted, leaving the forest data in the data directory on disk.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:database-delete("testDB")

  (: Deletes the testDB database and forest. :)

</pre>

</example>
	</function>
	<function name="error-detail" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:error-detail">
		<summary>This function returns the error detail associated with the specified
			<code>error-id</code>.</summary>
		<params>
			<param name="error-id" type="xs:unsignedLong" optional="false">The error id from a ticket.</param>
		</params>
		<return>element(info:error)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  for $ticket in info:tickets()
    let $error-id := info:ticket-errors($ticket)//info:error/@id
    return info:error-detail($error-id)

  (: Returns error details for all of the tickets. :)

</pre>

</example>
	</function>
	<function name="unload" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:unload">
		<summary>This function deletes all of the documents associated with the specified
			<code>$ticket-id</code>from one or more databases. The documents are deleted from the database associated with the ticket, as well as any additional databases specified by the
			<code>$database</code>parameter. The ticket status is "unloading" while the delete is in progress and "unloaded" when complete. A ticket may not be unloaded if its status is "active". If errors are encountered during the unloading process, an exception is thrown and the ticket status is set to "unload-aborted".</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket associated with the documents to be deleted.</param>
			<param name="database" type="xs:string*" optional="true">One or more database names. If no database is specified, only the documents from the database logged in the ticket are cleared. If databases are specified, documents associated with the ticket are deleted from those databases in addition to the database logged in the ticket.</param>
			<param name="batch-size" type="xs:positiveInteger?" optional="true">The number of documents to delete in a single transaction. If not specified, the default value of 5,000 is used.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:unload("/tickets/ticket/4920103524656746726")

  (: Deletes all of the documents associated with the ticket from the database
     specified in the ticket. :)

</pre>

</example>
	</function>
	<function name="flow-cancel" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:flow-cancel">
		<summary>This function cancels all active tickets associated with a flow. If the flow does not exist, an exception is thrown.</summary>
		<params>
			<param name="flow-id" type="xs:string" optional="false">The ID of the flow.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:flow-cancel("6184479677280143786")

  (: Cancels all active tickets for the flow.  :)

</pre>

</example>
	</function>
	<function name="flow-policy" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:flow-policy">
		<summary>This function returns the name of the policy associated with a flow. If the flow does not exist, an exception is thrown.</summary>
		<params>
			<param name="flow-id" type="xs:string" optional="false">The ID of the flow.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:flow-policy("6184479677280143786")

  (: Returns the name of the policy associated with the flow  :)

</pre>

</example>
	</function>
	<function name="flow-start" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:flow-start">
		<summary>This function starts (or "plays") the flow. If the flow does not exist, an exception is thrown.</summary>
		<params>
			<param name="flow-id" type="xs:string" optional="false">The ID of the flow.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:flow-start("6184479677280143786")

  (: Starts the specified flow to load the database.  :)

</pre>

</example>
	</function>
	<function name="flow-tickets" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:flow-tickets">
		<summary>This function returns a sequence of IDs for all of the tickets started by this flow. If the flow does not exist, an exception is thrown.</summary>
		<params>
			<param name="flow-id" type="xs:string" optional="false">The ID of the flow.</param>
			<param name="include-inactive" type="xs:boolean?" optional="true">Determines whether to return inactive tickets. By default, only the active tickets are returned. Set to
				<code>fn:true()</code>to return both active and inactive tickets.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:flow-tickets("6184479677280143786")

  (: Returns all active tickets associated with the flow.  :)

</pre>

</example>
	</function>
	<function name="flow-id" lib="info" category="Information Studio" bucket="XQuery Library Modules" hidden="false" fullname="info:flow-id">
		<summary>This function returns the id of the flow with the specified name. If no flow exists with this name, an empty sequence is returned.</summary>
		<params>
			<param name="flow-name" type="xs:string" optional="false">The name of the flow.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  info:flow-id("myFlow")

  (: Returns the id of the flow, "myFlow." :)

</pre>

</example>
	</function>
	<function name="check-options" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:check-options">
		<summary>This function checks the options node to ensure that the structure and values are correct. It returns a sequence of report elements. An empty sequence indicates that the options node is correct.</summary>
		<params>
			<param name="options" type="element(info:options)" optional="false">The options node to be checked.</param>
		</params>
		<return>element(info:report)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  infodev:check-options(
     &lt;options name="default" xmlns="http://marklogic.com/appservices/infostudio"&gt;
        &lt;collection&gt;http://marklogic.com/appservices/infostudio&lt;/collection&gt;
        &lt;error-handling&gt;continue-with-warning&lt;/error-handling&gt;
        &lt;fab-retention-duration&gt;P30D&lt;/fab-retention-duration&gt;
        &lt;file-filter&gt;^[^\.]&lt;/file-filter&gt;
        &lt;max-docs-per-transaction&gt;100&lt;/max-docs-per-transaction&gt;
        &lt;overwrite&gt;overwrite&lt;/overwrite&gt;
        &lt;ticket-retention-duration&gt;P30D&lt;/ticket-retention-duration&gt;
        &lt;uri&gt;
         &lt;literal&gt;http://foo&lt;/literal&gt;
          &lt;filename/&gt;
          &lt;literal&gt;.&lt;/literal&gt;
          &lt;ext/&gt;
       &lt;/uri&gt;
      &lt;/options&gt;)

(: Returns an empty sequence if the options node is correct.  Otherwise, errors
   are returned. :)

</pre>

</example>
	</function>
	<function name="ticket-create" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:ticket-create">
		<summary>This function generates a ticket and stores it in the specified database. It returns the id of the generated ticket.</summary>
		<params>
			<param name="annotation" type="element(info:annotation)?" optional="false">A custom annotation element designed to store implementation-specific data.</param>
			<param name="database" type="xs:string?" optional="false">The database in which to store the generated ticket.</param>
			<param name="policy-name" type="xs:string?" optional="false">The name of the policy to be used with requests associated with this ticket. If the name is provided but does not exist, an error is thrown. If no name is provided, a stored default policy is used if available. If neither exists, reasonable global defaults are used.</param>
			<param name="policy-deltas" type="element(info:options)?" optional="false">An options node to be used with requests associated with this ticket. It is merged with the effective policy at runtime.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";
  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  let $policy :=
  &lt;options name="default" xmlns="http://marklogic.com/appservices/infostudio"&gt;
    &lt;collection&gt;http://marklogic.com/appservices/infostudio&lt;/collection&gt;
    &lt;error-handling&gt;continue-with-warning&lt;/error-handling&gt;
    &lt;fab-retention-duration&gt;P30D&lt;/fab-retention-duration&gt;
    &lt;file-filter&gt;^[^\.]&lt;/file-filter&gt;
    &lt;max-docs-per-transaction&gt;100&lt;/max-docs-per-transaction&gt;
    &lt;overwrite&gt;overwrite&lt;/overwrite&gt;
    &lt;ticket-retention-duration&gt;P30D&lt;/ticket-retention-duration&gt;
    &lt;uri&gt;
      &lt;literal&gt;http://docs/newdocs/&lt;/literal&gt;
      &lt;filename/&gt;
      &lt;literal&gt;.&lt;/literal&gt;
      &lt;ext/&gt;
    &lt;/uri&gt;
  &lt;/options&gt;

  let $annotation := &lt;info:annotation&gt;Adding new docs to newdocs&lt;/info:annotation&gt;

  return
    infodev:ticket-create($annotation, "testDB", "default", $policy)

  (: Creates a new ticket. :)

</pre>

</example>
	</function>
	<function name="ticket-add-annotation" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:ticket-add-annotation">
		<summary>This function adds annotation to the specified ticket.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket to which to add the annotation.</param>
			<param name="annotation" type="element(info:annotation)" optional="false">A custom annotation element designed to store implementation-specific data.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";
  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  let $ticket-id := "/tickets/ticket/10095158268051211232"
  let $annotation := &lt;info:annotation&gt;Adding corrected documents&lt;/info:annotation&gt;

  return
    infodev:ticket-add-annotation($ticket-id, $annotation)

  (: Adds an annotation to the specified ticket. :)

</pre>

</example>
	</function>
	<function name="ticket-get-status" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:ticket-get-status">
		<summary>This function returns the status of the specified ticket.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket from which to get the status.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";
  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  for $ticket in info:tickets()
    return if (infodev:ticket-get-status($ticket) = "completed")
           then info:ticket-delete($ticket)
           else ()

  (: Remove all tickets with the status of 'completed'. :)

</pre>

</example>
	</function>
	<function name="ticket-set-status" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:ticket-set-status">
		<summary>This function sets the status of the specified ticket.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket to which to set the status.</param>
			<param name="status" type="xs:string" optional="false">The status to set on the ticket. The valid status values are "aborted", "active", "cancelled", "cleared", "completed", "inactive", "unloading", "unloaded", and "unload-aborted".</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  infodev:ticket-set-status("/tickets/ticket/13580249356496860619", "active")

  (: Sets the status of the specified ticket to "active." :)

</pre>

</example>
	</function>
	<function name="ticket-set-total-documents" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:ticket-set-total-documents">
		<summary>This function sets the number of documents to load into the database.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket.</param>
			<param name="total-documents" type="xs:unsignedInt" optional="false">The number of documents to load into the database.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  infodev:ticket-set-total-documents("/tickets/ticket/13580249356496860619", 5)

  (: Sets the total-documents value in the ticket to 5. :)

</pre>

</example>
	</function>
	<function name="ticket-set-total-transactions" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:ticket-set-total-transactions">
		<summary>This function adds and sets the value of a total-transactions element in the specified ticket.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket.</param>
			<param name="total-transactions" type="xs:unsignedInt" optional="false">The total-transactions value to set.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  infodev:ticket-set-total-transactions("/tickets/ticket/13580249356496860619", 2)

  (: Adds a &lt;total-transactions&gt; element to the ticket and sets the value to 2. :)

</pre>

</example>
	</function>
	<function name="file-filter" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:file-filter">
		<summary>This function returns a string representing a matching pattern to be applied to file paths on ingest.</summary>
		<params>
			<param name="policy-name" type="xs:string?" optional="false">The name of a stored ingestion policy.</param>
			<param name="policy-deltas" type="element(info:options)*" optional="false">Zero or more options nodes that contain a file-filter element. The specified file filter can be any valid XQuery regular expression.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  let $options :=
      &lt;options xmlns="http://marklogic.com/appservices/infostudio"&gt;
          &lt;file-filter&gt;^[^\.xml]&lt;/file-filter&gt;
      &lt;/options&gt;

  return
     infodev:file-filter("default", $options)

  =&gt;

  ^[^\.xml]

</pre>

</example>
	</function>
	<function name="transaction-size" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:transaction-size">
		<summary>This function resolves the transaction size parameter based on stored policy and runtime options and returns an integer that represents the maximum number of documents to handled in a single transaction.</summary>
		<params>
			<param name="policy-name" type="xs:string?" optional="false">The name of a stored ingestion policy. Uses default policy if none is provided.</param>
			<param name="policy-deltas" type="element(info:options)*" optional="false">Zero or more options nodes that override those in the stored or default policy.</param>
		</params>
		<return>xs:positiveInteger</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  infodev:transaction-size("default", ())

  (: Returns the max-docs-per-transaction size set in the default policy. :)

</pre>

</example>
	</function>
	<function name="handle-error" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:handle-error">
		<summary>This function provides configuration-aware error handling. If the error is to be logged, a
			<code>infodev:error</code>element is logged to the App-Services database, including document source-location, error code, and other information necessary to find and fix the error. Must be used within a try-catch block.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket.</param>
			<param name="context" type="xs:string" optional="false">The file that generated the error.</param>
			<param name="error" type="element(error:error)" optional="false">The error node caught by MarkLogic Server in the try block.</param>
			<param name="annotation" type="element(info:annotation)?" optional="true">The description of the error.</param>
			<param name="error-log-level" type="xs:string?" optional="true">The error log level. The possible levels are emergency, alert, critcal, error, warning, notice, info, config, debug, fine, finer, or finest. The default level is info.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  declare namespace error = "http://marklogic.com/xdmp/error";

  declare function local:load-doc(
     $doc
  ) as xs:string
  {
     let $document := xdmp:document-get($doc)
     let $path := "/xml/my.xml"
     let $annotation := &lt;info:annotation&gt;Adding new docs to newdocs&lt;/info:annotation&gt;
     let $ticket := infodev:ticket-create($annotation, "myDB", "default", ())

     let $deltas :=
     &lt;options xmlns="http://marklogic.com/appservices/infostudio"&gt;
        &lt;uri&gt;
           &lt;literal&gt;http://test&lt;/literal&gt;
           &lt;path/&gt;
           &lt;filename/&gt;
           &lt;literal&gt;.&lt;/literal&gt;
           &lt;ext/&gt;
        &lt;/uri&gt;
     &lt;/options&gt;

     let $ingestion :=
         try {
              infodev:ingest($document, $path, $ticket),
              infodev:log-progress(
                $ticket,
                &lt;info:annotation&gt;my.xml doc inserted&lt;/info:annotation&gt;)
         } catch($e) {
            infodev:handle-error($ticket, $path, $e)
         }
      let $_ := infodev:ticket-set-status($ticket, "completed")
      return (fn:concat($path, " loaded into myDB") )
  };

  local:load-doc("C:\test\my.xml")

  (: Logs any errors encountered when loading my.xml into the database. :)


</pre>

</example>
	</function>
	<function name="log-progress" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:log-progress">
		<summary>This function writes log information into a ticket's progress file that is written to the App-Services database.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of the ticket.</param>
			<param name="annotation" type="element(info:annotation)" optional="false">The string to place in the annotation element.</param>
			<param name="documents-processed" type="xs:nonNegativeInteger?" optional="true">The value to place in the documents-processed element.</param>
			<param name="transactions-completed" type="xs:nonNegativeInteger?" optional="true">The value to place in the transactions-completed element.</param>
			<param name="error-log-level" type="xs:string?" optional="true">The error log level. The possible levels are emergency, alert, critcal, error, warning, notice, info, config, debug, fine, finer, or finest. The default level is info.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";
  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  let $annotation := &lt;info:annotation&gt;Load took longer than 10 minutes&lt;/info:annotation&gt;

  for $ticket in info:tickets()
    let $time := fn:data(info:ticket($ticket)//info:time-consumed)
    return
      if (fn:minutes-from-duration(xs:duration($time)) gt 10)
      then infodev:log-progress($ticket, $annotation)
      else ()

  (: Change progress annotation on any ticket with a time-consumed value
     over 10 minutes. :)

</pre>

</example>
	</function>
	<function name="ingest" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:ingest">
		<summary>This function ingests a single document into the database specified in the ticket, according to the rules defined by the named policy and user-supplied options.</summary>
		<params>
			<param name="document" type="node()?" optional="false">The node to be inserted.</param>
			<param name="path" type="xs:string" optional="false">The name of the document and the URI path under which it is to be inserted in the database. In order for the path to be included in the URI, you must have &lt;path/&gt; in the uri portion of your policy:
				<p />
				<pre xml:space="preserve">
      &lt;options xmlns="http://marklogic.com/appservices/infostudio"&gt;
         &lt;uri&gt;
           &lt;literal/&gt;
           &lt;path/&gt;
           &lt;filename/&gt;
           &lt;literal&gt;.&lt;/literal&gt;
           &lt;ext/&gt;
         &lt;/uri&gt;
      &lt;/options&gt;
</pre></param>
			<param name="ticket-id" type="xs:string" optional="false">The ID of the ticket created by the
				<code>infodev:ticket-create</code>function.</param>
			<param name="policy-deltas" type="element(info:options)?" optional="true">An options node to be used with requests associated with this ticket. It is merged with the effective policy at runtime.</param>
			<param name="properties" type="element()*" optional="true">Any properties you want to set on the document. This does the same thing as the
				<code>xdmp:document-set-properties</code>function.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  let $document := xdmp:document-get("C:\mydocs\xmldocs\my.xml")
  let $path := "/newxml/my.xml"
  let $annotation := &lt;info:annotation&gt;Adding my.xml doc&lt;/info:annotation&gt;
  let $ticket := infodev:ticket-create($annotation, "myDB", "default", ())

  let $deltas :=
  &lt;options xmlns="http://marklogic.com/appservices/infostudio"&gt;
     &lt;uri&gt;
        &lt;literal&gt;http://testing&lt;/literal&gt;
        &lt;path/&gt;
        &lt;filename/&gt;
        &lt;literal&gt;.&lt;/literal&gt;
        &lt;ext/&gt;
     &lt;/uri&gt;
  &lt;/options&gt;

  return
     infodev:ingest($document, $path, $ticket. $deltas)

  (: loads the my.xml file, using the default policy, into the URI,
     http://testing/newxml/my.xml. :)

</pre>

</example>
	</function>
	<function name="collector-options" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:collector-options">
		<summary>This function returns an options node in the
			<code>xdmp:document-get</code>namespace that is ready to pass into
			<code>xdmp:document-get</code>, including default-namespace, repair, format, default-language, encoding if they are defined by policy or options.</summary>
		<params>
			<param name="policy-name" type="xs:string?" optional="false">The name of a stored ingestion policy.</param>
			<param name="policy-deltas" type="element(info:options)*" optional="false">Zero or more options nodes that override those in the stored or default policy.</param>
		</params>
		<return>element(dg:options)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  let $options :=
      &lt;options xmlns="http://marklogic.com/appservices/infostudio"&gt;
         &lt;format&gt;xml&lt;/format&gt;
      &lt;/options&gt;

  return
     infodev:collector-options("default", $options)

  =&gt;

  &lt;dg:options xmlns:dg="xdmp:document-get"&gt;
    &lt;dg:format&gt;xml&lt;/dg:format&gt;
  &lt;/dg:options&gt;

</pre>

</example>
	</function>
	<function name="effective-policy" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:effective-policy">
		<summary>This function temporarily resets the specified deltas on the named policy, while leaving the policy itself unchanged.</summary>
		<params>
			<param name="policy-name" type="xs:string?" optional="false">The name of the policy to temporily modify.</param>
			<param name="policy-deltas" type="element(info:options)*" optional="false">One or more deltas to be applied to the policy.</param>
		</params>
		<return>element(info:options)</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

  let $uri :=
  &lt;options name="default" xmlns="http://marklogic.com/appservices/infostudio"&gt;
    &lt;uri&gt;
      &lt;literal&gt;http://docs/&lt;/literal&gt;
      &lt;filename/&gt;
      &lt;literal&gt;.&lt;/literal&gt;
      &lt;ext/&gt;
    &lt;/uri&gt;
  &lt;/options&gt;

  let $error:=
  &lt;options name="default" xmlns="http://marklogic.com/appservices/infostudio"&gt;
      &lt;error-handling&gt;error&lt;/error-handling&gt;
  &lt;/options&gt;

  return infodev:effective-policy("default", ($uri, $error))

  (: Returns an options node reflecting different URI and error-handling settings
     in the default policy. :)

</pre>

</example>
	</function>
	<function name="filesystem-walk" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:filesystem-walk">
		<summary>This function can be used along with the
			<code>infodev:ingest</code>function to build custom load operations.
			<p />This function recurses the specified filesystem directory and uses the policy deltas from the specified ticket to determine which files to select for ingestion. The specified process function can be written to modify the content of files before calling the
			<code>infodev:ingest</code>function to load them into the database.</summary>
		<params>
			<param name="dir-path" type="xs:string" optional="false">The directory path to walk.</param>
			<param name="ticket-id" type="xs:string" optional="false">The ID of the created ticket.</param>
			<param name="function" type="xdmp:function" optional="false">The process function to apply to each file. This is where you can make modifications to each file before loading them into the database. The function signature must be as follows:
				<pre xml:space="preserve">
     declare function my:function(
        $document as node()?,
        $source-location as xs:string,
        $ticket-id as xs:string,
        $policy-deltas as element(info:options)?,
        $context as item()?)
     as empty-sequence()

</pre></param>
			<param name="policy-deltas" type="element(info:options)?" optional="false">One or more deltas to be applied to the policy.</param>
			<param name="context" type="item()?" optional="true">User-supplied context that is passed to the process function.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
   xquery version "1.0-ml";

   import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";
   import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

   declare function local:process-file(
       $document as node()?,
       $source-location as xs:string,
       $ticket-id as xs:string,
       $policy-deltas as element(info:options)?,
       $context as item()?)
     {
       (: You can modify the file here :)
       infodev:ingest($document, $source-location, $ticket-id)
     };

   let $function := xdmp:function(xs:QName("local:process-file"))
   let $annotation := &lt;info:annotation&gt;Loading XML docs&lt;/info:annotation&gt;
   let $dir-path := "C:\mydocs\xmldocs"
   let $ticket := infodev:ticket-create(
                      $annotation,
                      "myDB",
                      (),
                      () )

   return infodev:filesystem-walk(
                      $dir-path,
                      $ticket,
	              $function,
	              (),
                      () )

  (: This query does the same thing as the info:load function.  You can write the
     process-file function to modify each file in some manner before calling
     the infodev:ingest function. :)

</pre>

</example>
	</function>
	<function name="transaction" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:transaction">
		<summary>This function ingests a batch of documents in a single invoked transaction. The batch of documents is contained in
			<code>$document-map</code>. Ingestion is done using a function named by the
			<code>$function</code>parameter.</summary>
		<params>
			<param name="document-map" type="map:map" optional="false">A map containing a batch of documents to be ingested in a single transaction. Map keys are used to construct the URI used to locate the document to be ingested, such as the
				<code>$source-location</code>in the function referenced by the
				<code>$function</code>parameter, below.</param>
			<param name="ticket-id" type="xs:string" optional="false">The ID of the created ticket.</param>
			<param name="function" type="xdmp:function" optional="false">The ingestion function to apply to each file. This function should call
				<code>infodev:ingest</code>to insert the document into the database.
				<p />The function signature of
				<code>$function</code>must be of the pattern:
				<pre xml:space="preserve">

    declare function my:function(
        $document as node(),
        $source-location as xs:string,
        $ticket-id as xs:string,
        $policy-deltas as element(info:options)?,
        $context as item()?)
     as xs:string+

</pre></param>
			<param name="policy-deltas" type="element(info:options)?" optional="false">One or more deltas to be applied to the policy.</param>
			<param name="transaction-index" type="xs:integer" optional="false">An integer representing this transaction's index in a sequence of transactions. This is used in error reporting, to distinguish between transactions.</param>
			<param name="context" type="item()?" optional="false">User-supplied context that is passed to the process function.</param>
			<param name="error-log-level" type="xs:string?" optional="true">The error log level. The possible levels are emergency, alert, critcal, error, warning, notice, info, config, debug, fine, finer, or finest. The default level is info.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
   xquery version "1.0-ml";

   import module namespace info = "http://marklogic.com/appservices/infostudio"
      at "/MarkLogic/appservices/infostudio/info.xqy";
   import module namespace infodev = "http://marklogic.com/appservices/infostudio/dev"
      at "/MarkLogic/appservices/infostudio/infodev.xqy";

   (: Define a process-file function. :)
   declare function local:process-file(
       $document as node()?,
       $source-location as xs:string,
       $ticket-id as xs:string,
       $policy-deltas as element(info:options)?,
       $context as item()?)
     {
       (: You can modify the file here :)
       infodev:ingest($document, $source-location, $ticket-id)
     };

   let $function := xdmp:function(xs:QName("local:process-file"))
   let $annotation := &lt;info:annotation&gt;Loading XML Shakespeare docs&lt;/info:annotation&gt;

   (: Create a ticket to load contents into the myDB database. :)
   let $ticket := infodev:ticket-create($annotation, "myDB", (), ())

   (: Gather the documents to be loaded into $entries. :)
   let $playdir := "C:\Shakespeare\bill_xml"
   let $entries := for $x in xdmp:filesystem-directory($playdir)//dir:pathname/text()
                              [ends-with(lower-case(.), ".xml")]
                   return xdmp:document-get($x)

   (: Determine the number of documents; the number of documents to be loaded in each
      transaction, and the total number of transactions needed to load all of the documents. :)
   let $entry-count := fn:count($entries)
   let $transaction-size := 5 (: Typically, this value would be extracted from the policy. :)
   let $total-transactions := ceiling($entry-count div $transaction-size)

   (: Create a map containing the documents to be loaded. :)
   let $transactions :=
        for $i at $index in 1 to $total-transactions
        let $map := map:map()
        let $start :=  (($i -1) *$transaction-size) + 1
        let $finish := min((($start  - 1 + $transaction-size),$entry-count))
        let $put := for $entry in ($entries)[$start to $finish]
	      (: Create an ID for each document that consists of the date, a number, and a
	         filename contructed from the title of the play, minus spaces. :)
              let $title := fn:replace($entry/PLAY/TITLE, " ", "")
              let $id := fn:concat("/", fn:format-dateTime(fn:current-dateTime(),
	                          "[Y01]-[M01]-[D01]_[H01]-[m01]-[s01]-[f01]") ,
	                          "/", $index ,"/", $title, ".xml")
            return map:put($map,$id,$entry)
        return $map

    (: Create the transactions to load the documents into the database. :)
    let $ingestion :=
        for $transaction at $index in $transactions
        return
           try {
               infodev:transaction($transaction, $ticket, $function, (), $index,(),())
           } catch($e) {
               infodev:handle-error($ticket, concat("transaction ",$index), $e)
           }
    (: When the load transactions have completed, set the ticket status to "completed". :)
    let $_ := infodev:ticket-set-status($ticket, "completed")
    return ()

   (: This query creates multiple transactions to load the XML files located in the
      "C:\Shakespeare\bill_xml" directory into the myDB database.  Five documents are
      loaded in each transaction. :)

</pre>

</example>
	</function>
	<function name="get-file" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:get-file">
		<summary>
			<p>This is a convenience function that wraps
				<code>xdmp:document-get</code>. The document specified in
				<code>$source-location</code>is bundled with other documents into a transaction, and ingested.</p>
			<p>This function is similar to
				<code>infodev:ingest</code>, only it takes care of handling the infostudio options.</p>
		</summary>
		<params>
			<param name="source-location" type="xs:string" optional="false">The document to be ingested.</param>
			<param name="ticket-id" type="xs:string" optional="false">The ID of the ticket created by the
				<code>infodev:ticket-create</code>function.</param>
			<param name="policy-deltas" type="element(info:options)?" optional="false">An options node to be used with requests associated with this ticket. It is merged with the effective policy at runtime.</param>
		</params>
		<return>node()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/infostudio</code>
		</privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
xquery version "1.0-ml";

import module namespace infodev =
   "http://marklogic.com/appservices/infostudio/dev"
   at "/MarkLogic/appservices/infostudio/infodev.xqy";

infodev:get-file("/space/myfile.xml", infodev:ticket-create(), ())


</pre>

</example>
	</function>
	<function name="get-external-binary-file" lib="infodev" category="Information Studio Developer" bucket="XQuery Library Modules" hidden="false" fullname="infodev:get-external-binary-file">
		<summary>This function gets the specified binary file from the filesystem.</summary>
		<params>
			<param name="source-location" type="xs:string" optional="false">The path to the binary file.</param>
		</params>
		<return>node()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/infostudio</code>
		</privilege>
		<example xml:space="preserve">
<pre xml:space="preserve">
xquery version "1.0-ml";

import module namespace infodev =
   "http://marklogic.com/appservices/infostudio/dev"
   at "/MarkLogic/appservices/infostudio/infodev.xqy";

infodev:get-external-binary-file("/space/myfile.bin")

=&gt; returns the binary document
</pre>

</example>
	</function>
	<function name="point" type="kml" lib="kml" subcategory="KML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="kml:point">
		<summary>Create a cts:point value from a KML Point or Location element.</summary>
		<params>
			<param name="point" type="element()" optional="false">A Point or Location element.</param>
		</params>
		<return>cts:point</return>
		<usage>The KML Point and Location elements include additional information that is not retained in the cts:point value. In particular, the elevation part of the point value will be dropped. Therefore two KML points at the same latitude and longitude with different elevations will nevertheless have equal cts:point values.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace kml = "http://earth.google.com/kml/2.0"
         at "/MarkLogic/geospatial/kml.xqy";

  kml:point(
    &lt;kml:Point&gt;
      &lt;kml:coordinates&gt;-127.24,12.5,10.0&lt;/kml:coordinates&gt;
    &lt;/kml:Point&gt;)
  ,
  kml:point(
    &lt;kml:Location&gt;
      &lt;kml:latitude&gt;12.5&lt;/kml:latitude&gt;
      &lt;kml:longitude&gt;-127.24&lt;/kml:longitude&gt;
      &lt;kml:altitude&gt;10.0&lt;/kml:altitude&gt;
    &lt;/kml:Location&gt;)

</example>
	</function>
	<function name="box" type="kml" lib="kml" subcategory="KML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="kml:box">
		<summary>Create a cts:point value from a KML LatLongBox element.</summary>
		<params>
			<param name="envelope" type="element(kml:LatLongBox)" optional="false">A LatLongBox element.</param>
		</params>
		<return>cts:box</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace kml = "http://earth.google.com/kml/2.0"
         at "/MarkLogic/geospatial/kml.xqy";

  kml:box(
     &lt;kml:LatLongBox&gt;
       &lt;kml:north&gt;30&lt;/kml:north&gt;
       &lt;kml:south&gt;12.5&lt;/kml:south&gt;
       &lt;kml:east&gt;-122.24&lt;/kml:east&gt;
       &lt;kml:west&gt;-127.24&lt;/kml:west&gt;
     &lt;/kml:LatLongBox&gt;)

</example>
	</function>
	<function name="circle" type="kml" lib="kml" subcategory="KML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="kml:circle">
		<summary>Create a cts:circle value from a radius and KML Point or Location element.</summary>
		<params>
			<param name="radius" type="xs:double" optional="false">The radius of the circle, in miles.</param>
			<param name="center" type="element()" optional="false">A KML Point or Location element representing the center of the circle.</param>
		</params>
		<return>cts:circle</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace kml = "http://earth.google.com/kml/2.0"
         at "/MarkLogic/geospatial/kml.xqy";

  kml:circle(47,
	 &lt;kml:Point&gt;
	        &lt;kml:coordinates&gt;-127.24,12.5&lt;/kml:coordinates&gt;
	 &lt;/kml:Point&gt;)

</example>
	</function>
	<function name="polygon" type="kml" lib="kml" subcategory="KML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="kml:polygon">
		<summary>Create a cts:polygon value from a KML polygon or a sequence of KML Point or Location elements.</summary>
		<params>
			<param name="polygon-or-points" type="element()+" optional="false">A sequence of Point or Location elements representing the vertices of the polygon or a Polygon itself.</param>
		</params>
		<return>cts:polygon</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace kml = "http://earth.google.com/kml/2.0"
         at "/MarkLogic/geospatial/kml.xqy";

  kml:polygon((
    &lt;kml:Point&gt;&lt;kml:coordinates&gt;-127.24,12.5&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;,
    &lt;kml:Point&gt;&lt;kml:coordinates&gt;-127.8,15.25&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;,
    &lt;kml:Point&gt;&lt;kml:coordinates&gt;-126.1,13.45&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;,
    &lt;kml:Point&gt;&lt;kml:coordinates&gt;-127.24,12.5&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;
  ))

</example>
	</function>
	<function name="polygon" type="kml" lib="kml" subcategory="KML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="kml:polygon">
		<summary>Create a cts:polygon value from a KML Polygon element. The polygon returned represents the exterior polygon.</summary>
		<params>
			<param name="polygon-or-points" type="element()+" optional="false">A KML Polygon element representing the polygon.</param>
		</params>
		<return>cts:polygon</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace kml = "http://earth.google.com/kml/2.0"
         at "/MarkLogic/geospatial/kml.xqy";

  kml:polygon(
  &lt;kml:Polygon&gt;&lt;kml:outerBoundaryIs&gt;&lt;kml:LinearRing&gt;
   &lt;kml:coordinates&gt;-127.24,12.5 -127.8,15.25 -126.1,13.45 -127.24,12.5&lt;/kml:coordinates&gt;
  &lt;/kml:LinearRing&gt;&lt;/kml:outerBoundaryIs&gt;&lt;/kml:Polygon&gt;
  )

</example>
	</function>
	<function name="interior-polygon" type="kml" lib="kml" subcategory="KML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="kml:interior-polygon">
		<summary>Create a sequence of cts:polygon values from a KML Polygon element. The returned polygons represent the interior polygons, if any.</summary>
		<params>
			<param name="points" type="element(kml:Polygon)" optional="false">A KML Polygon element representing the polygon.</param>
		</params>
		<return>cts:polygon*</return>
		<example xml:space="preserve">
   xquery version "1.0-ml";
   import module namespace kml = "http://earth.google.com/kml/2.0"
         at "/MarkLogic/geospatial/kml.xqy";

  kml:interior-polygon(
    &lt;kml:Polygon&gt;
      &lt;kml:outerBoundaryIs&gt;&lt;kml:LinearRing&gt;&lt;kml:coordinates&gt;
      -127.24,12.5 -127.8,15.25 -126.1,13.45 -127.24,12.5
      &lt;/kml:coordinates&gt;&lt;/kml:LinearRing&gt;&lt;/kml:outerBoundaryIs&gt;
      &lt;kml:innerBoundaryIs&gt;&lt;kml:LinearRing&gt;&lt;kml:coordinates&gt;
      -127,13 127,-14 126,-14 127,-13
      &lt;/kml:coordinates&gt;&lt;/kml:LinearRing&gt;&lt;/kml:innerBoundaryIs&gt;
    &lt;/kml:Polygon&gt;
  )

</example>
	</function>
	<function name="geospatial-query" type="kml" lib="kml" subcategory="KML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="kml:geospatial-query">
		<summary>Returns a cts:query matching points within given regions.</summary>
		<params>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, polygons, or points. Where multiple boxes, circles, polygons, or points are specified, the query matches if any box, circle, polygon, or point matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root xmlns:kml="http://earth.google.com/kml/2.0"&gt;
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;30.0,10.5&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;35.34,15.35&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;40.55,5.11&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
&lt;/root&gt; );

xquery version "1.0-ml";
import module namespace kml = "http://earth.google.com/kml/2.0"
   at "/MarkLogic/geospatial/kml.xqy";

cts:search(doc("/points.xml")//item,
  kml:geospatial-query(
    kml:box(
      &lt;kml:LatLongBox&gt;
        &lt;kml:north&gt;20.0&lt;/kml:north&gt;
        &lt;kml:south&gt;10.0&lt;/kml:south&gt;
        &lt;kml:east&gt;40.0&lt;/kml:east&gt;
        &lt;kml:west&gt;35.0&lt;/kml:west&gt;
      &lt;/kml:LatLongBox&gt;) ))
(:
  returns the following node:
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;35.34,15.35&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  kml:geospatial-query(kml:box(
    &lt;kml:LatLongBox&gt;
      &lt;kml:north&gt;20.0&lt;/kml:north&gt;
      &lt;kml:south&gt;10.0&lt;/kml:south&gt;
      &lt;kml:east&gt;35.0&lt;/kml:east&gt;
      &lt;kml:west&gt;40.0&lt;/kml:west&gt;
    &lt;/kml:LatLongBox&gt;) ))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;30.0,10.5&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
:)

</example>
	</function>
	<function name="geospatial-query-from-elements" type="kml" lib="kml" subcategory="KML" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="kml:geospatial-query-from-elements">
		<summary>Returns a cts:query matching points within given regions.</summary>
		<params>
			<param name="regions" type="element()*" optional="false">One or more geographic boxes, circles, polygons, or points, represented as KML elements. Where multiple boxes, circles, polygons, or points are specified, the query matches if any box, circle, polygon, or point matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
			<p>This function will take into account interior polygons, if any, and properly construct the query to account for them.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root xmlns:kml="http://earth.google.com/kml/2.0"&gt;
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;30.0,10.5&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;35.34,15.35&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;40.55,5.11&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
&lt;/root&gt; );

xquery version "1.0-ml";
import module namespace kml = "http://earth.google.com/kml/2.0"
   at "/MarkLogic/geospatial/kml.xqy";

cts:search(doc("/points.xml")//item,
  kml:geospatial-query-from-elements(
      &lt;kml:LatLongBox&gt;
        &lt;kml:north&gt;20.0&lt;/kml:north&gt;
        &lt;kml:south&gt;10.0&lt;/kml:south&gt;
        &lt;kml:east&gt;40.0&lt;/kml:east&gt;
        &lt;kml:west&gt;35.0&lt;/kml:west&gt;
      &lt;/kml:LatLongBox&gt;) )
(:
  returns the following node:
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;35.34,15.35&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  kml:geospatial-query-from-elements(
    &lt;kml:LatLongBox&gt;
      &lt;kml:north&gt;20.0&lt;/kml:north&gt;
      &lt;kml:south&gt;10.0&lt;/kml:south&gt;
      &lt;kml:east&gt;35.0&lt;/kml:east&gt;
      &lt;kml:west&gt;40.0&lt;/kml:west&gt;
    &lt;/kml:LatLongBox&gt;) )
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;kml:Point&gt;&lt;kml:coordinates&gt;30.0,10.5&lt;/kml:coordinates&gt;&lt;/kml:Point&gt;&lt;/item&gt;
:)

</example>
	</function>
	<function name="create" type="link" lib="lnk" category="Links" bucket="CPF Functions" hidden="false" fullname="lnk:create">
		<summary>Create a link between the two given documents with the given role labels and strength. An error is raised if either of the documents involved does not exist or if the link would be invalid for some reason. This function will replace any existing link between those two documents with the new link.</summary>
		<params>
			<param name="from" type="xs:string" optional="false">The URI of the document at the tail of the link.</param>
			<param name="to" type="xs:string" optional="false">The URI of the document at the head of the link.</param>
			<param name="role" type="xs:string" optional="false">A label for the relationship of the head of the link to the tail of the link, one of "source", "consumer", "container", "variant", and "related".</param>
			<param name="rev-role" type="xs:string" optional="false">A label for the reverse relationship of the tail of the link to the head of the link.</param>
			<param name="strength" type="xs:string" optional="false">An indicator of the strength of the relationship between the two documents, either "strong" or "weak".</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace lnk = "http://marklogic.com/cpf/links"
	         at "/MarkLogic/cpf/links.xqy";

  lnk:create( "/myDocs/example.xhtml", "/myDocs/example.doc",
              "source", "conversion", "strong" )

</example>
	</function>
	<function name="insert" type="link" lib="lnk" category="Links" bucket="CPF Functions" hidden="false" fullname="lnk:insert">
		<summary>Insert the given link. An error is raised if either of the documents involved does not exist or if the link is invalid in some way. This function will replace any existing link between those two documents.</summary>
		<params>
			<param name="link" type="element(lnk:link)" optional="false">The link element.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace lnk = "http://marklogic.com/cpf/links"
	         at "/MarkLogic/cpf/links.xqy";

  lnk:insert( lnk:get( "/myDocs/fr/example.xhtml", "/myDocs/example.xhtml" ) )

</example>
	</function>
	<function name="remove" type="link" lib="lnk" category="Links" bucket="CPF Functions" hidden="false" fullname="lnk:remove">
		<summary>Remove the link between the two given documents and return the removed link. An error is raised if no such link exists.</summary>
		<params>
			<param name="from" type="xs:string" optional="false">The URI of the document at the tail of the link.</param>
			<param name="to" type="xs:string" optional="false">The URI of the document at the head of the link.</param>
		</params>
		<return>element(lnk:link)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace lnk = "http://marklogic.com/cpf/links"
	         at "/MarkLogic/cpf/links.xqy";

  lnk:remove( "/myDocs/example.xhtml", "/myDocs/example.doc" )

</example>
	</function>
	<function name="get" type="link" lib="lnk" category="Links" bucket="CPF Functions" hidden="false" fullname="lnk:get">
		<summary>Find and return the link between the two documents, if any. This function will check the properties of link and raise an error if they are inconsistent or incomplete in some way.</summary>
		<params>
			<param name="from" type="xs:string" optional="false">The URI of the document at the tail of the link.</param>
			<param name="to" type="xs:string" optional="false">The URI of the document at the head of the link.</param>
		</params>
		<return>element(lnk:link)?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace lnk = "http://marklogic.com/cpf/links"
	         at "/MarkLogic/cpf/links.xqy";

  lnk:get( "/myDocs/fr/example.xhtml", "/myDocs/example.xhtml" )

</example>
	</function>
	<function name="from" type="link" lib="lnk" category="Links" bucket="CPF Functions" hidden="false" fullname="lnk:from">
		<summary>Find and return all the links from the given document to some other. This function will check the properties of the link and raise an error if they are inconsistent or incomplete in some way.</summary>
		<params>
			<param name="from" type="xs:string" optional="false">The URI of the document at the tail of the link.</param>
		</params>
		<return>element(lnk:link)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace lnk = "http://marklogic.com/cpf/links"
	         at "/MarkLogic/cpf/links.xqy";

  for $link in lnk:from( "/myDocs/example.xhtml" )
  return $link/@to

</example>
	</function>
	<function name="to" type="link" lib="lnk" category="Links" bucket="CPF Functions" hidden="false" fullname="lnk:to">
		<summary>Find and return all the links to the given document from some other. This function will check the properties of the link and raise an error if they are inconsistent or incomplete in some way.</summary>
		<params>
			<param name="to" type="xs:string" optional="false">The URI of the document at the head of the link.</param>
		</params>
		<return>element(lnk:link)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace lnk = "http://marklogic.com/cpf/links"
	         at "/MarkLogic/cpf/links.xqy";

  for $link in lnk:from( "/myDocs/example.xhtml" )
  return $link/@to

</example>
	</function>
	<function name="strftime" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:strftime">
		<summary>Formats a dateTime value using POSIX strftime. This function uses the POSIX strftime system call in the way it is implemented on each platform. For other XQuery functions that have more functionality (for example, for things like timezones), use one or more if the various XQuery or XSLT standard functions such as
			<a href="#fn:format-dateTime">
				<code>fn:format-dateTime</code>
			</a>.</summary>
		<params>
			<param name="format" type="xs:string" optional="false">The strftime format string.</param>
			<param name="value" type="xs:dateTime" optional="false">The dateTime value.</param>
		</params>
		<return>xs:string</return>
		<usage>
			<p>The supported format strings differ for different platforms. For the supported format strings for Windows, see the following link:</p>
			<p>
				<a href="http://msdn2.microsoft.com/en-us/library/fe06s4ak(VS.80).aspx" target="_blank">http://msdn2.microsoft.com/en-us/library/fe06s4ak(VS.80).aspx</a>
			</p>
			<p>For the supported format strings for Solaris, see the following link:</p>
			<p>
				<a href="http://docs.sun.com/app/docs/doc/817-5438/6mkt5pcec?a=view" target="_blank">http://docs.sun.com/app/docs/doc/817-5438/6mkt5pcec?a=view</a>
			</p>
			<p>For the supported format strings for Linux, see the following link:</p>
			<p>
				<a href="http://linux.about.com/library/cmd/blcmdl3_strftime.htm" target="_blank">http://linux.about.com/library/cmd/blcmdl3_strftime.htm</a>
			</p>
		</usage>
		<example xml:space="preserve">
  xdmp:strftime("%a, %d %b %Y %H:%M:%S",current-dateTime())
   =&gt; Tue, 08 Apr 2003 17:21:37
</example>
	</function>
	<function name="exists" type="builtin" lib="xdmp" category="Extension" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:exists">
		<summary>Returns true if any fragment is selected by an expression, false if no fragments are selected. This can be used as a fast existence check.</summary>
		<params>
			<param name="expression" type="item()*" optional="false">The expression to check. This must be a partially searchable XPath expression or a
				<code>cts:search()</code>expression.</param>
		</params>
		<return>xs:integer</return>
		<usage>
			<p>Queries that use
				<code>xdmp:exists</code>require that the XPath expression searched is partially searchable. A
				<em>partially searchable</em>XPath expression is one whose first step is searchable. You can use
				<code>xdmp:query-trace()</code>to determine if a step is searchable. If there are no entries in the
				<code>xdmp:query-trace()</code>output indicating that the first step is
				<code>unsearchable</code>, then the expression is partially searchable and you can perform an
				<code>xdmp:exists</code>operation on it.</p>
			<p>Calling
				<code>xdmp:exists</code>on an expression is the same as calling
				<code>xdmp:estimate</code>on the expression with a maximum of 1. For example, the following are equivalent:
				<br /></p>
			<pre xml:space="preserve">
     xdmp:exists(cts:search(collection(), "foo"))

       is equivalent to:

     xs:boolean(xdmp:estimate(cts:search(collection(), "foo"), 1))
</pre>
		</usage>
		<example xml:space="preserve">
  xdmp:exists(collection())
   =&gt; true
</example>
	</function>
	<function name="estimate" type="builtin" lib="xdmp" category="Extension" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:estimate">
		<summary>Returns the number of fragments selected by an expression. This can be used as a fast estimate of the number of items in a sequence.</summary>
		<params>
			<param name="expression" type="item()*" optional="false">The expression to estimate. This must be a partially searchable XPath expression or a
				<code>cts:search()</code>expression.</param>
			<param name="maximum" type="xs:double?" optional="true">The maximum value to return. Stop selecting fragments if this number is reached.</param>
		</params>
		<return>xs:integer</return>
		<usage>Queries that use
			<code>xdmp:estimate</code>require that the XPath expression searched is partially searchable. A
			<em>partially searchable</em>XPath expression is one whose first step is searchable. You can use
			<code>xdmp:query-trace()</code>to determine if a step is searchable. If there are no entries in the
			<code>xdmp:query-trace()</code>output indicating that the first step is
			<code>unsearchable</code>, then the expression is partially searchable and you can perform an
			<code>xdmp:estimate</code>operation on it.</usage>
		<example xml:space="preserve">
  xdmp:estimate(collection())
   =&gt; 10476
</example>
	</function>
	<function name="plan" type="builtin" lib="xdmp" category="Extension" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:plan">
		<summary>Returns an XML element recording information about how the given expression will be processed by the index. The information is a structured representation of the information provided in the error log when query trace is enabled. The query will be processed up to the point of getting an estimate of the number of fragments returned by the index.</summary>
		<params>
			<param name="expression" type="item()*" optional="false">The expression to estimate. This must be a partially searchable XPath expression or a
				<code>cts:search()</code>expression.</param>
			<param name="maximum" type="xs:double?" optional="true">The maximum value to return. Stop selecting fragments if this number is reached.</param>
		</params>
		<return>element()</return>
		<usage>
			<p>The output from
				<code>xdmp:plan</code>will vary depending on various index settings.</p>
			<p>Running an
				<code>xdmp:plan</code>on a search is similar to running an
				<code>xdmp:estimate</code>on a search, but it returns a report on the search instead of just an estimate. As part of the report, the
				<code>qry:result</code>element includes the estimate. If the search expression argument cannot be run in the plan because it is not partially searchable, then an
				<code>XDMP-UNSEARCHABLE</code>exception is returned as part of the
				<code>xdmp:plan</code>output.</p>
			<p>If you are running a search using the search API (for example,
				<code>search:search</code>), use the option
				<code>&lt;return-plan&gt;true&lt;/return-plan&gt;</code>in your search API options node.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:plan(cts:search(fn:doc(),cts:word-query("cat")))
   =&gt;
&lt;qry:query-plan xmlns:qry="http://marklogic.com/cts/query"&gt;
  &lt;qry:info-trace&gt;xdmp:eval("xquery version &amp;amp;quot;1.0-ml&amp;amp;quot;;&amp;amp;#13;
  &amp;amp;#10;xdmp:plan(cts:search...", (), &amp;lt;options xmlns="xdmp:eval"&amp;gt;&amp;lt;
  default-xquery-version&amp;gt;0.9-ml&amp;lt;/default-xquery-version&amp;gt;&amp;lt;root
  &amp;gt;c:/...&amp;lt;/options&amp;gt;)&lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Analyzing path for search: fn:doc()&lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Step 1 is searchable: fn:doc()&lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Path is fully searchable.&lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Gathering constraints.&lt;/qry:info-trace&gt;
  &lt;qry:word-trace text="cat"&gt;
    &lt;qry:key&gt;12545744176132597186&lt;/qry:key&gt;
  &lt;/qry:word-trace&gt;
  &lt;qry:info-trace&gt;Search query contributed 1 constraint:
  cts:word-query("cat", ("lang=en"), 1)&lt;/qry:info-trace&gt;
  &lt;qry:partial-plan&gt;
    &lt;qry:term-query weight="1"&gt;
      &lt;qry:key&gt;12545744176132597186&lt;/qry:key&gt;
    &lt;/qry:term-query&gt;
  &lt;/qry:partial-plan&gt;
  &lt;qry:info-trace&gt;Executing search.&lt;/qry:info-trace&gt;
  &lt;qry:final-plan&gt;
    &lt;qry:and-query&gt;
      &lt;qry:term-query weight="1"&gt;
	&lt;qry:key&gt;12545744176132597186&lt;/qry:key&gt;
      &lt;/qry:term-query&gt;
    &lt;/qry:and-query&gt;
  &lt;/qry:final-plan&gt;
  &lt;qry:info-trace&gt;Selected 2 fragments to filter&lt;/qry:info-trace&gt;
  &lt;qry:result estimate="2"/&gt;
&lt;/qry:query-plan&gt;


</example>
    <example xml:space="preserve">
xquery version "1.0-ml" ;

xdmp:plan(
 cts:search(/document,
   cts:word-query("cut?",
    ("unstemmed", "wildcarded") ) ) )
(:
The &lt;qry:expansion-trace&gt; element indicates that a
lexicon expansion occurred on the wildcarded query
(word searches, three character searches and
a codepoint lexicon are enabled in the database
configuration for wildcard queries).  The
&lt;qry:expansion&gt; element shows what term(s) the
lexicon expansion found.  In this case, "cut?"
expands to "cute".
:)
=&gt;
&lt;qry:query-plan xmlns:qry="http://marklogic.com/cts/query"&gt;
  &lt;qry:info-trace&gt;xdmp:eval("xquery version &amp;amp;quot;1.0-ml&amp;amp;quot; ;
  &amp;amp;#13;&amp;amp;#10;&amp;amp;#13;&amp;amp;#10;xdmp:plan...", (),
  &amp;lt;options xmlns="xdmp:eval"&amp;gt;&amp;lt;database&amp;gt;
  13960881382049922482&amp;lt;/database&amp;gt;&amp;lt;default-xquery-version...
  &amp;lt;/options&amp;gt;)&lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Analyzing path for search: fn:collection()/document
  &lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Step 1 is searchable: fn:collection()&lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Step 2 is searchable: document&lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Path is fully searchable.&lt;/qry:info-trace&gt;
  &lt;qry:info-trace&gt;Gathering constraints.&lt;/qry:info-trace&gt;
  &lt;qry:expansion-trace text="cut?"&gt;
    &lt;qry:expansion text="cute"/&gt;
  &lt;/qry:expansion-trace&gt;
  &lt;qry:word-trace text="cute"&gt;
    &lt;qry:key&gt;16588943567160478160&lt;/qry:key&gt;
  &lt;/qry:word-trace&gt;
  &lt;qry:info-trace&gt;Search query contributed 1 constraint:
  cts:word-query("cut?", ("unstemmed","wildcarded","lang=en"), 1)
  &lt;/qry:info-trace&gt;
  &lt;qry:partial-plan&gt;
    &lt;qry:term-query weight="1"&gt;
      &lt;qry:key&gt;16588943567160478160&lt;/qry:key&gt;
    &lt;/qry:term-query&gt;
  &lt;/qry:partial-plan&gt;
  &lt;qry:info-trace&gt;Executing search.&lt;/qry:info-trace&gt;
  &lt;qry:final-plan&gt;
    &lt;qry:and-query&gt;
      &lt;qry:or-two-queries&gt;
	&lt;qry:term-query weight="0"&gt;
	  &lt;qry:key&gt;3998944933214536873&lt;/qry:key&gt;
	&lt;/qry:term-query&gt;
	&lt;qry:term-query weight="0"&gt;
	  &lt;qry:key&gt;13616698357625443361&lt;/qry:key&gt;
	&lt;/qry:term-query&gt;
      &lt;/qry:or-two-queries&gt;
      &lt;qry:term-query weight="1"&gt;
	&lt;qry:key&gt;16588943567160478160&lt;/qry:key&gt;
      &lt;/qry:term-query&gt;
    &lt;/qry:and-query&gt;
  &lt;/qry:final-plan&gt;
  &lt;qry:info-trace&gt;Selected 1 fragment to filter&lt;/qry:info-trace&gt;
  &lt;qry:result estimate="1"/&gt;
&lt;/qry:query-plan&gt;


</example>
	</function>
	<function name="version" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:version">
		<summary>Returns the current MarkLogic Server version.</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:version()
   =&gt; "4.3-1"
</example>
	</function>
	<function name="xquery-version" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:xquery-version">
		<summary>Returns the XQuery language version of the calling module. Currently supported XQuery versions are:
			<ul>
				<li>"0.9-ml": The legacy MarkLogic XQuery version. This was the only XQuery version available on MarkLogic Server 3.2 and earlier. It is based on the May 2003 XQuery Draft Recommendation, with MarkLogic extensions</li>
				<li>"1.0-ml": XQuery version 1.0, with MarkLogic extensions. This is the preferred version of XQuery beginning with release 4.0.</li>
				<li>"1.0": Strict XQuery version 1.0. This XQuery version complies as closely as possible with the published XQuery 1.0 specification.</li>
			</ul></summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:xquery-version()
   =&gt; "1.0-ml"
</example>
	</function>
	<function name="platform" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:platform">
		<summary>Returns the operating-system platform upon which MarkLogic Server is running ("solaris", "winnt", "linux", or "macosx").</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:platform()
   =&gt; "winnt"
</example>
	</function>
	<function name="architecture" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:architecture">
		<summary>Returns the hardware architecture upon which MarkLogic Server is running. If
			<code>xdmp:platform()</code>returns "linux", it will return "x86_64" or "i686. If
			<code>xdmp:platform()</code>returns "solaris", it will return "amd64" or "sparcv9". If
			<code>xdmp:platform()</code>returns "winnt", it will return "amd64" or "i686". If
			<code>xdmp:platform()</code>returns "macosx", it will return "x86_64".</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:architecture()
   =&gt; "amd64"
</example>
	</function>
	<function name="path" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:path">
		<summary>Returns a string whose value corresponds to the path of the node.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node whose path is returned.</param>
			<param name="include-document" type="xs:boolean?" optional="true">If true, then the path is presented with a leading
				<code>doc(..)/..</code>, otherwise the path is presented as
				<code>/..</code>.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  let $arg := &lt;a&gt;&lt;b&gt;&lt;c&gt;ccc&lt;/c&gt;&lt;/b&gt;
                &lt;b&gt;bbb&lt;/b&gt;&lt;/a&gt;
  return xdmp:path($arg/b[1]/c)
  =&gt; "/a/b[1]/c"
</example>
	</function>
	<function name="describe" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:describe">
		<summary>Returns a string representing the description of a given item sequence. If you take the output of the
			<code>xdmp:describe</code>function and evaluate it as an XQuery program, it returns the item(s) input to the function.</summary>
		<params>
			<param name="item" type="item()*" optional="false">The item sequence whose description is returned.</param>
			<param name="maxSequenceLength" type="xs:unsignedInt?" optional="true">Represents the maximum number of items per sequence to print. The default is 3. () means no maximum.</param>
			<param name="maxItemLength" type="xs:unsignedInt*" optional="true">Represents the maximum number of characters per item to print. The default is 64. The minimum is 8. () means no limit.</param>
		</params>
		<return>xs:string</return>
		<usage>
			<p>If you specify an item that is in a database,
				<code>xdmp:describe</code>returns the path to the item (or to the items if you specify multiple items). If the item or items are constructed in XQuery, then it prints out the item, truncating the characters in each item according to the
				<code>maxItemLength</code>parameter.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:describe(current-date())

  =&gt; xs:date("2007-01-15-08:00")
</example>
    <example xml:space="preserve">
  let $x := &lt;mynode&gt;Some text here.&lt;/mynode&gt;
  return
  xdmp:describe($x)

  =&gt; &lt;mynode&gt;Some text here.&lt;/mynode&gt;
</example>
    <example xml:space="preserve">
  (:  assume mydoc.xml is an XML document with
      the following content:
      &lt;mynode&gt;Some text here.&lt;/mynode&gt; :)
  xdmp:describe(doc("mydoc.xml")/mynode)

  =&gt; doc("mydoc.xml")/mynode
</example>
	</function>
	<function name="hash32" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:hash32">
		<summary>Returns the 32-bit hash of a string.</summary>
		<params>
			<param name="string" type="xs:string" optional="false">The string to be hashed.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  xdmp:hash32("/a/b[1]/c")
  =&gt; 152930691
</example>
	</function>
	<function name="hash64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:hash64">
		<summary>Returns the 64-bit hash of a string.</summary>
		<params>
			<param name="string" type="xs:string" optional="false">The string to be hashed.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:hash64("/a/b[1]/c")
  =&gt; 5082244643751628547
</example>
	</function>
	<function name="step64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:step64">
		<summary>Combines an initial hash with a subsequent hash.</summary>
		<params>
			<param name="initial" type="xs:unsignedLong" optional="false">An initial hash.</param>
			<param name="step" type="xs:unsignedLong" optional="false">A step hash to be combined with the initial hash.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:step64(xdmp:hash64("initial"), xdmp:hash64("step"))
  =&gt; 12899951685816192752
</example>
	</function>
	<function name="add64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:add64">
		<summary>Add two 64-bit integer values, discarding overflow.</summary>
		<params>
			<param name="x" type="xs:unsignedLong" optional="false">The first value.</param>
			<param name="y" type="xs:unsignedLong" optional="false">The second value.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:add64(11442580934957149475,14565934789622151058)
  =&gt; 7561771650869748917
</example>
	</function>
	<function name="and64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:and64">
		<summary>AND two 64-bit integer values.</summary>
		<params>
			<param name="x" type="xs:unsignedLong" optional="false">The first value.</param>
			<param name="y" type="xs:unsignedLong" optional="false">The second value.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:and64(255, 2)
   =&gt; 2
</example>
	</function>
	<function name="mul64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:mul64">
		<summary>Muliply two 64-bit integer values, discarding overflow.</summary>
		<params>
			<param name="x" type="xs:unsignedLong" optional="false">The first value.</param>
			<param name="y" type="xs:unsignedLong" optional="false">The second value.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:mul64(15107650474313474666,13290239292956375463)
  =&gt; 1404109880107289894
</example>
	</function>
	<function name="not64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:not64">
		<summary>NOT a 64-bit integer value.</summary>
		<params>
			<param name="x" type="xs:unsignedLong" optional="false">The input value.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:not64(255)
   =&gt; 18446744073709551360
</example>
	</function>
	<function name="or64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:or64">
		<summary>OR two 64-bit integer values.</summary>
		<params>
			<param name="x" type="xs:unsignedLong" optional="false">The first value.</param>
			<param name="y" type="xs:unsignedLong" optional="false">The second value.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:or64(255, 2)
   =&gt; 255
</example>
	</function>
	<function name="xor64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:xor64">
		<summary>XOR two 64-bit integer values.</summary>
		<params>
			<param name="x" type="xs:unsignedLong" optional="false">The first value.</param>
			<param name="y" type="xs:unsignedLong" optional="false">The second value.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:xor64(255, 2)
   =&gt; 253
</example>
	</function>
	<function name="lshift64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:lshift64">
		<summary>Left-shift a 64-bit integer value.</summary>
		<params>
			<param name="x" type="xs:unsignedLong" optional="false">The value to shift.</param>
			<param name="y" type="xs:integer" optional="false">The left shift to perform. This value may be negative.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:lshift64(255, 2)
   =&gt; 1020
</example>
	</function>
	<function name="rshift64" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:rshift64">
		<summary>Right-shift a 64-bit integer value.</summary>
		<params>
			<param name="x" type="xs:unsignedLong" optional="false">The value to shift.</param>
			<param name="y" type="xs:integer" optional="false">The right shift to perform. This value may be negative.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:rshift64(255, 2)
   =&gt; 63
</example>
	</function>
	<function name="random" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:random">
		<summary>Returns a random unsigned integer between 0 and a number up to 64 bits long.</summary>
		<params>
			<param name="max" type="xs:unsignedLong" optional="true">The optional maximum value (inclusive).</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:random(100)
  =&gt; 47
</example>
	</function>
	<function name="hex-to-integer" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:hex-to-integer">
		<summary>Parses a hexadecimal string, returning an integer.</summary>
		<params>
			<param name="hex" type="xs:string" optional="false">The hexadecimal string.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
  xdmp:hex-to-integer("1234567890abcdef")
   =&gt; 1311768467294899695
</example>
	</function>
	<function name="integer-to-hex" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:integer-to-hex">
		<summary>Returns a hexadecimal representation of an integer.</summary>
		<params>
			<param name="val" type="xs:integer" optional="false">The integer value.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:integer-to-hex(1234567890)
   =&gt; "499602d2"
</example>
	</function>
	<function name="octal-to-integer" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:octal-to-integer">
		<summary>Parses an octal string, returning an integer.</summary>
		<params>
			<param name="octal" type="xs:string" optional="false">The octal string.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
  xdmp:octal-to-integer("12345670")
   =&gt; 2739128
</example>
	</function>
	<function name="integer-to-octal" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:integer-to-octal">
		<summary>Returns an octal representation of an integer.</summary>
		<params>
			<param name="val" type="xs:integer" optional="false">The integer value.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:integer-to-octal(1234567890)
   =&gt; "11145401322"
</example>
	</function>
	<function name="request-timestamp" type="builtin" lib="xdmp" category="Extension" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:request-timestamp">
		<summary>Returns the system timestamp for this request if the request is a query statement. Returns the empty sequence if the current request is an update statement.</summary>
		<params />
		<return>xs:unsignedLong?</return>
		<usage>The
			<code>xdmp:request-timestamp</code>function returns the system timestamp that is in effect for current query. This timestamp will remain unchanged for the duration of the query. If you want to get the most recent system timestamp external to the current running context during an update statement (for example, if your query takes a long time to run, and there are other updates occurring in your database while your update statement is running), you can use
			<code>xdmp:eval</code>to evaluate a separate query statement that returns the system timestamp at the time the
			<code>xdmp:eval</code>query is evaluated.</usage>
		<example xml:space="preserve">
  xdmp:request-timestamp()
   =&gt; 1234567
</example>
	</function>
	<function name="eval" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:eval">
		<summary>Returns the result of evaluating a string as an XQuery module.</summary>
		<params>
			<param name="xquery" type="xs:string" optional="false">The XQuery string to be evaluated. If the XQuery string contains double quotes ("), surround the string with single quotes (').</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node for the
				<code>xdmp:eval</code>options must be in the
				<code>xdmp:eval</code>namespace. The following is a sample options node:
				<pre xml:space="preserve">
    &lt;options xmlns="xdmp:eval"&gt;
      &lt;isolation&gt;different-transaction&lt;/isolation&gt;
      &lt;prevent-deadlocks&gt;true&lt;/prevent-deadlocks&gt;
    &lt;/options&gt;
</pre>
				<p>The
					<code>xdmp:eval</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;database&gt;</p>
						</dt>
						<dd>The database ID, from
							<code>xdmp:database("db_name")</code>,
							<code>xdmp:security-database()</code>, or
							<code>xdmp:schema-database()</code>. To specify a database other than the context database, the
							<code>http://marklogic.com/xdmp/privileges/xdmp-eval-in</code>privilege is required.</dd>
						<dt>
							<p>&lt;modules&gt;</p>
						</dt>
						<dd>The modules database ID for processing module imports. Specifying no
							<code>&lt;modules&gt;</code>element in the options node specifies the current modules database. Specifying
							<code>0</code>specifies using the file system to process module imports. You must have the
							<code>http://marklogic.com/xdmp/privileges/xdmp-eval-modules-change</code>(for
							<code>xdmp:eval</code>),
							<code>http://marklogic.com/xdmp/privileges/xdmp-invoke-modules-change</code>(for
							<code>xdmp:invoke</code>), or the
							<code>http://marklogic.com/xdmp/privileges/xdmp-spawn-modules-change</code>(for
							<code>xdmp:spawn</code>) privilege to change either the modules database to another database or to change the root to another path. You must have the
							<code>http://marklogic.com/xdmp/privileges/xdmp-eval-modules-change-file</code>(for
							<code>xdmp:eval</code>),
							<code>http://marklogic.com/xdmp/privileges/xdmp-invoke-modules-change-file</code>(for
							<code>xdmp:invoke</code>), or the
							<code>http://marklogic.com/xdmp/privileges/xdmp-eval-modules-change-file</code>(for
							<code>xdmp:spawn</code>) privilege to change the modules database to the file system or to change a root on the filesystem.</dd>
						<dt>
							<p>&lt;root&gt;</p>
						</dt>
						<dd>The root path for modules. Specifying no
							<code>&lt;root&gt;</code>element in the options node specifies the current root. You need the same privileges to modify the root as you need to change the
							<code>module</code>option.</dd>
						<dt>
							<p>&lt;timestamp&gt;</p>
						</dt>
						<dd>The system timestamp to use for this evaluation. Specifying no
							<code>&lt;timestamp&gt;</code>element in the options node specifies the most recent timestamp. You may only specify a timestamp for a query statement, not for an update statement. The timestamp is a number that is incremented by 1 each time any configuration or content change is made to the system. Specifying a timestamp of 0 uses the current system timestamp (the value returned by
							<code>xdmp:request-timestamp()</code>). Specifying a timestamp requires the
							<code>xdmp:timestamp</code>execute privilege.</dd>
						<dt>
							<p>&lt;ignore-amps&gt;</p>
						</dt>
						<dd>(Only valid with
							<code>xdmp:eval</code>,
							<code>xdmp:invoke</code>,
							<code>xdmp:xslt-eval</code>,
							<code>xdmp:xslt-invoke</code>; does not apply to
							<code>xdmp:spawn</code>,
							<code>dbg:eval</code>or
							<code>dbg:invoke</code>) Either
							<code>true</code>or
							<code>false</code>. When set to
							<code>true</code>, the statement is evaluated without using any Amps from the caller. The default value for the
							<code>ignore-amps</code>option is
							<code>false</code>.</dd>
						<dt>
							<p>&lt;isolation&gt;</p>
						</dt>
						<dd>(Only valid with
							<code>xdmp:eval</code>or
							<code>xdmp:invoke</code>; does not apply to
							<code>xdmp:spawn</code>.) Either
							<code>same-statement</code>or
							<code>different-transaction</code>. When set to
							<code>same-statement</code>, the statement is evaluated in the same transaction as the one from which it is called, and subsequent expressions in the calling statement will not see any updates performed in the eval/invoke/spawn. You can only use
							<code>same-statement</code>isolation with update statements; query statements with
							<code>same-statement</code>isolation will throw an exception. When set to
							<code>different-transaction</code>, the statement is evaluated in a separate transaction from the one in which it is called, making those updates available to subsequent expressions in the calling statement (assuming the calling statement is an update statement; if the calling statement is not an update, then subsequent expressions will see the version of the database at the system timestamp when the calling statement begins its evaluation). When using
							<code>different-transaction</code>in an update statement that calls another update statement, do not update the same document as the calling statement is updating; doing so can cause a deadlock. You cannot evaluate a statement in a different database with the
							<code>isolation</code>option set to
							<code>same-statement</code>. The default value for the
							<code>isolation</code>option is
							<code>different-transaction</code>. For more details, see the "Understanding Transactions in MarkLogic Server" chapter of the
							<a href="http://developer.marklogic.com/pubs">Developer's Guide</a>.</dd>
						<dt>
							<p>&lt;static-check&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to only perform static checks on the module, and not to actually execute it.</dd>
						<dt>
							<p>&lt;prevent-deadlocks&gt;</p>
						</dt>
						<dd>(Only valid with
							<code>xdmp:eval</code>or
							<code>xdmp:invoke</code>; does not apply to
							<code>xdmp:spawn</code>.) Specify
							<code>true</code>for the server to disallow update requests from an update transaction. Only has an effect when the
							<code>isolation</code>option is set to
							<code>different-transaction</code>as there is no possibility of a deadlock if the
							<code>isolation</code>option is set to
							<code>same-statement</code>. When set to
							<code>true</code>in an update request calling another update request, MarkLogic Server throws the
							<code>XDMP-PREVENTDEADLOCKS</code>exception. Setting this option to
							<code>true</code>prevents the possibility of deadlocks occurring when running eval/invoke of an update transaction from another update transaction. The default value for the
							<code>prevent-deadlocks</code>option is
							<code>false</code>.</dd>
						<dt>
							<p>&lt;default-xquery-version&gt;</p>
						</dt>
						<dd>The default XQuery language version to use for the query, if the query does not contain an explicit version declaration. If this option is not provided, the defaults are:
							<ul>
								<li>
									<code>xdmp:eval</code>: The XQuery language version of the module that called eval. This version may vary module-by-module if a query consists of modules written in multiple language versions. It may also vary from run to run if the app-server default is changed.</li>
								<li>
									<code>xdmp:invoke</code>: The default XQuery version for the app server that the invocation occurs on. Note that this may be different than the XQuery version of the module that calls
									<code>xdmp:invoke</code>.</li>
								<li>
									<code>xdmp:spawn</code>: The XQuery version default set on the app server that called
									<code>xdmp:spawn</code>. The Task Server has no default XQuery version, the version to use is passed as a part of the task request.</li>
							</ul>Allowable values for this option are "0.9-ml", "1.0-ml", "1.0" and the special value "app-server". The first three are XQuery language versions. The last indicates that the default XQuery language version set on this app-server should be used. This is useful if code written in an older XQuery version needs to call
							<code>xdmp:eval</code>on strings that may have been passed as parameters, but should be interpreted in the app-server's default language version. A module may discover its own XQuery language version with
							<code>xdmp:xquery-version</code>.</dd>
						<dt>
							<p>&lt;time-limit&gt;</p>
						</dt>
						<dd>Override the default time limit with this time limit, in seconds, for this evaluation. You can set the value up to the maximum-time-limit value for the App Server in which the request is evaluated or to a lower value than the default time limit. This option only applies to
							<code>xdmp:spawn</code>, not to
							<code>xdmp:invoke</code>or
							<code>xdmp:eval</code>.</dd>
						<dt>
							<p>&lt;user-id&gt;</p>
						</dt>
						<dd>Specifies the user ID for the user to run the request being evaluated (the request specified in the
							<code>$xquery</code>parameter). If no
							<code>user-id</code>is specified, then the request is run as the current user. You need to have the
							<code>xdmp:login</code>(
							<code>http://marklogic.com/xdmp/privileges/xdmp-login</code>) privilege to use the
							<code>user-id</code>option. Be aware that this is a very privileged operation, as it allows a user with this privilege to evaluate requests as any other user. For an example, see the
							<a href="#eval-ex4">fourth example</a>below.</dd>
						<dt>
							<p>&lt;default-collation&gt;</p>
						</dt>
						<dd>Specifies the collation to use for this context, unless a collation is explicitly specified in the XQuery prolog or in a function call that allows you to specify a collation.</dd>
						<dt>
							<p>&lt;priority&gt;</p>
						</dt>
						<dd>Specify the priority of the spawned task. Allowable values for this option are "normal" and "higher". This option only applies to
							<code>xdmp:spawn</code>, not to
							<code>xdmp:invoke</code>or
							<code>xdmp:eval</code>.</dd>
						<dt>
							<p>&lt;result&gt;</p>
						</dt>
						<dd>Return a value future for the result of the spawned task. This value future can bound be to a variable without waiting so that work can proceed concurrently with the spawned task. When the calling request uses the value future in any operation, it will automatically wait for the spawned task to complete and it will use the result. This option only applies to
							<code>xdmp:spawn</code>, not to
							<code>xdmp:invoke</code>or
							<code>xdmp:eval</code>.</dd>
						<dt>
							<p>&lt;transaction-mode&gt;</p>
						</dt>
						<dd>Explicitly set the transaction mode for this context. Valid values are
							<code>auto</code>,
							<code>query</code>, and
							<code>update</code>. An
							<code>xdmp:transaction-mode</code>prolog option in the evaluated query will override any transaction mode specified with this option.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>item()*</return>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-eval</code>
			</p>
			<p>You must have the
				<code>http://marklogic.com/xdmp/privileges/xdmp-eval-in</code>privilege to specify the
				<code>&lt;database&gt;</code>option with a database other than the context database.</p>
			<p>You must have the
				<code>http://marklogic.com/xdmp/privileges/xdmp-eval-modules-change</code>(for
				<code>xdmp:eval</code>),
				<code>http://marklogic.com/xdmp/privileges/xdmp-invoke-modules-change</code>(for
				<code>xdmp:invoke</code>), or the
				<code>http://marklogic.com/xdmp/privileges/xdmp-spawn-modules-change</code>(for
				<code>xdmp:spawn</code>) privilege to change either the modules database to another database or to change the root to another path. You must have the
				<code>http://marklogic.com/xdmp/privileges/xdmp-eval-modules-change-file</code>(for
				<code>xdmp:eval</code>),
				<code>http://marklogic.com/xdmp/privileges/xdmp-invoke-modules-change-file</code>(for
				<code>xdmp:invoke</code>), or the
				<code>http://marklogic.com/xdmp/privileges/xdmp-eval-modules-change-file</code>(for
				<code>xdmp:spawn</code>) privilege to change the modules database to the file system or to change a root on the filesystem.</p>
			<p>You must have the
				<code>http://marklogic.com/xdmp/privileges/xdmp-login</code>privilege to use the
				<code>user-login</code>option.</p>
		</privilege>
		<example xml:space="preserve">
  xdmp:eval("1+1")
  =&gt; 2
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
declare namespace my='http://mycompany.com/test';

let $s :=
      "xquery version '1.0-ml';
       declare namespace my='http://mycompany.com/test';
       declare variable $my:x as xs:string external;
       concat('hello ', $my:x)"
return
    (: evaluate the query string $s using the variables
       supplied as the second parameter to xdmp:eval :)
    xdmp:eval($s, (xs:QName("my:x"), "world"))

=&gt; hello world

</example>
    <example xml:space="preserve">
  xdmp:eval("doc('/docs/mydoc.xml')",  (),
	         &lt;options xmlns="xdmp:eval"&gt;
	           &lt;database&gt;{xdmp:database("otherdb")}&lt;/database&gt;
	         &lt;/options&gt;)
  =&gt; The '/docs/mydoc.xml' document from the
     otherdb database.
</example>
    <example xml:space="preserve">
xdmp:eval('xdmp:get-current-user()', (),
 &lt;options xmlns="xdmp:eval"&gt;
  &lt;user-id&gt;{xdmp:user("someuser")}&lt;/user-id&gt;
 &lt;/options&gt;)
(:
  returns "someuser", assuming "someuser" exists in the
  security database and the user running the eval request has the
  xdmp:login privilege.
:)
</example>
	</function>
	<function name="eval-in" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:eval-in">
		<summary>[DEPRECATED: use
			<a href="#xdmp:eval">
				<code>xdmp:eval</code>
			</a>with the database option instead] Returns the result of evaluating a string as an XQuery module in a given database.</summary>
		<params>
			<param name="xquery" type="xs:string" optional="false">The XQuery string to be evaluated. If the XQuery string contains double quotes ("), surround the string with single quotes (').</param>
			<param name="ID" type="xs:unsignedLong" optional="false">The database ID, from
				<code>xdmp:database("db_name")</code>,
				<code>xdmp:security-database()</code>, or
				<code>xdmp:schema-database()</code>.</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="modules" type="xs:unsignedLong?" optional="true">The modules database for processing module imports. The empty sequence specifies the current modules database.</param>
			<param name="root" type="xs:string?" optional="true">The root path for modules. The empty sequence specifies the current root.</param>
		</params>
		<return>item()*</return>
		<example xml:space="preserve">
  xdmp:eval-in("1+1",2348790529)
  =&gt; 2
</example>
    <example xml:space="preserve">
xquery version "0.9-ml"
declare namespace my='http://mycompany.com/test'

let $s :=
      "xquery version '0.9-ml'
       declare namespace my='http://mycompany.com/test'
       define variable $my:x as xs:string external
       concat('hello ', $my:x)"
return
    (: evaluate the query string $s using the variables
       supplied as the second parameter to xdmp:eval :)
    xdmp:eval-in($s,
                 xdmp:database("Documents"),
	        (xs:QName("my:x"),
	        "world"))

=&gt; hello world

</example>
	</function>
	<function name="invoke" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:invoke">
		<summary>Returns the result of evaluating a module at the given path.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path of the module to be executed. The path is resolved against the root of the App Server evaluating the query, the Modules directory, or relative to the calling module. For details on resolving paths, see "Importing XQuery Modules and Resolving Paths" in the
				<em>Application Developer's Guide</em>.</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node must be in the
				<code>xdmp:eval</code>namespace. See the
				<a href="#xdmp:eval">
					<code>xdmp:eval</code>
				</a>section for a list of options.</param>
		</params>
		<return>item()*</return>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-invoke</code>
			</p>
		</privilege>
		<example xml:space="preserve">
  xdmp:invoke("http://example.com/modules/foo.xqy")
  =&gt; 2
</example>
    <example xml:space="preserve">
  This example invokes a module using external variables.

  Assume you have a module in the modules database with a URI
  "http://example.com/application/module.xqy" containing the
  following code:

  xquery version "1.0-ml";
  declare namespace my="my-namespace-uri";
  declare variable $my:var as xs:string external;
  xdmp:log($my:var)

  Then you can call this module using xdmp:invoke as follows:

  xquery version "1.0-ml";
  declare namespace my="my-namespace-uri";
  xdmp:invoke("module.xqy",
        (xs:QName("my:var"), "log this to ErrorLog.txt"),
        &lt;options xmlns="xdmp:eval"&gt;
          &lt;modules&gt;{xdmp:modules-database()}&lt;/modules&gt;
	  &lt;root&gt;http://example.com/application/&lt;/root&gt;
         &lt;/options&gt;)

  =&gt; Invokes an XQuery module from the modules database
     with the URI http://example.com/application/module.xqy.
     The invoked module will then be executed, logging the
     message sent in the external variable to the log file.
</example>
	</function>
	<function name="invoke-in" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:invoke-in">
		<summary>[DEPRECATED: use
			<a href="#xdmp:invoke">
				<code>xdmp:invoke</code>
			</a>with the database option instead] Returns the result of evaluating a module at the given path.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The path of the module to be executed. The path is resolved against the root of the App Server evaluating the query. The path must resolve to a main module (not a library module).</param>
			<param name="ID" type="xs:unsignedLong" optional="false">The database ID, from
				<code>xdmp:database("db_name")</code>,
				<code>xdmp:security-database()</code>, or
				<code>xdmp:schema-database()</code>.</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="modules" type="xs:unsignedLong?" optional="true">The modules database containing the module to invoke. The empty sequence specifies the current modules database.</param>
			<param name="root" type="xs:string?" optional="true">The root path for modules. The empty sequence specifies the current root.</param>
		</params>
		<return>item()*</return>
		<example xml:space="preserve">
  xdmp:invoke-in("http://example.com/modules/foo.xqy",2348790529)
  =&gt; 2
</example>
	</function>
	<function name="security-database" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:security-database">
		<summary>Returns the database ID of the security database associated with the current database.</summary>
		<params>
			<param name="database-id" type="xs:unsignedLong?" optional="true">A database ID. Defaults to the current database.</param>
		</params>
		<return>xs:unsignedLong</return>
		<usage>To run queries against the security database, you can specify the
			<code>xdmp:security-database()</code>function as the second parameter to
			<code>xdmp:eval-in()</code>.</usage>
		<example xml:space="preserve">
  xdmp:security-database()
  =&gt; 8447094497219470018
</example>
	</function>
	<function name="schema-database" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:schema-database">
		<summary>Returns the database ID of the schema database associated with the current database.</summary>
		<params>
			<param name="database-id" type="xs:unsignedLong?" optional="true">A database ID. Defaults to the current database.</param>
		</params>
		<return>xs:unsignedLong</return>
		<usage>To run queries against the schema database, you can specify the
			<code>xdmp:schema-database()</code>function as the second parameter to
			<code>xdmp:eval-in()</code>.</usage>
		<example xml:space="preserve">
  xdmp:schema-database()
  =&gt; 15467547981724877000
</example>
	</function>
	<function name="modules-database" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:modules-database">
		<summary>Returns the database ID of the modules database. Returns 0 if the current App Server uses the file system for its modules.</summary>
		<params />
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:modules-database()
  =&gt; 8447094497219470018
</example>
	</function>
	<function name="triggers-database" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:triggers-database">
		<summary>Returns the database ID of the triggers database associated with the current database.</summary>
		<params>
			<param name="database-id" type="xs:unsignedLong?" optional="true">A database ID. Defaults to the current database.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:triggers-database()
  =&gt; 8447094497219470018
</example>
	</function>
	<function name="quote" type="builtin" lib="xdmp" category="Extension" subcategory="XML" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:quote">
		<summary>Returns the unevaluated serialized representation of the input parameter as a string.</summary>
		<params>
			<param name="arg" type="item()*" optional="false">Input to be quoted.</param>
			<param name="options" type="node()?" optional="true">The options node for this quote operation. The default value is (). The node for the xdmp:quote options must be in the
				<code>xdmp:quote</code>namespace.
				<p>The
					<code>xdmp:quote</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;output-encoding&gt;</p>
						</dt>
						<dd>Specifies the encoding to use for this quote operation. This is only used to escape characters that cannot be represented.</dd>
						<dt>
							<p>&lt;output-sgml-character-entities&gt;</p>
						</dt>
						<dd>Specifies if character entities should be output upon serialization of the XML. Valid values are
							<code>normal</code>,
							<code>none</code>,
							<code>math</code>, and
							<code>pub</code>. By default (that is, if this option is not specified), no SGML entities are serialized on output, unless the App Server is configured to output SGML character entities.</dd>
						<dt>
							<p>&lt;method&gt;</p>
						</dt>
						<dd>Valid values are
							<code>xml</code>,
							<code>html</code>,
							<code>xhtml</code>, and
							<code>text</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;cdata-section-elements&gt;</p>
						</dt>
						<dd>A list of QNames to output as CDATA sections. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;encoding&gt;</p>
						</dt>
						<dd>The encoding. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;use-character-maps&gt;</p>
						</dt>
						<dd>Valid values are
							<code>xdmp:sgml-entities-normal</code>,
							<code>xdmp:sgml-entities-math</code>, and
							<code>xdmp:sgml-entities-pub</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;media-type&gt;</p>
						</dt>
						<dd>A mimetype representing a media type. For example,
							<code>text/plain</code>or
							<code>text/xml</code>(or other valid mimetypes). This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;byte-order-mark&gt;</p>
						</dt>
						<dd>Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;indent&gt;</p>
						</dt>
						<dd>Specifies if typed XML (that is, XML for which there is an in-scope schema) should be pretty-printed (indented). Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;indent-untyped&gt;</p>
						</dt>
						<dd>Specifies if untyped XML (that is, XML for which there is no in-scope schema) should be pretty-printed (indented). Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;include-content-type&gt;</p>
						</dt>
						<dd>Include the content-type declaration when serializing the node. Valid values are
							<code>yes</code>or
							<code>no</code>.</dd>
						<dt>
							<p>&lt;escape-uri-attributes&gt;</p>
						</dt>
						<dd>Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;doctype-public&gt;</p>
						</dt>
						<dd>A public identifier, which is the public identifier to use on the emitted DOCTYPE. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;doctype-system&gt;</p>
						</dt>
						<dd>A system identifier, which is the system identifier to use on the emitted DOCTYPE. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;omit-xml-declaration&gt;</p>
						</dt>
						<dd>Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;standalone&gt;</p>
						</dt>
						<dd>Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;normalization-form&gt;</p>
						</dt>
						<dd>Valid values are
							<code>NFC</code>,
							<code>NFD</code>, and
							<code>NFKD</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;default-attributes&gt;</p>
						</dt>
						<dd>Specifies whether attributes defaulted with a schema should be included in the serialization. Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  let $arg := &lt;a&gt;aaa&lt;/a&gt;
  return ($arg, xdmp:quote($arg))
  =&gt; (&lt;a&gt;aaa&lt;/a&gt;, "&lt;a&gt;aaa&lt;/a&gt;")
</example>
	</function>
	<function name="unquote" type="builtin" lib="xdmp" category="Extension" subcategory="XML" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:unquote">
		<summary>Parses a string as XML, returning one or more document nodes.</summary>
		<params>
			<param name="arg" type="xs:string" optional="false">Input to be unquoted.</param>
			<param name="default-namespace" type="xs:string?" optional="true">Default namespace for nodes in the first parameter.</param>
			<param name="options" type="xs:string*" optional="true">The options for getting this document. The default value is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"repair-full"</dt>
						<dd>Specifies that malformed XML content be repaired. XML content with multiple top-level elements will be parsed as multiple documents. This option has no effect on binary or text documents.</dd>
						<dt>"repair-none"</dt>
						<dd>Specifies that malformed XML content be rejected. XML content will be parsed as a single document, so a maximum of one document node will be returned. This option has no effect on binary or text documents.</dd>
						<dt>"format-text"</dt>
						<dd>Specifies to get the document as a text document, regardless of the URI specified.</dd>
						<dt>"format-binary"</dt>
						<dd>Specifies to get the document as a binary document, regardless of the URI specified.</dd>
						<dt>"format-xml"</dt>
						<dd>Specifies to get the document as an XML document, regardless of the URI specified.</dd>
						<dt>"default-language=
							<em>xx</em>"</dt>
						<dd>If the root element node specified in the first parameter does not already have an
							<code>xml:lang</code>attribute, the language to specify in an
							<code>xml:lang</code>attribute on the root element node. If
							<code>default-language</code>is not specified, then nothing is added to the root element node. Some examples are
							<code>default-language=en</code>and
							<code>default-language=fr</code>.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>document-node()+</return>
		<usage>
			<p>If no format is specified in $options, it is XML.</p>
			<p>If neither "repair-full" nor "repair-none" is present, the default is specified by the XQuery version of the caller. In XQuery version
				<code>1.0</code>and
				<code>1.0-ml</code>the default is "repair-none". In XQuery version
				<code>0.9-ml</code>the default is "repair-full".</p>
			<p>If $arg is the empty string,
				<code>xdmp:unquote</code>returns an empty document node.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:unquote("&lt;foo/&gt;")
  =&gt; &lt;foo/&gt;
  It returns this as a document node.
</example>
    <example xml:space="preserve">
  xdmp:unquote('&lt;foo&gt;hello&lt;/foo&gt;', "",
          ("repair-none", "default-language=en"))
  =&gt; &lt;foo xml:lang="en"&gt;hello&lt;/foo&gt;
  It returns this as a document node and does
  not perform tag repair on the node.
</example>
	</function>
	<function name="log" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:log">
		<summary>Logs a debug message to the log file
			<code>&lt;install_dir&gt;/Logs/ErrorLog.txt</code>.</summary>
		<params>
			<param name="msg" type="item()*" optional="false">Message for logging.</param>
			<param name="level" type="xs:string?" optional="true">One of: emergency, alert, critical, error, warning, notice, info, config, debug, fine, finer, or finest. The default level is "info".</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:log("AAAA")
  =&gt; ()
</example>
	</function>
	<function name="log-level" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:log-level">
		<summary>Retrieves the current server log level.</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:log-level()
  =&gt; finest
</example>
	</function>
	<function name="query-meters" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:query-meters">
		<summary>Returns the current value of the resource meters for this query sequence.</summary>
		<return>element()</return>
		<usage>
			<p>The resource meters returned include:</p>
			<blockquote>
				<dl>
					<dt>elapsed-time</dt>
					<dd>The time elapsed since the start of the processing of this query, in the form of a duration.</dd>
					<dt>requests</dt>
					<dd>The number of requests.</dd>
					<dt>list-cache-hits</dt>
					<dd>The number of successful list cache lookups. The list cache holds search termlists used to accelerate path expressions and text searches.</dd>
					<dt>list-cache-misses</dt>
					<dd>The number of unsuccessful list cache lookups. Each unsuccessful list cache lookup was followed by a disk access to load the search termlist into the cache.</dd>
					<dt>in-memory-list-hits</dt>
					<dd>The number of successful list lookups in in-memory stands.</dd>
					<dt>expanded-tree-cache-hits</dt>
					<dd>The number of successful expanded tree cache lookups. The expanded tree cache cache holds XML document data in the expanded representation used by the XQuery evaluator.</dd>
					<dt>expanded-tree-cache-misses</dt>
					<dd>The number of unsuccessful expanded tree cache lookups. Each unsuccessful expanded tree lookup was followed by a compressed tree cache lookup to load the expanded tree into the cache.</dd>
					<dt>compressed-tree-cache-hits</dt>
					<dd>The number of successful compressed tree cache lookups. The compressed tree cache holds XML document data in the compressed representation stored on disk.</dd>
					<dt>compressed-tree-cache-misses</dt>
					<dd>The number of unsuccessful compressed tree cache lookups. Each unsuccessful compressed tree cache lookup was followed by a disk access to load the compressed tree into the cache.</dd>
					<dt>in-memory-compressed-tree-hits</dt>
					<dd>The number of successful compressed tree lookups in in-memory stands.</dd>
					<dt>value-cache-hits</dt>
					<dd>The number of successful value cache lookups. The value cache is a transient cache that exists only for the duration of one query. It holds typed values, and is used to accelerate the frequent conversion of nodes to typed values.</dd>
					<dt>value-cache-misses</dt>
					<dd>The number of unsuccessful value cache lookups. Each unsuccessful value cache lookup was followed by a conversion of an XML node to a typed value.</dd>
					<dt>regexp-cache-hits</dt>
					<dd>The number of successful regular expression cache lookups. The regular expression cache is a transient cache that exists only for the duration of one query. It holds compiled regular expressions, and is used to accelerate the frequent use of regular expressions during the evaluation of a query.</dd>
					<dt>regexp-cache-misses</dt>
					<dd>The number of unsuccessful regular expression cache lookups. Each unsuccessful regular expression cache lookup was followed by a compilation of a regular expression from source text.</dd>
					<dt>link-cache-hits</dt>
					<dd>The number of successful link cache lookups. The link cache is a transient cache that exists only for the duration of one query. It holds pointers to expanded trees, and is used to accelerate the frequent dereferencing of link nodes.</dd>
					<dt>link-cache-misses</dt>
					<dd>The number of unsuccessful link cache lookups. Each unsuccessful link cache lookup was followed by a search for the link target tree.</dd>
					<dt>filter-hits</dt>
					<dd>The number of successful search filter matches.</dd>
					<dt>filter-misses</dt>
					<dd>The number of unsuccessful search filter matches.</dd>
					<dt>fragments-added</dt>
					<dd>The number of XML fragments added to the database by an update.</dd>
					<dt>fragments-deleted</dt>
					<dd>The number of XML fragments deleted from the database by an update.</dd>
					<dt>fs-program-cache-hits</dt>
					<dd>The number of module cache hits from the entire program made from modules on the file system.</dd>
					<dt>fs-program-cache-misses</dt>
					<dd>The number of module cache misses from the entire program made from modules on the file system.</dd>
					<dt>db-program-cache-hits</dt>
					<dd>The number of module cache hits from the entire program made from modules in a database (may contain library modules from the special Modules directory).</dd>
					<dt>db-program-cache-misses</dt>
					<dd>The number of module cache misses from the entire program made from modules in a database (may contain library modules from the special Modules directory).</dd>
					<dt>env-program-cache-hits</dt>
					<dd>The number of module cache hits from the entire program made from ad hoc XSLT stylesheet nodes.</dd>
					<dt>env-program-cache-misses</dt>
					<dd>The number of module cache misses from the entire program made from ad hoc XSLT stylesheet nodes.</dd>
					<dt>fs-main-module-sequence-cache-hits</dt>
					<dd>The number of main module cache hits from main modules on the file system.</dd>
					<dt>fs-main-module-sequence-cache-misses</dt>
					<dd>The number of main module cache misses from main modules on the file system.</dd>
					<dt>db-main-module-sequence-cache-hits</dt>
					<dd>The number of main module cache hits from main modules in a database.</dd>
					<dt>db-main-module-sequence-cache-misses</dt>
					<dd>The number of main module cache misses from main modules in a database.</dd>
					<dt>fs-library-module-cache-hits</dt>
					<dd>The number of library module cache hits from library modules on the file system.</dd>
					<dt>fs-library-module-cache-misses</dt>
					<dd>The number of library module cache misses from library modules on the file system.</dd>
					<dt>db-library-module-cache-hits</dt>
					<dd>The number of library module cache hits from library modules from the modules database.</dd>
					<dt>db-library-module-cache-misses</dt>
					<dd>The number of library module cache misses from library modules from the modules database.</dd>
				</dl>
			</blockquote>
			<p>Some meters are broken down by fragment root and document URI:</p>
			<blockquote>
				<dl>
					<dt>fragments</dt>
					<dd>A sequence of fragment elements, each containing:
						<dl>
							<dt>root</dt>
							<dd>The fragment root name.</dd>
							<dt>expanded-tree-cache-hits</dt>
							<dd>A count of successful expanded tree cache lookups for this fragment root.</dd>
							<dt>expanded-tree-cache-misses</dt>
							<dd>A count of unsuccessful expanded tree cache lookups for this fragment root.</dd>
						</dl></dd>
					<dt>documents</dt>
					<dd>A sequence of document elements, each containing:
						<dl>
							<dt>uri</dt>
							<dd>The document URI.</dd>
							<dt>expanded-tree-cache-hits</dt>
							<dd>A count of successful expanded tree cache lookups for this document URI.</dd>
							<dt>expanded-tree-cache-misses</dt>
							<dd>A count of unsuccessful expanded tree cache lookups for this document URI.</dd>
						</dl></dd>
				</dl>
			</blockquote>
			<p>There are also meters that measure the query activity per host. There is a
				<code>qm:hosts</code>element with one
				<code>qm:host</code>child per host that participates in the query. Each
				<code>qm:host</code>element contains meters showing the round-trip-time and round-trip-count for communications between the evaluator host and the host referenced in the
				<code>xdmp:query-meters</code>output. The
				<code>qm:hosts</code>element is empty for a single-node cluster.</p>
			<p>Certain operations are run concurrently with the timing operations, and if those operations are not actually used in the query, they might not be included in the timings. This occurs for operations like
				<code>xdmp:estimate</code>,
				<code>xdmp:exists</code>, and lexicon calls (for example,
				<code>cts:element-values</code>). If you want to see the total timings that include calls that are not used, you can form some other expression with the results of the calls. For example, if you have an expression that calls
				<code>xdmp:estimate</code>in a
				<code>let</code>expression, you can add 0 to the output, which causes it to be included in the timings (something like
				<code>xdmp:estimate($query) + 0</code>).</p>
		</usage>
		<example xml:space="preserve">
  xdmp:query-meters();
  =&gt;
  &lt;qm:query-meters
   xsi:schemaLocation="http://marklogic.com/xdmp/query-meters
       query-meters.xsd"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:qm="http://marklogic.com/xdmp/query-meters"&gt;
    &lt;qm:elapsed-time&gt;PT0.22S&lt;/qm:elapsed-time&gt;
    &lt;qm:requests&gt;1&lt;/qm:requests&gt;
    &lt;qm:list-cache-hits&gt;0&lt;/qm:list-cache-hits&gt;
    &lt;qm:list-cache-misses&gt;0&lt;/qm:list-cache-misses&gt;
    &lt;qm:in-memory-list-hits&gt;0&lt;/qm:in-memory-list-hits&gt;
    &lt;qm:expanded-tree-cache-hits&gt;0
       &lt;/qm:expanded-tree-cache-hits&gt;
    &lt;qm:expanded-tree-cache-misses&gt;0
       &lt;/qm:expanded-tree-cache-misses&gt;
    &lt;qm:compressed-tree-cache-hits&gt;0
       &lt;/qm:compressed-tree-cache-hits&gt;
    &lt;qm:compressed-tree-cache-misses&gt;0
       &lt;/qm:compressed-tree-cache-misses&gt;
    &lt;qm:in-memory-compressed-tree-hits&gt;0
       &lt;/qm:in-memory-compressed-tree-hits&gt;
    &lt;qm:value-cache-hits&gt;0&lt;/qm:value-cache-hits&gt;
    &lt;qm:value-cache-misses&gt;0&lt;/qm:value-cache-misses&gt;
    &lt;qm:regexp-cache-hits&gt;0&lt;/qm:regexp-cache-hits&gt;
    &lt;qm:regexp-cache-misses&gt;0&lt;/qm:regexp-cache-misses&gt;
    &lt;qm:link-cache-hits&gt;0&lt;/qm:link-cache-hits&gt;
    &lt;qm:link-cache-misses&gt;0&lt;/qm:link-cache-misses&gt;
    &lt;qm:fragments-added&gt;0&lt;/qm:fragments-added&gt;
    &lt;qm:fragments-deleted&gt;0&lt;/qm:fragments-deleted&gt;
    &lt;qm:fs-program-cache-hits&gt;1&lt;/qm:fs-program-cache-hits&gt;
    &lt;qm:fs-program-cache-misses&gt;0&lt;/qm:fs-program-cache-misses&gt;
    &lt;qm:db-program-cache-hits&gt;0&lt;/qm:db-program-cache-hits&gt;
    &lt;qm:db-program-cache-misses&gt;0&lt;/qm:db-program-cache-misses&gt;
    &lt;qm:env-program-cache-hits&gt;0&lt;/qm:env-program-cache-hits&gt;
    &lt;qm:env-program-cache-misses&gt;0&lt;/qm:env-program-cache-misses&gt;
    &lt;qm:fs-main-module-sequence-cache-hits&gt;0
       &lt;/qm:fs-main-module-sequence-cache-hits&gt;
    &lt;qm:fs-main-module-sequence-cache-misses&gt;0
       &lt;/qm:fs-main-module-sequence-cache-misses&gt;
    &lt;qm:db-main-module-sequence-cache-hits&gt;0
       &lt;/qm:db-main-module-sequence-cache-hits&gt;
    &lt;qm:db-main-module-sequence-cache-misses&gt;0
       &lt;/qm:db-main-module-sequence-cache-misses&gt;
    &lt;qm:fs-library-module-cache-hits&gt;0
       &lt;/qm:fs-library-module-cache-hits&gt;
    &lt;qm:fs-library-module-cache-misses&gt;0
       &lt;/qm:fs-library-module-cache-misses&gt;
    &lt;qm:db-library-module-cache-hits&gt;0
       &lt;/qm:db-library-module-cache-hits&gt;
    &lt;qm:db-library-module-cache-misses&gt;0
       &lt;/qm:db-library-module-cache-misses&gt;
    &lt;qm:fragments/&gt;
    &lt;qm:documents/&gt;
    &lt;qm:hosts/&gt;
  &lt;/qm:query-meters&gt;
</example>
    <example xml:space="preserve">

xquery version "1.0-ml";
declare namespace qm="http://marklogic.com/xdmp/query-meters";

fn:count(collection()),
xdmp:query-meters()/qm:elapsed-time

=&gt; The count of the number of documents in the database followed by
   the elapsed-time element of the xdmp:query-trace XML output:

153
&lt;qm:elapsed-time xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xmlns:qm="http://marklogic.com/xdmp/query-meters"&gt;
	        PT0.04S&lt;/qm:elapsed-time&gt;


</example>
	</function>
	<function name="elapsed-time" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:elapsed-time">
		<summary>Returns the elapsed time since the start of processing of this query. Gives the same information as the
			<code>elapsed-time</code>element of the
			<code>xdmp:query-meters</code>output, but has less overhead than calling
			<code>xdmp:query-meters</code>.</summary>
		<return>xs:dayTimeDuration</return>
		<usage>
			<p>Certain operations are run concurrently with the timing operations, and if those operations are not actually used in the query, they might not be included in the timings. This occurs for operations like
				<code>xdmp:estimate</code>,
				<code>xdmp:exists</code>, and lexicon calls (for example,
				<code>cts:element-values</code>). If you want to see the total timings that include calls that are not used, you can form some other expression with the results of the calls. For example, if you have an expression that calls
				<code>xdmp:estimate</code>in a
				<code>let</code>expression, you can add 0 to the output, which causes it to be included in the timings (something like
				<code>xdmp:estimate($query) + 0</code>).</p>
		</usage>
		<example xml:space="preserve">

xquery version "1.0-ml";

fn:count(collection()),
xdmp:elapsed-time()

=&gt; The count of the number of documents in the database followed by
   the elapsed-time of the query:

   153
   PT0.04S


</example>
	</function>
	<function name="query-trace" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:query-trace">
		<summary>Enables or disables tracing of this query. When query tracing is enabled, "info" level messages are logged detailing the search optimizations performed.</summary>
		<params>
			<param name="enabled" type="xs:boolean" optional="false">Specify true to enable query tracing, false to disenable query tracing.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>Search optimizations are performed in three phases:</p>
			<blockquote>
				<dl>
					<dt>the path analysis phase</dt>
					<dd>In this phase a path expression is analyzed to determine whether it can be executed in whole or in part through an optimized search. Each individual component of the path is analyzed to see if it is searchable. The searchablity of each path component is logged.</dd>
					<dt>the search constraint gathering phase</dt>
					<dd>In this phase, search constraints are gathered from the path expression components. The number of constraints contributed by each path component is logged.</dd>
					<dt>the search execution phase</dt>
					<dd>In this phase, a search is performed using the gathered constraints. The actual number of fragments selected for filtering is logged.</dd>
				</dl>
			</blockquote>
		</usage>
		<example xml:space="preserve">
  xdmp:query-trace(true())
  =&gt; ()
</example>
	</function>
	<function name="node-uri" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:node-uri">
		<summary>Returns the document-uri property of the parameter or its ancestor.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node whose URI is returned.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
  xdmp:node-uri(doc("http://marklogic.com/document"))
   =&gt; "http://marklogic.com/document"
</example>
	</function>
	<function name="node-database" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:node-database">
		<summary>Returns the database id where the parameter is stored. If the specified node does not come from a document in a database, then
			<code>xdmp:node-database</code>returns an empty list.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node whose database is returned.</param>
		</params>
		<return>xs:unsignedLong?</return>
		<example xml:space="preserve">
  xdmp:node-database(doc("http://marklogic.com/document"))
   =&gt; 18384173956586417397
</example>
	</function>
	<function name="product-edition" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:product-edition">
		<summary>Returns the current MarkLogic product edition.</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:product-edition()
   =&gt; "Standard"
</example>
	</function>
	<function name="document-locks" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-locks">
		<summary>Returns the locks for one or more documents or directories. Returns the locks for all documents and directories in the database if no parameter is given.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="true">A document URI.</param>
		</params>
		<return>document-node()*</return>
		<example xml:space="preserve">
xdmp:document-locks("example.xml")
=&gt;
&lt;?xml version="1.0" encoding="ASCII"?&gt;
&lt;lock:lock xmlns:lock="http://marklogic.com/xdmp/lock"&gt;
  &lt;lock:lock-type&gt;write&lt;/lock:lock-type&gt;
  &lt;lock:lock-scope&gt;exclusive&lt;/lock:lock-scope&gt;
  &lt;lock:active-locks&gt;
    &lt;lock:active-lock&gt;
      &lt;lock:depth&gt;0&lt;/lock:depth&gt;
      &lt;lock:owner&gt;
        &lt;DAV:href xmlns:DAV="DAV:"&gt;http://example.com/~user&lt;/DAV:href&gt;
      &lt;/lock:owner&gt;
      &lt;lock:timeout&gt;120&lt;/lock:timeout&gt;
      &lt;lock:lock-token&gt;http://marklogic.com/xdmp/locks/1c267a036b8480c3
      &lt;/lock:lock-token&gt;
      &lt;lock:timestamp&gt;1290136652&lt;/lock:timestamp&gt;
      &lt;sec:user-id xmlns:sec="http://marklogic.com/xdmp/security"&gt;
        893641342095093063&lt;/sec:user-id&gt;
    &lt;/lock:active-lock&gt;
  &lt;/lock:active-locks&gt;
&lt;/lock:lock&gt;
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

(:
   The time is in epoch time, which is seconds from the start
   of 1970, so this code does a little math on the values in
   the lock document to figure out how many seconds are left
   for the lock.  Assumes a lock on /example.xml, for example
   by running the following:

xquery version "1.0-ml";
declare namespace DAV="DAV:";

xdmp:lock-acquire("/example.xml",
           "exclusive",
           "0",
           &lt;DAV:href&gt;http://example.com/~user&lt;/DAV:href&gt;,
           xs:unsignedLong(120))

:)
let $lock := xdmp:document-locks("/example.xml")
let $lock-duration :=
   $lock/lock:lock/lock:active-locks/lock:active-lock/
         lock:timeout/fn:data(.)
let $current-epoch-time :=
 fn:round(
  ( fn:current-dateTime() - xs:dateTime("1970-01-01T00:00:00-00:00") )
  div xs:dayTimeDuration('PT1S') )
let $start-time :=
  $lock/lock:lock/lock:active-locks/lock:active-lock/
        lock:timestamp/fn:data(.)
let $end-time := $start-time + $lock-duration
let $seconds-left := $end-time - $current-epoch-time
return
 ($current-epoch-time, $start-time, $seconds-left)
=&gt;
1290136837
1290136832
115
</example>
	</function>
	<function name="document-properties" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-properties">
		<summary>Returns a sequence of properties documents, one for each of the specified documents that has a corresponding properties document. If no documents are specified, returns a sequence of properties documents for all documents in the database that have a corresponding properties document.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="true">A sequence of document URIs.</param>
		</params>
		<return>document-node()*</return>
		<example xml:space="preserve">
  xdmp:document-properties("/mydoc.xml")
  =&gt;
&lt;prop:properties xmlns:prop="http://marklogic.com/xdmp/property"&gt;
  &lt;cpf:processing-status xmlns:cpf="http://marklogic.com/cpf"&gt;done
    &lt;/cpf:processing-status&gt;
  &lt;cpf:last-updated xmlns:cpf="http://marklogic.com/cpf"&gt;
    2010-05-24T16:28:11.577608-07:00&lt;/cpf:last-updated&gt;
  &lt;cpf:state xmlns:cpf="http://marklogic.com/cpf"&gt;
    http://marklogic.com/states/final&lt;/cpf:state&gt;
  &lt;prop:last-modified&gt;2010-05-24T16:29:58-07:00&lt;/prop:last-modified&gt;
&lt;/prop:properties&gt;


</example>
    <example xml:space="preserve">
  xdmp:document-properties()
    =&gt;
    &lt;prop:properties
          xmlns:prop="http://marklogic.com/xdmp/property"&gt;
    Property Node1
    &lt;/prop:properties&gt;
    &lt;prop:properties
          xmlns:prop="http://marklogic.com/xdmp/property"&gt;
    Property Node2
    &lt;/prop:properties&gt;
    &lt;prop:properties
          xmlns:prop="http://marklogic.com/xdmp/property"&gt;
    Property NodeN
    &lt;/prop:properties&gt;
</example>
	</function>
	<function name="document-get-quality" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-get-quality">
		<summary>Returns the quality of the specified document if the document exists. Otherwise, returns the empty sequence.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document in question.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
  xdmp:document-get-quality("example.xml")
  =&gt; 10
</example>
	</function>
	<function name="document-forest" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-forest">
		<summary>Returns the forest ID of the forest in which a document (or a lock or a property) with the specified URI is stored. Otherwise, returns the empty sequence.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document, lock, or property.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Restricts the ID(s) of the forest(s) in which this function may return.</param>
		</params>
		<return>xs:integer?</return>
		<example xml:space="preserve">
  xdmp:document-forest("example.xml")
  =&gt; 12972338785465832200
</example>
	</function>
	<function name="forest" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest">
		<summary>Returns the the ID of the forest specified as the parameter.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the forest.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:forest("myForest")
  =&gt; 15495681647217162987
</example>
	</function>
	<function name="database" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database">
		<summary>Returns the the ID of the database named in the the parameter. Returns the ID of the current database if no parameter is specified.</summary>
		<params>
			<param name="name" type="xs:string" optional="true">The name of the database. The default value is the name of the current database.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:database("myDB")
  =&gt; 74495681647284736476
</example>
	</function>
	<function name="database-forests" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-forests">
		<summary>Returns a sequence of forest IDs in the specified database.</summary>
		<params>
			<param name="database" type="xs:unsignedLong" optional="false">A database ID.</param>
			<param name="include-replicas" type="xs:boolean?" optional="true">True if replica forest ids should also be included.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:database-forests(xdmp:database("Documents"))
  =&gt; (8456374036761185098, 10615125154705099114)
</example>
	</function>
	<function name="forest-open-replica" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-open-replica">
		<summary>Returns the forest ID for each specified forest or for each forest's replica if the forest is currently experiencing a local disk failover.</summary>
		<params>
			<param name="forestIDs" type="unsignedLong*" optional="false">The IDs of the forests that may have failed over.</param>
		</params>
		<return>unsignedLong*</return>
		<example xml:space="preserve">
xdmp:forest-status(
  xdmp:forest-open-replica(
    xdmp:database-forests(xdmp:database("Documents"))))

=&gt; returns the status for each active and open forest in the Documents
   database, whether the forests are masters or replicas


</example>
	</function>
	<function name="database-name" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-name">
		<summary>Return the name of the database with the given ID.</summary>
		<params>
			<param name="database-id" type="xs:unsignedLong" optional="false">A database ID.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xdmp:database-name(8456374036761185098)
=&gt; "Documents"
</example>
	</function>
	<function name="database-is-replica" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-is-replica">
		<summary>Tests if a database is a replica of a foreign database.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="false">A database ID.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
xdmp:database-is-replica(8456374036761185098)
=&gt; true
</example>
	</function>
	<function name="database-nonblocking-timestamp" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-nonblocking-timestamp">
		<summary>Returns the most recent commit timestamp for which a query on the database will not block waiting for transactions to commit or journal frames to arrive from a foreign master.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="false">A database ID.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
xdmp:database-nonblocking-timestamp(8456374036761185098)
=&gt; 13155925136769870
</example>
	</function>
	<function name="database-global-nonblocking-timestamp" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-global-nonblocking-timestamp">
		<summary>Returns the most recent commit timestamp for which a query on the database including its foreign database will not block waiting for transactions to commit or journal frames to arrive from a foreign master.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="false">A database ID.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
xdmp:database-global-nonblocking-timestamp(8456374036761185098)
=&gt; 13155925136769870
</example>
	</function>
	<function name="server-name" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:server-name">
		<summary>Return the name of the App Server with the given ID.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="false">A App Server ID.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xdmp:server-name(845637403676198)
=&gt; "Docs"
</example>
	</function>
	<function name="forest-name" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-name">
		<summary>Return the name of the forest with the given id.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="false">A forest ID.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xdmp:forest-name(8456374036761185098)
=&gt; "Documents"
</example>
	</function>
	<function name="forest-host" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-host">
		<summary>Return the host of the forest with the given id.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="false">A forest ID.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
xdmp:forest-name(8456374036761185098)
=&gt; 628308917998312873
</example>
	</function>
	<function name="databases" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:databases">
		<summary>Returns a sequence of the IDs of all the databases in the system.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:databases()
   =&gt; (14389140626518478220,
          8456374036761185098,
	  10615125154705099114)
</example>
	</function>
	<function name="forests" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forests">
		<summary>Returns a sequence of the IDs of all the forests in the system.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:forests()
   =&gt; 18263538320779601865
2760886727871312968
1551965607977434000
2714941248661564752
</example>
	</function>
	<function name="forest-databases" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-databases">
		<summary>Returns the database ID corresponding to the database to which the specified forest belongs.</summary>
		<params>
			<param name="forest" type="xs:unsignedLong" optional="false">A forest ID.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:forest-databases(xdmp:forest("Documents"))
  =&gt; 2032458498523149048
</example>
	</function>
	<function name="document-get" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-get">
		<summary>Returns the document in the file specified by $location.</summary>
		<params>
			<param name="location" type="xs:string" optional="false">The location of the input document. If the scheme of the location is HTTP (that is, if the string starts with "http://"), then the document is requested over HTTP. If the scheme is file (that is, if the string starts with "file://"), then the document is requested over file protocol from the local filesystem. Otherwise, the document is fetched from the local filesystem. On the filesystem, the path can be fully qualifed or relative. Relative pathnames are resolved from the directory in which MarkLogic Server is installed.</param>
			<param name="options" type="node()?" optional="true">The options node for getting this document. The default value is (). The node for the xdmp:document-get options must be in the
				<code>xdmp:document-get</code>namespace. This parameter can also include option elements in the
				<a href="#xdmp:http-get">
					<code>xdmp:http</code>
				</a>namespace for the HTTP parameters.
				<p>The
					<code>xdmp:document-get</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;default-namespace&gt;</p>
						</dt>
						<dd>The namespace to use if there is no namespace at the root node of the document. The default value is "".</dd>
						<dt>
							<p>&lt;repair&gt;</p>
						</dt>
						<dd>A value of
							<code>full</code>specifies that malformed XML content be repaired. A value of
							<code>none</code>specifies that malformed XML content is rejected. If no repair option is explicitly specified, the default is implicitly specified by the XQuery version of the caller. In XQuery
							<code>1.0</code>and
							<code>1.0-ml</code>the default is
							<code>none</code>. In XQuery
							<code>0.9-ml</code>the default is
							<code>full</code>. This option has no effect on binary or text documents.</dd>
						<dt>
							<p>&lt;format&gt;</p>
						</dt>
						<dd>A value of
							<code>text</code>specifies to get the document as a text document, regardless of the URI specified. A value of
							<code>binary</code>specifies to get the document as a binary document, regardless of the URI specified. A value of
							<code>xml</code>specifies to get the document as an XML document, regardless of the URI specified.</dd>
						<dt>
							<p>&lt;default-language&gt;</p>
						</dt>
						<dd>The language to specify in an
							<code>xml:lang</code>attribute on the root element node if the root element node does not already have an
							<code>xml:lang</code>attribute. If
							<code>default-language</code>is not specified, then nothing is added to the root element node.</dd>
						<dt>
							<p>&lt;encoding&gt;</p>
						</dt>
						<dd>Specifies the encoding to use when reading the document into MarkLogic Server. Supported values include
							<code>UTF-8</code>,
							<code>ISO-8859-1</code>, as well as many other popular encodings. See the
							<em>Search Developer's Guide</em>for a list of character set encodings by language. All encodings will be translated into UTF-8 from the specified encoding. The string specifed for the
							<code>encoding</code>option will be matched to an encoding name according to the Unicode Charset Alias Matching rules (
							<a href="http://www.unicode.org/reports/tr22/#Charset_Alias_Matching">http://www.unicode.org/reports/tr22/#Charset_Alias_Matching</a>). An automatic encoding detector will be used if the value
							<code>auto</code>is specified. If no encoding can be detected, the encoding defaults to UTF-8. If no encoding option is specified, the encoding defaults to the encoding specified in the http header (if using with one of the http functions, for example,
							<code>xdmp:http-get</code>), otherwise it defaults to UTF-8; any encoding http headers are ignored if there is any value specified for the
							<code>encoding</code>option.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()</return>
		<usage>
			<p>If no format is specified in $options, and the document is from an HTTP server, the format is specified by the document content type from the HTTP response. If no format is specified in $options, and the document is from the filesystem, the format is specified by the document content type from the filename extension. The mimetype extensions and corresponding content types are set in the Admin Interface.</p>
			<p>If no
				<code>repair</code>option is specified, the default is specified by the XQuery version of the caller. In XQuery version
				<code>1.0</code>and
				<code>1.0-ml</code>the default is
				<code>&lt;repair&gt;none&lt;/repair&gt;</code>. In XQuery version
				<code>0.9-ml</code>the default is
				<code>&lt;repair&gt;full&lt;/repair&gt;</code>.</p>
			<p>When the document is from an HTTP server,
				<code>xdmp:document-get</code>will always return the response from the HTTP server, even if it is an error response such as 404 or 500. If you want to be able to examine the response header in your application, use the
				<a href="#xdmp:http-get">
					<code>xdmp:http-get</code>
				</a>instead, which returns both the response header and the response.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/xdmp-document-get</code>
		</privilege>
		<example xml:space="preserve">
  xdmp:document-get("myDocument.xml")
  =&gt; the xml contained in myDocument.xml,
        for example, &lt;myDocument/&gt;
</example>
    <example xml:space="preserve">
  xdmp:document-get("myDocument.html",
       &lt;options xmlns="xdmp:document-get"&gt;
           &lt;repair&gt;full&lt;/repair&gt;
       &lt;/options&gt;)
  =&gt; myDocument.html as an XML document that has gone
     through any needed tag repair
</example>
    <example xml:space="preserve">
  xdmp:document-get("http://myCompany.com/file.xml",
       &lt;options xmlns="xdmp:document-get"
                xmlns:http="xdmp:http"&gt;
           &lt;format&gt;xml&lt;/format&gt;
           &lt;http:authentication&gt;
	      &lt;http:username&gt;user&lt;/http:username&gt;
	      &lt;http:password&gt;pass&lt;/http:password&gt;
	   &lt;/http:authentication&gt;
       &lt;/options&gt;)
  =&gt; gets an XML document named file.xml, sending the
     authentication credentials user/pass to the
     http://myCompany.com server

</example>
	</function>
	<function name="get" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get">
		<summary>[DEPRECATED: use
			<a href="#xdmp:document-get">
				<code>xdmp:document-get</code>
			</a>instead] Returns the document in the XML file specified by $path.
			<p>This function is deprecated and will be removed from a future release. Use
				<a href="#xdmp:document-get">
					<code>xdmp:document-get</code>
				</a>instead.</p></summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path to the input file. The path can be fully qualifed or relative. Relative pathnames are resolved from the directory in which MarkLogic Server is installed.</param>
			<param name="default-namespace" type="xs:string?" optional="true">Default namespace for nodes in the first parameter. If $default-namespace is specified and the root node of the loaded document does not explicitly specify a namespace, $default-namespace will be applied to the root node. The default value for $default-namespace is "".</param>
			<param name="options" type="xs:string*" optional="true">The options for getting this document. The default value is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"repair-full"</dt>
						<dd>Specifies that malformed XML content be repaired. This option has no effect on binary or text documents.</dd>
						<dt>"repair-none"</dt>
						<dd>Specifies that malformed XML content be rejected. This option has no effect on binary or text documents.</dd>
						<dt>"format-text"</dt>
						<dd>Specifies to get the document as a text document, regardless of the URI specified.</dd>
						<dt>"format-binary"</dt>
						<dd>Specifies to get the document as a binary document, regardless of the URI specified.</dd>
						<dt>"format-xml"</dt>
						<dd>Specifies to get the document as an XML document, regardless of the URI specified.</dd>
						<dt>"lang=en"</dt>
						<dd>Specifies that the document is in english.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()</return>
		<usage>
			<p>If no format is specified in $options, it is specified by the document content type specified by the extension of the document URI. The mimetype extensions and corresponding content types are set in the Admin Interface.</p>
			<p>If neither "repair-full" nor "repair-none" is present, the default is specified by the XQuery version of the caller. In XQuery version
				<code>1.0</code>and
				<code>1.0-ml</code>the default is "repair-none". In XQuery version
				<code>0.9-ml</code>the default is "repair-full".</p>
		</usage>
		<example xml:space="preserve">
  xdmp:get("foo.xml")
  =&gt; &lt;foo/&gt;
</example>
    <example xml:space="preserve">
  xdmp:get("foo.html", "", ("repair-full", "format-xml"))
  =&gt; foo.html as an XML document that has gone through any
        needed tag repair
</example>
	</function>
	<function name="directory" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:directory">
		<summary>Returns the documents in a directory.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URI of the directory. Typically, directory URIs end with a forward slash (/).</param>
			<param name="depth" type="xs:string?" optional="true">"1" for immediate children, "infinity" for all. If not supplied, depth is "1".</param>
		</params>
		<return>document-node()*</return>
		<example xml:space="preserve">
  for $d in xdmp:directory("http://example.com/foo/","1")
  return xdmp:node-uri($d)
  =&gt; http://example.com/foo/bar.xml
     http://example.com/foo/baz.xml
</example>
	</function>
	<function name="directory-properties" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:directory-properties">
		<summary>Returns a sequence of properties documents, one for each document in the specified directory that has a corresponding properties document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the directory. Typically, directory URIs end with a forward slash (/).</param>
			<param name="depth" type="xs:string?" optional="true">"1" for immediate children, "infinity" for all children. If not supplied, depth is "1".</param>
		</params>
		<return>document-node()*</return>
		<example xml:space="preserve">
  xdmp:directory-properties("http://example.com/dir/","1")
  =&gt; &lt;prop:properties
            xmlns:prop="http://marklogic.com/xdmp/property"&gt;
         &lt;prop:directory/&gt;
     &lt;/prop:properties&gt;

   The properties document returned has one directory element, indicating
   that there is a single directory that is an immediate child of the
   specified directory.

</example>
	</function>
	<function name="collection-properties" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:collection-properties">
		<summary>Returns a sequence of properties documents, one for each document in the specified collection(s) that has a corresponding properties document.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="true">The URI(s) of the collection(s).</param>
		</params>
		<return>document-node()*</return>
		<example xml:space="preserve">
  xquery version "0.9-ml"
  declare namespace cpf="http://marklogic.com/cpf"

  for $d in xdmp:collection-properties(
                   ("http://example.com/col1/",
                    "http://example.com/col2/"))
  where $d/property::cpf:error
  return xdmp:node-uri($d)

  =&gt; A list of document URIs of documents that have a
        cpf:error property in their corresponding properties
	documents.  For example:

      http://example.com/bar.xml http://example.com/baz.xml
</example>
	</function>
	<function name="directory-locks" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:directory-locks">
		<summary>Returns locks of documents in a directory.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URI of the directory. Typically, directory URIs end with a forward slash (/).</param>
			<param name="depth" type="xs:string?" optional="true">"1" for immediate children, "infinity" for all. If not supplied, depth is "1".</param>
		</params>
		<return>document-node()*</return>
		<example xml:space="preserve">
  for $d in xdmp:directory-locks("http://example.com/foo/","1")
  return xdmp:node-uri($d)
  =&gt; http://example.com/foo/bar.xml
     http://example.com/foo/baz.xml
</example>
	</function>
	<function name="collection-locks" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:collection-locks">
		<summary>Returns locks of documents in a collection.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="true">The input URI.</param>
		</params>
		<return>document-node()*</return>
		<example xml:space="preserve">
  for $d in xdmp:collection-locks(
                     ("http://example.com/col1/",
                      "http://example.com/col2/"))
  return xdmp:node-uri($d)
  =&gt; http://example.com/bar.xml
     http://example.com/baz.xml
</example>
	</function>
	<function name="uri-content-type" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:uri-content-type">
		<summary>Returns the content type of the given URI as matched in the mimetypes configuration. xdmp:content-type continues to work too.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:uri-content-type("example.txt")
  =&gt; text/plain
</example>
    <example xml:space="preserve">
  xdmp:uri-content-type("example.xml")
  =&gt; text/xml
</example>
    <example xml:space="preserve">
  xdmp:uri-content-type("example.doc")
  =&gt; application/msword
</example>
	</function>
	<function name="uri-format" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:uri-format">
		<summary>Returns the format of the given URI as matched in the mimetypes configuration.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:uri-format("example.txt")
  =&gt; text
</example>
    <example xml:space="preserve">
  xdmp:format("example.xml")
  =&gt; xml
</example>
	</function>
	<function name="document-get-properties" type="builtin" lib="xdmp" category="Extension" subcategory="Documents, Directories, Properties, and Locks" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-get-properties">
		<summary>Returns the property values for a document's property.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
			<param name="property" type="xs:QName" optional="false">The property name. This is the QName of the top-level property element in the specified properties document.</param>
		</params>
		<return>element()*</return>
		<example xml:space="preserve">
  xdmp:document-get-properties(
         "http://example.com/foo.xml",
         fn:QName("http://examples.com/","priority"))
   =&gt; &lt;priority xmlns="http://examples.com/"&gt;5&lt;/priority&gt;
</example>
	</function>
	<function name="access" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:access">
		<summary>Returns whether a given action on the specified document URI would succeed.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
			<param name="action" type="xs:string" optional="false">The type of access: "create", "insert", "update", or "execute".</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xdmp:access(
         "http://example.com/foo.xml",
         "create")
   =&gt; true()
</example>
	</function>
	<function name="http-get" type="builtin" lib="xdmp" category="Extension" subcategory="HTTP" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:http-get">
		<summary>Sends the http GET method to the specified URI. Returns the http response as well as whatever information is identified by the specified URI (for example, an html document).</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the requested document.</param>
			<param name="options" type="node()?" optional="true">The options node for this request. The default value is (). The node for the
				<code>xdmp:http-get</code>options must be in the
				<code>xdmp:http</code>namespace. This parameter can also include certain option elements (for example,
				<code>repair</code>,
				<code>encoding</code>,
				<code>default-language</code>) in the
				<code>xdmp:document-load</code>and
				<a href="#xdmp:document-get">
					<code>xdmp:document-get</code>
				</a>namespaces.
				<p>The
					<code>xdmp:http-get</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;headers&gt;</p>
						</dt>
						<dd>A sequence of &lt;name&gt;value&lt;/name&gt; pairs. The names can be anything, but many HTTP servers understand HTTP names such as
							<code>content-type</code>. These are turned into name:value HTTP headers. An error is raised if the child elements of the &lt;headers&gt; option are not of the form &lt;name&gt;value&lt;/name&gt;.</dd>
						<dt>
							<p>&lt;authentication&gt;</p>
						</dt>
						<dd>The credentials and the authentication method to use for this request. This option has child elements for the
							<code>username</code>and
							<code>password</code>. The username is the name of the user to be authenticated on the http server. The password is that user's password. You can optionally specify a
							<code>method</code>attribute on the &lt;authentication&gt; element. If it is specified it must be either 'basic' or 'digest'. If a method is specified and the HTTP server requests a different type of authentication, then an error is raised. If the attribute is not specified, or matches the server's requested method, the authentication proceeds.</dd>
						<dt>
							<p>&lt;timeout&gt;</p>
						</dt>
						<dd>The amount of time, in seconds, to wait until the HTTP connection times out. The default value is the
							<code>http timeout</code>for the group.</dd>
						<dt>
							<p>&lt;ciphers&gt;</p>
						</dt>
						<dd>A standard cipher string. For details on legal ciper strings, see
							<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS</a>.</dd>
						<dt>
							<p>&lt;client-cert&gt;</p>
						</dt>
						<dd>A PEM encoded client certificate for identifying the client to the remote server.</dd>
						<dt>
							<p>&lt;client-key&gt;</p>
						</dt>
						<dd>The private key that corresponds to
							<code>client-cert</code>.</dd>
						<dt>
							<p>&lt;pass-phrase&gt;</p>
						</dt>
						<dd>A pass phrase, if one is needed to decrypt client-key.</dd>
						<dt>
							<p>&lt;method&gt;</p>
						</dt>
						<dd>The authentication method, which can be either "basic" or "digest".</dd>
						<dt>
							<p>&lt;username&gt;</p>
						</dt>
						<dd>A user name, if required for authentication.</dd>
						<dt>
							<p>&lt;password&gt;</p>
						</dt>
						<dd>A password, if required for authentication.</dd>
						<dt>
							<p>&lt;allow-sslv3&gt;</p>
						</dt>
						<dd>A boolean value to specify whether to communicate using the SSL v3 protocol. The default is
							<code>true</code>, which indicates communication using the SSL v3 protocol.</dd>
						<dt>
							<p>&lt;allow-tls&gt;</p>
						</dt>
						<dd>A boolean value to specify whether to communicate using the TLS protocol. The default is
							<code>true</code>, which indicates communication using the TLS protocol.</dd>
						<dt>
							<p>&lt;verify-cert&gt;</p>
						</dt>
						<dd>A boolean value to specify whether the server's certificate should be verified. The default value is
							<code>true</code>. A value of
							<code>false</code>should only be specfied after careful consideration of the security risks since it permits communication with servers whose certificates are expired, revoked, or signed by unknown or untrusted authorities. A value of
							<code>false</code>also removes protection against a man-in-the-middle attack.</dd>
						<dt>
							<p>&lt;ssl-session-cache&gt;</p>
						</dt>
						<dd>A boolean value to specify whether ssl session should be cached and reused. The default value is
							<code>true</code>. A value of
							<code>false</code>should only be specfied if ssl session cache causes problem with a url.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>item()+</return>
		<usage>
			<p>The http functions only operate on URIs that use the http or https schemes; specifying a URI that does not begin with
				<code>http://</code>or
				<code>https://</code>throws an exception.</p>
			<p>If an http function times out, it throws a socket received exception (SVC-SOCRECV).</p>
			<p>An automatic encoding detector will be used if the value
				<code>auto</code>is specified for the
				<code>encoding</code>option (in the
				<code>xdmp:document-get</code>namespace). If no option is specified, the encoding defaults to the encoding specified in the http header. If there is no encoding in the http header, the encoding defaults to UTF-8.</p>
			<p>The first node in the output of
				<code>xdmp:http-get</code>is the response header from the http server.</p>
			<p>The second node in the output of
				<code>xdmp:http-get</code>is the response from the http server. The response is treated as text, XML, or binary, depending on the content-type header sent from the http server. If the node is html, the header should indicate
				<code>text/html</code>, which is returned as a text document by default. The type of document is determined by the mimetypes mappings, and you can change the mappings in the Admin Interface as needed. If you happen to know that the response is XML, even if the header does not specify it as XML, and want to process the response as XML, you can wrap the response in an
				<code>xdmp:unquote</code>call to parse the response as XML. You could also use the
				<code>&lt;format&gt;xml&lt;/format&gt;</code>option (in the
				<code>xdmp:document-get</code>namespace) to tell the API to treat the document as XML. Also, if you know the response is an HTML document, you can wrap the response in an
				<code>xdmp:tidy</code>call, which will treat the text as HTML, clean it up, and return an XHTML XML document.</p>
		</usage>
		<example xml:space="preserve">
xdmp:http-get("http://www.my.com/document.xhtml",
     &lt;options xmlns="xdmp:http"&gt;
       &lt;authentication method="basic"&gt;
         &lt;username&gt;myname&lt;/username&gt;
         &lt;password&gt;mypassword&lt;/password&gt;
       &lt;/authentication&gt;
     &lt;/options&gt;)
=&gt; the response from the server as well as the specified document


</example>
    <example xml:space="preserve">
xdmp:http-get("http://www.my.com/iso8859document.html",
     &lt;options xmlns="xdmp:document-get"&gt;
       &lt;encoding&gt;iso-8859-1&lt;/encoding&gt;
     &lt;/options&gt;)[2]
=&gt; The specified document, transcoded from ISO-8859-1
   to UTF-8 encoding.  This assumes the document is
   encoded in ISO-8859-1. Note that the encoding option
   is in the "xdmp:document-get" namespace.


</example>
    <example xml:space="preserve">
xdmp:unquote(
  xdmp:http-get("http://www.my.com/somexml.xml")[2])
=&gt; The specified xml document, parsed as XML by
   xdmp:unquote.  If the header specifies a
   mimetype that is configured to be treated as
   XML, the xdmp:unquote call is not needed.
   Alternately, you can treat the response as XML
   by specifying XML in the options node as
   follows (note that the format option is in
   the "xdmp:document-get" namespace:

xdmp:http-get("http://www.my.com/somexml.xml",
	&lt;options xmlns="xdmp:http-get"&gt;
	   &lt;format xmlns="xdmp:document-get"&gt;xml&lt;/format&gt;
	&lt;/options&gt;)[2]


</example>
    <example xml:space="preserve">
xdmp:tidy(
  xdmp:http-get("http://www.my.com/somehtml.html")[2])[2]
=&gt; The specified html document, cleaned and transformed
   to xhtml by xdmp:tidy.  The second node of the tidy
   output is the xhtml node (the first node is the status).
   You could then perform XPath on the output to return
   portions of the document. Note that the document (and
   all of its elements) will be in the XHTML namespace, so
   you need to specify the namespace in the XPath steps.
   For example:

xquery version "1.0-ml";
declare namespace xh="http://www.w3.org/1999/xhtml";

xdmp:tidy(
  xdmp:http-get("http://www.my.com/somehtml.html")[2])[2]//xh:title


</example>
	</function>
	<function name="http-head" type="builtin" lib="xdmp" category="Extension" subcategory="HTTP" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:http-head">
		<summary>Sends the http HEAD method to the specified URI. Returns the http response header for the specified URI.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document whose response header is being requested.</param>
			<param name="options" type="node()?" optional="true">The options node for this request. The default value is (). The node for the
				<code>xdmp:http-head</code>options must be in the
				<code>xdmp:http</code>namespace. The options are the same as the other
				<code>xdmp:http-*</code>functions, and the options are documented with the
				<a href="#xdmp:http-get">
					<code>xdmp:http-get</code>
				</a>$options parameter.</param>
		</params>
		<return>item()+</return>
		<usage>
			<p>The http functions only operate on URIs that use the http or https schemes; specifying a URI that does not begin with
				<code>http://</code>or
				<code>https://</code>throws an exception.</p>
			<p>If an http function times out, it throws a socket received exception (SVC-SOCRECV).</p>
		</usage>
		<example xml:space="preserve">
xdmp:http-head("http://www.my.com/document.xhtml",
     &lt;options xmlns="xdmp:http"&gt;
       &lt;authentication method="basic"&gt;
         &lt;username&gt;myname&lt;/username&gt;
         &lt;password&gt;mypassword&lt;/password&gt;
       &lt;/authentication&gt;
     &lt;/options&gt;)
=&gt; the response header from the server


</example>
	</function>
	<function name="http-options" type="builtin" lib="xdmp" category="Extension" subcategory="HTTP" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:http-options">
		<summary>Sends the http OPTIONS method to the specified URI. Returns the http response for the specified URI.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document whose options response is being requested.</param>
			<param name="options" type="node()?" optional="true">The options node for this request. The default value is (). The node for the
				<code>xdmp:http-options</code>options must be in the
				<code>xdmp:http</code>namespace. The options are the same as the other
				<code>xdmp:http-*</code>functions, and the options are documented with the
				<a href="#xdmp:http-get">
					<code>xdmp:http-get</code>
				</a>$options parameter.</param>
		</params>
		<return>item()+</return>
		<usage>
			<p>The http functions only operate on URIs that use the http or https schemes; specifying a URI that does not begin with
				<code>http://</code>or
				<code>https://</code>throws an exception.</p>
			<p>If an http function times out, it throws a socket received exception (SVC-SOCRECV).</p>
		</usage>
		<example xml:space="preserve">
xdmp:http-options("http://localhost:8000/",
     &lt;options xmlns="xdmp:http"&gt;
       &lt;authentication method="digest"&gt;
         &lt;username&gt;myname&lt;/username&gt;
         &lt;password&gt;mypassword&lt;/password&gt;
       &lt;/authentication&gt;
     &lt;/options&gt;)
=&gt; the response from the HTTP server, for example:

&lt;response xmlns="xdmp:http"&gt;
  &lt;code&gt;302&lt;/code&gt;
  &lt;message&gt;Found&lt;/message&gt;
  &lt;headers&gt;
    &lt;location&gt;/use-cases/&lt;/location&gt;
    &lt;server&gt;MarkLogic&lt;/server&gt;
    &lt;content-length&gt;0&lt;/content-length&gt;
    &lt;connection&gt;close&lt;/connection&gt;
  &lt;/headers&gt;
&lt;/response&gt;




</example>
	</function>
	<function name="http-delete" type="builtin" lib="xdmp" category="Extension" subcategory="HTTP" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:http-delete">
		<summary>Sends an http DELETE request to the http server specified in the URI to delete the specified resource. The server should respond if the request is to be completed, but a response is not guaranteed. Also, even if the server does respond, it does not guarantee that the request has been or will be completed.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to delete.</param>
			<param name="options" type="node()?" optional="true">The options node for this request. The default value is (). The node for the
				<code>xdmp:http-delete</code>options must be in the
				<code>xdmp:http</code>namespace. The options are the same as the other
				<code>xdmp:http-*</code>functions, and the options are documented with the
				<a href="#xdmp:http-get">
					<code>xdmp:http-get</code>
				</a>$options parameter.</param>
		</params>
		<return>item()+</return>
		<usage>
			<p>The http functions only operate on URIs that use the http or https schemes; specifying a URI that does not begin with
				<code>http://</code>or
				<code>https://</code>throws an exception.</p>
			<p>If an http function times out, it throws a socket received exception (SVC-SOCRECV).</p>
			<p>Note the the
				<code>xdmp:http-delete</code>function simply sends a DELETE request to the specified web server; what happens with the DELETE request depends on the web server. The request does not delete a document from a MarkLogic Server database. To delete a document from a database, use the
				<a href="apidocs.xqy?fname=UpdateBuiltins#xdmp:document-delete">
					<code>xdmp:document-delete</code>
				</a>function.</p>
		</usage>
		<example xml:space="preserve">
xdmp:http-delete("http://www.my.com/document.xhtml",
     &lt;options xmlns="xdmp:http"&gt;
       &lt;authentication method="basic"&gt;
         &lt;username&gt;myname&lt;/username&gt;
         &lt;password&gt;mypassword&lt;/password&gt;
       &lt;/authentication&gt;
     &lt;/options&gt;)
=&gt; an optional response from the server


</example>
	</function>
	<function name="http-post" type="builtin" lib="xdmp" category="Extension" subcategory="HTTP" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:http-post">
		<summary>Sends the http POST request to the server.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to which the data is to be posted.</param>
			<param name="options" type="node()?" optional="true">The options node for this request. The default value is (). The node for the
				<code>xdmp:http-post</code>options must be in the
				<code>xdmp:http</code>namespace.
				<p>The
					<code>xdmp:http-post</code>options include the following option (in the
					<code>xdmp:http</code>namespace), in addition to the options documented with the
					<a href="#xdmp:http-get">
						<code>xdmp:http-get</code>
					</a>$options parameter:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;data&gt;</p>
						</dt>
						<dd>This node can contain any string. Anything in the
							<code>data</code>node is sent as a string in the PUT or POST body. When POSTing to a web service, the data may need to be a SOAP XML structure or binary content. The optional third argument can be used to specify non-text data.</dd>
						<dt>
							<p>The other options are the same as the other
								<code>xdmp:http-*</code>functions, and the options are documented with the
								<a href="#xdmp:http-get">
									<code>xdmp:http-get</code>
								</a>$options parameter.</p>
						</dt>
					</dl>
				</blockquote></param>
			<param name="data" type="node()?" optional="true">The data for this request. This takes is an alternative to the
				<code>data</code>option for the second parameter, and allows binary content to be specified.</param>
		</params>
		<return>item()+</return>
		<usage>
			<p>The http functions only operate on URIs that use the http or https schemes; specifying a URI that does not begin with
				<code>http://</code>or
				<code>https://</code>throws an exception.</p>
			<p>If an http function times out, it throws a socket received exception (SVC-SOCRECV).</p>
			<p>If you expect the request body from this http function to be processed by another application (via a web service, for example), you should specify a content-type header. If no content-type header is specified, the content type defaults to text/plain.</p>
		</usage>
		<example xml:space="preserve">
xdmp:http-post("http://www.my.com/document.xhtml",
     &lt;options xmlns="xdmp:http"&gt;
       &lt;authentication method="basic"&gt;
         &lt;username&gt;myname&lt;/username&gt;
         &lt;password&gt;mypassword&lt;/password&gt;
       &lt;/authentication&gt;
     &lt;/options&gt;)
=&gt; the response from the server as well as the specified document


</example>
    <example xml:space="preserve">
(: Use xdmp:unquote to encode the XML as a string
   because the &lt;data&gt; options element is a string :)
let $payload := xdmp:quote(
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV='http://schemas.xmlsoap.org/soap/envelope/'
  xmlns:xsd='http://www.w3.org/2001/XMLSchema'
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xmlns:SOAP-ENC='http://schemas.xmlsoap.org/soap/encoding/'
  xmlns:my='urn:MyConnection'&gt;
 &lt;SOAP-ENV:Body&gt;
   &lt;my:LogOn&gt;
     &lt;my:User&gt;user&lt;/my:User&gt;
     &lt;my:Password&gt;pass&lt;/my:Password&gt;
     &lt;my:Ticket&gt;abc123&lt;/my:Ticket&gt;
     &lt;my:newData&gt;1234&lt;/my:newData&gt;
   &lt;/my:LogOn&gt;
 &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
)
return
xdmp:http-post("http://www.my.com/document.xhtml",
     &lt;options xmlns="xdmp:http"&gt;
       &lt;authentication method="basic"&gt;
         &lt;username&gt;myname&lt;/username&gt;
         &lt;password&gt;mypassword&lt;/password&gt;
       &lt;/authentication&gt;
       &lt;data&gt;{$payload}&lt;/data&gt;
       &lt;headers&gt;
         &lt;content-type&gt;text/xml&lt;/content-type&gt;
       &lt;/headers&gt;
     &lt;/options&gt;)
=&gt; the response from the server as well as the specified document


</example>
	</function>
	<function name="http-put" type="builtin" lib="xdmp" category="Extension" subcategory="HTTP" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:http-put">
		<summary>Sends an HTTP PUT request to an HTTP server. The HTTP server should return a response, which will differ depending on the action the HTTP server takes for the PUT.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to which the data is to be put.</param>
			<param name="options" type="node()?" optional="true">The options node for this request. The default value is (). The node for the
				<code>xdmp:http-put</code>options must be in the
				<code>xdmp:http</code>namespace.
				<p>The options include the following option (in the
					<code>xdmp:http</code>namespace), in addition to the options documented with the
					<a href="#xdmp:http-get">
						<code>xdmp:http-get</code>
					</a>$options parameter:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;data&gt;</p>
						</dt>
						<dd>This node can contain any string. Anything in the
							<code>data</code>node is sent as a string in the PUT or POST body. If binary content is to be sent, it can be specified as the optional third argument instead.</dd>
						<dt>
							<p>The other options are the same as the other
								<code>xdmp:http-*</code>functions, and the options are documented with the
								<a href="#xdmp:http-get">
									<code>xdmp:http-get</code>
								</a>$options parameter.</p>
						</dt>
					</dl>
				</blockquote></param>
			<param name="data" type="node()?" optional="true">The data for this request. This takes is an alternative to the
				<code>data</code>option for the second parameter, and allows binary content to be specified.</param>
		</params>
		<return>item()+</return>
		<usage>
			<p>The http functions only operate on URIs that use the http or https schemes; specifying a URI that does not begin with
				<code>http://</code>or
				<code>https://</code>throws an exception.</p>
			<p>If an http function times out, it throws a socket received exception (SVC-SOCRECV).</p>
			<p>If you expect the request body from this http function to be processed by another application (via a web service, for example), you should specify a content-type header. If no content-type header is specified, the content type defaults to text/plain.</p>
		</usage>
		<example xml:space="preserve">
xdmp:http-put("http://www.my.com/document.xhtml",
     &lt;options xmlns="xdmp:http"&gt;
       &lt;authentication method="basic"&gt;
         &lt;username&gt;myname&lt;/username&gt;
         &lt;password&gt;mypassword&lt;/password&gt;
       &lt;/authentication&gt;
     &lt;/options&gt;)
=&gt; the response from the HTTP server as well as the specified document




</example>
	</function>
	<function name="rethrow" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:rethrow">
		<summary>Within the catch section of a try-catch expression, re-throw the currently caught error.</summary>
		<params />
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  try {
    xdmp:document-delete($uri)
  } catch ($ex) {
    (: ignore documents that aren't there :)
    if ($ex/error:code eq 'XDMP-DOCNOTFOUND') then ()
    else xdmp:rethrow()
  }
</example>
	</function>
	<function name="base64-encode" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:base64-encode">
		<summary>Converts plaintext into base64-encoded string.</summary>
		<params>
			<param name="plaintext" type="xs:string" optional="false">Plaintext to be encoded.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:base64-encode("slings and arrows of outrageous fortune")
   =&gt; c2xpbmdzIGFuZCBhcnJvd3Mgb2Ygb3V0cmFnZW91cyBmb3J0dW5l
</example>
	</function>
	<function name="base64-decode" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:base64-decode">
		<summary>Converts base64-encoded string to plaintext.</summary>
		<params>
			<param name="encoded" type="xs:string" optional="false">Encoded text to be decoded.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xdmp:base64-decode(
     "c2xpbmdzIGFuZCBhcnJvd3Mgb2Ygb3V0cmFnZW91cyBmb3J0dW5l")
=&gt; slings and arrows of outrageous fortune
</example>
	</function>
	<function name="subbinary" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:subbinary">
		<summary>Returns a binary node made up of a subset of the given binary node.</summary>
		<params>
			<param name="source" type="binary()" optional="false">A binary node whose subset will be returned</param>
			<param name="starting-location" type="xs:double" optional="false">The new binary node starts at the byte position indicated by starting-location. The first byte is at location 1.</param>
			<param name="length" type="xs:double" optional="true">The length in bytes of the new binary node.</param>
		</params>
		<return>binary()</return>
		<usage>
			<p>Usage is exactly like fn:substring except that it applies to a binary node rather than a string.</p>
		</usage>
		<example xml:space="preserve">
  data(xdmp:subbinary(binary { xs:hexBinary("DEADBEEF") }, 3, 2))
  =&gt; xs:hexBinary("BEEF")
</example>
	</function>
	<function name="external-binary" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:external-binary">
		<summary>Returns an external binary node.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">Filesystem path to the external binary file.</param>
			<param name="starting-location" type="xs:double" optional="true">The new binary node starts at the byte position indicated by
				<code>starting-location</code>. The first byte is at location 1. The default value is 1.</param>
			<param name="length" type="xs:double" optional="true">The length in bytes of the content in the new binary node. Omitting the length has performance implications; see usage notes.</param>
		</params>
		<return>binary()</return>
		<usage>
			<p>If no length is provided, the length is calculated from the starting position and the filesystem length of the external file. If the file does not exist when the length is calculated,
				<code>XDMP-MISSINGFILE</code>is thrown.</p>
			<p>If a length is provided, the length is trusted. That is, no attempt is made to confirm the existence or read the length of the external file. Therefore, including the length in the call (if known) results in the best performance during document creation.</p>
		</usage>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-external-binary</code>
			</p>
		</privilege>
		<example xml:space="preserve">
  xdmp:external-binary("/testdata1/logo.gif", 1, 2456))

  =&gt; A binary node representing the external file at
     /testdata1/logo.gif, beginning at offset 1, with
     a length of 2456 bytes.
</example>
	</function>
	<function name="binary-size" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:binary-size">
		<summary>Returns the size of the data, in bytes, represented by a binary node.</summary>
		<params>
			<param name="source" type="binary()?" optional="true">A binary node whose data size will be returned.</param>
		</params>
		<return>xs:unsignedLong?</return>
		<example xml:space="preserve">
  xdmp:binary-size(fn:doc("example.mpeg")/binary())
  =&gt; the size (in bytes) of "example.mpeg"
</example>
	</function>
	<function name="binary-is-external" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:binary-is-external">
		<summary>Test whether or not a binary node represents an external binary.</summary>
		<params>
			<param name="source" type="binary()" optional="false">The binary mode to be tested.</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>An external binary node is one created using
				<a href="#xdmp:external-binary">
					<code>xdmp:external-binary</code>
				</a>. For more details, see "Working With Binary Documents" in the
				<em>Application Developer's Guide</em>.</p>
		</usage>
		<example xml:space="preserve">
  let $n := xdmp:external-binary("/testdata1/logo.gif", 1, 2456))
  return xdmp:binary-is-external($n)

  =&gt; true
</example>
	</function>
	<function name="binary-is-small" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:binary-is-small">
		<summary>Check whether a binary node is a small binary.</summary>
		<params>
			<param name="source" type="binary()" optional="false">A binary node</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>A small binary is one whose size is below the large size threshold. See
				<a href="Admin Library#admin:database-set-large-size-threshold">
					<code>admin:database-set-large-size-threshold</code>
				</a>. For details, see "Working With Binary Documents" in the
				<em>Application Developer's Guide</em>.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:binary-is-small(doc("/logo.gif")/binary())

  =&gt; true if the binary content is below the large size threshold.
</example>
	</function>
	<function name="binary-is-large" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:binary-is-large">
		<summary>Check whether a binary node is a large binary.</summary>
		<params>
			<param name="source" type="binary()" optional="false">The binary node to test.</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>A large binary is one whose size is above the large size threshold. See
				<a href="Admin Library#admin:database-set-large-size-threshold">
					<code>admin:database-set-large-size-threshold</code>
				</a>. This function returns false for small and external binary nodes. For details, see "Working With Binary Documents" in the
				<em>Application Developer's Guide</em>.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:binary-is-large(doc("/logo.gif")/binary())
  =&gt; false
</example>
	</function>
	<function name="external-binary-path" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:external-binary-path">
		<summary>Return the path to the external file associated with an external binary document.</summary>
		<params>
			<param name="source" type="binary()" optional="false">The external binary node for which to retrieve the external file path.</param>
		</params>
		<return>xs:string?</return>
		<usage>
			<p>If the source binary node does not represent an external binary binary document,
				<code>XDMP-ARG</code>is thrown. That is, the source binary node must have been created by
				<a href="#xdmp:external-binary">
					<code>xdmp:external-binary</code>
				</a>. Use
				<a href="#xdmp:binary-is-external">
					<code>xdmp:binary-is-external</code>
				</a>to test whether or not a node represents an external binary.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:external-binary-path(doc("/movies/external-movie-1.mp4")/binary())

  =&gt; /space/binaries/movies/movie-1.mp4
</example>
	</function>
	<function name="spawn" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:spawn">
		<summary>Place the specified module on the task queue for evaluation.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path, relative to the specified root, of the module to be executed. For more details on resolving paths, see "Importing XQuery Modules and Resolving Paths" in the
				<em>Application Developer's Guide</em>.</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node must be in the
				<code>xdmp:eval</code>namespace. See the
				<a href="#xdmp:eval">
					<code>xdmp:eval</code>
				</a>section for a list of options.</param>
		</params>
		<return>item()*</return>
		<usage>
			<p>The
				<code>xdmp:spawn</code>function places the specified XQuery module in the task queue to be processed. The module will be evaluated when the task server has the available resources to process it. The tasks are processed in the order in which they are added to the queue.</p>
			<p>Once
				<code>xdmp:spawn</code>is called, it cannot be rolled back, even if the transaction from which it is called does not complete. Therefore, use care or preferably avoid calling
				<code>xdmp:spawn</code>from a module that is performing an update transaction. Once a module is spawned, its evaluation is completely asynchronous of the statement in which
				<code>xdmp:spawn</code>was called. Consequently, if you call
				<code>xdmp:spawn</code>from a module that is updating a document, and if the update ends up retrying (for example, if a deadlock is detected), then the entire module is re-evaluated and the
				<code>xdmp:spawn</code>call is therefore called again. This will only happen in update statements, not in query statements. For details on how transactions work in MarkLogic Server, see "Understanding Transactions in MarkLogic Server" in the
				<em>Developer's Guide</em>.</p>
		</usage>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-spawn</code>
			</p>
		</privilege>
		<example xml:space="preserve">
  xdmp:spawn("module.xqy", (),
        &lt;options xmlns="xdmp:eval"&gt;
          &lt;modules&gt;{xdmp:modules-database()}&lt;/modules&gt;
	  &lt;root&gt;http://example.com/application/&lt;/root&gt;
         &lt;/options&gt;)

  =&gt; Puts the module from the modules database with the
     URI http://example.com/application/module.xqy
     in the task server queue.
</example>
	</function>
	<function name="spawn-in" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:spawn-in">
		<summary>[DEPRECATED: use
			<a href="#xdmp:spawn">
				<code>xdmp:spawn</code>
			</a>with the database option instead] Place the specified module on the task queue for evaluation. It will be evaluated in the given database.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path, relative to the specified root, of the module to be executed.</param>
			<param name="ID" type="xs:unsignedLong" optional="false">The database ID, from
				<code>xdmp:database("db_name")</code>,
				<code>xdmp:security-database()</code>, or
				<code>xdmp:schema-database()</code>.</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="modules" type="xs:unsignedLong?" optional="true">The modules database that contains the module to invoke. The empty sequence specifies the current modules database.</param>
			<param name="root" type="xs:string?" optional="true">The root path for modules. The empty sequence specifies the current root.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>The
				<code>xdmp:spawn-in</code>function places the specified XQuery module in the task queue to be processed. The module will be evaluated when the task server has the available resources to process it. The tasks are processed in the order in which they are added to the queue.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:spawn-in("example.xqy",
                324398742983742,
                (),
                xdmp:modules-database(),
                "http://example.com/application/")
  =&gt; ()
  Puts the module from the modules database with the
  URI http://example.com/application/module.xqy
  in the task server queue. The module will be
  executed in the context of the database with
  an ID of 324398742983742.
</example>
	</function>
	<function name="trace" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:trace">
		<summary>Signal a trace event. If trace events are activated and the event is enabled, the trace event is logged.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The trace event name.</param>
			<param name="value" type="item()*" optional="false">The trace event data.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:trace("My Application Event",$my-application-data)
  =&gt; ()
</example>
	</function>
	<function name="set" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set">
		<summary>Set the value of a variable to the specified expression. The
			<code>xdmp:set</code>command allows you to introduce changes to the state (side effects) of a query by changing the value of a variable to something other than what it is bound to.</summary>
		<params>
			<param name="variable" type="item()*" optional="false">A variable to set.</param>
			<param name="expr" type="item()*" optional="false">A value to set the variable.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>When a variable is bound to a sequence in a
			<code>for</code>loop, and when that variable is changed by
			<code>xdmp:set</code>in the
			<code>return</code>clause, the change only affects the value for one iteration of the
			<code>for</code>loop at a time; when the next value is sent to the return clause, it is set to the next value in the sequence specified in the
			<code>for</code>clause. The value changes only after the
			<code>xdmp:set</code>call is made.</usage>
		<example xml:space="preserve">
(: set the value of the variable $x
   to 1234 and then print out $x :)

let $x := 12
return
(xdmp:set($x, 1234), $x)

=&gt; 1234
</example>
    <example xml:space="preserve">
(: set the value of the variable $x
   to 5 and then print out $x for
   each value of $y :)

for $x in (1, 2)
  for $y in ($x, $x)
return
($y, xdmp:set($x, 5), $x)

=&gt; (1, 5, 1, 5, 2, 5, 2, 5)


</example>
    <example xml:space="preserve">
(: note the effect on $z of changing the
   value of $x :)

for $x in (1, 2)
  for $y in (3,4)
    for $z in ($x, $x)
return
($z, xdmp:set($x, 5))

=&gt; (1, 1, 5, 5, 2, 2, 5, 5)


</example>
    <example xml:space="preserve">
(: every time the name of the input node changes,
   output the new name  :)

let $n := ()
for $i in (&lt;x&gt;1&lt;/x&gt;, &lt;x&gt;2&lt;/x&gt;, &lt;y&gt;3&lt;/y&gt;)
return (
   if (name($i) eq $n)
   then ()
   else (xdmp:set($n, name($i)), $n)
  , data($i)
)

=&gt; (x, 1, 2, y, 3)


</example>
	</function>
	<function name="host" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:host">
		<summary>Returns the the ID of the host named in the parameter. Returns the ID of the current host if no parameter is specified.</summary>
		<params>
			<param name="name" type="xs:string" optional="true">The name of the host. The default value is the name of the current host.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:host("foo.example.com")
  =&gt; 15495681647217162987
</example>
	</function>
	<function name="host-name" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:host-name">
		<summary>Returns the the name of the host ID specified as the parameter. Returns the current host if no name is specified.</summary>
		<params>
			<param name="ID" type="xs:unsignedLong" optional="false">A host ID.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:host-name(15495681647217162987)
  =&gt; foo.example.com
</example>
	</function>
	<function name="hosts" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:hosts">
		<summary>Returns a sequence of the IDs of all the hosts in the system.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:hosts()
   =&gt; 18263538320779601865
2760886727871312968
1551965607977434000
2714941248661564752
</example>
	</function>
	<function name="cluster" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:cluster">
		<summary>Returns the the ID of the cluster named in the parameter. Returns the ID of the current cluster if no parameter is specified.</summary>
		<params>
			<param name="name" type="xs:string" optional="true">The name of the cluster. The default value is the name of the current cluster.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:cluster()
  =&gt; 15495681647217162987
</example>
	</function>
	<function name="cluster-name" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:cluster-name">
		<summary>Returns the the name of the cluster with the specified ID. Returns the name of the current cluster if no ID is specified.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="true">The ID of the cluster. The default value is the ID of the current cluster.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:cluster-name()
  =&gt; "San Francisco"
</example>
	</function>
	<function name="foreign-clusters" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:foreign-clusters">
		<summary>Returns the the IDs of the foreign clusters.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:cluster()
  =&gt; 15495681647217162987
</example>
	</function>
	<function name="server" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:server">
		<summary>Returns the the ID(s) of the App Server specified in the parameter. Returns the ID of the current App Server if no parameter is specified.</summary>
		<params>
			<param name="name" type="xs:string" optional="true">The name of the App Server. The default value is the name of the current App Server.</param>
		</params>
		<return>xs:unsignedLong+</return>
		<example xml:space="preserve">
  xdmp:server("foo.example.com")
  =&gt; 15495681647217162987
</example>
	</function>
	<function name="servers" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:servers">
		<summary>Returns a sequence of the IDs of all the App Servers in the system.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:servers()
   =&gt; 18263538320779601865
2760886727871312968
1551965607977434000
2714941248661564752
</example>
	</function>
	<function name="groups" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:groups">
		<summary>Returns a sequence of the IDs of all the groups in the system.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:groups()
   =&gt; 12363538320723601865
2350822345151312968
7891965607973455300
2314941134541564752
</example>
	</function>
	<function name="group" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:group">
		<summary>Returns the the ID of the group specified in the parameter. Returns the ID of the current group if no parameter is specified.</summary>
		<params>
			<param name="name" type="xs:string" optional="true">The name of the group. The default value is the name of the group the current host belongs to.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:group("Default")
  =&gt; 134722342511344334243
</example>
	</function>
	<function name="group-name" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:group-name">
		<summary>Returns the the name of the group with the given ID. Returns the name of the current group if no parameter is specified.</summary>
		<params>
			<param name="name" type="xs:unsignedLong" optional="true">The id of the group. The default value is the id of the group the current host belongs to.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:group-name(134722342511344334243)
  =&gt; "Default"
</example>
	</function>
	<function name="group-hosts" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:group-hosts">
		<summary>Returns the IDs of all hosts belonging to the group with the given ID. If no parameter is specified, it uses the group of the current host.</summary>
		<params>
			<param name="name" type="xs:unsignedLong" optional="true">The ID of the group. The default value is the id of the group the current host belongs to.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:group-hosts(134722342511344334243)
  =&gt; 18263538320779601865
2760886727871312968
</example>
	</function>
	<function name="group-servers" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:group-servers">
		<summary>Returns the the IDs of all App Servers belonging to the group with the given ID. If no parameter is specified, it uses the group of the current host.</summary>
		<params>
			<param name="name" type="xs:unsignedLong" optional="true">The ID of the group. The default value is the ID of the group to which the current host belongs.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:group-servers(xdmp:group("Default"))
   =&gt; 18263538320779601865
       2760886727871312968
       2714941248661564752
</example>
	</function>
	<function name="request" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:request">
		<summary>Returns the unique key of the current request.</summary>
		<params />
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:request()
   =&gt; 18263538320779601865
</example>
	</function>
	<function name="modules-root" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:modules-root">
		<summary>Returns the current root path for modules.</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:modules-root()
   =&gt; Docs
</example>
	</function>
	<function name="diacritic-less" type="builtin" lib="xdmp" category="Extension" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:diacritic-less">
		<summary>Returns the specified string, converting all of the characters with diacritics to characters without diacritics.</summary>
		<params>
			<param name="string" type="xs:string" optional="false">The string to convert.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xdmp:diacritic-less("José")
=&gt; Jose
</example>
	</function>
	<function name="collation-canonical-uri" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:collation-canonical-uri">
		<summary>Returns the canonical URI for the given URI, if it represents a valid collation. A canonical URI is the unique string MarkLogic Server uses to identify a given collation. The canonical URI string places any attributes that occur in the URI in a predefined order, and it removes any attributes that are redundant due to locale defaults.</summary>
		<params>
			<param name="collation-uri" type="xs:string" optional="false">A collation URI.</param>
		</params>
		<return>xs:string</return>
		<usage>If the specified collation URI is not a valid URI, an exception is thrown.</usage>
		<example xml:space="preserve">
xdmp:collation-canonical-uri("http://marklogic.com/collation/en/S3")
=&gt; http://marklogic.com/collation/en
</example>
	</function>
	<function name="value" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:value">
		<summary>Evaluate an expression in the context of the current evaluating statement. This differs from
			<code>xdmp:eval</code>in that
			<code>xdmp:value</code>preserves all of the context from the calling query, so you do not need to re-define namespaces, variables, and so on. Although the expression retains the context from the calling query, it is evaluated in its own transaction with same-statement isolation.</summary>
		<params>
			<param name="expr" type="xs:string" optional="false">The string representing an expression to evaluate.</param>
		</params>
		<return>item()*</return>
		<usage>
			<p>You can only evaluate expressions with
				<code>xdmp:value</code>; no prolog definitions (namespace declarations, function definitions, module imports, and so on) are allowed.</p>
			<p>If the expression references something not in the context of either the calling query or the value expression, then an error is thrown. For example, the following throws an undefined variable exception:</p>
			<pre xml:space="preserve">
<code>xdmp:value("$y")</code>
</pre>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/xdmp-value</code>
		</privilege>
		<example xml:space="preserve">
  let $var := 5
  return
  xdmp:value("$var")
  =&gt; 5

</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

xdmp:document-insert("/test.xml",
 &lt;root&gt;
   &lt;step1&gt;this is step1&lt;/step1&gt;
   &lt;step2&gt;this is step2&lt;/step2&gt;
 &lt;/root&gt;)
;

(:
use xdmp:value to dynamically specify a step
in an XPath expression
:)
for $x in ("step1", "step2")
return
/root/xdmp:value($x)

=&gt;
&lt;step1&gt;this is step1&lt;/step1&gt;
&lt;step2&gt;this is step2&lt;/step2&gt;

</example>
	</function>
	<function name="unpath" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:unpath">
		<summary>Evaluate a string as an XPath and return the corresponding node(s). Any value that is the result of
			<code>xdmp:path</code>is a valid input to
			<code>xdmp:unpath</code>. Any invalid inputs throw an
			<code>XDMP-UNPATH</code>exception. To evaluate non-XPath expressions, use
			<code>xdmp:value</code>.</summary>
		<params>
			<param name="expr" type="xs:string" optional="false">The XPath expression string to evaluate. The XPath expression must be of the form returned by
				<code>xdmp:path</code>.</param>
		</params>
		<return>item()*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/xdmp-value</code>
		</privilege>
		<example xml:space="preserve">
  xdmp:unpath("/bookstore/book/title")
  =&gt; &lt;title&gt;Querying XML&lt;/title&gt;

</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

let $doc := &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
              &lt;body&gt;&lt;p&gt;This is a document&lt;/p&gt;&lt;/body&gt;
            &lt;/html&gt;
let $namespaces:= ("xh", "http://www.w3.org/1999/xhtml")
let $xpath-str := "$doc/xh:body/xh:p"
return xdmp:with-namespaces($namespaces, xdmp:unpath($xpath-str))

=&gt; &lt;p xmlns="http://www.w3.org/1999/xhtml"&gt;This is a document&lt;/p&gt;

</example>
    <example xml:space="preserve">
  xdmp:unpath("/bookstore/book/title[@name eq 'Querying XML']")
  =&gt; throws the XDMP-UNPATH exception, because the specified
     path expression would never be the output of xdmp:path.

</example>
	</function>
	<function name="map" type="builtin" lib="map" category="map" hidden="false" bucket="MarkLogic Built-In Functions" fullname="map:map">
		<summary>Creates a map.</summary>
		<params>
			<param name="map" type="element(map:map)" optional="true">A serialized map element.</param>
		</params>
		<return>map:map</return>
		<example xml:space="preserve">
  map:map()
  =&gt; map:map(&lt;map xmlns="http://marklogic.com/xdmp/map"/&gt;)
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

let $map :=
&lt;map:map xmlns:map="http://marklogic.com/xdmp/map"&gt;
 &lt;map:entry&gt;
   &lt;map:key&gt;2&lt;/map:key&gt;
   &lt;map:value xsi:type="xs:string"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
    world&lt;/map:value&gt;
 &lt;/map:entry&gt;
 &lt;map:entry&gt;
   &lt;map:key&gt;1&lt;/map:key&gt;
   &lt;map:value xsi:type="xs:string"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
    hello&lt;/map:value&gt;
 &lt;/map:entry&gt;
&lt;/map:map&gt;
return
map:get(map:map($map), "2")
=&gt;
world
</example>
	</function>
	<function name="put" type="builtin" lib="map" category="map" hidden="false" bucket="MarkLogic Built-In Functions" fullname="map:put">
		<summary>Put a value into a map at the given key.</summary>
		<params>
			<param name="map" type="map:map" optional="false">A map.</param>
			<param name="key" type="xs:string" optional="false">A key. If the key is not unique, it will overwrite the existing key.</param>
			<param name="value" type="item()*" optional="false">A value. If the value is the empty sequence, it will remove the key from the map.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
let $map := map:map()
let $put := map:put($map, "some-key",
                  &lt;info&gt;45683&lt;/info&gt;)
return
&lt;result&gt;{$map}&lt;/result&gt;

=&gt;
&lt;result&gt;
  &lt;map:map xmlns:map="http://marklogic.com/xdmp/map"&gt;
    &lt;map:entry&gt;
      &lt;map:key&gt;some-key&lt;/map:key&gt;
      &lt;map:value&gt;&lt;info&gt;45683&lt;/info&gt;&lt;/map:value&gt;
    &lt;/map:entry&gt;
  &lt;/map:map&gt;
&lt;/result&gt;
</example>
	</function>
	<function name="get" type="builtin" lib="map" category="map" hidden="false" bucket="MarkLogic Built-In Functions" fullname="map:get">
		<summary>Get a value from a map.</summary>
		<params>
			<param name="map" type="map:map" optional="false">A map.</param>
			<param name="key" type="xs:string" optional="false">A key.</param>
		</params>
		<return>item()*</return>
		<example xml:space="preserve">
  map:get($table, "some-key")
  =&gt; &lt;info&gt;45683&lt;/info&gt;
</example>
	</function>
	<function name="keys" type="builtin" lib="map" category="map" hidden="false" bucket="MarkLogic Built-In Functions" fullname="map:keys">
		<summary>Get the keys used in the map.</summary>
		<params>
			<param name="map" type="map:map" optional="false">A map.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  map:keys($table)
  =&gt; ("some-key", "another key", "and another one")
</example>
	</function>
	<function name="clear" type="builtin" lib="map" category="map" hidden="false" bucket="MarkLogic Built-In Functions" fullname="map:clear">
		<summary>Clear a map.</summary>
		<params>
			<param name="map" type="map:map" optional="false">A map.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  map:clear($table)
  =&gt; ()
</example>
	</function>
	<function name="count" type="builtin" lib="map" category="map" hidden="false" bucket="MarkLogic Built-In Functions" fullname="map:count">
		<summary>Returns the number of entries used in the map.</summary>
		<params>
			<param name="map" type="map:map" optional="false">A map.</param>
		</params>
		<return>xs:unsignedInt</return>
		<example xml:space="preserve">
  map:count($table)
  =&gt; 15
</example>
	</function>
	<function name="delete" type="builtin" lib="map" category="map" hidden="false" bucket="MarkLogic Built-In Functions" fullname="map:delete">
		<summary>Delete a value from a map.</summary>
		<params>
			<param name="map" type="map:map" optional="false">A map.</param>
			<param name="key" type="xs:string" optional="false">A key.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  map:delete($table, "some-key")
  =&gt; ()
</example>
	</function>
	<function name="function" type="builtin" lib="xdmp" category="Extension" subcategory="Function Values" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:function">
		<summary>Returns a function value as an
			<code>xdmp:function</code>type. You can return an
			<code>xdmp:function</code>from an expression or a function. You can execute the function referred to by an
			<code>xdmp:function</code>by passing the
			<code>xdmp:function</code>value to
			<code>xdmp:apply</code>.</summary>
		<params>
			<param name="function" type="xs:QName" optional="false">The function QName, which includes its local name and namespace. If the function is not found in the current query context or in the module specified in the second parameter, then an exception is thrown.</param>
			<param name="module-path" type="xs:string?" optional="true">The optional path to the module where the function specified in the first parameter is defined. If the module-path is not supplied, the function QName must be in-scope in the query context. If the empty sequence is supplied, the function behaves as if the parameter is not supplied (that is, it uses the in-scope query context).</param>
		</params>
		<return>xdmp:function</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

xdmp:function(xs:QName("fn:empty"))
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

declare namespace admin="http://marklogic.com/xdmp/admin";

xdmp:function(xs:QName("admin:get-configuration"),
      "/MarkLogic/admin.xqy")
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

let $function := xdmp:function(xs:QName("fn:concat"))
return
   xdmp:apply($function, "hello", " world")

=&gt; hello world
</example>
	</function>
	<function name="apply" type="builtin" lib="xdmp" category="Extension" subcategory="Function Values" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:apply">
		<summary>Applies an
			<code>xdmp:function</code>with the given parameters.</summary>
		<params>
			<param name="function" type="xdmp:function" optional="false">The xdmp:function value to be applied.</param>
			<param name="params-1-to-N" type="item()*" optional="true">The parameters to pass into the specified function value. Specify one parameter for each parameter that the specified function takes, with the first parameter corresponding to the first parameter in the specified function's signature, the second parameter corresponding to the second, and so on. Omit this parameter if the specified function takes no parameters.</param>
		</params>
		<return>item()*</return>
		<example xml:space="preserve">
  let $function := xdmp:function(xs:QName("fn:empty"))
  return
    xdmp:apply($function, ())

  =&gt; true
</example>
    <example xml:space="preserve">
  let $function := xdmp:function(xs:QName("fn:concat"))
  return
    xdmp:apply($function, "hello", " world")

  =&gt; hello world
</example>
    <example xml:space="preserve">
  let $function := xdmp:function(xs:QName("fn:current-date"))
  return
    xdmp:apply($function)

  =&gt; 2009-02-14-08:00  (or whatever is the current date)
</example>
	</function>
	<function name="function-name" type="builtin" lib="xdmp" category="Extension" subcategory="Function Values" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:function-name">
		<summary>Returns the QName of the function(s) that the xdmp:function refers to.</summary>
		<params>
			<param name="function" type="xdmp:function" optional="false">The xdmp:function value.</param>
		</params>
		<return>xs:QName</return>
		<example xml:space="preserve">
  let $fn := xdmp:function(xs:QName("fn:empty"))
  return
    xdmp:function-name($fn)
  ==&gt; "fn:empty"
</example>
	</function>
	<function name="function-module" type="builtin" lib="xdmp" category="Extension" subcategory="Function Values" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:function-module">
		<summary>Returns the module location (if any) that the xdmp:function value refers to.</summary>
		<params>
			<param name="function" type="xdmp:function" optional="false">The function value.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  let $fn := xdmp:function(xs:QName("admin:get-configuration"),"/MarkLogic/admin.xqy")
  return
    xdmp:function-module($fn)
  ==&gt; "/MarkLogic/admin.xqy"
</example>
	</function>
	<function name="sleep" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:sleep">
		<summary>Delays for a specific amount of time.</summary>
		<params>
			<param name="msec" type="xs:unsignedInt" optional="false">The amount of time to sleep, in milliseconds.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:sleep(1000)
   =&gt; ()
</example>
	</function>
	<function name="with-namespaces" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:with-namespaces">
		<summary>Evaluates the expression in the context of a specific set of namespace bindings.</summary>
		<params>
			<param name="nsbindings" type="xs:string*" optional="false">An alternating sequence of prefixes and URIs. Each prefix is bound to the following URI. If the prefix is the empty string, the following URI becaomes the default namespace of the resulting item(s).</param>
			<param name="expr" type="item()*" optional="false">An expression to evaluate in the context of the given namespace bindings.</param>
		</params>
		<return>item()*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/xdmp-with-namespaces</code>
		</privilege>
		<example xml:space="preserve">

let $version := "1.2" return
xdmp:with-namespaces(("p", fn:concat("http://marklogic.com/p/",$version)),
   &lt;p:bar/&gt;
)

Returns:

   &lt;p:bar xmlns:p="http://marklogic.com/p/1.2"/&gt;

</example>
    <example xml:space="preserve">
xdmp:with-namespaces(
   ('', 'x'),
   &lt;test&gt;
      &lt;test1&gt;hello&lt;/test1&gt;
   &lt;/test&gt;
=&gt;
&lt;test xmlns="x"&gt;
  &lt;test1&gt;hello&lt;/test1&gt;
&lt;/test&gt;


</example>
	</function>
	<function name="element-content-type" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:element-content-type">
		<summary>Returns the schema-defined content-type of an element ("empty", "simple", "element-only", or "mixed").</summary>
		<params>
			<param name="element" type="element()" optional="false">An element node.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:element-content-type(&lt;html xmlns="http://www.w3.org/1999/xhtml"/&gt;)
  =&gt; "element-only"
</example>
	</function>
	<function name="pretty-print" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:pretty-print">
		<summary>Returns a well-formatted XQuery module.</summary>
		<params>
			<param name="xquery" type="xs:string" optional="false">An XQuery module to be reformatted.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:pretty-print("for $x in 1 to 10 return $x")
   =&gt; "for $x in 1 to 10
       return $x"
</example>
	</function>
	<function name="xslt-invoke" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:xslt-invoke">
		<summary>Executes an XSLT stylesheet against a node.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path of the stylesheet to be executed. The path is resolved against the root of the App Server evaluating the query, the Modules directory, or relative to the calling module. For details on resolving paths, see "Importing XQuery Modules and Resolving Paths" in the
				<em>Application Developer's Guide</em>.</param>
			<param name="input" type="node()?" optional="false">The context node to which the stylesheet is applied.</param>
			<param name="params" type="map:map?" optional="true">The stylesheet parameter values for this evaluation. Each key in the map is a string representing the name of the parameter in Clark notation: "{namespaceURI}localname". The function
				<a href="#xdmp:key-from-QName">xdmp:key-from-QName</a>is a convenient way to generate these keys. Each entry in the map is the value of the corresponding parameter.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node must be in the
				<code>xdmp:eval</code>namespace. See the
				<a href="#xdmp:eval">
					<code>xdmp:eval</code>
				</a>section for a list of options. Additional options include:
				<dl>
					<dt>
						<p>&lt;mode&gt;</p>
					</dt>
					<dd>A QName specifying the initial stylesheet mode to use (the
						<code>&lt;xsl:template&gt;</code>with the specified
						<code>mode</code>attribute).</dd>
					<dt>
						<p>&lt;template&gt;</p>
					</dt>
					<dd>A QName specifying the name of the initial template to apply.</dd>
					<dt>
						<p>&lt;encoding&gt;</p>
					</dt>
					<dd>Specifies the encoding to use when reading the stylesheet into MarkLogic Server. Supported values include
						<code>UTF-8</code>,
						<code>ISO-8859-1</code>, as well as many other popular encodings. See the
						<em>Search Developer's Guide</em>for a list of character set encodings by language. All encodings will be translated into UTF-8 from the specified encoding. The string specifed for the
						<code>encoding</code>option will be matched to an encoding name according to the Unicode Charset Alias Matching rules (
						<a href="http://www.unicode.org/reports/tr22/#Charset_Alias_Matching">http://www.unicode.org/reports/tr22/#Charset_Alias_Matching</a>). An automatic encoding detector will be used if the value
						<code>auto</code>is specified. If no encoding can be detected, the encoding defaults to UTF-8.</dd>
				</dl></param>
		</params>
		<return>document-node()*</return>
		<usage>
			<p>When running an XSLT stylesheet in MarkLogic, you pass in a node on which the stylesheet operates. Many stylesheets are written to expect the initial node to be a document node. In other XSLT processors, the node you pass to the stylesheet is typically read in from the filesystem and is always treated as a document node. In MarkLogic, you often get the node to pass to the stylesheet as the result of a query or a search, and the node is not necessarily a document node. Therefore, if your stylesheet expects the context node to be a document node, make sure to pass in a document node and not an element node. If you pass in an element node to a stylesheet that has default template rules to expect a document node, then you might miss the processing on the element you passed in (because the stylesheet might expect the child node to be the root element of the XML document, but if you passed in the root element instead of its parent document node, then the child nodes would be the children of the root element, causing the root element to miss its default processing).</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(:
this example requires a document named hello.xsl directly
at the App Server root with the following content:

&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                  version="2.0"&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:text&gt;hello&lt;/xsl:text&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
:)
xdmp:xslt-invoke("/hello.xsl", document{ &lt;foo/&gt; })
=&gt;
hello
</example>
    <example xml:space="preserve">
xquery version "1.0-ml" ;

(: Hello World example for xslt:invoke, with a parameter.
   Assumes a stylesheet names params.xsl directly at
   the App Server root with the following content:
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:f="foo" xmlns:b="bar"
      version="2.0"&gt;
    &lt;xsl:param name="f:pName"/&gt;
    &lt;xsl:param name="b:bName"/&gt;
    &lt;xsl:param name="cName"/&gt;
    &lt;xsl:param name="greeting" select="'Hi there '"/&gt;
    &lt;xsl:template match="/"&gt;
       &lt;output&gt;
         &lt;xsl:copy-of select="node"/&gt;
         &lt;greeting&gt;&lt;xsl:value-of select="$greeting"/&gt;&lt;/greeting&gt;
         &lt;param&gt;&lt;xsl:value-of select="$f:pName"/&gt;&lt;/param&gt;
         &lt;param&gt;&lt;xsl:value-of select="$b:bName"/&gt;&lt;/param&gt;
         &lt;param&gt;&lt;xsl:value-of select="$cName"/&gt;&lt;/param&gt;
       &lt;/output&gt;
    &lt;/xsl:template&gt;
  &lt;/xsl:stylesheet&gt;
:)

let $params := map:map()
let $_put := map:put(
                    $params,
                    xdmp:key-from-QName(fn:QName("foo", "pName")),
                    "Stephen")
let $_put := map:put(
                    $params,
                    xdmp:key-from-QName(fn:QName("bar", "bName")),
                    "Ron")
let $_put := map:put(
                    $params,
                    "cName",
                    "Dave")
return
xdmp:xslt-invoke("/params.xsl",
    document { &lt;node&gt;Hello World&lt;/node&gt; },
    $params)
=&gt;
&lt;?xml version="1.0" encoding="ASCII"?&gt;
&lt;output xmlns:f="foo" xmlns:b="bar"&gt;
  &lt;node&gt;Hello World&lt;/node&gt;
  &lt;greeting&gt;Hi there &lt;/greeting&gt;
  &lt;param&gt;Stephen&lt;/param&gt;
  &lt;param&gt;Ron&lt;/param&gt;
  &lt;param&gt;Dave&lt;/param&gt;
&lt;/output&gt;


</example>
	</function>
	<function name="xslt-eval" type="builtin" lib="xdmp" category="Extension" subcategory="XQuery Context" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:xslt-eval">
		<summary>Executes an XSLT stylesheet against a node.</summary>
		<params>
			<param name="stylesheet" type="element()" optional="false">The stylesheet to be executed.</param>
			<param name="input" type="node()?" optional="false">The context node to which the stylesheet is applied.</param>
			<param name="params" type="map:map?" optional="true">The stylesheet parameter values for this evaluation. Each key in the map is a string representing the name of the parameter in Clark notation: "{namespaceURI}localname". The function
				<a href="#xdmp:key-from-QName">xdmp:key-from-QName</a>is a convenient way to generate these keys. Each entry in the map is the value of the corresponding parameter.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node must be in the
				<code>xdmp:eval</code>namespace. See the
				<a href="#xdmp:eval">
					<code>xdmp:eval</code>
				</a>section for a list of options. Additional options include:
				<dl>
					<dt>
						<p>&lt;mode&gt;</p>
					</dt>
					<dd>A QName specifying the initial stylesheet mode to use (the
						<code>&lt;xsl:template&gt;</code>with the specified
						<code>mode</code>attribute).</dd>
					<dt>
						<p>&lt;template&gt;</p>
					</dt>
					<dd>A QName specifying the name of the initial template to apply.</dd>
				</dl></param>
		</params>
		<return>document-node()*</return>
		<usage>
			<p>When creating the
				<code>xsl:stylesheet</code>element that is the stylesheet parameter to
				<code>xdmp:xslt-eval</code>, keep in mind that it has to first be parsed by XQuery before it is evaluated as a stylesheet. Therefore, any characters in the stylesheet that require escaping in XQuery must be escaped, otherwise you get an error in the XQuery. For example, if the stylesheet has any curly braces ( { or } ), you must escape the curly braces (with curly braces). For an example, see
				<a href="#xslteval4">the example</a>below.</p>
			<p>When running an XSLT stylesheet in MarkLogic, you pass in a node on which the stylesheet operates. Many stylesheets are written to expect the initial node to be a document node. In other XSLT processors, the node you pass to the stylesheet is typically read in from the filesystem and is always treated as a document node. In MarkLogic, you often get the node to pass to the stylesheet as the result of a query or a search, and the node is not necessarily a document node. Therefore, if your stylesheet expects the context node to be a document node, make sure to pass in a document node and not an element node. If you pass in an element node to a stylesheet that has default template rules to expect a document node, then you might miss the processing on the element you passed in (because the stylesheet might expect the child node to be the root element of the XML document, but if you passed in the root element instead of its parent document node, then the child nodes would be the children of the root element, causing the root element to miss its default processing).</p>
		</usage>
		<example xml:space="preserve">
let $foo-to-bar :=
  &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                  version="2.0"&gt;
    &lt;xsl:template match="foo"&gt;
      &lt;bar&gt;
        &lt;xsl:apply-templates select="node()"/&gt;
      &lt;/bar&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="@*|node()"&gt;
      &lt;xsl:copy&gt;
        &lt;xsl:apply-templates select="@*|node()"/&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;
  &lt;/xsl:stylesheet&gt;
return xdmp:xslt-eval($foo-to-bar,
  &lt;stuff&gt;
   &lt;one/&gt;
   &lt;foo/&gt;
   &lt;two/&gt;
   &lt;foo&gt;&lt;blah&gt;42&lt;/blah&gt;&lt;/foo&gt;
   &lt;bar&gt;22&lt;/bar&gt;
  &lt;/stuff&gt;)/element()
</example>
    <example xml:space="preserve">
xquery version "1.0-ml" ;

(: Hello World example for xslt:eval, with a parameter :)

let $params := map:map()
let $_put := map:put(
                    $params,
                    xdmp:key-from-QName(fn:QName("foo", "pName")),
                    "Stephen")
let $_put := map:put(
                    $params,
                    xdmp:key-from-QName(fn:QName("bar", "bName")),
                    "Ron")
let $_put := map:put(
                    $params,
                    "cName",
                    "Dave")
return
  xdmp:xslt-eval(
    &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:f="foo" xmlns:b="bar"
      version="2.0"&gt;
    &lt;xsl:param name="f:pName"/&gt;
    &lt;xsl:param name="b:bName"/&gt;
    &lt;xsl:param name="cName"/&gt;
    &lt;xsl:param name="greeting" select="'Hi there '"/&gt;
    &lt;xsl:template match="/"&gt;
       &lt;output&gt;
         &lt;xsl:copy-of select="node"/&gt;
         &lt;greeting&gt;&lt;xsl:value-of select="$greeting"/&gt;&lt;/greeting&gt;
         &lt;param&gt;&lt;xsl:value-of select="$f:pName"/&gt;&lt;/param&gt;
         &lt;param&gt;&lt;xsl:value-of select="$b:bName"/&gt;&lt;/param&gt;
         &lt;param&gt;&lt;xsl:value-of select="$cName"/&gt;&lt;/param&gt;
       &lt;/output&gt;
    &lt;/xsl:template&gt;
  &lt;/xsl:stylesheet&gt;,
  document { &lt;node&gt;Hello World&lt;/node&gt; },
  $params)
=&gt;
&lt;?xml version="1.0" encoding="ASCII"?&gt;
&lt;output xmlns:f="foo" xmlns:b="bar"&gt;
  &lt;node&gt;Hello World&lt;/node&gt;
  &lt;greeting&gt;Hi there &lt;/greeting&gt;
  &lt;param&gt;Stephen&lt;/param&gt;
  &lt;param&gt;Ron&lt;/param&gt;
  &lt;param&gt;Dave&lt;/param&gt;
&lt;/output&gt;
</example>
    <example xml:space="preserve">
xquery version "1.0-ml" ;

(: example that passes in a QName for a mode :)
xdmp:xslt-eval(
    &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
     version="2.0"&gt;
    &lt;xsl:template match="/"&gt;
       &lt;output&gt;this has no mode&lt;/output&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="/" mode="my-mode"&gt;
      &lt;debug&gt;this has a mode&lt;/debug&gt;
    &lt;/xsl:template&gt;
  &lt;/xsl:stylesheet&gt;,
  document { &lt;node&gt;Hello World&lt;/node&gt; },
  (),
  &lt;options xmlns="xdmp:eval"&gt;
    &lt;mode&gt;{fn:QName("", "my-mode")}&lt;/mode&gt;
  &lt;/options&gt;)
=&gt;
&lt;?xml version="1.0" encoding="ASCII"?&gt;
&lt;debug&gt;this has a mode&lt;/debug&gt;


</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

(:
  Note the esacped curly braces ( {{ and }} on the name attribute
  of xsl:element), as the stylesheet must first be parsed by XQuery
  before it is evaluated as a stylesheet.  If you do not escape
  the curly braces, the query throws the XQuery exception:
  [1.0-ml] XDMP-CONTEXT: (err:XPDY0002) Expression depends on the context
           where none is defined
  That is because, without the escaped braces, XQuery tries to evaluate
  the expression in the name attribute, but there is no context for it.
:)
xdmp:xslt-eval(
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      version="2.0"&gt;
    &lt;xsl:template match="foo"&gt;
     &lt;xsl:element name="{{name(.)}}"/&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
,
document{ &lt;foo&gt;something goes here&lt;/foo&gt;} )
=&gt;
&lt;?xml version="1.0" encoding="ASCII"?&gt;
&lt;foo/&gt;
</example>
	</function>
	<function name="key-from-QName" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:key-from-QName">
		<summary>Construct a context-independent string from a QName. This string is of the form "{namespaceURI}localname" and is suitable for use as a map key.</summary>
		<params>
			<param name="name" type="xs:QName" optional="false">The QName to compute a key for.</param>
		</params>
		<return>xs:string</return>
		<usage></usage>
		<example xml:space="preserve"></example>
	</function>
	<function name="QName-from-key" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:QName-from-key">
		<summary>Construct a QName from a string of the form "{namespaceURI}localname". This function is useful for constructing Clark notation parameters for the
			<a href="#xdmp:xslt-eval">xdmp:xslt-eval</a>and
			<a href="#xdmp:xslt-invoke">xdmp:xslt-invoke</a>functions.</summary>
		<params>
			<param name="key" type="xs:string" optional="false">The string from which to construct a QName.</param>
		</params>
		<return>xs:QName</return>
		<usage></usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
(: returns the Clark notation form of the QName :)

xdmp:key-from-QName(xs:QName("fn:foo"))
=&gt;
{http://www.w3.org/2005/xpath-functions}foo
</example>
	</function>
	<function name="encoding-language-detect" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:encoding-language-detect">
		<summary>Analyzes binary, text, or XML data and suggests possible pairs of encoding and language, with a confidence score for each pair. Scores of 10 and above are high confidence recommendations. The results are given in order of decreasing score. Accuracy may be poor for short documents.</summary>
		<params>
			<param name="document" type="node()" optional="false">Node to be analyzed for possible encodings and languages. If the node is an XML element or document node, the function takes the string value of the specified node (equivalent of
				<code>fn:string($node)</code>) to detect the encoding and language.</param>
		</params>
		<return>element()*</return>
		<usage>
			<p>If the input is very small (for example, less than two words), then
				<code>xdmp:encoding-language-detect</code>returns the empty sequence.</p>
			<p>For best results, the input should be at least several hundred bytes.</p>
		</usage>
		<example xml:space="preserve">
xdmp:encoding-language-detect(xdmp:document-get("/tmp/unknown.dat"))
=&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;en&lt;/language&gt;
  &lt;score&gt;9.834&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;it&lt;/language&gt;
  &lt;score&gt;8.976&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1250&lt;/encoding&gt;
  &lt;language&gt;sl&lt;/language&gt;
  &lt;score&gt;8.265&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1250&lt;/encoding&gt;
  &lt;language&gt;ro&lt;/language&gt;
  &lt;score&gt;7.975&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;fr&lt;/language&gt;
  &lt;score&gt;7.933&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;da&lt;/language&gt;
  &lt;score&gt;7.656&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;nb&lt;/language&gt;
  &lt;score&gt;7.603&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;nl&lt;/language&gt;
  &lt;score&gt;7.331&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;es&lt;/language&gt;
  &lt;score&gt;7.167&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;ca&lt;/language&gt;
  &lt;score&gt;7.143&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;de&lt;/language&gt;
  &lt;score&gt;6.605&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1250&lt;/encoding&gt;
  &lt;language&gt;sr&lt;/language&gt;
  &lt;score&gt;6.595&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1250&lt;/encoding&gt;
  &lt;language&gt;sk&lt;/language&gt;
  &lt;score&gt;6.455&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1250&lt;/encoding&gt;
  &lt;language&gt;cs&lt;/language&gt;
  &lt;score&gt;6.438&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;nn&lt;/language&gt;
  &lt;score&gt;6.337&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;sv&lt;/language&gt;
  &lt;score&gt;5.827&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;pt&lt;/language&gt;
  &lt;score&gt;5.762&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1250&lt;/encoding&gt;
  &lt;language&gt;hu&lt;/language&gt;
  &lt;score&gt;5.356&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1250&lt;/encoding&gt;
  &lt;language&gt;hr&lt;/language&gt;
  &lt;score&gt;4.941&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1250&lt;/encoding&gt;
  &lt;language&gt;pl&lt;/language&gt;
  &lt;score&gt;4.693&lt;/score&gt;
&lt;/encoding-language&gt;
&lt;encoding-language xmlns="xdmp:encoding-language-detect"&gt;
  &lt;encoding&gt;windows-1252&lt;/encoding&gt;
  &lt;language&gt;fi&lt;/language&gt;
  &lt;score&gt;3.885&lt;/score&gt;
&lt;/encoding-language&gt;
</example>
	</function>
	<function name="binary-decode" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:binary-decode">
		<summary>Converts an encoded byte sequence, passed in as a binary node, from the specified encoding to a unicode string.</summary>
		<params>
			<param name="encoded" type="node()" optional="false">A binary node containing the encoded stream.</param>
			<param name="encoding-name" type="xs:string" optional="false">Specifies the encoding to use when decoding the document. Supported values include
				<code>UTF-8</code>and
				<code>ISO-8859-1</code>. The string specifed for the
				<code>encoding</code>option will be matched to a registered encoding name using the Unicode Charset Alias Matching rules (
				<a href="http://www.unicode.org/reports/tr22/#Charset_Alias_Matching">http://www.unicode.org/reports/tr22/#Charset_Alias_Matching</a>).</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
xdmp:binary-decode(
   fn:doc("binary_doc_encoded_as_ShiftJIS.dat")/node(),
          "sjis")
=&gt; contents of document after decoding, in unicode characters
</example>
	</function>
	<function name="host-forests" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:host-forests">
		<summary>Returns a sequence of forest IDs in the specified host.</summary>
		<params>
			<param name="ID" type="xs:unsignedLong" optional="false">A host ID.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
xdmp:host-forests(xdmp:group-hosts(xdmp:group("Default")))
  =&gt; (8456374036761185098, 10615125154705099114)
</example>
	</function>
	<function name="validate" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:validate">
		<summary>Returns an element containing a summary of validation errors in a node.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node to validate.</param>
			<param name="mode" type="xs:string" optional="true">The validation mode, either "strict", "lax", or "type".</param>
			<param name="typeName" type="xs:QName" optional="true">The name of the type to validate against, if the mode is "type". An error is raised if a typeName is given with a different validation mode, or if no type is given if the mode is "type".</param>
		</params>
		<return>element(xdmp:validation-errors)</return>
		<example xml:space="preserve">
declare namespace t="http://marklogic.com/xdmp/thesaurus";
xdmp:validate(
document {
&lt;t:thesaurus&gt;
  &lt;t:entry&gt;
     &lt;t:term&gt;one&lt;/t:term&gt;
     &lt;t:notes&gt;unexpected stuff&lt;/t:notes&gt;
     &lt;t:part-of-speech&gt;expl&lt;/t:part-of-speech&gt;
     &lt;t:synonym&gt;
        &lt;t:term&gt;unique&lt;/t:term&gt;
     &lt;/t:synonym&gt;
  &lt;/t:entry&gt;
&lt;/t:thesaurus&gt;
} )
=&gt;
&lt;xdmp:validation-errors&gt;
  &lt;error:error xmlns:error="http://marklogic.com/xdmp/error"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
    &lt;error:code&gt;XDMP-VALIDATEUNEXPECTED&lt;/error:code&gt;
    &lt;error:name&gt;err:XQDY0027&lt;/error:name&gt;
    &lt;error:xquery-version&gt;1.0-ml&lt;/error:xquery-version&gt;
    &lt;error:message&gt;Invalid node&lt;/error:message&gt;
    &lt;error:format-string&gt;XDMP-VALIDATEUNEXPECTED:
    (err:XQDY0027) validate full { () } -- Invalid node: Found t:notes but
    expected (t:part-of-speech?,t:qualifiers?,t:scope-notes?,t:synonym*) at
    fn:doc("")/t:thesaurus/t:entry/t:notes using schema
    "thesaurus.xsd"&lt;/error:format-string&gt;
    &lt;error:retryable&gt;false&lt;/error:retryable&gt;
    &lt;error:expr&gt;validate full { () }&lt;/error:expr&gt;
    &lt;error:data&gt;
      &lt;error:datum&gt;t:notes&lt;/error:datum&gt;
      &lt;error:datum&gt;(t:part-of-speech?,t:qualifiers?,t:scope-notes?,t:synonym*)
      &lt;/error:datum&gt;
      &lt;error:datum&gt;fn:doc("")/t:thesaurus/t:entry/t:notes&lt;/error:datum&gt;
      &lt;error:datum&gt;"thesaurus.xsd"&lt;/error:datum&gt;
    &lt;/error:data&gt;
    &lt;error:stack&gt;
      &lt;error:frame&gt;
	&lt;error:line&gt;2&lt;/error:line&gt;
	&lt;error:column&gt;0&lt;/error:column&gt;
	&lt;error:xquery-version&gt;1.0-ml&lt;/error:xquery-version&gt;
      &lt;/error:frame&gt;
    &lt;/error:stack&gt;
  &lt;/error:error&gt;&lt;error:error xmlns:error="http://marklogic.com/xdmp/error"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
    &lt;error:code&gt;XDMP-VALIDATEBADTYPE&lt;/error:code&gt;
    &lt;error:name&gt;err:XQDY0027&lt;/error:name&gt;
    &lt;error:xquery-version&gt;1.0-ml&lt;/error:xquery-version&gt;
    &lt;error:message&gt;Invalid node type&lt;/error:message&gt;
    &lt;error:format-string&gt;XDMP-VALIDATEBADTYPE: (err:XQDY0027) validate
    full { () } -- Invalid node type: t:part-of-speech lexical value "expl"
    invalid for expected type #t:part-of-speech at
    fn:doc("")/t:thesaurus/t:entry/t:part-of-speech using schema
    "thesaurus.xsd"&lt;/error:format-string&gt;
    &lt;error:retryable&gt;false&lt;/error:retryable&gt;
    &lt;error:expr&gt;validate full { () }&lt;/error:expr&gt;
    &lt;error:data&gt;
      &lt;error:datum&gt;t:part-of-speech&lt;/error:datum&gt;
      &lt;error:datum&gt;"expl"&lt;/error:datum&gt;
      &lt;error:datum&gt;#t:part-of-speech&lt;/error:datum&gt;
      &lt;error:datum&gt;fn:doc("")/t:thesaurus/t:entry/t:part-of-speech&lt;/error:datum&gt;
      &lt;error:datum&gt;"thesaurus.xsd"&lt;/error:datum&gt;
    &lt;/error:data&gt;
    &lt;error:stack&gt;
      &lt;error:frame&gt;
	&lt;error:line&gt;2&lt;/error:line&gt;
	&lt;error:column&gt;0&lt;/error:column&gt;
	&lt;error:xquery-version&gt;1.0-ml&lt;/error:xquery-version&gt;
      &lt;/error:frame&gt;
    &lt;/error:stack&gt;
  &lt;/error:error&gt;
&lt;/xdmp:validation-errors&gt;
</example>
	</function>
	<function name="timestamp-to-wallclock" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:timestamp-to-wallclock">
		<summary>Converts a 64 bit timestamp value to an xs:dateTime.</summary>
		<params>
			<param name="timestamp" type="xs:unsignedLong" optional="false">The timestamp.</param>
		</params>
		<return>xs:dateTime</return>
		<example xml:space="preserve">
  xdmp:timestamp-to-wallclock(9476208600000000)
  =&gt; 2000-01-11T12:01:00

</example>
	</function>
	<function name="wallclock-to-timestamp" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:wallclock-to-timestamp">
		<summary>Converts an xs:dateTime to a 64 bit timestamp value.</summary>
		<params>
			<param name="timestamp" type="xs:unsignedLong" optional="false">The xs:datetime value.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:wallclock-to-timestamp(xs:dateTime("2000-01-11T12:01:00"))
  =&gt; 9476208600000000

</example>
	</function>
	<function name="configuration-timestamp" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:configuration-timestamp">
		<summary>Returns timestamp of last configuration changed</summary>
		<params>
			<param name="name" type="xs:string" optional="true">The name of configuration file. The default value is empty string.</param>
		</params>
		<return>xs:unsignedLong?</return>
		<example xml:space="preserve">
  xdmp:configuration-timestamp("databases.xml")
  =&gt; 15495681647217162987
</example>
	</function>
	<function name="acos" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:acos">
		<summary>Returns the arc cosine of x, in radians, in the range from 0 to pi (inclusive).</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The fraction to be evaluated. Must be in the range of -1 to +1 (inclusive).</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:acos(.5)

  =&gt; 1.0471975511966
</example>
	</function>
	<function name="asin" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:asin">
		<summary>Returns the arc sine of x, in radians, in the range from -pi/2 to +pi/2 (inclusive).</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The fraction to be evaluated. Must be in the range of -1 to +1 (inclusive).</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:asin(.5)

  =&gt; 0.523598775598299
</example>
	</function>
	<function name="atan" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:atan">
		<summary>Returns the arc tangent of x, in radians. in the range from -pi/2 to +pi/2 (inclusive).</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:atan(3.14159)

  =&gt; 1.26262701154934
</example>
	</function>
	<function name="atan2" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:atan2">
		<summary>Returns the arc tangent of y/x, in radians, in the range from -pi/2 to +pi/2 (inclusive), using the signs of y and x to determine the apropriate quadrant.</summary>
		<params>
			<param name="y" type="xs:double" optional="false">The floating point dividend.</param>
			<param name="x" type="xs:double" optional="false">The floating point divisor.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:atan2(36.23, 5.234)

  =&gt; 1.42732303452594

</example>
	</function>
	<function name="cos" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:cos">
		<summary>Returns the cosine of x, in the range from -1 to +1 (inclusive).</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:cos(11)

  =&gt; 0.00442569798805079
</example>
	</function>
	<function name="cosh" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:cosh">
		<summary>Returns the hyperbolic cosine of x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:cosh(11)

  =&gt; 29937.0708659498

</example>
	</function>
	<function name="sin" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:sin">
		<summary>Returns the sine of x, in the range from -1 to +1 (inclusive).</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:sin(1.95)

  =&gt; 0.928959715003869
</example>
	</function>
	<function name="sinh" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:sinh">
		<summary>Returns the hyperbolic sine of x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:sinh(1.95)

  =&gt; 3.44320675450139
</example>
	</function>
	<function name="tan" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:tan">
		<summary>Returns the tangent of x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:tan(19.5)

  =&gt; 0.760905351982977
</example>
	</function>
	<function name="tanh" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:tanh">
		<summary>Returns the hyperbolic tangent of x, in the range from -1 to +1 (inclusive).</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:tanh(.95)

  =&gt; 0.739783051274004
</example>
	</function>
	<function name="exp" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:exp">
		<summary>Returns e (approximately 2.71828182845905) to the xth power.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The exponent to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:exp(.01)

  =&gt; 1.01005016708417
</example>
	</function>
	<function name="frexp" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:frexp">
		<summary>Returns x broken up into mantissa and exponent, where x = mantissa*2^exponent.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The exponent to be evaluated.</param>
		</params>
		<return>(xs:double,xs:integer)</return>
		<example xml:space="preserve">
  math:frexp(10)

  =&gt; 0.625
     4
</example>
	</function>
	<function name="ldexp" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:ldexp">
		<summary>Returns x*2^i.</summary>
		<params>
			<param name="y" type="xs:double" optional="false">The floating-point number to be multiplied.</param>
			<param name="i" type="xs:integer" optional="false">The exponent integer.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:ldexp(1.333, 10)

  =&gt; 1364.992
</example>
	</function>
	<function name="log" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:log">
		<summary>Returns the base-e logarithm of x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:log(1000))

  =&gt; 6.90775527898214
</example>
	</function>
	<function name="log10" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:log10">
		<summary>Returns the base-10 logarithm of x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:log10(1000))

  =&gt; 3
</example>
	</function>
	<function name="modf" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:modf">
		<summary>Returns x broken up into fraction and integer. x = fraction+integer.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>(xs:double,xs:double)</return>
		<example xml:space="preserve">
  math:modf(1.333)

  =&gt; 0.333
     1
</example>
	</function>
	<function name="pow" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:pow">
		<summary>Returns x^y.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating-point base number.</param>
			<param name="y" type="xs:double" optional="false">The exponent to be applied to x.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:pow(2, 10)

  =&gt; 1024
</example>
	</function>
	<function name="sqrt" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:sqrt">
		<summary>Returns the square root of x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:sqrt(4)

  =&gt; 2
</example>
	</function>
	<function name="ceil" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:ceil">
		<summary>Returns the smallest integer greater than or equal to x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:ceil(36.00001)

  =&gt; 37
</example>
	</function>
	<function name="fabs" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:fabs">
		<summary>Returns the absolute value of x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:fabs(4.013)

  =&gt; 4.013
</example>
	</function>
	<function name="floor" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:floor">
		<summary>Returns the largest integer less than or equal to x.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point number to be evaluated.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:floor(4.013)

  =&gt; 4
</example>
	</function>
	<function name="fmod" type="builtin" lib="math" category="MathBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="math:fmod">
		<summary>Returns the remainder of x/y.</summary>
		<params>
			<param name="x" type="xs:double" optional="false">The floating point dividend.</param>
			<param name="x" type="xs:double" optional="false">The floating point divisor.</param>
		</params>
		<return>xs:double</return>
		<example xml:space="preserve">
  math:fmod(10, 3)

  =&gt; 1
</example>
	</function>
	<function name="point" type="mcgm" lib="mcgm" subcategory="MCGM" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="mcgm:point">
		<summary>Create a cts:point value from a MCGM Dot element.</summary>
		<params>
			<param name="point" type="element(Dot)" optional="false">A Dot element.</param>
		</params>
		<return>cts:point</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace mcgm = "http://marklogic.com/geospatial/mcgm"
         at "/MarkLogic/geospatial/mcgm.xqy";

  mcgm:point(&lt;Dot Latitude="12.5" Longitude="-127.24"/&gt;)

</example>
	</function>
	<function name="circle" type="mcgm" lib="mcgm" subcategory="MCGM" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="mcgm:circle">
		<summary>Create a cts:circle value from a radius and MCGM Dot element.</summary>
		<params>
			<param name="radius" type="xs:double" optional="false">The radius of the circle, in miles.</param>
			<param name="center" type="element(Dot)" optional="false">A Point element representing the center of the circle.</param>
		</params>
		<return>cts:circle</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace mcgm = "http://marklogic.com/geospatial/mcgm"
         at "/MarkLogic/geospatial/mcgm.xqy";

  mcgm:circle(47, &lt;Dot Latitude="12.5" Longitude="-127.24"/&gt;)

</example>
	</function>
	<function name="polygon" type="mcgm" lib="mcgm" subcategory="MCGM" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="mcgm:polygon">
		<summary>Construct a cts:polygon value from a sequence of MCGM Dot elements.</summary>
		<params>
			<param name="vertices" type="element(Dot)*" optional="false">A sequence of Dot elements representing the vertices of the polygon.</param>
		</params>
		<return>cts:polygon</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace mcgm = "http://marklogic.com/geospatial/mcgm"
         at "/MarkLogic/geospatial/mcgm.xqy";

  mcgm:polygon(( &lt;Dot Latitude="12.5" Longitude="-127.24"/&gt;,
                 &lt;Dot Latitude="15.25" Longitude="-127.8"/&gt;,
                 &lt;Dot Latitude="13.45" Longitude="-126.1"/&gt;,
                 &lt;Dot Latitude="12.5" Longitude="-127.24"/&gt;
              ))

</example>
	</function>
	<function name="geospatial-query" type="mcgm" lib="mcgm" subcategory="MCGM" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="mcgm:geospatial-query">
		<summary>Returns a cts:query matching points within given regions.</summary>
		<params>
			<param name="regions" type="cts:region*" optional="false">One or more geographic boxes, circles, polygons, or points. Where multiple boxes, circles, polygons, or points are specified, the query matches if any box, circle, polygon, or point matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: create a document with test data :)
xdmp:document-insert("/points.xml",
&lt;root xmlns:mcgm="http://marklogic.com/geospatial/mcgm"&gt;
  &lt;item&gt;&lt;Dot Latitude="10.5" Longitude="30.0"/&gt;&lt;/item&gt;
  &lt;item&gt;&lt;Dot Latitude="15.35" Longitude="35.34"/&gt;&lt;/item&gt;
  &lt;item&gt;&lt;Dot Latitude="5.11" Longitude="40.55"/&gt;&lt;/item&gt;
&lt;/root&gt; );

xquery version "1.0-ml";
import module namespace mcgm = "http://marklogic.com/geospatial/mcgm"
   at "/MarkLogic/geospatial/mcgm.xqy";

cts:search(doc("/points.xml")//item,
  mcgm:geospatial-query(
    cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;Dot Latitude="15.35" Longitude="35.34"/&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  mcgm:geospatial-query(cts:box(10.0, 40.0, 20.0, 35.0)))
(:
  returns the following nodes (wrapping around the Earth):
  &lt;item&gt;&lt;Dot Latitude="10.5" Longitude="30.0"/&gt;&lt;/item&gt;
:)
,

cts:search(doc("/points.xml")//item,
  mcgm:geospatial-query(
    cts:box(10.0, 35.0, 20.0, 40.0)))
(:
  returns the following node:
  &lt;item&gt;&lt;Dot Latitude="15.35" Longitude="35.34"/&gt;&lt;/item&gt;
:)


</example>
	</function>
	<function name="geospatial-query-from-elements" type="mcgm" lib="mcgm" subcategory="MCGM" bucket="XQuery Library Modules" category="Geospatial Supporting Functions" hidden="false" fullname="mcgm:geospatial-query-from-elements">
		<summary>Returns a cts:query matching points within given regions.</summary>
		<params>
			<param name="regions" type="element(Dot)*" optional="false">One or more geographic regions, represented by MCGM elements. Where multiple regions are specified, the query matches if any region matches.</param>
			<param name="options" type="xs:string*" optional="true">Options to this query. The default is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"coordinate-system=wgs84"</dt>
						<dd>Use the WGS84 coordinate system.</dd>
						<!--
        <dt>"unit=miles"</dt>
        <dd>Distance (for circles) is measured in miles.</dd>
        -->
						<dt>"boundaries-included"</dt>
						<dd>Points on boxes' and circles' boundaries are counted as matching. This is the default.</dd>
						<dt>"boundaries-excluded"</dt>
						<dd>Points on boxes' and circles' boundaries are not counted as matching.</dd>
						<dt>"boundaries-latitude-excluded"</dt>
						<dd>Points on boxes' latitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-longitude-excluded"</dt>
						<dd>Points on boxes' longitude boundaries are not counted as matching.</dd>
						<dt>"boundaries-south-excluded"</dt>
						<dd>Points on the boxes' southern boundaries are not counted as matching.</dd>
						<dt>"boundaries-west-excluded"</dt>
						<dd>Points on the boxes' western boundaries are not counted as matching.</dd>
						<dt>"boundaries-north-excluded"</dt>
						<dd>Points on the boxes' northern boundaries are not counted as matching.</dd>
						<dt>"boundaries-east-excluded"</dt>
						<dd>Points on the boxes' eastern boundaries are not counted as matching.</dd>
						<dt>"boundaries-circle-excluded"</dt>
						<dd>Points on circles' boundary are not counted as matching.</dd>
					</dl>
				</blockquote></param>
			<param name="weight" type="xs:double?" optional="true">A weight for this query. The default is 1.0.</param>
		</params>
		<return>cts:query</return>
		<usage>
			<p>The point value is expressed in the content of the element as a pair of numbers, separated by whitespace and punctuation (excluding decimal points and sign characters).</p>
			<p>Point values and boundary specifications of boxes are given in degrees relative to the WGS84 coordinate system. Southern latitudes and Western longitudes take negative values. Longitudes will be wrapped to the range (-180,+180) and latitudes will be clipped to the range (-90,+90).</p>
			<p>If the northern boundary of a box is south of the southern boundary, no points will match. However, longitudes wrap around the globe, so that if the western boundary is east of the eastern boundary, then the box crosses the anti-meridian.</p>
			<p>Special handling occurs at the poles, as all longitudes exist at latitudes +90 and -90.</p>
		</usage>
	</function>
	<function name="clean" type="msword" lib="msword" category="MSWord Conversion" bucket="CPF Functions" hidden="false" fullname="msword:clean">
		<summary>Clean up any conversion artifacts or other infelicities.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The source URI of the converted document.</param>
			<param name="doc" type="node()?" optional="false">The XHTML produced by conversion of a Microsoft Word document.</param>
		</params>
		<return>node()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace msword = "http://marklogic.com/cpf/msword"
	         at "/MarkLogic/conversion/msword.xqy";

  msword:clean("my_doc.xhtml",fn:doc("my_doc.xhtml"))

</example>
	</function>
	<function name="package-uris" lib="ooxml" category="ZIP Package" bucket="XQuery Library Modules" hidden="false" fullname="ooxml:package-uris">
		<summary>This function returns the list of files in the zip package.</summary>
		<params>
			<param name="package" type="node()" optional="false">The zip package.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace ooxml= "http://marklogic.com/openxml"
            at "/MarkLogic/openxml/package.xqy";

let $pkg := xdmp:document-get("c:/tmp/test.docx")
return
ooxml:package-uris($pkg)
=&gt; The sequence comprising th list of documents in the archive,
for example:
("[Content_Types].xml", "_rels/.rels", "word/_rels/document.xml.rels",
"word/document.xml", "word/footer3.xml", "word/footer2.xml",
"word/footer1.xml", "word/endnotes.xml", "word/footnotes.xml",
"word/_rels/header1.xml.rels", "word/header1.xml",
"word/media/image1.wmf", "word/theme/theme1.xml",
"word/_rels/settings.xml.rels", "word/settings.xml",
"word/styles.xml", "customXml/itemProps1.xml", "word/numbering.xml",
"customXml/_rels/item1.xml.rels", "word/fontTable.xml",
"docProps/app.xml", "docProps/core.xml", "customXml/item1.xml",
"word/webSettings.xml", "docProps/custom.xml")



</example>
	</function>
	<function name="package-parts" lib="ooxml" category="ZIP Package" bucket="XQuery Library Modules" hidden="false" fullname="ooxml:package-parts">
		<summary>This function returns the documents within the zip package. Typically, the parts are returned as document nodes. They are returned in the order the package uris are returned, which is the manifest order.</summary>
		<params>
			<param name="package" type="node()" optional="false">The zip package.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace ooxml= "http://marklogic.com/openxml"
          at "/MarkLogic/openxml/package.xqy";

let $pkg := xdmp:document-get("c:/tmp/test.docx")
return
ooxml:package-parts($pkg)[4]
=&gt; The fourth document in the archive, which is the
word/document.xml part in this example.


</example>
	</function>
	<function name="package-parts-insert" lib="ooxml" category="ZIP Package" bucket="XQuery Library Modules" hidden="false" fullname="ooxml:package-parts-insert">
		<summary>This function inserts one document in the database for each part at the specified URI. If a directory is given, then all parts are inserted into documents in that directory, with the rest of the URI determined by the $uris specified (typically from the manifest of a zip file or Office document).</summary>
		<params>
			<param name="directory" type="xs:string?" optional="false">The name of the base directory to concatenate with each of the $package-uris. If this is the empty string, then the URIs for each document are the $package-uris. If the string does not end in a forward slash (
				<code>/</code>), one is added (because directory URIs should end in a forward slash).</param>
			<param name="package-uris" type="xs:string*" optional="false">The list of URIs for the parts to insert, typically from the zip package manifest (or from
				<code>ooxml:package-uris</code>.) The order must correspond to the order of $package-parts.</param>
			<param name="package-parts" type="node()*" optional="false">The uncompressed parts to insert, typically from the zip package (or from
				<code>ooxml:package-parts</code>.) The order must correspond to the order of $package-uris.</param>
			<param name="permissions" type="element(sec:permission)*" optional="true">Security permission elements corresponding to the permissions for the document. If not supplied, the current user's default permissions are applied. The default value used for $permissions can be obtained by calling xdmp:default-permissions(). A document that is created by a non-admin user (that is, by any user who does not have the
				<code>admin</code>role) must have at least one update permission, otherwise the creation will throw an
				<code>XDMP-MUSTHAVEUPDATE</code>exception.</param>
			<param name="collections" type="xs:string*" optional="true">The collection URIs for collections to which this document belongs. If not supplied, the document is added to the current user's default collections. For each collection that is protected, the user must have permissions to update that collection or have the
				<code>any-collection</code>privilege. For each unprotected collection, the user must have the
				<code>unprotected-collections</code>privilege. The default value used for $collections can be obtained by calling
				<code>xdmp:default-collections()</code>.</param>
			<param name="quality" type="xs:int?" optional="true">The quality of this document. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Specifies the ID of the forest in which this document is inserted. If the document already exists in the database and if $forest-ids is not specified, it will remain in its existing forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the document is inserted into one of the specifed forests.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>This function has similar semantics to
			<code>xdmp:document-insert</code>. If a document already exists at one of the specified URIs, the function replaces the contents of the existing documents with the specified content. In addition to replacing the content,
			<code>ooxml:package-parts-insert</code>replaces any permissions, collections, and quality with the ones specified (or with the default values for these parameters, if not explicitly specified). Also, if a properties document exists at the same URI, that properties document (including any content it contains) is preserved.</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace ooxml= "http://marklogic.com/openxml"
               at "/MarkLogic/openxml/package.xqy";

let $dir := "/my/office/docs/"
let $pkg := xdmp:document-get("c:/tmp/test.docx")
let $uris := ooxml:package-uris($pkg)
let $parts := ooxml:package-parts($pkg)
return ooxml:package-parts-insert($dir, $uris, $parts)
=&gt; The empty sequence.  The documents are inserted
into the database under the /my/office/docs/ directory.


</example>
	</function>
	<function name="runs-merge" lib="ooxml" category="WordProcessingML" bucket="XQuery Library Modules" hidden="false" fullname="ooxml:runs-merge">
		<summary>This function updates document or paragraph node(s) (from a Word 2007 document) so that all similar runs are merged, retaining formatting, and removing text split across elements.</summary>
		<params>
			<param name="nodes" type="node()*" optional="false">The nodes to merge.</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace ooxml= "http://marklogic.com/openxml"
          at "/MarkLogic/openxml/word-processing-ml.xqy";
declare namespace w=
	  "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

let $runs := &lt;w:p w:rsidR="00D203FD" w:rsidRDefault="00423AEC"&gt;
           &lt;w:r&gt;&lt;w:t&gt;This is a de&lt;/w:t&gt;&lt;/w:r&gt;
           &lt;w:r&gt;&lt;w:t xml:space="preserve"&gt;monstration &lt;/w:t&gt;&lt;/w:r&gt;
            &lt;w:r&gt;&lt;w:t&gt;of merging runs&lt;/w:t&gt;&lt;/w:r&gt;
        &lt;/w:p&gt;
return
ooxml:runs-merge($runs)
=&gt;
&lt;w:p w:rsidR="00D203FD" w:rsidRDefault="00423AEC"
 xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;
 &lt;w:r&gt;
	 &lt;w:t xml:space="preserve"&gt;This is a demonstration of merging runs&lt;/w:t&gt;
  &lt;/w:r&gt;
&lt;/w:p&gt;

</example>
	</function>
	<function name="insert" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:insert">
		<summary>Insert a fully constructed content processing pipeline, returning its unique ID. If a pipeline with the same name already exists in the database, it is replaced.</summary>
		<params>
			<param name="pipeline-node" type="node()" optional="false">The pipeline definition. Any pipeline-id element will be ignored.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  p:insert( xdmp:get("/pipelines/myapp.xml")/* )

</example>
	</function>
	<function name="create" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:create">
		<summary>Create a new content processing pipeline.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the pipeline. It must be unique.</param>
			<param name="description" type="xs:string" optional="false">A description of the pipeline.</param>
			<param name="success-action" type="element(p:action)?" optional="false">The default action for successful transitions. If none is provided the system default success action will be used. Create using p:action.</param>
			<param name="failure-action" type="element(p:action)?" optional="false">The default action for failed transitions. If none is provided the system default failure action will be used. Create using p:action.</param>
			<param name="status-transitions" type="element(p:status-transition)*" optional="false">Status transition definitions. There should be exactly one status transition for the statuses "created", "deleted", and "updated". Create using p:status-transition.</param>
			<param name="state-transitions" type="element(p:state-transition)*" optional="false">State transition definitions. There should be at most one state transition for a given state. Create using p:state-transition.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  let $init-state := xs:anyURI("http://example.com/states/init")
  let $error-state := xs:anyURI("http://example.com/states/error")
  return
  p:create( "Empty", "No nothing much", (), (),
            ( p:status-transition("created", "",
                                  $init-state,
	                         $error-state,
	                         (), (), () ),
	      p:status-transition("deleted", "",
	                          (),
	                          $error-state,
	                         (), (), () ),
	      p:status-transition("updated", "",
	                         (),
	                         $error-state,
	                         (), (), () )
             ), ()
          )

</example>
	</function>
	<function name="remove" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:remove">
		<summary>Remove the named pipeline. An error is raised if no such pipeline exists.</summary>
		<params>
			<param name="pipeline-name" type="xs:string" optional="false">The name of the pipeline to remove.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  p:remove( "Empty" )

</example>
	</function>
	<function name="get" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:get">
		<summary>Find a particular pipeline.</summary>
		<params>
			<param name="pipeline-name" type="xs:string" optional="false">The name of the pipeline to get. An error is raised if no such pipeline exists.</param>
		</params>
		<return>element(p:pipeline)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  p:get( "Link Maintenance" )

</example>
	</function>
	<function name="get-by-id" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:get-by-id">
		<summary>Find a particular pipeline.</summary>
		<params>
			<param name="pipeline-id" type="xs:unsignedLong" optional="false">The ID of the pipeline to get. An error is raised if no such pipeline exists.</param>
		</params>
		<return>element(p:pipeline)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";
  import module namespace dom = "http://marklogic.com/cpf/domains"
	         at "/MarkLogic/cpf/domains.xqy";

  p:get-by-id( dom:get("Default Domain")/dom:pipeline[1] )

</example>
	</function>
	<function name="collection" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:collection">
		<summary>Return the name of the collection in which pipelines are stored.</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  p:collection()
      ==&gt; returns "http://marklogic.com/cpf/pipelines"

</example>
	</function>
	<function name="pipelines" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:pipelines">
		<summary>Return all the pipelines.</summary>
		<params />
		<return>element(p:pipeline)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  for $pipeline in p:pipelines()
  return $pipeline/p:pipeline-name

</example>
	</function>
	<function name="state-transition" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:state-transition">
		<summary>Construct a new state transition element.</summary>
		<params>
			<param name="state" type="xs:anyURI" optional="false">The name of the state.</param>
			<param name="description" type="xs:string" optional="false">A description of the transition.</param>
			<param name="on-success" type="xs:anyURI?" optional="false">The successor state, should the transition succeed. If no successor state is defined, the document will remain in its current state.</param>
			<param name="on-failure" type="xs:anyURI?" optional="false">The successor state, should the transition fail. If no successor state is defined, the document will remain in its current state.</param>
			<param name="priority" type="xs:unsignedLong?" optional="false">The priority for this transition. Higher priority transitions will be examined before lower priority ones. If no priority is passed, then the transition gets the highest priority.</param>
			<param name="default-action" type="element(p:action)?" optional="false">The default action to execute on entry into this state, if none of the rules apply.</param>
			<param name="rules" type="element(p:execute)*" optional="false">The execution rules to apply in this transition. The first rule whose condition is true will have its action executed.</param>
		</params>
		<return>element(p:state-transition)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  p:state-transition( xs:anyURI("http://example.com/states/review"),
                      "Document review state",
                      (), xs:anyURI("http://example.com/states/error"), (),
                      p:action("/app/send-to-reviewer.xqy",(), ()),
                      () )

</example>
	</function>
	<function name="status-transition" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:status-transition">
		<summary>Construct a new status transition element.</summary>
		<params>
			<param name="status" type="xs:string" optional="false">The status: either "created", "updated", or "deleted".</param>
			<param name="description" type="xs:string" optional="false">A description of the transition.</param>
			<param name="on-success" type="xs:anyURI?" optional="false">The successor state, should the transition succeed. If no successor state is defined, the document will remain in its current state.</param>
			<param name="on-failure" type="xs:anyURI?" optional="false">The successor state, should the transition fail. If no successor state is defined, the document will remain in its current state.</param>
			<param name="priority" type="xs:unsignedLong?" optional="false">The priority for this transition. Higher priority transitions will be examined before lower priority ones. If no priority is passed, then the transition gets the highest priority.</param>
			<param name="default-action" type="element(p:action)?" optional="false">The default action to execute on entry into this status, if none of the rules apply.</param>
			<param name="rules" type="element(p:execute)*" optional="false">The execution rules to apply in this transition. The first rule whose condition is true will have its action executed.</param>
		</params>
		<return>element(p:status-transition)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  p:status-transition("created",
                      "Document creation: Put in initial state.",
                      xs:anyURI("http://example.com/states/initial"), (), (),
                      (), () )

</example>
	</function>
	<function name="execute" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:execute">
		<summary>Construct a execute element.</summary>
		<params>
			<param name="condition" type="element(p:condition)?" optional="false">The condition to execute to test whether this rule applies. If no condition is specified, the action always executes.</param>
			<param name="action" type="element(p:action)?" optional="false">The action to execute should this rule apply. If no action is specified, the default success action will execute instead.</param>
			<param name="description" type="xs:string?" optional="false">A description of the rule.</param>
		</params>
		<return>element(p:execute)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  let $options :=
     &lt;options xmlns="/app/test-root.xqy"&gt;
        &lt;root&gt;workitem&lt;/root&gt;
     &lt;/options&gt;
  return
  p:execute( p:condition("/app/test-root.xqy", (), $options ), (),
             "Execute default action on workitems."
           )

</example>
	</function>
	<function name="condition" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:condition">
		<summary>Construct a condition element.</summary>
		<params>
			<param name="module" type="xs:string" optional="false">The path to the module to evaluate.</param>
			<param name="description" type="xs:string?" optional="false">A description of the condition.</param>
			<param name="options" type="element()?" optional="false">The options element to pass to the module as the external variable $cpf:options. The options element will be in the namespace of the module.</param>
		</params>
		<return>element(p:condition)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  let $options :=
     &lt;options xmlns="/app/test-root.xqy"&gt;
        &lt;root&gt;workitem&lt;/root&gt;
     &lt;/options&gt;
  return p:condition("/app/test-root.xqy", (), $options )
         ===&gt; returns
            &lt;p:condition xmlns:p="http:marklogic.com/cpf/pipelines"&gt;
               &lt;p:module&gt;/app/test-root.xqy&lt;/p:module&gt;
               &lt;options xmlns="/app/test-root.xqy"&gt;
                 &lt;root&gt;workitem&lt;/root&gt;
               &lt;/options&gt;
            &lt;/p:condition&gt;

</example>
	</function>
	<function name="action" type="pipeline" lib="p" category="Pipelines" bucket="CPF Functions" hidden="false" fullname="p:action">
		<summary>Construct an action element.</summary>
		<params>
			<param name="module" type="xs:string" optional="false">The path to the module to evaluate.</param>
			<param name="description" type="xs:string?" optional="false">A description of the action.</param>
			<param name="options" type="element()?" optional="false">The options element to pass to the module as the external variable $cpf:options. The options element will be in the namespace of the module.</param>
		</params>
		<return>element(p:action)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace p = "http://marklogic.com/cpf/pipelines"
	         at "/MarkLogic/cpf/pipelines.xqy";

  p:action("/app/process-workitem.xqy", (), () )
         ===&gt; returns
            &lt;p:action xmlns:p="http:marklogic.com/cpf/pipelines"&gt;
               &lt;p:module&gt;/app/process-workitem.xqy&lt;/p:module&gt;
            &lt;/p:action&gt;

</example>
	</function>
	<function name="create" lib="package" category="Configuration Packaging" bucket="XQuery Library Modules" hidden="false" fullname="package:create">
		<summary>Create an empty configuration for use with other packaging functions.</summary>
		<params />
		<return>element(pkg:package)</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace package = "http://marklogic.com/package/package"
	         at "/MarkLogic/package/package.xqy";

package:create()

  =&gt; An empty package. Use package:add-appserver
     and package:add-database to add settings.

</example>
	</function>
	<function name="add-appserver" lib="package" category="Configuration Packaging" bucket="XQuery Library Modules" hidden="false" fullname="package:add-appserver">
		<summary>Add the configuration settings for an App Server to a package.</summary>
		<params>
			<param name="pkg" type="element(pkg:package)" optional="false">The package to which to add App Server configuration settings.</param>
			<param name="groupname" type="xs:string" optional="false">The name of the Group containing the target App Server.</param>
			<param name="appname" type="xs:string" optional="false">The name of the App Server whose settings should be added to the package. The App Server must be in the Group identified by
				<code>$groupname</code>.</param>
		</params>
		<return>element(pkg:package)</return>
		<usage>
			<p>If the named App Server is already in the package, this function has no effect.</p>
			<p>If the App Server described by the
				<code>$groupname</code>and
				<code>$appname</code>does not exist, an exception is raised.</p>
			<p>The security role
				<code>manage-user</code>grants
				<code>http://marklogic.com/xdmp/privileges/manage</code>.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/manage</code>
		</privilege>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace package = "http://marklogic.com/package/package"
	         at "/MarkLogic/package/package.xqy";

let $my-package := package:create()
return package:add-appserver($my-package, "Default", "sample-server")

  =&gt; A package containing the configuration settings for
     the App Server "sample-server" in the "Default" group.

</example>
	</function>
	<function name="add-database" lib="package" category="Configuration Packaging" bucket="XQuery Library Modules" hidden="false" fullname="package:add-database">
		<summary>Add the configuration settings for a database to a package.</summary>
		<params>
			<param name="pkg" type="element(pkg:package)" optional="false">The package to which to add database configuration settings.</param>
			<param name="dbname" type="xs:string" optional="false"></param>
		</params>
		<return>element(pkg:package)</return>
		<usage>
			<p>If the database is already in the package, this function has no effect.</p>
			<p>If the database does not exist, an exception is raised.</p>
			<p>The pre-defined security role
				<code>manage-user</code>grants
				<code>http://marklogic.com/xdmp/privileges/manage</code>.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/manage</code>
		</privilege>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace package = "http://marklogic.com/package/package"
	         at "/MarkLogic/package/package.xqy";

let $my-package := package:create()
return package:add-database($my-package, "sample-db")

  =&gt; A package containing the configuration settings for
     the database "sample-db".

</example>
	</function>
	<function name="compare" lib="package" category="Configuration Packaging" bucket="XQuery Library Modules" hidden="false" fullname="package:compare">
		<summary>Compare two configuration packages previously created using the packaging API, and return the differences as a
			<code>pkg:package-diff</code>.</summary>
		<params>
			<param name="source-pkg" type="node()" optional="false">The "updated" package to diff against the baseline. The node must be
				<code>element(pkg:package)</code>or a document node rooted at
				<code>pkg:package</code>.</param>
			<param name="target-pkg" type="node()" optional="false">The "original" package to diff against. Differences are reported as changes from this baseline. The node must be a
				<code>element(pkg:package)</code>or a document node rooted at
				<code>pkg:package</code>.</param>
		</params>
		<return>element(pkg:package-diff)</return>
		<usage>
			<p>The returned
				<code>pkg:package-diff</code>contains the entire configuration, with differences called out in
				<code>pkg:delta</code>elements.</p>
			<p>The differences between the two input packages are reported as changes that transform
				<code>from-pkg</code>into
				<code>to-pkg</code>.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: package the original database configuration and save as a document :)
import module namespace package = "http://marklogic.com/package/package"
    at "/MarkLogic/package/package.xqy";
let $from-package := package:create()
let $from-doc :=
  xdmp:document-insert("/package/from",
    package:add-database($from-package, "samples"))
return "saved from-package";

(: modify the database configuration by flipping word positions setting :)
import module namespace admin = "http://marklogic.com/xdmp/admin"
    at "/MarkLogic/admin.xqy";
let $db-id := xdmp:database("samples")
let $config := admin:get-configuration()
return admin:save-configuration(
  admin:database-set-word-positions(
    $config, $db-id,
    fn:not(admin:database-get-word-positions($config,$db-id))
  ));

(: package the modified database configuration and save as a document :)
import module namespace package = "http://marklogic.com/package/package"
    at "/MarkLogic/package/package.xqy";
let $to-package := package:create()
let $to-doc :=
  xdmp:document-insert("/package/to",
    package:add-database($to-package, "samples"))
return "saved to-package";

(: compare the original and modified configurations :)
import module namespace package = "http://marklogic.com/package/package"
    at "/MarkLogic/package/package.xqy";
declare namespace pkg = "http://marklogic.com/package";
let $deltas :=
  package:compare(fn:doc("/package/to"), fn:doc("/package/from"))//pkg:delta
for $delta in ($deltas)
return $delta/..


  =&gt; The package differences, showing word positions changed
     from false to true:

saved from-package
saved to-package
&lt;db:timestamp xmlns:pkg="http://marklogic.com/package"
              xmlns:db="http://marklogic.com/package/databases"&gt;
  &lt;pkg:delta&gt;
    &lt;pkg:del&gt;2011-09-26T12:19:55.237658-07:00&lt;/pkg:del&gt;
    &lt;pkg:add&gt;2011-09-26T12:19:55.732692-07:00&lt;/pkg:add&gt;
  &lt;/pkg:delta&gt;
&lt;/db:timestamp&gt;
&lt;word-positions xmlns:pkg="http://marklogic.com/package"
                xmlns:db="http://marklogic.com/package/databases"
                xmlns="http://marklogic.com/package/databases"&gt;
  &lt;pkg:delta&gt;
    &lt;pkg:del&gt;false&lt;/pkg:del&gt;
    &lt;pkg:add&gt;true&lt;/pkg:add&gt;
  &lt;/pkg:delta&gt;
&lt;/word-positions&gt;

</example>
	</function>
	<function name="install" lib="package" category="Configuration Packaging" bucket="XQuery Library Modules" hidden="false" fullname="package:install">
		<summary>Apply the configuration settings in a package to a MarkLogic Server instance.</summary>
		<params>
			<param name="pkg" type="node()" optional="false">The packaged configuration to install. The node must be either an
				<code>element(pkg:package)</code>, or a document node rooted at
				<code>element(pkg:package)</code>.</param>
		</params>
		<return>element(pkg:result)</return>
		<usage>
			<p>Only users in the
				<code>admin</code>role may install packages.</p>
			<p>Installing a package creates a ticket. The ticket number is provided in the returned
				<code>pkg:result</code>. Use
				<code>info:ticket</code>to check the status of the ticket.</p>
			<p>Modifying some settings requires a server restart. If package installation requires a server restart to complete, the returned result directs you to restart.</p>
			<p>The returned
				<code>pkg:result</code>reports success or failure in the
				<code>pkg:result-status</code>child element. If the installation fails, the live configuration is unchanged; errors are reported in the
				<code>pkg:configuration-errors</code>child element.</p>
			<p>Attempting to install two or more packages concurrently may leave your configuration in an indeterminate state.</p>
		</usage>
		<example xml:space="preserve">
(: install a package previously saved as a document :)
import module namespace package = "http://marklogic.com/package/package"
    at "/MarkLogic/package/package.xqy";
package:install(fn:doc("/package/to"))

  =&gt; The settings in /package/to are applied and a pkg:result is
     returned, indicating success or failure. For example:

  &lt;pkg:result xmlns:pkg="http://marklogic.com/package"&gt;
    &lt;pkg:ticket-id&gt;/tickets/ticket/2438123874498566113&lt;/pkg:ticket-id&gt;
    &lt;pkg:result-status&gt;COMPLETED&lt;/pkg:result-status&gt;
    &lt;pkg:result-event&gt;PACKAGE_WRITTEN&lt;/pkg:result-event&gt;
  &lt;/pkg:result&gt;

</example>
	</function>
	<function name="valid" lib="package" category="Configuration Packaging" bucket="XQuery Library Modules" hidden="false" fullname="package:valid">
		<summary>Test a package for consistency.</summary>
		<params>
			<param name="pkg" type="element()" optional="false">The package to check. This should be an
				<code>element(pkg:package)</code>.</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>This function returns true if the package is valid and false otherwise. Use
				<code>package:errors</code>to view a list of errors for an invalid package.</p>
			<p>A package may be invalid for many reasons, including a violation of the package schema (Config/package.xsd), fields with erroneous values, or duplicate settings.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace package = "http://marklogic.com/package/package"
    at "/MarkLogic/package/package.xqy";

let $incomplete-package :=
  &lt;pkg:package xmlns:pkg="http://marklogic.com/package"&gt;
   &lt;package-database xmlns="http://marklogic.com/package/databases"&gt;
    &lt;name&gt;samples&lt;/name&gt;
   &lt;/package-database&gt;
  &lt;/pkg:package&gt;
return package:valid($incomplete-package)

  =&gt; false because the package is incomplete

</example>
	</function>
	<function name="errors" lib="package" category="Configuration Packaging" bucket="XQuery Library Modules" hidden="false" fullname="package:errors">
		<summary>Check a package for errors and, if there are errors, return a description of the errors as
			<code>pkg:configuration-error</code>elements.</summary>
		<params>
			<param name="pkg" type="element()" optional="false">The package for which to report errors. This should be an
				<code>element(pkg:package)</code>.</param>
		</params>
		<return>element(pkg:configuration-errors)*</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace package = "http://marklogic.com/package/package"
    at "/MarkLogic/package/package.xqy";

let $incomplete-package :=
  &lt;pkg:package xmlns:pkg="http://marklogic.com/package"&gt;
   &lt;package-database xmlns="http://marklogic.com/package/databases"&gt;
    &lt;name&gt;samples&lt;/name&gt;
   &lt;/package-database&gt;
  &lt;/pkg:package&gt;
return package:errors($incomplete-package)

  =&gt; A schema violation error because the package is incomplete:

  &lt;pkg:configuration-errors xmlns:pkg="http://marklogic.com/package"&gt;
    &lt;pkg:resource-type&gt;package&lt;/pkg:resource-type&gt;
    &lt;pkg:configuration-error&gt;
      The package document is not schema-valid.
    &lt;/pkg:configuration-error&gt;
  &lt;/pkg:configuration-errors&gt;

</example>
	</function>
	<function name="revert" lib="package" category="Configuration Packaging" bucket="XQuery Library Modules" hidden="false" fullname="package:revert">
		<summary>Revert configuration settings to those prior to a particular package installation.</summary>
		<params>
			<param name="ticket-id" type="xs:string" optional="false">The id of a ticket created by a previous successful call to
				<code>package:install</code>.</param>
		</params>
		<return>element(pkg:result)</return>
		<usage>
			<p>Reverting a package installation restores all settings to their state at the time ticket was created by calling
				<code>package:install</code>. If other configuration changes are applied between the successful install and the attempt to revert, those changes are lost.</p>
			<p>Successful calls to
				<code>package:install</code>create a ticket associated with the configuration changes. The ticket id provided in the
				<code>pkg:result</code>returned by
				<code>package:install</code>. Use this ticket id to revert the changes.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace package = "http://marklogic.com/package/package"
    at "/MarkLogic/package/package.xqy";

(: install a package :)
package:install(fn:doc("/package/to"));

(: Produces the following for some previously saved package:

  &lt;pkg:result xmlns:pkg="http://marklogic.com/package"&gt;
    &lt;pkg:ticket-id&gt;/tickets/ticket/14006129137320060991&lt;/pkg:ticket-id&gt;
    &lt;pkg:result-status&gt;COMPLETED&lt;/pkg:result-status&gt;
    &lt;pkg:result-event&gt;NO_CONFIG_CHANGE&lt;/pkg:result-event&gt;
  &lt;/pkg:result&gt;
:)

(: revert the above install :)
import module namespace package = "http://marklogic.com/package/package"
    at "/MarkLogic/package/package.xqy";

package:revert("/tickets/ticket/14006129137320060991")


  =&gt; The changes applied by the package are reverted:

  &lt;pkg:result xmlns:pkg="http://marklogic.com/package"&gt;
    &lt;pkg:ticket-id&gt;/tickets/ticket/2438123874498566113&lt;/pkg:ticket-id&gt;
    &lt;pkg:result-status&gt;COMPLETED&lt;/pkg:result-status&gt;
    &lt;pkg:result-event&gt;PACKAGE_WRITTEN&lt;/pkg:result-event&gt;
  &lt;/pkg:result&gt;


</example>
	</function>
	<function name="clean" type="pdf" lib="pdf" category="PDF Conversion" bucket="CPF Functions" hidden="false" fullname="pdf:clean">
		<summary>Clean up any conversion artifacts or other infelicities.</summary>
		<params>
			<param name="doc" type="node()?" optional="false">The XHTML produced by conversion of a PDF document.</param>
			<param name="toc" type="element()?" optional="false">The TOC produced by conversion of a PDF document.</param>
		</params>
		<return>node()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace pdf = "http://marklogic.com/cpf/pdf"
	         at "/MarkLogic/conversion/pdf.xqy";

  pdf:clean(fn:doc("my_pdf.xhtml"), pdf:get-toc("my_pdf.xhtml"))

</example>
	</function>
	<function name="get-toc" type="pdf" lib="pdf" category="PDF Conversion" bucket="CPF Functions" hidden="false" fullname="pdf:get-toc">
		<summary>Fetch the linked TOC, if any.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the converted PDF document.</param>
		</params>
		<return>element()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace pdf = "http://marklogic.com/cpf/pdf"
	         at "/MarkLogic/conversion/pdf.xqy";

  pdf:get-toc("my_pdf.xhtml")

</example>
	</function>
	<function name="make-toc" type="pdf" lib="pdf" category="PDF Conversion" bucket="CPF Functions" hidden="false" fullname="pdf:make-toc">
		<summary>Clean and normalize the TOC produced by raw conversion.</summary>
		<params>
			<param name="toc" type="element()?" optional="false">The raw TOC element.</param>
		</params>
		<return>element()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace pdf = "http://marklogic.com/cpf/pdf"
	         at "/MarkLogic/conversion/pdf.xqy";

  let $results :=
     xdmp:pdf-convert( xdmp:get("/myfiles/myfile.pdf"), "myfile.pdf" )
  let $manifest := $results[1]
  let $toc :=
      for $doc at $index in $results[2 to last()]
      let $name := string($manifest/*[$index])
      where fn:matches( $name, "toc.xml" )
      return $doc
  return pdf:make-toc( $toc )

</example>
	</function>
	<function name="insert-toc-headers" type="pdf" lib="pdf" category="PDF Conversion" bucket="CPF Functions" hidden="false" fullname="pdf:insert-toc-headers">
		<summary>Locate TOC anchors and make them properly refer to headers at the appropriate level. Returned the transformed document.</summary>
		<params>
			<param name="doc" type="node()?" optional="false">The cleaned XHTML produced by PDF conversion.</param>
			<param name="toc" type="element()?" optional="false">The normalized TOC.</param>
		</params>
		<return>node()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace pdf = "http://marklogic.com/cpf/pdf"
	         at "/MarkLogic/conversion/pdf.xqy";

  xdmp:document-insert( "myfile.xhtml",
         pdf:insert-toc-headers( doc("myfile.xhtml"),
                                 pdf:get-toc("myfile.xhtml") )
  )

</example>
	</function>
	<function name="create-template" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:create-template">
		<summary>This function creates a new X.509 certificate request template. Each time a new certificate request is generated, a new public/private key pair is generated. A new random ID is generated and returned as part of the element. This ID is used for identifying this template and its related key pairs and certificates. The returned element must be separately inserted into the database with
			<code>pki:insert-template</code>.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the certificate request template.</param>
			<param name="description" type="xs:string" optional="false">A description of the certificate request template.</param>
			<param name="key-type" type="xs:string?" optional="false">The type of key to use (enter "rsa").</param>
			<param name="key-options" type="element()?" optional="false">The options for generating new keys. The valid options are
				<code>key-length</code>, which specifies the number of bits in a key (512, 1024, 2048, 4096), and
				<code>pass-phrase</code>, which specifies the pass phrase for encrypting/decrypting a private key.</param>
			<param name="csr" type="element(x509:req)" optional="false">An XML representation of the certificate request template.</param>
		</params>
		<return>element(pki:template)</return>
		<example xml:space="preserve">
     (: execute this against the security database :)
     xquery version "1.0-ml";

     import module namespace pki = "http://marklogic.com/xdmp/pki"
         at "/MarkLogic/pki.xqy";

     declare namespace x509 = "http://marklogic.com/xdmp/x509";
     declare namespace ssl = "http://marklogic.com/xdmp/ssl";

     let $x509 :=
       &lt;x509:req&gt;
         &lt;x509:version&gt;2&lt;/x509:version&gt;
         &lt;x509:subject&gt;
           &lt;x509:countryName&gt;US&lt;/x509:countryName&gt;
           &lt;x509:stateOrProvinceName&gt;CA&lt;/x509:stateOrProvinceName&gt;
           &lt;x509:localityName&gt;San Carlos&lt;/x509:localityName&gt;
           &lt;x509:organizationName&gt;MarkLogic&lt;/x509:organizationName&gt;
           &lt;x509:organizationalUnitName&gt;Engineering&lt;/x509:organizationalUnitName&gt;
           &lt;x509:commonName&gt;my.host.com&lt;/x509:commonName&gt;
           &lt;x509:emailAddress&gt;user@marklogic.com&lt;/x509:emailAddress&gt;
         &lt;/x509:subject&gt;
         &lt;x509:v3ext&gt;
           &lt;x509:basicConstraints critical="false"&gt;CA:TRUE&lt;/x509:basicConstraints&gt;
           &lt;x509:keyUsage critical="false"&gt;Certificate Sign, CRL Sign&lt;/x509:keyUsage&gt;
           &lt;x509:nsCertType critical="false"&gt;SSL Server&lt;/x509:nsCertType&gt;
           &lt;x509:subjectKeyIdentifier critical="false"&gt;B2:2C:0C:F8:5E:A7:44:B7&lt;/x509:subjectKeyIdentifier&gt;
         &lt;/x509:v3ext&gt;
       &lt;/x509:req&gt;

     let $options :=
       &lt;pki:key-options xmlns="ssl:options"&gt;
         &lt;key-length&gt;2048&lt;/key-length&gt;
       &lt;/pki:key-options&gt;

     return pki:create-template(
            "testTemplate",
            "Creating a new template",
            "rsa",
             $options,
             $x509)

  (: Creates a new certificate template, named "testTemplate." :)

</example>
	</function>
	<function name="insert-template" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:insert-template">
		<summary>This function inserts the specified certificate request template into the Security database and returns the certificate template id.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate request template created by the
				<code>pki:create-template()</code>function.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
     (: execute this against the security database :)
     xquery version "1.0-ml";

     import module namespace pki = "http://marklogic.com/xdmp/pki"
         at "/MarkLogic/pki.xqy";

     declare namespace x509 = "http://marklogic.com/xdmp/x509";
     declare namespace ssl = "http://marklogic.com/xdmp/ssl";

     let $x509 :=
       &lt;x509:req&gt;
         &lt;x509:version&gt;2&lt;/x509:version&gt;
         &lt;x509:subject&gt;
           &lt;x509:countryName&gt;US&lt;/x509:countryName&gt;
           &lt;x509:stateOrProvinceName&gt;CA&lt;/x509:stateOrProvinceName&gt;
           &lt;x509:localityName&gt;San Carlos&lt;/x509:localityName&gt;
           &lt;x509:organizationName&gt;MarkLogic&lt;/x509:organizationName&gt;
           &lt;x509:organizationalUnitName&gt;Engineering&lt;/x509:organizationalUnitName&gt;
           &lt;x509:commonName&gt;my.host.com&lt;/x509:commonName&gt;
           &lt;x509:emailAddress&gt;user@marklogic.com&lt;/x509:emailAddress&gt;
         &lt;/x509:subject&gt;
         &lt;x509:v3ext&gt;
           &lt;x509:basicConstraints critical="false"&gt;CA:TRUE&lt;/x509:basicConstraints&gt;
           &lt;x509:keyUsage critical="false"&gt;Certificate Sign, CRL Sign&lt;/x509:keyUsage&gt;
           &lt;x509:nsCertType critical="false"&gt;SSL Server&lt;/x509:nsCertType&gt;
           &lt;x509:subjectKeyIdentifier critical="false"&gt;B2:2C:0C:F8:5E:A7:44:B7&lt;/x509:subjectKeyIdentifier&gt;
         &lt;/x509:v3ext&gt;
       &lt;/x509:req&gt;

     let $options :=
       &lt;pki:key-options xmlns="ssl:options"&gt;
         &lt;key-length&gt;2048&lt;/key-length&gt;
       &lt;/pki:key-options&gt;

     let $template := pki:create-template(
            "testTemplate",
            "Creating a new template",
            "rsa",
             $options,
             $x509)

     return
       pki:insert-template($template)

  (: Creates a new certificate template, named "testTemplate," and inserts it into the database. :)

</example>
	</function>
	<function name="delete-certificate" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:delete-certificate">
		<summary>This function removes the specified certificate from the Security database.</summary>
		<params>
			<param name="certificate-id" type="xs:unsignedLong" optional="false">The id of the certificate to be removed.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  declare namespace x509=  "http://marklogic.com/xdmp/x509";

  let $cert-id := pki:get-certificates(pki:get-trusted-certificate-ids())
    [x509:cert/x509:subject/x509:organizationName eq "Bad Company"]/pki:certificate-id

  return  pki:delete-certificate($cert)

  (: Removes the certificates issued by "Bad Company" from the database. :)

</example>
	</function>
	<function name="delete-template" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:delete-template">
		<summary>This function removes the specified certificate request template from the Security database.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The id of the certificate request template to be removed.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
   (: execute this against the security database :)
   xquery version "1.0-ml";
   import module namespace pki = "http://marklogic.com/xdmp/pki"
        at "/MarkLogic/pki.xqy";

   let $tid := pki:template-get-id(pki:get-template-by-name("test"))

   return (fn:concat("Removed:  ", $tid), pki:delete-template($tid))

   (: Deletes the template, named "test," from the database. :)

</example>
	</function>
	<function name="template-get-id" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-get-id">
		<summary>This function returns the id of the specified certificate template.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">A certificate request template created by the
				<code>pki:create-template()</code>function.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";

  pki:template-get-id(pki:get-template-by-name("test"))

  (: Returns the id for the "test" certificate template. :)

</example>
	</function>
	<function name="template-get-name" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-get-name">
		<summary>This function returns the name of the specified certificate template.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template from which to get the name.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";

  for $tid in pki:get-template-ids()
    return  pki:template-get-name(pki:get-template($tid))

  =&gt;
    mycert3
    mycert2
    mycert

</example>
	</function>
	<function name="template-set-name" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-set-name">
		<summary>This function changes the name of the specified certificate template and returns the XML containing the change. Use
			<code>pki:insert-template</code>to save the change to the Security database.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template for which to change the name.</param>
			<param name="name" type="xs:string" optional="false">The new name for the certificate template.</param>
		</params>
		<return>element(pki:template)</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  let $tid := pki:get-template-ids()[1]
    return  pki:template-set-name(pki:get-template($tid), "foo")

  (: Returns the XML for the certificate template with the new name. :)

</example>
	</function>
	<function name="template-get-description" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-get-description">
		<summary>This function returns the description of the specified certificate template.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template from which to get the description.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";

  for $tid in pki:get-template-ids()
    return  pki:template-get-description(pki:get-template($tid))

  (: Returns the descriptions of the certificate templates. :)

</example>
	</function>
	<function name="template-set-description" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-set-description">
		<summary>This function changes the description of the specified certificate template and returns the XML containing the change. Use
			<code>pki:insert-template</code>to save the change to the Security database.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template for which to change the description.</param>
			<param name="description" type="xs:string" optional="false">The new description for the certificate template.</param>
		</params>
		<return>element(pki:template)</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";

  let $tid := pki:get-template-ids()[1]
  return
     pki:template-set-description(
         pki:get-template($tid),
         "The new description of the certificate.")

  (: Returns the XML for the certificate template with the new description. :)

</example>
	</function>
	<function name="template-get-key-type" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-get-key-type">
		<summary>This function returns the key type for the specified certificate template.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template from which to get the key type.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";;

  for $tid in pki:get-template-ids()
     return  pki:template-get-key-type(pki:get-template($tid))

  (: Returns the key types of the certificate templates. :)

</example>
	</function>
	<function name="template-set-key-type" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-set-key-type">
		<summary>This function changes the key type for the specified certificate template and returns the XML containing the change. Use
			<code>pki:insert-template</code>to save the change to the Security database.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template for which to change the key type.</param>
			<param name="key-type" type="xs:string" optional="false">The new key type for the certificate template. The key type must be "rsa" and entered in lower case.</param>
		</params>
		<return>element(pki:template)</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";;

  let $tid := pki:get-template-ids()[1]
  return
     pki:template-set-key-type(pki:get-template($tid), "rsa")

  (: Returns the XML for the certificate template with the new key type. :)

</example>
	</function>
	<function name="template-get-version" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-get-version">
		<summary>This function returns the version number for the specified certificate template.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template from which to get the version number.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";

  for $tid in pki:get-template-ids()
  return
    pki:template-get-version(pki:get-template($tid))

  (: Returns the version numbers of the certificate templates. :)

</example>
	</function>
	<function name="template-get-key-options" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-get-key-options">
		<summary>This function returns all of the template key options set in the specified certificate template.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template from which to get the key options.</param>
		</params>
		<return>element(pki:key-options)</return>
		<example xml:space="preserve">
    (: execute this against the security database :)
    xquery version "1.0-ml";
    import module namespace pki = "http://marklogic.com/xdmp/pki"
         at "/MarkLogic/pki.xqy";

    pki:template-get-key-options(pki:get-template-by-name("test"))

    (: Return all of the key options in the certificate template, named "test." :)

</example>
	</function>
	<function name="template-set-key-options" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-set-key-options">
		<summary>This function sets the options for generating new keys in the specified certificate template. The returned element must be separately inserted into the database with
			<code>pki:insert-template</code>.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template for which to set the key options.</param>
			<param name="key-options" type="element(pki:key-options)" optional="false">The options for generating new keys. The valid options are
				<code>key-length</code>, which specifies the number of bits in a key (512, 1024, 2048, 4096), and
				<code>pass-phrase</code>, which specifies the pass phrase for encrypting/decrypting a private key.</param>
		</params>
		<return>element(pki:template)</return>
		<example xml:space="preserve">
     (: execute this against the security database :)
     xquery version "1.0-ml";
     import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";

     declare namespace ssl = "http://marklogic.com/xdmp/ssl";

     let $options :=  &lt;pki:key-options xmlns="ssl:options"&gt;
                         &lt;key-length&gt;2048&lt;/key-length&gt;
                      &lt;/pki:key-options&gt;

     return
       pki:template-set-key-options(
          pki:get-template-by-name("test"), $options)

     (: Sets the key options in the "test" template. :)

</example>
	</function>
	<function name="template-get-request" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-get-request">
		<summary>This function returns the request portion of the certificate template.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template from which to extract the request portion.</param>
		</params>
		<return>element(x509:req)</return>
		<example xml:space="preserve">
    (: execute this against the security database :)
    xquery version "1.0-ml";
    import module namespace pki = "http://marklogic.com/xdmp/pki"
        at "/MarkLogic/pki.xqy";

    pki:template-get-request(pki:get-template-by-name("test"))

    (: Returns the request portion of the "test" template. :)

</example>
	</function>
	<function name="template-set-request" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-set-request">
		<summary>This function sets the request portion for the specified certificate template. Use
			<code>pki:insert-template</code>to save the change to the Security database.</summary>
		<params>
			<param name="template" type="element(pki:template)" optional="false">The certificate template from which to set the request portion.</param>
			<param name="req" type="element(x509:req)" optional="false">The request portion to be set in the certificate template.</param>
		</params>
		<return>element(pki:template)</return>
		<example xml:space="preserve">
   (: execute this against the security database :)
   xquery version "1.0-ml";

   import module namespace pki = "http://marklogic.com/xdmp/pki"
	         at "/MarkLogic/pki.xqy";

   declare namespace x509 = "http://marklogic.com/xdmp/x509";

     let $x509 :=
       &lt;x509:req&gt;
         &lt;x509:version&gt;2&lt;/x509:version&gt;
         &lt;x509:subject&gt;
           &lt;x509:countryName&gt;US&lt;/x509:countryName&gt;
           &lt;x509:stateOrProvinceName&gt;CA&lt;/x509:stateOrProvinceName&gt;
           &lt;x509:localityName&gt;San Carlos&lt;/x509:localityName&gt;
           &lt;x509:organizationName&gt;MarkLogic&lt;/x509:organizationName&gt;
           &lt;x509:organizationalUnitName&gt;Engineering&lt;/x509:organizationalUnitName&gt;
           &lt;x509:commonName&gt;my.host.com&lt;/x509:commonName&gt;
           &lt;x509:emailAddress&gt;user@marklogic.com&lt;/x509:emailAddress&gt;
         &lt;/x509:subject&gt;
         &lt;x509:v3ext&gt;
           &lt;x509:basicConstraints critical="false"&gt;CA:TRUE&lt;/x509:basicConstraints&gt;
           &lt;x509:keyUsage critical="false"&gt;Certificate Sign, CRL Sign&lt;/x509:keyUsage&gt;
           &lt;x509:nsCertType critical="false"&gt;SSL Server&lt;/x509:nsCertType&gt;
           &lt;x509:subjectKeyIdentifier critical="false"&gt;B2:2C:0C:F8:5E:A7:44:B7&lt;/x509:subjectKeyIdentifier&gt;
         &lt;/x509:v3ext&gt;
       &lt;/x509:req&gt;

  return
    pki:insert-template(
    pki:template-set-request(
      pki:get-template-by-name("test"), $x509))

  (: Updates the request portion of the "test" template. :)

</example>
	</function>
	<function name="get-template-ids" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-template-ids">
		<summary>This function returns the ids for all of the certificate templates.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">

  (: execute this against the security database :)
  xquery version "1.0-ml";

  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  pki:get-template-ids()

   =&gt; 8197058186045144130
      10553510181853787005
      1457227631685032024
      8898647899939825066

</example>
	</function>
	<function name="get-template" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-template">
		<summary>This function returns the certificate template for the specified id.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong*" optional="false">The id of the certificate template to be returned.</param>
		</params>
		<return>element(pki:template)*</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";

  for $tid in pki:get-template-ids()
     return (pki:get-template($tid))

  (: Returns all of the certificate templates in the security database. :)

</example>
	</function>
	<function name="generate-certificate-request" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:generate-certificate-request">
		<summary>This function generates a PEM encoded X.509 certificate request from the template for the specified id. If $dns-name or $ip-addr are specified, those values will override any values specified in the template. A new public/private key pair is generated for the request and inserted as a temporary document in the database. When the signed certificate is inserted later, it is matched up against this document and any previously in use private key / certificate is replaced with the new one.
			<p>The Admin UI will only set common-name, and leave both dns-name and ip-addr unspecified. Control over these values is provided only for power users to use through custom administration scripts.</p></summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for which to generate the certificate request.</param>
			<param name="common-name" type="xs:string" optional="false">The common name to put into the template.</param>
			<param name="dns-name" type="xs:string?" optional="false">The DNS name, if any, to substitute into the template.</param>
			<param name="ip-addr" type="xs:string?" optional="false">The IP address, if any, to substitute into the template.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  let $tid := pki:get-template-ids()[1]
   return
      pki:generate-certificate-request($tid, (), "marklogic.com", "127.0.0.1")

   =&gt;

     -----BEGIN CERTIFICATE REQUEST-----
     MIIByDCCATECAQIwRDELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRMwEQYDVQQH
     EwpTYW4gQ2FybG9zMRMwEQYDVQQKEwpNYXJrIExvZ2ljMIGfMA0GCSqGSIb3DQEB
     AQUAA4GNADCBiQKBgQC6g8iGk1cgO4fFc+3f9kncQ/jEZLlTQESeKTfzglKL7YjS
     Eb85EjrND9MMnj/fEPxgRnoD6nfmiG54/xnj9A/0SnjtN1EVKb0XZaa6wh9KN8b4
     jzlPPYzJ0sLkwBtesrCW3So4gdBYC+xExjDWzdILVj78wzaDMNA4lm9wR2oMHQID
     AQABoEQwQgYJKoZIhvcNAQkOMTUwMzARBglghkgBhvhCAQEEBAMCBkAwHgYDVR0R
     BBcwFYINbWFya2xvZ2ljLmNvbYcEfwAAATANBgkqhkiG9w0BAQUFAAOBgQCwey7j
     JXYsGBf+D4YADIC9Qtcx7Y528S3XDlnhsySA7U9+bILoV55OdSwswL194faIkBGD
     uG77BNsbtf332rmWit8AQPfTQF50agDYwZoall3OeVUp1b5ZPemC/9kp20PgsIOG
     jcxcxla0ZCvzdid4gB+1NfP5mnNrCLhMHsJ1IQ==
     -----END CERTIFICATE REQUEST-----

</example>
	</function>
	<function name="get-pending-certificate-requests-pem" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-pending-certificate-requests-pem">
		<summary>This function returns any pending certificate requests for the specified template. The pending requests are returned as PEM encoded strings.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificate requests to be returned.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  for $tid in pki:get-template-ids()
     return pki:get-pending-certificate-requests-pem($tid)

  (: Returns all of the pending certificate requests in the security database in PEM
  encoded format. :)

</example>
	</function>
	<function name="get-pending-certificate-requests-xml" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-pending-certificate-requests-xml">
		<summary>This function returns any pending certificate requests for the specified template. The pending requests are returned as XML.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificate requests to be returned.</param>
		</params>
		<return>element(x509:req)*</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  for $tid in pki:get-template-ids()
     return pki:get-pending-certificate-requests-xml($tid)

  (: Returns all of the pending certificate requests in the security database in XML format. :)

</example>
	</function>
	<function name="insert-signed-certificates" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:insert-signed-certificates">
		<summary>This function inserts one or more PEM-encoded signed certificates into the database. The signed certificates are matched up against previously generated certificate requests and any previous certificate is replaced. If there is no matching certifcate request for the specified certificate, the certificate is not inserted into the database.</summary>
		<params>
			<param name="certs" type="xs:string" optional="false">One or more PEM-encoded signed certificates to be inserted into the database.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  pki:insert-signed-certificates(
     xdmp:document-get(
         "c:\SignedCertificates\Signed_cert.cer",
         &lt;options xmlns="xdmp:document-get"&gt;&lt;format&gt;text&lt;/format&gt;&lt;/options&gt;))

  (: Inserts the PEM-encoded signed certificate from the Signed_cert.cer file into
     the database. :)

</example>
	</function>
	<function name="insert-trusted-certificates" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:insert-trusted-certificates">
		<summary>This function inserts PEM-encoded certificates into the database without checking for a matching certificate request. This allows you to insert temporary certificates and those from new Certificate Authorities.</summary>
		<params>
			<param name="certs" type="xs:string" optional="false">One or more PEM-encoded certificates to be inserted into the database.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  pki:insert-trusted-certificates(
     xdmp:document-get(
         "c:\TrustedCertificates\Trusted_cert.cer",
         &lt;options xmlns="xdmp:document-get"&gt;&lt;format&gt;text&lt;/format&gt;&lt;/options&gt;))

  (: Inserts the PEM-encoded trusted certificate from the Trusted_cert.cer file into
     the database. :)

</example>
	</function>
	<function name="get-trusted-certificate-ids" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-trusted-certificate-ids">
		<summary>This function returns the ids of all of the trusted certificates in the Security database.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
   (: execute this against the security database :)
   xquery version "1.0-ml";
   import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

   pki:get-trusted-certificate-ids()

   =&gt;
       5182918040410509551
       14829635941505935843
       17428733531660907126
       1566218877500482981

</example>
	</function>
	<function name="get-certificate" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-certificate">
		<summary>This function returns the certificate for the specified template and host. The certificate data is returned in both PEM-encoded and XML formats. The common name must be specified. The DNS name and IP address are optional.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificate to be returned.</param>
			<param name="common-name" type="xs:string" optional="false">The common hostname (e.g.,
				<code>myhost.company.com</code>or
				<code>company.com</code>) in the certificate.</param>
			<param name="dns-name" type="xs:string?" optional="false">The DNS name in the certificate.</param>
			<param name="ip-addr" type="xs:string?" optional="false">The IP address name in the certificate.</param>
		</params>
		<return>element(pki:certificate)?</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  declare namespace x509=  "http://marklogic.com/xdmp/x509";

  let $config := admin:get-configuration()
  let $hostname := admin:host-get-name(
                       $config,
                       admin:host-get-id($config, xdmp:host-name()))

  for $tid in pki:get-template-ids()
  return
    pki:get-certificate($tid, $hostname, (), ())
      [x509:cert/x509:issuer/x509:commonName eq "mycert Certificate Authority"]

  (: Returns all of the certificates on the local host that were issued
     by the "mycert" Certificate Authority. :)

</example>
	</function>
	<function name="need-certificate" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:need-certificate">
		<summary>This function returns true if the certificate specified by the template id and host combination are not signed by a trusted certificate authority. Otherwise, false is returned. The common name must be specified. The DNS name and IP address are optional.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificate.</param>
			<param name="common-name" type="xs:string" optional="false">The common hostname (e.g.,
				<code>myhost.company.com</code>or
				<code>company.com</code>) in the certificate.</param>
			<param name="dns-name" type="xs:string?" optional="false">The DNS name in the certificate.</param>
			<param name="ip-addr" type="xs:string?" optional="false">The IP address name in the certificate.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

   "The certificates for the following templates are unsigned:", "",

  let $config := admin:get-configuration()
  let $hostname := admin:host-get-name(
                       $config,
                       admin:host-get-id($config, xdmp:host-name()))

  for $tid in pki:get-template-ids()
     return if (pki:need-certificate($tid, $hostname, (), ()))
        then pki:template-get-name(pki:get-template($tid))
        else ()

  (: Returns the list templates for which there are unsigned certificates. :)

</example>
	</function>
	<function name="get-pending-certificate-request" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-pending-certificate-request">
		<summary>This function returns any pending certificate requests for the specified template id and host combination. The certificate request data is return in both PEM-encoded and XML formats. The common name must be specified. The DNS name and IP address are optional.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificate request to be returned.</param>
			<param name="common-name" type="xs:string" optional="false">The common hostname (e.g.,
				<code>myhost.company.com</code>or
				<code>company.com</code>) in the certificate request.</param>
			<param name="dns-name" type="xs:string?" optional="false">The DNS name in the certificate request.</param>
			<param name="ip-addr" type="xs:string?" optional="false">The IP address name in the certificate request.</param>
		</params>
		<return>element(pki:request)?</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $hostname := admin:host-get-name(
                       $config,
                       admin:host-get-id($config, xdmp:host-name()))

  for $tid in pki:get-template-ids()
  return
      pki:get-pending-certificate-request($tid, $hostname, (), ())

  (: Returns all of the pending certificate requests for the local host :)

</example>
	</function>
	<function name="generate-temporary-certificate-if-necessary" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:generate-temporary-certificate-if-necessary">
		<summary>This function generates a new key pair and temporary certificate from the specified certificate template. If a temporary certificate already exists for the template, this function does nothing. If $dns-name or $ip-addr are specified, those portions of the template are replaced with the specified values. The certificate is inserted into the database. This is used to ensure that secure app servers are initially usable while waiting for signed certificates.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id to use for the creating the certificate.</param>
			<param name="valid-for" type="xs:unsignedInt" optional="false">The number of days the certificate should be valid for</param>
			<param name="common-name" type="xs:string" optional="false">The common name to put into the template.</param>
			<param name="dns-name" type="xs:string?" optional="false">The DNS name, if any, to substitute into the template.</param>
			<param name="ip-addr" type="xs:string?" optional="false">The IP address, if any, to substitute into the template</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  let $tid := pki:template-get-id(pki:get-template-by-name("test"))

  return
     pki:generate-temporary-certificate-if-necessary($tid, 150, "My.Host.com", (), ())

  (: Generates a temporary certificate, if one does not already exist for the template :)

</example>
	</function>
	<function name="generate-temporary-certificate" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:generate-temporary-certificate">
		<summary>This function generates a new key pair and temporary certificate from the specified certificate template. If $dns-name or $ip-addr are specified, those portions of the template are replaced with the specified values. The certificate is inserted into the database. This is used to ensure that secure app servers are initially usable while waiting for signed certificates.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id to use for the creating the certificate.</param>
			<param name="valid-for" type="xs:unsignedInt" optional="false">The number of days the certificate should be valid for</param>
			<param name="common-name" type="xs:string" optional="false">The common name to put into the template</param>
			<param name="dns-name" type="xs:string?" optional="false">The DNS name, if any, to substitute into the template.</param>
			<param name="ip-addr" type="xs:string?" optional="false">The IP address, if any, to substitute into the template</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
   (: execute this against the security database :)
   xquery version "1.0-ml";
   import module namespace pki = "http://marklogic.com/xdmp/pki"
       at "/MarkLogic/pki.xqy";

   let $tid := pki:template-get-id(pki:get-template-by-name("test"))

   return
       pki:generate-temporary-certificate($tid, 150, "My.Host.com", (), ())

  (: Generates a temporary certificate from the "test" template. :)

</example>
	</function>
	<function name="is-temporary" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:is-temporary">
		<summary>This function returns true if the certificate is temporary. Otherwise, it returns false.</summary>
		<params>
			<param name="cert" type="element(pki:certificate)" optional="false">The certificate to be tested.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $tid := pki:template-get-id(pki:get-template-by-name("mycert"))
  let $hostname := admin:host-get-name(
                       $config,
                       admin:host-get-id($config, xdmp:host-name()))

  return pki:is-temporary(pki:get-certificate($tid, $hostname, (), ()))

  (: Returns 'true' if certificate is temporary; otherwise 'false'. :)

</example>
	</function>
	<function name="get-certificate-xml" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-certificate-xml">
		<summary>This function returns the XML representation of the certificate for the specified id and common host name combination.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificate to be returned.</param>
			<param name="hostname" type="xs:string" optional="false">The common host name, if any.</param>
		</params>
		<return>element(x509:cert)*</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";
  import module namespace admin = "http://marklogic.com/xdmp/admin"
      at "/MarkLogic/admin.xqy";

  let $config := admin:get-configuration()
  let $tid := pki:template-get-id(pki:get-template-by-name("test"))
  let $hostname := admin:host-get-name(
                       $config,
                       admin:host-get-id($config, xdmp:host-name()))

  return
     pki:get-certificate-xml($tid, $hostname)

  (: Returns the certificate in XML format for the local host. :)

</example>
	</function>
	<function name="get-certificates-for-template-xml" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-certificates-for-template-xml">
		<summary>This function returns all of the certificates for the specified certificate template in XML format.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificates to be returned.</param>
		</params>
		<return>element(x509:cert)*</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";
  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  let $tid := pki:template-get-id(pki:get-template-by-name("mycert"))

  return
     pki:get-certificates-for-template-xml($tid)

  (: Returns the certificates for the "mycert" template in XML format. :)

</example>
	</function>
	<function name="get-certificate-pem" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-certificate-pem">
		<summary>This function returns the PEM encoded certificate for the specified certificate template and common name combination.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificate to be returned.</param>
			<param name="hostname" type="xs:string" optional="false">The common host name, if any.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
    (: execute this against the security database :)
    xquery version "1.0-ml";
    import module namespace pki = "http://marklogic.com/xdmp/pki"
          at "/MarkLogic/pki.xqy";
    import module namespace admin = "http://marklogic.com/xdmp/admin"
          at "/MarkLogic/admin.xqy";

    let $config := admin:get-configuration()
    let $tid := pki:template-get-id(pki:get-template-by-name("mycert"))
    let $hostname := admin:host-get-name(
                       $config,
                       admin:host-get-id($config, xdmp:host-name()))

    return pki:get-certificate-pem($tid, $hostname)

  =&gt;
      -----BEGIN CERTIFICATE-----
      MIICbzCCAdigAwIBAgIEL9pBCTANBgkqhkiG9w0BAQUFADBrMQswCQYDVQQGEwJV
      UzELMAkGA1UECBMCQ0ExEzARBgNVBAcTClNhbiBDYXJsb3MxEzARBgNVBAoTCk1h
      cmsgTG9naWMxJTAjBgNVBAMTHGhwNjkxMC02MjR2NjRiLm1hcmtsb2dpYy5jb20w
      HhcNMDkwMjE4MjAxOTA4WhcNMTAwMjE4MjAxOTA4WjBrMQswCQYDVQQGEwJVUzEL
      MAkGA1UECBMCQ0ExEzARBgNVBAcTClNhbiBDYXJsb3MxEzARBgNVBAoTCk1hcmsg
      TG9naWMxJTAjBgNVBAMTHGhwNjkxMC02MjR2NjRiLm1hcmtsb2dpYy5jb20wgZ8w
      DQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAM/gj+cfWnL2IOsUgbiKhEahbdbCye57
      NcschJ0mMzBaHcJ43u/HhJI11RhW9rCUaF9h8JAMmtP03TFEkFzaUs9NZNTqvVzH
      mWjk71oKvy/JJUley15Lbs/twqmDo6punvsWFbjxKt6kzjrg6NMNTxn2pGOtYEf6
      yymUfL19J069AgMBAAGjIDAeMAkGA1UdEwQCMAAwEQYJYIZIAYb4QgEBBAQDAgZA
      MA0GCSqGSIb3DQEBBQUAA4GBAJvN5UVn/b6S2XUYge9aQDiIhyc1EwbWyuXxvA6i
      WCiTWUl/2Dbh+UNjK+KwLvxO8wR4RLO4TtX86XA0Up+3fpLDyY+Q3W0Q2uj6ZzMe
      pRmQyo67qQDrfJU8bgUzx0uqTEbgYhGyJ3IQuNpUWt9tZty6+4i6WdCgGVA9CWuU
      ujPm
      -----END CERTIFICATE-----

</example>
	</function>
	<function name="get-template-by-name" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-template-by-name">
		<summary>This function returns the certificate template with the specified name.</summary>
		<params>
			<param name="template-name" type="xs:string" optional="false">The name of the template to be returned.</param>
		</params>
		<return>element(pki:template)*</return>
		<example xml:space="preserve">
    (: execute this against the security database :)
    xquery version "1.0-ml";
    import module namespace pki = "http://marklogic.com/xdmp/pki"
        at "/MarkLogic/pki.xqy";

    pki:get-template-by-name("test")

    (: Returns the certificate template, named "test". :)

</example>
	</function>
	<function name="get-template-certificate-authority" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-template-certificate-authority">
		<summary>This function returns the certificate authority for the specified certificate template.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template for which to return the certificate authority.</param>
		</params>
		<return>element(pki:certificate)?</return>
		<example xml:space="preserve">
    (: execute this against the security database :)
    xquery version "1.0-ml";
    import module namespace pki = "http://marklogic.com/xdmp/pki"
        at "/MarkLogic/pki.xqy";

    let $tid := pki:template-get-id(pki:get-template-by-name("mycert"))

    return
        pki:get-template-certificate-authority($tid)

    (: Return the certificate authority for the "mycert" template. :)

</example>
	</function>
	<function name="generate-template-certificate-authority" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:generate-template-certificate-authority">
		<summary>This function creates a common temporary certificate authority to sign all the certificates for the specified certificate template.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template for which to create the certificate authority.</param>
			<param name="valid-for" type="xs:unsignedInt" optional="false">The number of days the generated certificate will be valid.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
    (: execute this against the security database :)
    xquery version "1.0-ml";
    import module namespace pki = "http://marklogic.com/xdmp/pki"
        at "/MarkLogic/pki.xqy";

    let $tid := pki:template-get-id(pki:get-template-by-name("mycert"))

    return
        pki:generate-template-certificate-authority($tid, 250)

    (: Generate a certificate authority for the "mycert" template. :)

</example>
	</function>
	<function name="get-certificates" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-certificates">
		<summary>This function returns the certificate data for the specified certificates.</summary>
		<params>
			<param name="cert-id" type="xs:unsignedLong*" optional="false">One or more certificate ids.</param>
		</params>
		<return>element(pki:certificate)*</return>
		<example xml:space="preserve">
  (: execute this against the security database :)
  xquery version "1.0-ml";

  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  pki:get-certificates(
           pki:get-trusted-certificate-ids()) [pki:authority = fn:true()]

  (: Returns all of the certificates generated by a certificate authority. :)

</example>
	</function>
	<function name="get-certificates-for-template" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:get-certificates-for-template">
		<summary>This function returns all of the certificates for the specified certificate template.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The certificate template id for the certificates to be returned.</param>
		</params>
		<return>element(pki:certificate)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  let $tid := pki:template-get-id(pki:get-template-by-name("mycert"))

  return
     pki:get-certificates-for-template($tid)

  (: Returns the certificates for the "mycert" template. :)

</example>
	</function>
	<function name="template-in-use" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:template-in-use">
		<summary>This function checks whether a certificate template is in use by an App Server. Returns
			<code>true</code>if the template is in use. Otherwise
			<code>false</code>is returned.</summary>
		<params>
			<param name="template-id" type="xs:unsignedLong" optional="false">The id of the certificate template to be tested.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace pki = "http://marklogic.com/xdmp/pki"
      at "/MarkLogic/pki.xqy";

  let $tid := pki:template-get-id(pki:get-template-by-name("mycert"))

  return
     pki:template-in-use($tid)

  (: Returns 'true' if the template is in use by an App Server.  Otherwise, 'false'. :)

</example>
	</function>
	<function name="insert-certificate-revocation-list" lib="pki" category="PKI" bucket="XQuery Library Modules" hidden="false" fullname="pki:insert-certificate-revocation-list">
		<summary>This function inserts a PEM- or DER-encoded Certificate Revocation List (CRL) into the security database. A CRL is a list of certificate serial numbers that have been revoked, and the revocation date of each. The CRL is signed by the Certificate Authority to verify its accuracy. The CRL contains two dates, one indicating when it was published and the other indicating when it will next be published. This is useful in determining whether a newer CRL should be fetched.
			<p />Certificate Authorities typically allow the CRL to be downloaded via HTTP. The document URL in the database is derived from the URL passed in to the function, so Inserting a newer CRL retrieved from the same URL will replace the previous one in the database.</summary>
		<params>
			<param name="url" type="xs:string" optional="false">The URL from which the CRL was downloaded.</param>
			<param name="crl" type="item()" optional="false">The PEM- or DER-encoded CRL.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace pki = "http://marklogic.com/xdmp/pki"
  at "/MarkLogic/pki.xqy";

  let $URI := "http://crl.verisign.com/pca3.crl"

  return
      pki:insert-certificate-revocation-list(
           $URI,
           xdmp:document-get($URI)/binary() )

  (: Inserts a CRL from Verisign into the database. :)

</example>
	</function>
	<function name="plugins" lib="plugin" category="Plugin" bucket="XQuery Library Modules" hidden="false" fullname="plugin:plugins">
		<summary>This function returns unique IDs of the registered plugins that have the specified capabilities. If no matching plugins are registered, an empty sequence is returned.</summary>
		<params>
			<param name="capability" type="xs:string*" optional="false">A list of strings representing desired capabilities to match. The plugin must match all of the listed capabilities. Specify an empty sequence to return the IDs of all of the plugins.</param>
			<param name="scope" type="xs:string" optional="true">A scope identifier. This must be a "dotted" package-style path, which will be resolved relative to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins</code>directory. For example, a
				<code>$scope</code>value of
				<code>my-plugin-scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/myplugin-scope</code>directory and a
				<code>$scope</code>value of
				<code>my.plugin.scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/my/plugin/scope</code>directory.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace plugin = "http://marklogic.com/extension/plugin"
      at "/MarkLogic/plugin/plugin.xqy";

  plugin:plugins("http://marklogic.com/appservices/infostudio/collector/abort")

  (: Lists all collector plugins with the 'abort' capability. :)

</example>
	</function>
	<function name="enumerate" lib="plugin" category="Plugin" bucket="XQuery Library Modules" hidden="false" fullname="plugin:enumerate">
		<summary>This function enumerates functions implementing all capabilities supported by the given plugin. It returns a map, keyed on the capabilities.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The unique identifier of the plugin.</param>
			<param name="scope" type="xs:string" optional="true">A scope identifier. This must be a "dotted" package-style path, which will be resolved relative to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins</code>directory. For example, a
				<code>$scope</code>value of
				<code>my-plugin-scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/myplugin-scope</code>directory and a
				<code>$scope</code>value of
				<code>my.plugin.scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/my/plugin/scope</code>directory.</param>
		</params>
		<return>map:map</return>
		<example xml:space="preserve">

  xquery version "1.0-ml";

  import module namespace plugin = "http://marklogic.com/extension/plugin"
      at "/MarkLogic/plugin/plugin.xqy";

  plugin:enumerate("plugin:collector-filescan.xqy")

  (: Returns the capabilities map for the filescan collector. :)

</example>
	</function>
	<function name="capability" lib="plugin" category="Plugin" bucket="XQuery Library Modules" hidden="false" fullname="plugin:capability">
		<summary>This function returns a function pointer implementing a given capability from a particular plugin. If the plugin doesn't exist an exception is thrown. If the plugin does exist but the capability isn't present, an empty sequence is returned.</summary>
		<params>
			<param name="capability" type="xs:string" optional="false">The desired capability to match.</param>
			<param name="uri" type="xs:string" optional="false">The unique identifier of the plugin.</param>
			<param name="scope" type="xs:string" optional="true">A scope identifier. This must be a "dotted" package-style path, which will be resolved relative to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins</code>directory. For example, a
				<code>$scope</code>value of
				<code>my-plugin-scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/myplugin-scope</code>directory and a
				<code>$scope</code>value of
				<code>my.plugin.scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/my/plugin/scope</code>directory.</param>
		</params>
		<return>xdmp:function?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace plugin = "http://marklogic.com/extension/plugin"
      at "/MarkLogic/plugin/plugin.xqy";

  plugin:capability(
     "http://marklogic.com/appservices/infostudio/collector/cancel",
     "plugin:collector-filescan.xqy")

  (: Returns a pointer to the function that implements the 'cancel' capability. :)

</example>
	</function>
	<function name="implementations" lib="plugin" category="Plugin" bucket="XQuery Library Modules" hidden="false" fullname="plugin:implementations">
		<summary>This function returns a map referencing all of the plugins that implement the specified capability. If no plugins implement the given capability, returns an empty map.</summary>
		<params>
			<param name="capability" type="xs:string" optional="false">The desired capability to match.</param>
			<param name="scope" type="xs:string" optional="true">A scope identifier. This must be a "dotted" package-style path, which will be resolved relative to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins</code>directory. For example, a
				<code>$scope</code>value of
				<code>my-plugin-scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/myplugin-scope</code>directory and a
				<code>$scope</code>value of
				<code>my.plugin.scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/my/plugin/scope</code>directory.</param>
		</params>
		<return>map:map</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace plugin = "http://marklogic.com/extension/plugin"
      at "/MarkLogic/plugin/plugin.xqy";

  plugin:implementations(
     "http://marklogic.com/appservices/infostudio/collector/cancel")

  (: Returns a pointer to the function that implements the 'cancel' capability
     for each plugin that implements 'cancel'. :)

</example>
	</function>
	<function name="register" lib="plugin" category="Plugin" bucket="XQuery Library Modules" hidden="false" fullname="plugin:register">
		<summary>This function registers the capabilities map for use by MarkLogic Server. It returns the URI of the plugin.</summary>
		<params>
			<param name="capabilities" type="map:map" optional="false">The map of capabilities to be registered.</param>
			<param name="plugin-uri" type="xs:string" optional="false">An identifier that uniquely identifies this plugin. If a plugin is added with the same identifier as an existing plugin, then the newly registered plugin will be used.</param>
		</params>
		<return>xs:string</return>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/plugin-register</code>
			</p>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  declare namespace testdoc = "http://marklogic.com/extension/plugin/testdoc";

  import module namespace plugin = "http://marklogic.com/extension/plugin"
      at "/MarkLogic/plugin/plugin.xqy";

  declare function testdoc:capabilities()
  as map:map
  {
   let $map := map:map()
   let $_ := map:put($map,
                "http://marklogic.com/appservices/infostudio/collector/model",
                xdmp:function(xs:QName("testdoc:model")))
   let $_ := map:put($map,
	       "http://marklogic.com/appservices/infostudio/collector/start",
                xdmp:function(xs:QName("testdoc:start")))
   let $_ := map:put($map,
	"http://marklogic.com/appservices/infostudio/collector/config-view",
        xdmp:function(xs:QName("testdoc:view")))
   let $_ := map:put($map,
	"http://marklogic.com/appservices/infostudio/collector/cancel",
         xdmp:function(xs:QName("testdoc:cancel")))
   let $_ := map:put($map,
	 "http://marklogic.com/appservices/infostudio/collector/abort",
         xdmp:function(xs:QName("testdoc:abort")))
   let $_ := map:put($map,
	 "http://marklogic.com/appservices/infostudio/collector/validate",
         xdmp:function(xs:QName("testdoc:validate")))
   let $_ := map:put($map, "http://marklogic.com/appservices/string",
                       xdmp:function(xs:QName("testdoc:string")))
   return $map
  };

  (: Implement the functions in the capabilities map. :)

  plugin:register(testdoc:capabilities(), "testdoc.xqy")

  (: Registers the capabilities in the map for this plugin. :)

</example>
	</function>
	<function name="initialize-scope" lib="plugin" category="Plugin" bucket="XQuery Library Modules" hidden="false" fullname="plugin:initialize-scope">
		<summary>
			<p>This function ensures the availability of all plugins from a given scope. A scope is a directory relative to
				<code>
					<em>marklogic-dir</em>/Assets/plugins</code>. Attempting to reload the System scope (with an empty string for
				<code>$scope</code>) has no effect (and hence returns 0). Any application that calls this function must do so through a function amped to the
				<code>application-plugin-registrar</code>role.</p>
			<p>This function MUST be called by an application before querying or enumerating plugins (or else see an empty set of available plugins). Even if called on every request, this function will only load from the directory on the first call. This function checks the global debug flag, and if true, forces a reload on every request.</p>
		</summary>
		<params>
			<param name="scope" type="xs:string" optional="false">A scope identifier. This must be a "dotted" package-style path, which will be resolved relative to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins</code>directory. For example, a
				<code>$scope</code>value of
				<code>my-plugin-scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/myplugin-scope</code>directory and a
				<code>$scope</code>value of
				<code>my.plugin.scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/my/plugin/scope</code>directory.</param>
		</params>
		<return>xs:integer</return>
		<privilege>
			<p>This function requires the privileges in the
				<code>application-plugin-registrar</code>role, and the best practice is to put
				<code>plugin:initialize-scope</code>in a a function that is amped to the
				<code>application-plugin-registrar</code>role.</p>
		</privilege>
		<example xml:space="preserve">
xquery version "1.0-ml";

import module namespace plugin = "http://marklogic.com/xdmp/plugin"
    at "/MarkLogic/plugin.xqy";

plugin:initialize-scope("my-plugin-scope")

</example>
	</function>
	<function name="flush-scope" lib="plugin" category="Plugin" bucket="XQuery Library Modules" hidden="false" fullname="plugin:flush-scope">
		<summary>This function unloads all application plugins from a given scope. Note that system plugins are unaffected by this function. Like
			<code>plugin:initialize-scope</code>, this function requires the
			<code>application-plugin-registrar</code>role.</summary>
		<params>
			<param name="scope" type="xs:string" optional="false">A scope identifier. This must be a "dotted" package-style path, which will be resolved relative to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins</code>directory. For example, a
				<code>$scope</code>value of
				<code>my-plugin-scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/myplugin-scope</code>directory and a
				<code>$scope</code>value of
				<code>my.plugin.scope</code>is resolved to the
				<code>
					<em>marklogic-dir</em>/Assets/plugins/my/plugin/scope</code>directory.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>This function requires the privileges in the
			<code>application-plugin-registrar</code>role, and the best practice is to put
			<code>plugin:flush-scope</code>in a function that is amped to the
			<code>application-plugin-registrar</code>role.</privilege>
		<example xml:space="preserve">
xquery version "1.0-ml";

import module namespace plugin = "http://marklogic.com/xdmp/plugin"
    at "/MarkLogic/plugin.xqy";

plugin:flush-scope("my-plugin-scope")
</example>
	</function>
	<function name="clean" type="powerpoint" lib="ppt" category="Powerpoint Conversion" bucket="CPF Functions" hidden="false" fullname="ppt:clean">
		<summary>Clean up any conversion artifacts or other infelicities, putting each slide into its own div element.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The source URI of the converted presentation.</param>
			<param name="doc" type="node()?" optional="false">The XHTML produced by conversion of a Microsoft Powerpoint presentation.</param>
		</params>
		<return>node()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace ppt = "http://marklogic.com/cpf/powerpoint"
	         at "/MarkLogic/conversion/powerpoint.xqy";

  ppt:clean("my_ppt.xhtml",fn:doc("my_ppt.xhtml"))

</example>
	</function>
	<function name="enable" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:enable">
		<summary>
			<p>Enable profiling for this request. Profiling may be enabled or disabled as often as you like. Enabling while a request is enabled has no effect.</p>
			<p>If profiling is not allowed for the App Server, this function does nothing.</p>
			<p>Note that profiling does not cross eval/invoke boundaries. If the request being profiled calls xdmp:eval or xdmp:invoke, the individual expressions in that code will not be profiled. The overall time taken by the called code will appear as a single call in the caller's profiling report.</p>
		</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong" optional="false">A request ID. Use the
				<code>xdmp:request()</code>function, which returns the request ID for the currently running request, to specify the current request.</param>
		</params>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for profiling requests other than the current request, with the
				<code>profile-my-requests</code>privilege allowing profiling of requests issued by the same user ID, and the
				<code>profile-any-requests</code>privilege allowing profiling of requests issued by any user ID. No privilege is required to profile the currently running request (that is, self-profiling is always allowed).</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  prof:enable(xdmp:request())
  =&gt; ()

</example>
	</function>
	<function name="disable" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:disable">
		<summary>Disable profiling for this request. Profiling may be enabled or disabled as often as you like. Disabling does not clear accumulated profiling statistics. Disabling while disabled has no effect. If profiling is not allowed for the App Server, this function does nothing.</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong" optional="false">A request ID. Use the
				<code>xdmp:request()</code>function, which returns the request ID for the currently running request, to specify the current request.</param>
		</params>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for profiling requests other than the current request, with the
				<code>profile-my-requests</code>privilege allowing profiling of requests issued by the same user ID, and the
				<code>profile-any-requests</code>privilege allowing profiling of requests issued by any user ID. No privilege is required to profile the currently running request (that is, self-profiling is always allowed).</p>
		</privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>Any expressions evaluated after
				<code>prof:disable</code>is called (but before
				<code>prof:enable</code>is called again) will not be profiled and will not appear in the profile report.</p>
		</usage>
		<example xml:space="preserve">
  prof:disable(xdmp:request())
  =&gt; ()

</example>
    <example xml:space="preserve">
prof:enable(xdmp:request()),
fn:concat("hello", " world"),
prof:disable(xdmp:request()),
fn:current-dateTime(),
prof:report(xdmp:request())

  =&gt; A profile report that does not include
     the call to fn:current-dateTime().

</example>
	</function>
	<function name="reset" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:reset">
		<summary>Clear any accumulated profiling statistics for the requests. If profiling has never been started for the request, nothing is done. If profiling is not allowed for the App Server, this function does nothing.</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong" optional="false">A request ID. Use the
				<code>xdmp:request()</code>function, which returns the request ID for the currently running request, to specify the current request.</param>
		</params>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for profiling requests other than the current request, with the
				<code>profile-my-requests</code>privilege allowing profiling of requests issued by the same user ID, and the
				<code>profile-any-requests</code>privilege allowing profiling of requests issued by any user ID. No privilege is required to profile the currently running request (that is, self-profiling is always allowed).</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  prof:reset(xdmp:request())
  =&gt; ()

</example>
	</function>
	<function name="report" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:report">
		<summary>Return a
			<code>prof:report</code>node containing the current state of profiling statistics for the given request. If profiling has never been enabled for the request, the empty sequence is returned. If profiling is not allowed for the App Server, this function returns an empty sequence.</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong" optional="false">A request ID. Use the
				<code>xdmp:request()</code>function, which returns the request ID for the currently running request, to specify the current request.</param>
		</params>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for profiling requests other than the current request, with the
				<code>profile-my-requests</code>privilege allowing profiling of requests issued by the same user ID, and the
				<code>profile-any-requests</code>privilege allowing profiling of requests issued by any user ID. No privilege is required to profile the currently running request (that is, self-profiling is always allowed).</p>
		</privilege>
		<return>element(prof:report)?</return>
		<example xml:space="preserve">
(: Before running this, make sure profiling is enabled
   on the App Server :)
prof:enable(xdmp:request()),
fn:current-dateTime(),
prof:report(xdmp:request())
=&gt;

2007-02-16T19:24:30.093-08:00
&lt;prof:report xsi:schemaLocation="http://marklogic.com/xdmp/profile
   profile.xsd"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:prof="http://marklogic.com/xdmp/profile"&gt;
  &lt;prof:metadata&gt;
    &lt;prof:overall-elapsed&gt;PT0S&lt;/prof:overall-elapsed&gt;
    &lt;prof:created&gt;2007-02-16T19:24:30.093-08:00&lt;/prof:created&gt;
    &lt;prof:server-version&gt;3.2-20070214&lt;/prof:server-version&gt;
  &lt;/prof:metadata&gt;
  &lt;prof:histogram&gt;
    &lt;prof:expression&gt;
      &lt;prof:expr-id&gt;11698068205613195480&lt;/prof:expr-id&gt;
      &lt;prof:expr-source&gt;prof:report(xdmp:request())&lt;/prof:expr-source&gt;
      &lt;prof:uri/&gt;
      &lt;prof:line&gt;3&lt;/prof:line&gt;
      &lt;prof:count&gt;0&lt;/prof:count&gt;
      &lt;prof:shallow-time&gt;PT0S&lt;/prof:shallow-time&gt;
      &lt;prof:deep-time&gt;PT0S&lt;/prof:deep-time&gt;
    &lt;/prof:expression&gt;
    &lt;prof:expression&gt;
      &lt;prof:expr-id&gt;6277409173981051716&lt;/prof:expr-id&gt;
      &lt;prof:expr-source&gt;xdmp:request()&lt;/prof:expr-source&gt;
      &lt;prof:uri/&gt;
      &lt;prof:line&gt;3&lt;/prof:line&gt;
      &lt;prof:count&gt;1&lt;/prof:count&gt;
      &lt;prof:shallow-time&gt;PT0S&lt;/prof:shallow-time&gt;
      &lt;prof:deep-time&gt;PT0S&lt;/prof:deep-time&gt;
    &lt;/prof:expression&gt;
    &lt;prof:expression&gt;
      &lt;prof:expr-id&gt;13716364291188563274&lt;/prof:expr-id&gt;
      &lt;prof:expr-source&gt;current-dateTime()&lt;/prof:expr-source&gt;
      &lt;prof:uri/&gt;
      &lt;prof:line&gt;2&lt;/prof:line&gt;
      &lt;prof:count&gt;1&lt;/prof:count&gt;
      &lt;prof:shallow-time&gt;PT0S&lt;/prof:shallow-time&gt;
      &lt;prof:deep-time&gt;PT0S&lt;/prof:deep-time&gt;
    &lt;/prof:expression&gt;
    &lt;prof:expression&gt;
      &lt;prof:expr-id&gt;6174150852679522465&lt;/prof:expr-id&gt;
      &lt;prof:expr-source&gt;prof:enable(xdmp:request())&lt;/prof:expr-source&gt;
      &lt;prof:uri/&gt;
      &lt;prof:line&gt;1&lt;/prof:line&gt;
      &lt;prof:count&gt;1&lt;/prof:count&gt;
      &lt;prof:shallow-time&gt;PT0S&lt;/prof:shallow-time&gt;
      &lt;prof:deep-time&gt;PT0S&lt;/prof:deep-time&gt;
    &lt;/prof:expression&gt;
  &lt;/prof:histogram&gt;
&lt;/prof:report&gt;


</example>
	</function>
	<function name="allowed" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:allowed">
		<summary>
			<p>Returns the value of the Profile Allow setting for the App Server or Task Server upon which the target request is running. This function is useful to determine if subsequent calls to profiling functions will be effective.</p>
		</summary>
		<params>
			<param name="request-id" type="xs:unsignedLong" optional="false">A request ID.</param>
		</params>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for profiling requests other than the current request, with the
				<code>profile-my-requests</code>privilege allowing profiling of requests issued by the same user ID, and the
				<code>profile-any-requests</code>privilege allowing profiling of requests issued by any user ID. No privilege is required to profile the currently running request (that is, self-profiling is always allowed).</p>
		</privilege>
		<return>xs:boolean</return>
		<usage>
			<p>Use this function to determine if profiling is allowed on the App Server that owns the target request. This will indicate whether the other profiling functions will be effective.</p>
			<p>If the Profile Allow setting is off on the App Server, then calls to profiling functions do nothing and return the empty sequence. You can use
				<code>prof:allow</code>to test if profiling is allowed on the App Server, and if it is then use the other profiling APIs to profile other requests or to call
				<code>prof:eval</code>or
				<code>prof:invoke</code>; if it is not allowed, then your code does not call them. This type of logic allows you to keep profiling code in your XQuery code and it will only be executed if profiling is allowed in the context in which the code is run, thus allowing you to globally (at the App Server level) switch off profiling without breaking any code.</p>
			<p>Appropriate privileges are required to call this function, as with the other profiling functions. The return value is the state of the App Server Profile Allow setting. This function does not verify that the target request is stopped for debugging, which is required for one request to profile another.</p>
		</usage>
		<example xml:space="preserve">
  prof:allowed(xdmp:request())
  =&gt; true

</example>
    <example xml:space="preserve">
let $profallowed := prof:allowed(xdmp:request())
return
(
  if ( $profallowed )
  then ( prof:eval('fn:current-dateTime()') )
  else ( ),
  "your code here"
)

  =&gt; The profile report (only if profiling is enabled
     on the App Server) followed by the output of your code.

</example>
	</function>
	<function name="eval" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:eval">
		<summary>
			<p>Evaluate a string as an XQuery for profiling. A
				<code>prof:report</code>node will be prepended to any output produced by evaluating the string. If profiling is not allowed for the App Server, this function will throw a
				<code>PROF-PROFILEALLOW</code>exception.</p>
			<p>Note that profiling does not cross eval/invoke boundaries. If the request being profiled calls xdmp:eval or xdmp:invoke, the individual expressions in that code will not be profiled. The overall time taken by the called code will appear as a single call in the caller's profiling report.</p>
		</summary>
		<params>
			<param name="xquery" type="xs:string" optional="false">The XQuery string to be evaluated. If the XQuery string contains double quotes ("), surround the string with single quotes (').</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="options" type="node()?" optional="true">The options node, as for
				<code>xdmp:eval</code>. Must be in the
				<code>xdmp:eval</code>namespace.</param>
		</params>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for
				<code>prof:eval</code>(the
				<code>profile-my-requests</code>privilege is suffient because the resulting request is always run by the same user who initiated the call, but the
				<code>profile-any-requests</code>privilege will also work).</p>
		</privilege>
		<return>item()*</return>
		<example xml:space="preserve">
  prof:eval("xdmp:random()")
  =&gt; (&lt;prof:report&gt;...&lt;/prof:report&gt;,9478952250821284456)

</example>
	</function>
	<function name="invoke" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:invoke">
		<summary>
			<p>Profiles and returns the result of evaluating a module at the given path. Any result produced by the evaluation will be prepended with a
				<code>prof:report</code>node containing timing and count information about the evaluation. If profiling is not allowed for the App Server, this function will throw a
				<code>PROF-PROFILEALLOW</code>exception.</p>
			<p>Note that profiling does not cross eval/invoke boundaries. If the request being profiled calls xdmp:eval or xdmp:invoke, the individual expressions in that code will not be profiled. The overall time taken by the called code will appear as a single call in the caller's profiling report.</p>
		</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path of the module to be executed. The path is resolved against the root of the App Server evaluating the query. The path must resolve to a main module (not a library module).</param>
			<param name="vars" type="item()*" optional="true">The external variable values for this evaluation. This must be a sequence of even length, alternating QNames and items. Each QName and item pair specify a variable name and value.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node must be in the
				<code>xdmp:eval</code>namespace. See the
				<code>xdmp:eval</code>section for a list of options.</param>
		</params>
		<return>item()*</return>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for
				<code>prof:invoke</code>(the
				<code>profile-my-requests</code>privilege is suffient because the resulting request is always run by the same user who initiated the call, but the
				<code>profile-any-requests</code>privilege will also work).</p>
		</privilege>
		<example xml:space="preserve">
  prof:invoke("http://example.com/modules/foo.xqy")
  =&gt; (&lt;prof:report&gt;...&lt;/prof:report&gt;,42)
</example>
		<algorithm />
	</function>
	<function name="value" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:value">
		<summary>Evaluate an expression in the context of the current evaluating statement and return the profiling report for its evaluation. This differs from
			<code>prof:eval</code>in that
			<code>prof:value</code>preserves all of the context from the calling query, so you do not need to re-define namespaces, variables, and so on. Although the expression retains the context from the calling query, it is evaluated in its own transaction.</summary>
		<params>
			<param name="expr" type="xs:string" optional="false">The string representing an expression to evaluate.</param>
		</params>
		<usage>
			<p>You can only evaluate and profile expressions with
				<code>prof:value</code>; no prolog definitions (namespace declarations, function definitions, module imports, and so on) are allowed.</p>
		</usage>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for
				<code>prof:invoke</code>(the
				<code>profile-my-requests</code>privilege is suffient because the resulting request is always run by the same user who initiated the call, but the
				<code>profile-any-requests</code>privilege will also work).</p>
		</privilege>
		<return>item()*</return>
		<example xml:space="preserve">
  prof:value("xdmp:random()")
  =&gt; (&lt;prof:report&gt;...&lt;/prof:report&gt;,9478952250821284456)
</example>
	</function>
	<function name="xslt-eval" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:xslt-eval">
		<summary>
			<p>Evaluate a string as an XSLT stylesheet for profiling. A
				<code>prof:report</code>node will be prepended to any output produced by evaluating the string. If profiling is not allowed for the App Server, this function will throw a
				<code>PROF-PROFILEALLOW</code>exception.</p>
			<p>Note that profiling does not cross eval/invoke boundaries. If the request being profiled calls xdmp:eval or xdmp:invoke, the individual expressions in that code will not be profiled. The overall time taken by the called code will appear as a single call in the caller's profiling report.</p>
		</summary>
		<params>
			<param name="stylesheet" type="element()" optional="false">The stylesheet to be executed.</param>
			<param name="input" type="node()?" optional="false">The context node to which the stylesheet is applied.</param>
			<param name="params" type="map:map?" optional="true">The stylesheet parameter values for this evaluation. Each key in the map is a string representing the name of the parameter in Clark notation: "{namespaceURI}localname". Each entry in the map is the value of the corresponding parameter.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node must be in the
				<code>xdmp:eval</code>namespace. See the
				<a href="#xdmp:eval">
					<code>xdmp:eval</code>
				</a>section for a list of options. Additional options include:
				<dl>
					<dt>
						<p>&lt;mode&gt;</p>
					</dt>
					<dd>The initial stylesheet mode to use.</dd>
					<dt>
						<p>&lt;template&gt;</p>
					</dt>
					<dd>The name of the initial template to apply.</dd>
				</dl></param>
		</params>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for
				<code>prof:eval</code>(the
				<code>profile-my-requests</code>privilege is suffient because the resulting request is always run by the same user who initiated the call, but the
				<code>profile-any-requests</code>privilege will also work).</p>
		</privilege>
		<return>item()*</return>
	</function>
	<function name="xslt-invoke" type="builtin" lib="prof" category="ProfileBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="prof:xslt-invoke">
		<summary>
			<p>Profiles and returns the result of evaluating an XSLT stylesheet at the given path. Any result produced by the evaluation will be prepended with a
				<code>prof:report</code>node containing timing and count information about the evaluation. If profiling is not allowed for the App Server, this function will throw a
				<code>PROF-PROFILEALLOW</code>exception.</p>
			<p>Note that profiling does not cross eval/invoke boundaries. If the request being profiled calls xdmp:eval or xdmp:invoke, the individual expressions in that code will not be profiled. The overall time taken by the called code will appear as a single call in the caller's profiling report.</p>
		</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path of the stylesheet to be executed. The path is resolved against the root of the App Server evaluating the query, the Modules directory, or relative to the calling module. For details on resolving paths, see "Importing XQuery Modules and Resolving Paths" in the
				<em>Developer's Guide</em>.</param>
			<param name="input" type="node()?" optional="false">The context node to which the stylesheet is applied.</param>
			<param name="params" type="map:map?" optional="true">The stylesheet parameter values for this evaluation. Each key in the map is a string representing the name of the parameter in Clark notation: "{namespaceURI}localname". Each entry in the map is the value of the corresponding parameter.</param>
			<param name="options" type="node()?" optional="true">The options node. The default value is (). The node must be in the
				<code>xdmp:eval</code>namespace. See the
				<a href="#xdmp:eval">
					<code>xdmp:eval</code>
				</a>section for a list of options. Additional options include:
				<dl>
					<dt>
						<p>&lt;mode&gt;</p>
					</dt>
					<dd>The initial stylesheet mode to use.</dd>
					<dt>
						<p>&lt;template&gt;</p>
					</dt>
					<dd>The name of the initial template to apply.</dd>
				</dl></param>
		</params>
		<privilege>
			<p>Either
				<code>http://marklogic.com/xdmp/privileges/profile-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/profile-any-requests</code>is required for
				<code>prof:invoke</code>(the
				<code>profile-my-requests</code>privilege is suffient because the resulting request is always run by the same user who initiated the call, but the
				<code>profile-any-requests</code>privilege will also work).</p>
		</privilege>
		<return>item()*</return>
		<usage></usage>
		<example xml:space="preserve"></example>
		<algorithm />
	</function>
	<function name="rewrite" lib="rest" category="rest Library" bucket="XQuery Library Modules" hidden="false" fullname="rest:rewrite">
		<summary>This function is used in the URL rewriter to map the incoming request to an endpoint.</summary>
		<params>
			<param name="options" type="element(rest:options)" optional="false">The options node that defines the request.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace rest="http://marklogic.com/appservices/rest"
      at "/MarkLogic/appservices/utils/rest.xqy";

  declare default function namespace "http://www.w3.org/2005/xpath-functions";

  declare option xdmp:mapping "false";

  let $options :=
    &lt;rest:options&gt;
      &lt;rest:request uri="^/shake/endpoint/(.+)/(\d+)$" endpoint="/shake/endpoint.xqy"&gt;
        &lt;rest:uri-param name="play"&gt;$1.xml&lt;/rest:uri-param&gt;
        &lt;rest:uri-param name="act" as="decimal"&gt;$2&lt;/rest:uri-param&gt;
      &lt;/rest:request&gt;
      &lt;rest:request uri="^/shake/endpoint/(.+)/?$" endpoint="/shake/endpoint.xqy"&gt;
        &lt;rest:uri-param name="play"&gt;$1.xml&lt;/rest:uri-param&gt;
      &lt;/rest:request&gt;
    &lt;/rest:options&gt;

  let $rewrite := rest:rewrite($options)

  return
    $rewrite

  (: Rewrites a URL ending with either /shake/endpoint/play or /shake/endpoint/play/{number}
     for execution by the endpoint.xqy module. :)

</pre>

</example>
	</function>
	<function name="report-error" lib="rest" category="rest Library" bucket="XQuery Library Modules" hidden="false" fullname="rest:report-error">
		<summary>This function formats the specified error structure.</summary>
		<params>
			<param name="error" type="element()" optional="false">The error structure to be formatted.</param>
		</params>
		<return>element()</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace rest="http://marklogic.com/appservices/rest"
      at "/MarkLogic/appservices/utils/rest.xqy";

  try {
     let $params := rest:process-request($request)
     return
       ...the non-error case...
   } catch ($e) {
       rest:report-error($e)
   }



</pre>

</example>
	</function>
	<function name="check-options" lib="rest" category="rest Library" bucket="XQuery Library Modules" hidden="false" fullname="rest:check-options">
		<summary>This function validates the specified
			<code>options</code>node. Validation includes both schema validation and some additional rule-based validation. An empty sequence indicates valid options and any problems are reported via
			<code>rest:report</code>elements.</summary>
		<params>
			<param name="options" type="element(rest:options)" optional="false">The options node to be validated.</param>
		</params>
		<return>element(rest:report)*</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace rest="http://marklogic.com/appservices/rest"
      at "/MarkLogic/appservices/utils/rest.xqy";

      try {
         rest:check-options(
           &lt;options xmlns="http://marklogic.com/appservices/rest"&gt;
              &lt;request uri="^/(.+)$" endpoint="/endpoint.xqy"&gt;
                &lt;uri-param name="play"&gt;$1.xml&lt;/uri-param&gt;
              &lt;/request&gt;
           &lt;/options&gt;)
    } catch ($e) {
       rest:report-error($e)
    }

</pre>

</example>
	</function>
	<function name="get-raw-query-params" lib="rest" category="rest Library" bucket="XQuery Library Modules" hidden="false" fullname="rest:get-raw-query-params">
		<summary>This function extracts all of the query parameters and returns them in a map. This does not include the parameters that would be derived from matching the URI string. No error checking or type conversion is performed by this function. The parameters returned by this function are all strings, as they are not type checked.</summary>
		<return>map:map</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace rest="http://marklogic.com/appservices/rest"
     at "/MarkLogic/appservices/utils/rest.xqy";

  rest:get-raw-query-params ( )

  (: Returns a map of the query parameters. :)

</pre>

</example>
	</function>
	<function name="matching-request" lib="rest" category="rest Library" bucket="XQuery Library Modules" hidden="false" fullname="rest:matching-request">
		<summary>This function returns the
			<code>request</code>element in the
			<code>options</code>node that matches the specified URI. If you only specify options parameter, then the current environment is used for all the other parameters.</summary>
		<params>
			<param name="options" type="element(rest:options)" optional="false">The options node.</param>
			<param name="uri" type="xs:string" optional="true">The URI with which to locate the matching
				<code>request</code>element.</param>
			<param name="method" type="xs:string" optional="true">The HTTP method to match with the
				<code>request</code>element.</param>
			<param name="accept-headers" type="xs:string" optional="true">The accept header. The Accept request-header to match any accept conditions in the
				<code>request</code>element.</param>
			<param name="user-params" type="map:map" optional="true">The user parameters to match with those in the
				<code>request</code>element.</param>
		</params>
		<return>element(rest:request)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace rest="http://marklogic.com/appservices/rest"
  at "/MarkLogic/appservices/utils/rest.xqy";

  declare option xdmp:mapping "false";

  let $options :=
    &lt;options xmlns="http://marklogic.com/appservices/rest"&gt;
      &lt;request uri="^/shakespeare/(.+)/(.+)" endpoint="/redirect.xqy"&gt;
        &lt;uri-param name="__ml_redirect__"&gt;/$1/$2&lt;/uri-param&gt;
      &lt;/request&gt;
      &lt;request uri="^/shakespeare/(.+)" endpoint="/redirect.xqy"&gt;
        &lt;uri-param name="__ml_redirect__"&gt;/$1&lt;/uri-param&gt;
      &lt;/request&gt;
      &lt;request uri="^/(.+)/act(\d+)" endpoint="/endpoint.xqy"&gt;
        &lt;uri-param name="play"&gt;$1.xml&lt;/uri-param&gt;
        &lt;uri-param name="act" as="integer"&gt;$2&lt;/uri-param&gt;
        &lt;param name="scene" as="integer" values="1|2|3" default="1"/&gt;
      &lt;/request&gt;
      &lt;request uri="^/(.+)$" endpoint="/endpoint.xqy"&gt;
        &lt;uri-param name="play"&gt;$1.xml&lt;/uri-param&gt;
      &lt;/request&gt;
      &lt;request uri="^(.+)$" endpoint="/options.xqy" user-params="allow"&gt;
        &lt;uri-param name="__ml_options__"&gt;$1&lt;/uri-param&gt;
        &lt;http method="OPTIONS"/&gt;
      &lt;/request&gt;
    &lt;/options&gt;

  let $uri     := "/shakespeare/hamlet"
  let $accept  := xdmp:get-request-header("Accept")
  let $params  := map:map()

  return rest:matching-request($options, $uri, "GET", $accept, $params)

  (: Returns the request node that matches the URI, "/shakespeare/hamlet". :)

</pre>

</example>
	</function>
	<function name="process-request" lib="rest" category="rest Library" bucket="XQuery Library Modules" hidden="false" fullname="rest:process-request">
		<summary>This function is used in the endpoint main module to parse the incoming request against the options. It returns a map that contains all of the parameters as typed values. Processing the request also checks all of the associated conditions and will raise an error if any condition is not met.
			<p />If the request is processed successfully, then all of the conditions have been met and the returned map contains all of the parameters. If not, an error occurs.</summary>
		<params>
			<param name="request" type="element(rest:request)" optional="false">The request to be processed into a map.</param>
		</params>
		<return>map:map</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace rest="http://marklogic.com/appservices/rest"
      at "/MarkLogic/appservices/utils/rest.xqy";

  declare default function namespace "http://www.w3.org/2005/xpath-functions";

  declare option xdmp:mapping "false";

  let $request :=
    &lt;rest:request uri="^/endpoint/(.+)/(\d+)$" endpoint="/endpoint.xqy"&gt;
      &lt;rest:uri-param name="play"&gt;$1.xml&lt;/rest:uri-param&gt;
      &lt;rest:uri-param name="act" as="decimal" optional="true"&gt;$2&lt;/rest:uri-param&gt;
    &lt;/rest:request&gt;

  let $map  := rest:process-request($request)
  let $play := map:get($map, "play")
  let $num  := map:get($map, "act")

  return
    if (empty($num))
    then
      fn:doc($play)
    else
      fn:doc($play)/PLAY/ACT[$num]

  (: The rest:process-request returns a map from $request that contains the
     keys 'play' and 'act', which are use to return either the contents of
     an entire play or a specific act in the play. :)

</pre>

</example>
	</function>
	<function name="check-request" lib="rest" category="rest Library" bucket="XQuery Library Modules" hidden="false" fullname="rest:check-request">
		<summary>This function takes a
			<code>request</code>element and returns a report of the problems found. If this function does not return an empty sequence, you have made a mistake and the library will not perform reliably.</summary>
		<params>
			<param name="options" type="element(rest:request)" optional="false">The options node that defines the request.</param>
		</params>
		<return>element(rest:report)?</return>
		<example xml:space="preserve">
<pre xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace rest="http://marklogic.com/appservices/rest"
      at "/MarkLogic/appservices/utils/rest.xqy";

  rest:check-request(
    &lt;request uri="^/(.+)$"
             endpoint="/endpoint.xqy"
             xmlns="http://marklogic.com/appservices/rest"&gt;
      &lt;uri-param name="play"&gt;$1.xml&lt;/uri-param&gt;
    &lt;/request&gt;)



</pre>

</example>
	</function>
	<function name="check-options" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:check-options">
		<summary>This function verifies that options XML is properly structured. Used in debugging, normally not in production. Returns the empty sequence on success, otherwise it returns one or more error messages inside
			<code>&lt;report&gt;</code>elements.</summary>
		<params>
			<param name="options" type="element(search:options)?" optional="false">Options to define the search grammar and control the search. See description for
				<a href="#search-options">
					<code>$options</code>
				</a>for the function
				<code>search:search</code>.</param>
			<param name="strict" type="xs:boolean?" optional="true">If
				<code>true</code>, index settings are additionally verified. The default is
				<code>false</code>.</param>
		</params>
		<return>element(search:report)*</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:check-options(
    &lt;options xmlns="http://marklogic.com/appservices/search"&gt;
      &lt;grammar&gt;
        &lt;joiner strength="10" apply="infix"
                element="cts:or-query"&gt;|&lt;/joiner&gt;
        &lt;joiner strength="20" apply="infix"
                element="cts:and-query"&gt;&amp;amp;&lt;/joiner&gt;
      &lt;/grammar&gt;
    &lt;/options&gt;)

=&gt;

()


</example>
	</function>
	<function name="estimate" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:estimate">
		<summary>This function quickly estimates the number of hits a query will return. The result is unfiltered and reflects the index resolution of the search (like
			<code>xdmp:estimate</code>).</summary>
		<params>
			<param name="cts-query" type="schema-element(cts:query)" optional="false">A serialized and annotated
				<code>cts:query</code>, typically the result of a call to
				<a href="#search:parse">
					<code>search:parse</code>
				</a>.</param>
			<param name="options" type="element(search:options)?" optional="true">Options to define the search grammar and control the search. See description for
				<a href="#search-options">
					<code>$options</code>
				</a>for the function
				<code>search:search</code>.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:estimate(search:parse("Vannevar Bush"))

=&gt;

12345


</example>
	</function>
	<function name="get-default-options" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:get-default-options">
		<summary>This function returns the default options XML. Default options do not contain any constraints or anything else that requires specific index settings.</summary>
		<return>element(search:options)</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:get-default-options()

=&gt;

&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
  ...
&lt;/options&gt;


</example>
	</function>
	<function name="parse" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:parse">
		<summary>This function parses query text according to given options and returns the appropriate
			<code>cts:query</code>XML.</summary>
		<params>
			<param name="qtext" type="xs:string+" optional="false">The query text to parse. This may be a sequence, to accommodate more complex search UI. Multiple query texts will be ANDed together.</param>
			<param name="options" type="element(search:options)?" optional="true">Options to define the search grammar and control the search. See description for
				<a href="#search-options">
					<code>$options</code>
				</a>for the function
				<code>search:search</code>.</param>
		</params>
		<return>element()?</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
     at "/MarkLogic/appservices/search/search.xqy";

search:parse("tag:technology AND format:pdf",
   &lt;options xmlns="http://marklogic.com/appservices/search"&gt;
     &lt;constraint name="tag"&gt;
       &lt;collection/&gt;
     &lt;/constraint&gt;
     &lt;constraint name="format"&gt;
        &lt;value&gt;
          &lt;element ns="http://purl.org/dc/elements/1.1/" name="tag"/&gt;
        &lt;/value&gt;
     &lt;/constraint&gt;
   &lt;/options&gt;
)
=&gt;

&lt;cts:and-query qtextjoin="AND" strength="20"
	xmlns:cts="http://marklogic.com/cts"&gt;
  &lt;cts:collection-query qtextpre="tag:" qtextref="cts:annotation"&gt;
   &lt;cts:annotation qtextref="following-sibling::cts:uri"/&gt;
   &lt;cts:uri&gt;technology&lt;/cts:uri&gt;
  &lt;/cts:collection-query&gt;
  &lt;cts:element-value-query qtextpre="format:" qtextref="cts:annotation"&gt;
   &lt;cts:element xmlns:_1="http://purl.org/dc/elements/1.1/"&gt;_1:tag&lt;/cts:element&gt;
   &lt;cts:annotation qtextref="following-sibling::cts:text"/&gt;
   &lt;cts:text&gt;pdf&lt;/cts:text&gt;
  &lt;/cts:element-value-query&gt;
&lt;/cts:and-query&gt;


</example>
	</function>
	<function name="remove-constraint" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:remove-constraint">
		<summary>This function safely removes a token from query text, ensuring that grammar elements (AND, OR, quotes, parentheses) are handled properly.</summary>
		<params>
			<param name="qtext" type="xs:string" optional="false">The full query text string.</param>
			<param name="ptext" type="xs:string" optional="false">A token to remove from full query text.</param>
			<param name="options" type="element(search:options)?" optional="false">Options to define the search grammar and control the search. See description for
				<a href="#search-options">
					<code>$options</code>
				</a>for the function
				<code>search:search</code>.</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
   at "/MarkLogic/appservices/search/search.xqy";

let $options :=
 &lt;options xmlns="http://marklogic.com/appservices/search"&gt;
   &lt;constraint name="tag"&gt;
     &lt;word&gt;
      &lt;element ns="http://widgets-r-us.com" name="tag"/&gt;
     &lt;/word&gt;
   &lt;/constraint&gt;
   &lt;constraint name="year"&gt;
     &lt;value&gt;
      &lt;element ns="http://widgets-r-us.com" name="year"/&gt;
     &lt;/value&gt;
   &lt;/constraint&gt;
 &lt;/options&gt;
return
search:remove-constraint("tag:foo AND (year:2007 OR year:2008)",
   "year:2008", $options)

=&gt;
"tag:foo AND year:2007"


</example>
	</function>
	<function name="resolve" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:resolve">
		<summary>This function is the same as
			<code>search:search</code>, except that it takes a parsed and annotated
			<code>cts:query</code>XML tree as input.</summary>
		<params>
			<param name="cts-query" type="schema-element(cts:query)" optional="false">A serialized and annotated
				<code>cts:query</code>, typically the result of a call to
				<a href="#search:parse">
					<code>search:parse</code>
				</a>.</param>
			<param name="options" type="element(search:options)?" optional="true">Options to define the search grammar and control the search. See description for
				<a href="#search-options">
					<code>$options</code>
				</a>for the function
				<code>search:search</code>.</param>
			<param name="start" type="xs:unsignedLong?" optional="true">The index of the first hit to return. The default is 1.</param>
			<param name="page-length" type="xs:unsignedLong?" optional="true">The maximum number of hits to return. The default is 10. If the value is 0, no results are returned.</param>
		</params>
		<return>element(search:response)</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:resolve(search:parse("Vannevar Bush"),
    &lt;options xmlns="http://marklogic.com/appservices/search"&gt;
      &lt;return-results&gt;false&lt;/return-results&gt;
      &lt;return-facets&gt;true&lt;/return-facets&gt;
    &lt;/options&gt;)

=&gt;

&lt;search:response total="1234" start="1" page-length="10" xmlns=""
        xmlns:search="http://marklogic.com/appservices/search"&gt;
  &lt;search:facet name="date"&gt;
	  &lt;search:facet-value value="today" count="1000"&gt;
	         Today&lt;/search:facet-value&gt;
	  &lt;search:facet-value value="yesterday" count="234"&gt;
	         Yesterday&lt;/search:facet-value&gt;
	  &lt;search:facet-value value="thismonth" count="1234"&gt;
	         This Month&lt;/search:facet-value&gt;
  &lt;search:/facet&gt;
    ...
&lt;/search:response&gt;


</example>
	</function>
	<function name="resolve-nodes" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:resolve-nodes">
		<summary>This function performs the same search as
			<code>search:search</code>, but it takes a parsed and annotated
			<code>cts:query</code>XML tree as input and returns the actual result nodes from the database.</summary>
		<params>
			<param name="cts-query" type="schema-element(cts:query)" optional="false">A serialized and annotated
				<code>cts:query</code>, typically the result of a call to
				<a href="#search:parse">
					<code>search:parse</code>
				</a>.</param>
			<param name="options" type="element(search:options)?" optional="true">Options to define the search grammar and control the search. See description for
				<a href="#search-options">
					<code>$options</code>
				</a>for the function
				<code>search:search</code>.</param>
			<param name="start" type="xs:unsignedLong?" optional="true">The index of the first hit to return. The default is 1.</param>
			<param name="page-length" type="xs:unsignedLong?" optional="true">The maximum number of hits to return. The default is 10. If the value is 0, no results are returned.</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:resolve-nodes(search:parse("Vannevar Bush"),
    &lt;options xmlns="http://marklogic.com/appservices/search"&gt;
      &lt;return-results&gt;false&lt;/return-results&gt;
      &lt;return-facets&gt;true&lt;/return-facets&gt;
    &lt;/options&gt;)

=&gt;

... sequence of document nodes ...



</example>
	</function>
	<function name="search" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:search">
		<summary>This function parses and invokes a query according to specified options, returning up to $page-length result nodes starting from $start.</summary>
		<params>
			<param name="qtext" type="xs:string+" optional="false">The query text to parse. This may be a sequence, to accommodate more complex search UI. Multiple query texts are combined with an AND operator.</param>
			<param name="options" type="element(search:options)?" optional="true">Options to define the search grammar and control the search.
				<p id="search-options">The following is a summary of the XML structure of an options node:</p>
				<blockquote>
					<dl>
						<dt>
							<pre xml:space="preserve">
&lt;additional-query&gt;
</pre>
						</dt>
						<dd>An additional serialized
							<code>cts:query</code>node, which is combined using a
							<code>cts:and-query</code>with the query resulting from the specified
							<code>$qtext</code>. The query results are constrained by the specified additional-query, but any terms matching the addtional-query are not highlighted in the snippet result output. For example, the following options node constrains the results to the directory named
							<code>/my/directory/</code>:
							<pre xml:space="preserve">
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
  &lt;additional-query&gt;{cts:directory-query("/my/directory/")}
  &lt;/additional-query&gt;
&lt;/options&gt;

</pre>
							<p>If you have multiple
								<code>additional-query</code>options, they are combined using a
								<code>cts:and-query</code>.</p></dd>
						<dt>
							<pre id="concurrency-level" xml:space="preserve">
&lt;concurrency-level&gt;
</pre>
						</dt>
						<dd>The maximum number of threads used to resolve facets. The default is 8, which specifies that at most 8 threads will be used concurrently to resolve facets. For example, the following specifies a concurrency level of 16:
							<pre xml:space="preserve">
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
	&lt;concurrency-level&gt;16&lt;/concurrency-level&gt;
&lt;/options&gt;

</pre></dd>
						<dt>
							<pre id="constraint" xml:space="preserve">
&lt;constraint&gt;
</pre>
						</dt>
						<dd>The outer wrapper element for a constraint definition. Constraints are used to define facets which can be returned as part of the search results. The default is no defined constraints.
							<p>Each
								<code>constraint</code>element must have an
								<code>@name</code>attribute (required), which is the unique name of this constraint. The name can then be used in the search grammar to specify the constraint.</p>
							<p>The
								<code>constraint</code>element can have zero or more of the following elements:</p>
							<dl>
								<dt>
									<pre xml:space="preserve">
&lt;value&gt;
</pre>
								</dt>
								<dd>Specifies element or attribute values on which to constrain. You cannot create facets from a
									<code>value</code>constraint. For example:
									<pre xml:space="preserve">
&lt;constraint name="my-value"&gt;
    &lt;value&gt;
      &lt;element ns="my-namespace" name="my-localname"/&gt;
    &lt;/value&gt;
&lt;/constraint&gt;
&lt;constraint name="my-attribute-value"&gt;
    &lt;value&gt;
      &lt;attribute ns="" name="my-attribute"/&gt;
      &lt;element ns="my-namespace" name="my-localname"/&gt;
    &lt;/value&gt;
&lt;/constraint&gt;
&lt;constraint name="fieldvalue"&gt;
    &lt;value&gt;
        &lt;field name="fieldvalue"/&gt;
    &lt;/value&gt;
&lt;/constraint&gt;
</pre></dd>
								<dt>
									<pre xml:space="preserve">
&lt;word&gt;
</pre>
								</dt>
								<dd>Specifies the element, attribute, or field on which to constrain by word. You cannot create facets from a
									<code>word</code>constraint. For example:
									<pre xml:space="preserve">
&lt;constraint name="name"&gt;
    &lt;word&gt;
      &lt;element ns="http://widgets-r-us.com" name="name"/&gt;
    &lt;/word&gt;
&lt;/constraint&gt;
&lt;constraint name="description"&gt;
    &lt;word&gt;
        &lt;field name="my-field"/&gt;
    &lt;/word&gt;
&lt;/constraint&gt;

</pre></dd>
								<dt>
									<pre xml:space="preserve">
&lt;collection&gt;
</pre>
								</dt>
								<dd>Specifies the collection on which to constrain. For example:
									<pre xml:space="preserve">
&lt;constraint name="my-collection"&gt;
    &lt;collection prefix="http://server.com/my-collection/"/&gt;
&lt;/constraint&gt;

</pre></dd>
								<dt>
									<pre xml:space="preserve">
&lt;range&gt;
</pre>
								</dt>
								<dd>Specifies the element or attribute on which to constrain by range. There must be a range index of the specified type (and collation for string range indexes) defined for the specified element or attribute. Each
									<code>range</code>element with a
									<code>type</code>attribute child, an optional
									<code>collation</code>attribute child (for string range indexes), an
									<code>element</code>child, an optional
									<code>attribute</code>child (for attribute ranges), and may have one or more
									<code>computed-bucket</code>children and/or one or more
									<code>facet-option</code>children (to pass options to the underlying lexicon apis). If it is a field range constraint, then the
									<code>range</code>element has a
									<code>field</code>child element with a
									<code>name</code>attribute. For example:
									<pre xml:space="preserve">
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
 &lt;constraint name="made"&gt;
    &lt;range type="xs:dateTime"&gt;&lt;!-- requires a dateTime range index --&gt;
    &lt;element ns="http://example.com" name="manufactured"/&gt;
    &lt;attribute ns="" name="date"/&gt;
    &lt;computed-bucket name="today" ge="P0D" lt="P1D"
            anchor="now"&gt;Today&lt;/computed-bucket&gt;
    &lt;computed-bucket name="30-days" ge="-P30D" lt="P1D"
            anchor="now"&gt;Last 30 days&lt;/computed-bucket&gt;
    &lt;computed-bucket name="60-days" ge="-P60D" lt="P1D"
            anchor="now"&gt;Last 60 Days&lt;/computed-bucket&gt;
    &lt;computed-bucket name="year" ge="-P1Y" lt="P1D"
            anchor="now"&gt;Last Year&lt;/computed-bucket&gt;
  &lt;/range&gt;
 &lt;/constraint&gt;
 &lt;constraint name="color"&gt;
   &lt;range type="xs:string"&gt;
     &lt;element ns="" name="bodycolor"/&gt;
   &lt;/range&gt;
 &lt;/constraint&gt;
 &lt;constraint name="name"&gt;
   &lt;range type="xs:string" collation="http://marklogic.com/collation/"&gt;
     &lt;field name="my-field-name"/&gt;
   &lt;/range&gt;
 &lt;/constraint&gt;
 &lt;constraint name="color-facet"&gt;
    &lt;range type="xs:string" facet="true"&gt;
      &lt;element ns="" name="bodycolor"/&gt;
      &lt;!-- the facet-option values are passed directly to the
           underlying lexicon calls --&gt;
      &lt;facet-option&gt;frequency-order&lt;/facet-option&gt;
      &lt;facet-option&gt;descending&lt;/facet-option&gt;
    &lt;/range&gt;
 &lt;/constraint&gt;
 &lt;constraint name="fieldrange"&gt;
    &lt;range type="xs:string" collation="http://marklogic.com/collation/"&gt;
        &lt;field name="fieldrange"/&gt;
    &lt;/range&gt;
 &lt;/constraint&gt;
 &lt;constraint name="fieldrangebucket"&gt;
    &lt;range type="xs:dateTime"&gt;
        &lt;facet-option&gt;ascending&lt;/facet-option&gt;
        &lt;field name="fieldrangebucket"/&gt;
	&lt;computed-bucket name="older" lt="-P365D" anchor="now"
	       &gt;Older than 1 years&lt;/computed-bucket&gt;
	&lt;computed-bucket name="year" ge="-P365D" lt="-P30D" anchor="now"
	       &gt;1 month to 1 year ago&lt;/computed-bucket&gt;
	&lt;computed-bucket name="month" ge="-P30D" lt="-P7D" anchor="now"
	       &gt;7 to 30 days ago&lt;/computed-bucket&gt;
	&lt;computed-bucket name="week" ge="-P7D" lt="-P1D" anchor="now"
	       &gt;1 to 7 days ago&lt;/computed-bucket&gt;
	&lt;computed-bucket name="today" ge="-P1D" lt="P0D" anchor="now"
	       &gt;Today&lt;/computed-bucket&gt;
	&lt;computed-bucket name="future" ge="P0D" anchor="now"
	       &gt;Future&lt;/computed-bucket&gt;
    &lt;/range&gt;
 &lt;/constraint&gt;
&lt;/options&gt;
</pre>
									<p>For
										<code>range</code>constraints with either
										<code>bucket</code>or
										<code>computed-bucket</code>specifications, for maximum performance and sortability, the buckets should be in a continuous order; if the order is not continuous (either ascending or descending), then the buckets are returned in the order specified, regardless of any sorting
										<code>facet-option</code>in the specification.</p></dd>
								<dt>
									<pre xml:space="preserve">
&lt;element-query&gt;
</pre>
								</dt>
								<dd>Specifies a constraint that restricts the search to the specified element. You cannot create facets from an
									<code>element-query</code>constraint.
									<pre xml:space="preserve">
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
  &lt;constraint name="sample-element-constraint"&gt;
    &lt;element-query name="title" ns="http://my/namespace" /&gt;
  &lt;/constraint&gt;
&lt;/options&gt;

</pre></dd>
								<dt>
									<pre xml:space="preserve">
&lt;properties&gt;
</pre>
								</dt>
								<dd>Specifies a constraint that finds matches on the corresponding properties documents. You cannot create facets from a
									<code>properties</code>constraint.
									<pre xml:space="preserve">
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
  &lt;constraint name="sample-property-constraint"&gt;
    &lt;properties /&gt;
  &lt;/constraint&gt;
&lt;/options&gt;

</pre>For an additional example, see
									<a href="#prop-constraint">the second example</a>below.</dd>
								<dt>
									<pre xml:space="preserve">
&lt;geo-*&gt;
</pre>
								</dt>
								<dd>Specifies a geospatial constraint. Must be one of the following elements:
									<code>&lt;geo-attr-pair&gt;</code>,
									<code>&lt;geo-elem-pair&gt;</code>, or
									<code>&lt;geo-elem&gt;</code>. If the constraint has a
									<code>&lt;heatmap&gt;</code>child, then it can be used as a facet, and can contain
									<code>&lt;facet-options&gt;</code>. For example:
									<pre xml:space="preserve">
&lt;constraint name="my-geo-attr-pair"&gt;
	&lt;!-- Uses cts:element-attribute-pair-geospatial-query, and
	cts:element-attribute-pair-geospatial-boxes for the
	heatmap facet.  --&gt;
  &lt;geo-attr-pair&gt;
    &lt;heatmap s="23.2" w="-118.3" n="23.3" e="-118.2"
             latdivs="4" londivs="4"/&gt;
    &lt;facet-option&gt;empties&lt;/facet-option&gt;
    &lt;parent ns="ns1" name="elem1"/&gt;
    &lt;lat ns="ns2" name="attr2"/&gt;
    &lt;lon ns="ns3" name="attr3"/&gt;
  &lt;/geo-attr-pair&gt;
&lt;/constraint&gt;
&lt;constraint name="my-geo-elem-pair"&gt;
	&lt;!-- Uses cts:element-pair-geospatial-query, and
	cts:element-pair-geospatial-boxes for the
	heatmap facet (not shown).  --&gt;
  &lt;geo-elem-pair&gt;
    &lt;parent ns="ns1" name="elem2"/&gt;
    &lt;lat ns="ns2" name="attr2"/&gt;
    &lt;lon ns="ns3" name="attr3"/&gt;
  &lt;/geo-elem-pair&gt;
&lt;/constraint&gt;
&lt;constraint name="my-geo-elem"&gt;
	&lt;!-- Uses cts:element-geospatial-query, and
	cts:element-geospatial-boxes for the
	heatmap facet (not shown).  --&gt;
  &lt;geo-elem&gt;
    &lt;element ns="ns1" name="elem3"/&gt;
    &lt;geo-option&gt;type=long-lat-points&lt;/geo-option&gt;
  &lt;/geo-elem&gt;
&lt;/constraint&gt;
&lt;constraint name="my-geo-elem-child"&gt;
	&lt;!-- Uses cts:element-child-geospatial-query, and
	cts:element-geospatial-boxes for the
	heatmap facet (not shown).  --&gt;
  &lt;geo-elem&gt;
    &lt;parent ns="ns1" name="elem4"/&gt;
    &lt;element ns="ns1" name="elem5"/&gt;
  &lt;/geo-elem&gt;
&lt;/constraint&gt;


</pre>
									<p>Note that when specifying coordinates using a geospatial constraint, you must put any coordinate values that contain the negative sign (-) in double-quotes, otherwise the search API will interpret the negaitve sign as the negation operator (when using the default grammar). For example, to specify a point using a geospatial constraint, specify qtext of the form
										<code>my-geo-elem-child:"-12, 5"</code>in your search string.</p></dd>
								<dt>
									<pre xml:space="preserve">
&lt;custom&gt;
</pre>
								</dt>
								<dd>Specifies a custom constraint along with the name of the function implementations used to evaluate the custom constraint. For example:
									<pre xml:space="preserve">
&lt;constraint name="my-custom"&gt;
    &lt;custom facet="true"&gt;
	    &lt;parse apply="my-parse-function"
	           ns="my-function-namespace" at="path-to-module.xqy"/&gt;
	    &lt;start-facet apply="my-start-function"
	           ns="my-function-namespace" at="path-to-module.xqy"/&gt;
	    &lt;finish-facet apply="my-finish-function"
	           ns="my-function-namespace" at="path-to-module.xqy"/&gt;
    &lt;/custom&gt;
&lt;/constraint&gt;
&lt;!--  The start-facet and finish-facet elements can be omitted if
      facet="false". When facet="true", the start-facet can be ommitted
      if you do not run in concurrent mode ("concurrent" option on the
      lexicon functions).
--&gt;

</pre></dd>
								<dt>
									<pre id="term-option" xml:space="preserve">
&lt;term-option&gt;
</pre>
								</dt>
								<dd>
									<p>Specifies the options passed into the search (for example, case-insensitive). There can be zero or more
										<code>term-option</code>elements. By default, the search uses the same default options as the underlying
										<code>cts:query</code>constructors, and the defaults change based on your index configuration. You can use
										<code>term-option</code>elements as a child of either the
										<code>
											<a href="#term">term</a>
										</code>element or as a child of the
										<code>
											<a href="#constraint">constraint</a>
										</code>element.</p>
									<p>Legal term option values are:</p>
									<p>
										<code>case-sensitive</code>
										<br />
										<code>case-insensitive</code>
										<br />
										<code>diacritic-sensitive</code>
										<br />
										<code>diacritic-insensitive</code>
										<br />
										<code>punctuation-sensitive</code>
										<br />
										<code>punctuation-insensitive</code>
										<br />
										<code>whitespace-sensitive</code>
										<br />
										<code>whitespace-insensitive</code>
										<br />
										<code>stemmed</code>
										<br />
										<code>unstemmed</code>
										<br />
										<code>wildcarded</code>
										<br />
										<code>unwilcarded</code>
										<br />
										<code>exact</code>
										<br />
										<code>lang=
											<em>iso639code</em></code>
										<br />
									</p>
									<p>For example:</p>
									<pre xml:space="preserve">
&lt;term-option&gt;diacritic-insensitive&lt;/term-option&gt;
</pre>
								</dd>
								<dt>
									<pre id="facet-option" xml:space="preserve">
&lt;facet-option&gt;
</pre>
								</dt>
								<dd>
									<p>Specifies options for facets, and is specified as a child of any range constraint or other constraint that can be used as a facet (any constraints except
										<code>word</code>,
										<code>value</code>,
										<code>element-query</code>, or
										<code>property</code>).</p>
									<p>Legal values for a
										<code>facet-option</code>element are generally any option that can be passed into the underlying
										<code>cts:range-query</code>or lexicon API. The following list enumerates the
										<code>facet-option</code>values, but be aware that some options are only available with some range types. For more detail on these options, see the documentation for the underlying range or lexicon APIs</p>
									<p>
										<code>ascending</code>
										<br />
										<code>descending</code>
										<br />
										<code>empties</code>
										<br />
										<code>any</code>
										<br />
										<code>document</code>
										<br />
										<code>properties</code>
										<br />
										<code>locks</code>
										<br />
										<code>frequency-order</code>
										<br />
										<code>item-order</code>
										<br />
										<code>fragment-frequency</code>
										<br />
										<code>item-frequency</code>
										<br />
										<code>type=
											<em>type</em></code>
										<br />
										<code>timezone=
											<em>TZ</em></code>
										<br />
										<code>limit=
											<em>N</em></code>
										<br />
										<code>sample=
											<em>N</em></code>
										<br />
										<code>truncate=
											<em>N</em></code>
										<br />
										<code>skip=
											<em>N</em></code>
										<br />
										<code>score-logtfidf</code>
										<br />
										<code>score-logtf</code>
										<br />
										<code>score-simple</code>
										<br />
										<code>score-random</code>
										<br />
										<code>checked</code>
										<br />
										<code>unchecked</code>
										<br />
										<code>concurrent</code>
										<br />
										<code>map</code>
										<br />
									</p>
									<p>For example:</p>
									<pre xml:space="preserve">
&lt;constraint name="color" xmlns="http://marklogic.com/appservices/search"&gt;
   &lt;range type="xs:string"&gt;
     &lt;element ns="" name="bodycolor"/&gt;
     &lt;facet-option&gt;item-frequency&lt;/facet-option&gt;
   &lt;/range&gt;
&lt;/constraint&gt;
</pre>
								</dd>
							</dl></dd>
						<dt>
							<pre xml:space="preserve">
&lt;debug&gt;
</pre>
						</dt>
						<dd>Activates debugging mode. Additional report elements will be present in the output. Set to
							<code>true</code>to activate. The default is
							<code>false</code>.</dd>
						<dt>
							<pre xml:space="preserve">
&lt;default-suggestion-source&gt;
</pre>
						</dt>
						<dd>
							<p>Defines the content to be used as the default source of suggestions (see
								<a href="#search:suggest">
									<code>search:suggest</code>
								</a>). The source may be expressed as a reference to an existing named constraint, or as a collection, value, word or word-lexicon element. Note that the use of
								<code>word-lexicon</code>(the database-wide word lexicon) is not recommended as best practice; collection and range lexicons will yield the best performance.</p>
							<p>Each
								<code>default-suggestion-source</code>element can optionally have an
								<code>@collation</code>attribute, which specifies the collation of the value lexicon used during query evaluation. If no collation is specified, then the query uses default collation for the context in which the query is evaluated.</p>
							<p>The
								<code>default-suggestion-source</code>element can have zero or more of the following child elements:</p>
							<dl>
								<dt>
									<pre xml:space="preserve">
&lt;collection&gt;
</pre>
								</dt>
								<dd>Specifies using the collection lexicon for suggestions. For example:
									<pre xml:space="preserve">
&lt;default-suggestion-source&gt;
        &lt;collection/&gt;
&lt;/default-suggestion-source&gt;
</pre></dd>
								<dt>
									<pre xml:space="preserve">
&lt;range&gt;
</pre>
								</dt>
								<dd>Specifies the element or attribute lexicon to use for suggestions. For example:
									<pre xml:space="preserve">
&lt;default-suggestion-source&gt;
  &lt;range type="xs:string"&gt;
    &lt;element ns="my-namespace" name="my-localname"/&gt;
    &lt;attribute ns="" name="my-attribute"/&gt;
   &lt;/range&gt;
&lt;/default-suggestion-source&gt;
</pre></dd>
								<dt>
									<pre xml:space="preserve">
&lt;word&gt;
</pre>
								</dt>
								<dd>Specifies using the word lexicon for suggestions. This option might not scale well for a large database. For example:
									<pre xml:space="preserve">
&lt;default-suggestion-source&gt;
        &lt;word/&gt;
&lt;/default-suggestion-source&gt;
&lt;default-suggestion-source&gt;
    &lt;word&gt;
        &lt;field name="my-field"/&gt;
    &lt;/word&gt;
&lt;/default-suggestion-source&gt;
</pre></dd>
							</dl>
						</dd>
						<dt>
							<pre xml:space="preserve">
&lt;forest&gt;
</pre>
						</dt>
						<dd>A single forest ID to pass into
							<code>cts:search</code>. To specify multiple forests, use multiple
							<code>forest</code>elements in the options node.
							<p>The value must be an
								<code>xs:unsignedLong</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;fragment-scope&gt;
</pre>
						</dt>
						<dd>Controls the scope over which to search. Valid values are
							<code>documents</code>and
							<code>properties</code>, and the default value is
							<code>documents</code>.
							<p>You can specify
								<code>fragment-scope</code>as a child of
								<code>&lt;options&gt;</code>, and that sets a global fragment scope which applies both to what the search returns (that is, if it returns results from document fragments or from property fragments) and the global scope is inherited by any constraints that do not explicitly override the
								<code>fragment-scope</code>.</p>
							<p>You can also specify
								<code>fragment-scope</code>as a child of
								<code>&lt;range&gt;</code>,
								<code>&lt;value&gt;</code>, or
								<code>&lt;word&gt;</code>constraints. Specifying as a child of one of these constraints sets a local fragment scope for that constraint. The local
								<code>fragment-scope</code>overrides a global
								<code>fragment-scope</code>. For example, a
								<code>fragment-scope</code>of
								<code>properties</code>on a range constraint enables you to facet on a value stored in a property, even if you are searching over documents. For example:</p>
							<pre xml:space="preserve">
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
&lt;fragment-scope&gt;documents&lt;/fragment-scope&gt;
  &lt;constraint name="last-modified"&gt;
    &lt;range type="xs:dateTime"&gt;
      &lt;element ns="http://marklogic.com/xdmp/property"
               name="last-modified"/&gt;
      &lt;fragment-scope&gt;properties&lt;/fragment-scope&gt;
    &lt;/range&gt;
  &lt;/constraint&gt;
  &lt;debug&gt;true&lt;/debug&gt;
&lt;/options&gt;

</pre></dd>
						<dt>
							<pre xml:space="preserve">
&lt;grammar&gt;
</pre>
						</dt>
						<dd>Wrapper element for grammar definition. The default grammar defines "Google-style" parsing.
							<p>The
								<code>grammar</code>element has a
								<code>quotation</code>element that specifies the quotation character with which to surround phrases. The text between the quotation characters is treated as a phrase. You cannot specify a search that includes the quotation character; for example, to specify a search that includes the double quotation character (the default quotation character), modify your grammar to use a different quotation character.</p>
							<p>The
								<code>grammar</code>element can have 0 or more
								<code>joiner</code>elements and 0 or more
								<code>starter</code>elements.</p>
							<p>The
								<code>grammar</code>element should have one or more of each of the following elements. If the grammer element is present but empty, then the grammar does nothing, and the search is parsed according to the
								<code>term</code>option.</p>
							<dl>
								<dt>
									<pre xml:space="preserve">
&lt;implicit&gt;
</pre>
								</dt>
								<dd>Specifies the
									<code>cts:query</code>to use to implicitly combine terms when no joiner is specified in the qtext. Use this to modify the implicit search grammar (for example, if you want the default search to be a
									<code>cts:or-query</code>instead of a
									<code>cts:and-query</code>).
									<p>The following is an example of a
										<code>options</code>element with an
										<code>implicit</code>specification for a
										<code>cts:or-query</code>:</p>
									<pre xml:space="preserve">
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
  &lt;grammar&gt;
    &lt;implicit&gt;
      &lt;cts:or-query strength="10" xmlns:cts="http://marklogic.com/cts"/&gt;
    &lt;/implicit&gt;
  &lt;/grammar&gt;
&lt;/options&gt;

</pre></dd>
								<dt>
									<pre xml:space="preserve">
&lt;joiner&gt;
</pre>
								</dt>
								<dd>Specifies what text to use to combine terms together, and what is the underlying
									<code>cts:query</code>constructor to use to join the terms together. You specify the function to call for the joiner with the
									<code>apply</code>attribute, along with optional
									<code>ns</code>(for the module namespace) and
									<code>at</code>(for the module path) attributes. Additionally, the
									<code>strength</code>attribute determines the order of precedence over other
									<code>joiner</code>elements, the optional
									<code>options</code>attribute specifies a space-separated list of options that are passed through to the underlying
									<code>cts:query</code>constructor, and the
									<code>element</code>attribute specifies the
									<code>cts:query</code>element name (for example,
									<code>cts:and-query</code>).</dd>
								<dt>
									<pre xml:space="preserve">
&lt;starter&gt;
</pre>
								</dt>
								<dd>Specifies what text to use to delimit and group terms. You specify the function to call for the starter with the
									<code>apply</code>attribute, along with optional
									<code>ns</code>(for the module namespace) and
									<code>at</code>(for the module path) attributes. Additionally, the
									<code>strength</code>attribute determines the order of precedence over other
									<code>starter</code>elements, the optional
									<code>options</code>attribute specifies a space-separated list of options that are passed through to the underlying
									<code>cts:query</code>constructor, the
									<code>element</code>attribute specifies the
									<code>cts:query</code>element name (for example,
									<code>cts:and-query</code>), and the
									<code>delimiter</code>attribute specifies the string to use as a delimiter for the starter.</dd>
							</dl>
							<p>The following is an example of a
								<code>grammar</code>element.</p>
							<pre xml:space="preserve">
&lt;grammar xmlns="http://marklogic.com/appservices/search"&gt;
  &lt;quotation&gt;"&lt;/quotation&gt;
  &lt;implicit&gt;
    &lt;cts:and-query strength="20" xmlns:cts="http://marklogic.com/cts"/&gt;
  &lt;/implicit&gt;
  &lt;starter strength="30" apply="grouping" delimiter=")"&gt;(&lt;/starter&gt;
  &lt;starter strength="40" apply="prefix" element="cts:not-query"&gt;-&lt;/starter&gt;
  &lt;joiner strength="10" apply="infix" element="cts:or-query"
	  tokenize="word"&gt;OR&lt;/joiner&gt;
  &lt;joiner strength="20" apply="infix" element="cts:and-query"
	  tokenize="word"&gt;AND&lt;/joiner&gt;
  &lt;joiner strength="30" apply="infix" element="cts:near-query"
	  tokenize="word"&gt;NEAR&lt;/joiner&gt;
  &lt;joiner strength="30" apply="near2" element="cts:near-query"&gt;NEAR/&lt;/joiner&gt;
  &lt;joiner strength="50" apply="constraint"&gt;:&lt;/joiner&gt;
  &lt;joiner strength="50" apply="constraint" compare="LT"
	  tokenize="word"&gt;LT&lt;/joiner&gt;
  &lt;joiner strength="50" apply="constraint" compare="LE"
	  tokenize="word"&gt;LE&lt;/joiner&gt;
  &lt;joiner strength="50" apply="constraint" compare="GT"
	  tokenize="word"&gt;GT&lt;/joiner&gt;
  &lt;joiner strength="50" apply="constraint" compare="GE"
	  tokenize="word"&gt;GE&lt;/joiner&gt;
  &lt;joiner strength="50" apply="constraint" compare="NE"
	  tokenize="word"&gt;NE&lt;/joiner&gt;
&lt;/grammar&gt;
</pre></dd>
						<dt>
							<pre xml:space="preserve">
&lt;operator&gt;
</pre>
						</dt>
						<dd>A named wrapper for one or more
							<code>state</code>elements, each representing a unique run-time configuration option. For example, if an operator with the name "sort" is defined, query text [sort:foo] will select the
							<code>state</code>child with the name "foo" at query runtime, using the option specified on that
							<code>state</code>element. Options affecting query parsing (such as
							<code>constraint</code>,
							<code>grammar</code>,
							<code>term</code>,
							<code>empty</code>) may not be configured via operators.
							<p>An
								<code>operator</code>element can have one or more
								<code>state</code>elements. Each
								<code>state</code>element can have one of the following elements:</p>
							<dl>
								<dt>
									<code>additional-query</code>
								</dt>
								<dt>
									<code>debug</code>
								</dt>
								<dt>
									<code>forest</code>
								</dt>
								<dt>
									<code>page-length</code>
								</dt>
								<dt>
									<code>quality-weight</code>
								</dt>
								<dt>
									<code>searchable-expression</code>
								</dt>
								<dt>
									<code>sort-order</code>
								</dt>
								<dt>
									<code>transform-results</code>
								</dt>
							</dl>
							<p>In the following example, a search for
								<code>special:hello</code>constrains the search by the "hello world" query, and a search for
								<code>special:forest</code>constrains the search to the forest names "my-forest".</p>
							<pre xml:space="preserve">
&lt;operator name="special"&gt;
  &lt;state name="hello"&gt;
	  &lt;additional-query&gt;{cts:word-query("hello world")}
	          &lt;/additional-query&gt;
  &lt;/state&gt;
  &lt;state name="forest"&gt;
	  &lt;forest&gt;{xdmp:forest("my-forest")}&lt;/forest&gt;
  &lt;/state&gt;
&lt;/operator&gt;
</pre></dd>
						<dt>
							<pre xml:space="preserve">
&lt;page-length&gt;
</pre>
						</dt>
						<dd>Specifies the number of results per page. The default value is 10.
							<p>The value must be an
								<code>xs:unsignedInt</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;quality-weight&gt;
</pre>
						</dt>
						<dd>Specifies a a weighting factor to use in the query. The default value is 1.0.
							<p>The value must be an
								<code>xs:double</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;return-constraints&gt;
</pre>
						</dt>
						<dd>Include original constraint definitions in the results. The default is false.
							<p>The value must be an
								<code>xs:boolean</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;return-facets&gt;
</pre>
						</dt>
						<dd>Include resolved facets in the results. The default is
							<code>true</code>.
							<p>The value must be an
								<code>xs:boolean</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;return-metrics&gt;
</pre>
						</dt>
						<dd>Include statistics in the results. The default is
							<code>true</code>.
							<p>The value must be an
								<code>xs:boolean</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;return-plan&gt;
</pre>
						</dt>
						<dd>Include
							<code>xdmp:plan</code>output in the results. The default is
							<code>false</code>. The output is useful in examining the evaluation plan of the search.
							<p>The value must be an
								<code>xs:boolean</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;return-qtext&gt;
</pre>
						</dt>
						<dd>Include the original query text in the results. The default is
							<code>true</code>.
							<p>The value must be an
								<code>xs:boolean</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;return-query&gt;
</pre>
						</dt>
						<dd>Include the XML query representation in the results. The default is
							<code>false</code>.
							<p>The value must be an
								<code>xs:boolean</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;return-results&gt;
</pre>
						</dt>
						<dd>Include search results in the output. (Use transform-results to specify how each result should be formatted.) The default is
							<code>true</code>.
							<p>The value must be an
								<code>xs:boolean</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;return-similar&gt;
</pre>
						</dt>
						<dd>Include with each search result a list of URLs of similar documents in the database. The default is
							<code>false</code>.
							<p>The value must be an
								<code>xs:boolean</code>type.</p></dd>
						<dt>
							<pre xml:space="preserve">
&lt;search-option&gt;
</pre>
						</dt>
						<dd>For advanced users, a single option to be passed in with
							<code>cts:search</code>calls (for example,
							<code>filtered</code>,
							<code>unfiltered</code>,
							<code>score-logtfidf</code>, and so on). To pass in multiple options, specify multiple
							<code>search-options</code>elements in the options node. The default is no additional options. For example:
							<pre xml:space="preserve">
&lt;search-option&gt;unfiltered&lt;/search-option&gt;
&lt;search-option&gt;score-logtf&lt;/search-option&gt;

</pre></dd>
						<dt>
							<pre xml:space="preserve">
&lt;searchable-expression&gt;
</pre>
						</dt>
						<dd>An expression to be searched. Whatever expression is specified is returned from the search. For example, if you specify
							<code>//p</code>, then
							<code>p</code>elements that match the search criteris are returned. The expression must be an inline fully searchable XPath expression, and all necessary namespaces must be declared using
							<code>xmlns</code>attributes. For example:
							<pre xml:space="preserve">
&lt;searchable-expression xmlns:ex="http:example.com"
	xmlns:com="http://company.com"&gt;/ex:orders/com:company
&lt;/searchable-expression&gt;

</pre>The default value is
							<code>fn:collection()</code>, which searches all documents in the database.</dd>
						<dt>
							<pre xml:space="preserve">
&lt;sort-order&gt;
</pre>
						</dt>
						<dd>
							<p>Set the default sort order. The first such element is the primary sort order, the second secondary sort order, and so on. The default is to sort by score, descending. Note that the default scoring algorithm can be set just like any other option with the option named
								<code>search-option</code>. If you are sorting by an element or an attribute, you must specify a
								<code>type</code>attribute with a value corresponding to the range index type of that element or attribute (for example,
								<code>xs:string</code>,
								<code>xs:dateTime</code>, and so on). If the corresponding range index is of type
								<code>xs:string</code>, then you can optionally specify a
								<code>collation</code>attribute (otherwise the collation of the query is used). To change the sorting direction, specify an optional
								<code>direction</code>attribute with a value of
								<code>decending</code>(the default) or
								<code>ascending</code>.</p>
							<p>The
								<code>sort-order</code>element must have either a single
								<code>element</code>child or a single
								<code>score</code>child. If there is a
								<code>score</code>child, it specifies to sort by the score of the search result. If there is an
								<code>element</code>child it can optionally have an
								<code>attribute</code>sibling (to specify an attribute of the preceding
								<code>element</code>). Both the
								<code>element</code>and
								<code>attribute</code>elements must have
								<code>ns</code>and
								<code>name</code>attributes to specify the namespace and local-name of the specified element and attribute. Additionally, the
								<code>sort-order</code>element can have 0 or more
								<code>annotation</code>elements (to add comments, for example).</p>
							<p>For example, the following specifies a primary sort order using the element value for
								<code>my-element</code>(which needs a string range index with the specified collation), and a secondary sort order of score ascending:</p>
							<pre xml:space="preserve">
&lt;sort-order type="xs:string"
	collation="http://marklogic.com/collation/"
            direction="ascending"&gt;
  &lt;element ns="my-namespace" name="my-element"/&gt;
  &lt;annotation&gt;some user comment can go here&lt;/annotation&gt;
&lt;/sort-order&gt;
&lt;sort-order direction="ascending"&gt;
  &lt;score/&gt;
&lt;/sort-order&gt;

</pre>
						</dd>
						<dt>
							<pre xml:space="preserve">
&lt;suggestion-source&gt;
</pre>
						</dt>
						<dd>
							<p>Specifies a constraint source to override a named constraint when using
								<code>
									<a href="#search:suggest">search:suggest</a>
								</code>. The suggestions are often used for type-ahead suggestions in a search user interface. If empty, no suggestions are generated when that constraint is applied. Specifying an alternate
								<code>suggestion-source</code>is useful in cases where you have a named constraint to use for searching and facets, but you might want to use a slightly (or completely) different source for type-ahead suggestions without needed to re-parse your search terms.</p>
							<p>Each suggestion source must have a
								<code>name</code>attribute corresponding to a named constraint (one
								<code>suggestion-source</code>per named constraint). A
								<code>suggestion-source</code>can have one of the following child elements:
								<code>collection</code>,
								<code>range</code>,
								<code>word</code>, or
								<code>word-lexicon</code>.</p>
							<p>For example, the following overrides the
								<code>tag:</code>prefix, using the range index for the attribute
								<code>shortname</code>instead of the one for
								<code>name</code>when using
								<code>search:suggest</code>:</p>
							<pre xml:space="preserve">
 &lt;constraint name="tag"&gt;
	 &lt;range collation="http://marklogic.com/collation/"
          type="xs:string" facet="true"&gt;
      &lt;element ns="my-namespace"
               name="my-element"/&gt;
      &lt;attribute ns="" name="name"/&gt;
   &lt;/range&gt;
 &lt;/constraint&gt;
 &lt;suggestion-source name="tag"&gt;
	 &lt;range collation="http://marklogic.com/collation/"
          type="xs:string" facet="true"&gt;
      &lt;element ns="my-namespace"
               name="my-element"/&gt;
      &lt;attribute ns="" name="shortname"/&gt;
   &lt;/range&gt;
 &lt;/suggestion-source&gt;


</pre>
						</dd>
						<dt>
							<pre id="term" xml:space="preserve">
&lt;term&gt;
</pre>
						</dt>
						<dd>
							<p>Specifies handling of empty searches and controls options for how individual terms (that is, terms
								<em>not</em>associated with a constraint) will be represented when parseing the search.</p>
							<p>To control how empty searches (that is, the empty string passed into
								<code>search:search</code>) are resolved, specify an
								<code>empty</code>child element with an
								<code>apply</code>attribute. The value of the
								<code>apply</code>attribute specifies the behavior for empty searches: a value of
								<code>all-results</code>specifies that empty searches return everything in the database, a value of
								<code>no-results</code>(the default) specifies that an empty search returns nothing. Additionally, you create your own function to handle empty searches. To specify your own function, create a function that returns a
								<code>cts:query</code>and specify the local-name of your function in the
								<code>apply</code>attribute, the namespace of the function library module in the
								<code>ns</code>attribute, and the path to the module in the
								<code>at</code>attribute.</p>
							<p>Additionally, you can specify zero or more
								<a href="#term-option">
									<code>term-option</code>
								</a>elements to control the behavior of the search terms.</p>
							<p>For example:</p>
							<pre xml:space="preserve">
 &lt;term&gt;
   &lt;empty apply="no-results" /&gt;
   &lt;term-option&gt;diacritic-insensitive&lt;/term-option&gt;
   &lt;term-option&gt;unwildcarded&lt;/term-option&gt;
 &lt;/term&gt;


</pre>
						</dd>
						<dt>
							<pre xml:space="preserve">
&lt;transform-results&gt;
</pre>
						</dt>
						<dd>
							<p>Specifies a function to use to process a search result for the snippet output. The default is that each result is formatted using the built-in default snippetting function.</p>
							<p>To use a different snippitting function, you must use either
								<code>search:search</code>or
								<code>search:resolve</code>; the
								<code>search:snippet</code>function always uses the default snippeting function. Specify the local-name of the function to pass in as the value of the
								<code>apply</code>attribute, the namespace as the value of the
								<code>ns</code>attribute, and the path to the module as the value of the
								<code>at</code>attribute. You can pass in parameters to the function by specifying zero or more
								<code>param</code>child elements (the parameters are passed in in the order specified).</p>
							<p>In addition to the default snippitting function, there are three other built-in snippetting functions:
								<code>apply="raw"</code>(return the whole node),
								<code>apply="empty-snippet"</code>(return an empty snippet), and
								<code>apply="metadata-snippet"</code>(return the snippet from the specified element in the properties document).</p>
							<p>The following example specifies a custom snippitting function:</p>
							<pre xml:space="preserve">
&lt;transform-results apply="snippet" ns="my-namespace"
                   at="/my-library.xqy"/&gt;


</pre>
							<p>The following example specifies a snippit returning the element named
								<code>my-element</code>in the properties document:</p>
							<pre xml:space="preserve">
&lt;transform-results apply="metadata-snippet"&gt;
  &lt;preferred-elements&gt;
    &lt;!-- Specify namespace and localname for elements that exist
         in properties documents --&gt;
    &lt;element ns="" name="my-element"/&gt;
  &lt;/preferred-elements&gt;
&lt;/transform-results&gt;


</pre>
						</dd>
					</dl>
				</blockquote></param>
			<param name="start" type="xs:unsignedLong?" optional="true">The index of the first hit to return. If 0, treated as 1. If greater than the number of results, no results will be returned. The default is 1.</param>
			<param name="page-length" type="xs:unsignedLong?" optional="true">The maximum number of hits to return. The default is 10. If the value is 0, no results are returned.</param>
		</params>
		<return>element(search:response)</return>
		<usage>
			<p>The output of
				<code>search:search</code>returns a
				<code>&lt;response&gt;</code>element, which in turn contains a
				<code>total</code>attribute. The value of the
				<code>total</code>attribute is an estimate, based on the index resolution of the query, and it is not filtered for accuracy. The accuracy of the index resolution depends on the index configuration of the database, on the query, and on the data being searched.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:search("Vannevar Bush",
    &lt;options xmlns="http://marklogic.com/appservices/search"&gt;
      &lt;return-results&gt;false&lt;/return-results&gt;
      &lt;return-facets&gt;true&lt;/return-facets&gt;
    &lt;/options&gt;)

=&gt;

&lt;search:response total="1234" start="1" page-length="10" xmlns=""
        xmlns:search="http://marklogic.com/appservices/search"&gt;
  &lt;search:facet name="date"&gt;
	  &lt;search:facet-value value="today" count="1000"&gt;
	         Today&lt;/search:facet-value&gt;
	  &lt;search:facet-value value="yesterday" count="234"&gt;
	         Yesterday&lt;/search:facet-value&gt;
	  &lt;search:facet-value value="thismonth" count="1234"&gt;
	         This Month&lt;/search:facet-value&gt;
  &lt;search:/facet&gt;
    ...
&lt;/search:response&gt;


</example>
    <example xml:space="preserve">
(: properties constraint example :)
xquery version "1.0-ml";
(: create a document with some properties to test with :)
xdmp:document-insert("/foo.xml", &lt;foo&gt;hello&lt;/foo&gt;);
xdmp:document-set-properties("/foo.xml", &lt;blah&gt;boo&lt;/blah&gt;);

(: do a properties constraint search :)
import module namespace search = "http://marklogic.com/appservices/search"
     at "/MarkLogic/appservices/search/search.xqy";

search:search("hello sample-property-constraint:boo",
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
  &lt;constraint name="sample-property-constraint"&gt;
    &lt;properties /&gt;
  &lt;/constraint&gt;
  &lt;debug&gt;true&lt;/debug&gt;
&lt;/options&gt;)

=&gt;

&lt;search:response total="1" start="1" page-length="10" xmlns=""
	xmlns:search="http://marklogic.com/appservices/search"&gt;
  &lt;search:result index="1" uri="/foo.xml"
	       path="fn:doc(&amp;quot;/foo.xml&amp;quot;)" score="328"
	       confidence="0.807121" fitness="0.901397"&gt;
    &lt;search:snippet&gt;
	    &lt;search:match path="fn:doc(&amp;quot;/foo.xml&amp;quot;)/foo"&gt;
	           &lt;search:highlight&gt;hello&lt;/search:highlight&gt;&lt;/search:match&gt;
    &lt;/search:snippet&gt;
  &lt;/search:result&gt;
  &lt;search:qtext&gt;hello sample-property-constraint:boo&lt;/search:qtext&gt;
  &lt;search:report id="SEARCH-FLWOR"&gt;(cts:search(fn:collection(),
	  cts:and-query((cts:word-query("hello", ("lang=en"), 1),
	  cts:properties-query(cts:word-query("boo", ("lang=en"), 1))),
	  ()), ("score-logtfidf"), 1))[1 to 10]
  &lt;/search:report&gt;
  &lt;search:metrics&gt;
    &lt;search:query-resolution-time&gt;PT0.647S&lt;/search:query-resolution-time&gt;
    &lt;search:facet-resolution-time&gt;PT0S&lt;/search:facet-resolution-time&gt;
    &lt;search:snippet-resolution-time&gt;PT0.002S&lt;/search:snippet-resolution-time&gt;
    &lt;search:total-time&gt;PT0.651S&lt;/search:total-time&gt;
  &lt;/search:metrics&gt;
&lt;/search:response&gt;



</example>
	</function>
	<function name="snippet" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:snippet">
		<summary>This function extracts matching text from the result node based on options, and returns the matches wrapped in a containing node, with highlights tagged.</summary>
		<params>
			<param name="result" type="node()" optional="false">A node from which to pull matching snippets from.</param>
			<param name="cts-query" type="schema-element(cts:query)" optional="false">A serialized and annotated
				<code>cts:query</code>, typically the result of a call to
				<a href="#search:parse">
					<code>search:parse</code>
				</a>.</param>
			<param name="options" type="element(search:options)?" optional="true">Options to define the search grammar and control the search. See description for
				<a href="#search-options">
					<code>$options</code>
				</a>for the function
				<code>search:search</code>. Note that you cannot specify the
				<code>apply</code>attribute on the
				<code>transform-results</code>option with
				<code>search:snippet</code>; to use a different snippetting function, use
				<a href="#search:search">
					<code>search:search</code>
				</a>or
				<a href="#search:resolve">
					<code>search:resolve</code>
				</a>instead.</param>
		</params>
		<return>element(search:snippet)?</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:snippet(
 &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
     &lt;head&gt;
        &lt;title&gt;Page Title&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
       &lt;div&gt;Query terms in this div will be ignored for snippeting.&lt;/div&gt;
       &lt;p&gt;Text surrounding query terms is highlighted and truncated
               according to configuration.&lt;/p&gt;
     &lt;/body&gt;
     &lt;/html&gt;,
      search:parse("term"),
      &lt;transform-results apply="snippet"
      xmlns="http://marklogic.com/appservices/search"&gt;
          &lt;per-match-tokens&gt;30&lt;/per-match-tokens&gt;
          &lt;max-matches&gt;4&lt;/max-matches&gt;
          &lt;max-snippet-chars&gt;200&lt;/max-snippet-chars&gt;
          &lt;preferred-elements&gt;
              &lt;element name="p" ns="http://www.w3.org/1999/xhtml"/&gt;
          &lt;/preferred-elements&gt;
      &lt;/transform-results&gt;)

=&gt;

&lt;search:snippet xmlns:search="http://marklogic.com/appservices/search"&gt;
  &lt;search:match path="/*:html/*:body/*:p[1]"&gt;
      Text surrounding query
    &lt;search:highlight&gt;terms&lt;/search:highlight&gt;
      is highlighted and truncated according to configuration.
  &lt;/search:match&gt;
&lt;/search:snippet&gt;


</example>
	</function>
	<function name="suggest" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:suggest">
		<summary>This function returns a sequence of suggested text strings that match a wildcarded search for the
			<code>$qtext</code>input, ready for use in a user interface. Typically this is used for type-ahead applications to provide the user suggestions while entering terms in a search box.</summary>
		<params>
			<param name="qtext" type="xs:string+" optional="false">One or more strings of query text. The first string in the list (or the string corresponding to the position in the $focus parameter value) is used to find matching suggestons by performing a lexicon match query. The other strings (if any) are parsed as a
				<code>cts:query</code>, with the resulting queries combined with a
				<code>cts:and-query</code>, and the resulting
				<code>cts:query</code>is passed as a constraining query to the lexicon match query, restricting the suggestions to fragments that match the
				<code>cts:query</code>. Typically, each item in the sequence corresponds to a single text entry box in a user interface.</param>
			<param name="options" type="element(search:options)?" optional="true">Options to define the search grammar and control the search. See description for
				<a href="#search-options">
					<code>$options</code>
				</a>for the function
				<code>search:search</code>. In particular, the
				<code>default-suggestion-source</code>and
				<code>suggestion-source</code>options are specific to
				<code>search:suggest</code>.</param>
			<param name="limit" type="xs:unsignedInt?" optional="true">The maximum number of suggestions to return. The default is 10.</param>
			<param name="cursor-position" type="xs:unsignedInt?" optional="true">The position of the cursor, from point of origin, in the text box corresponding to the
				<code>$focus</code>parameter. This is used to determine on which part of the query text to perform a lexicon match. The default is the string length of the
				<code>$focus</code>string (all of the string).</param>
			<param name="focus" type="xs:positiveInteger?" optional="true">If there are multiple
				<code>$qtext</code>strings, the index of the string corresponding to the text box that has current "focus" in the user interface (and therefore containing a partial query text for completion). The default is 1 (the first
				<code>$qtext</code>string.</param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>On large databases, the performance of using a word lexicon for suggestions will probably be slower than using a value lexicon. This can be very application specific, and in some cases the performance might be good, but in general, value lexicons (range constraints) will perform much better than word lexicons (word constraints) with
				<code>search:suggest</code>. Therefore, MarkLogic recommends using value lexicons for suggestions, not word lexicons.</p>
			<p>The performance of
				<code>search:suggest</code>is highly data-dependent. The best performing suggestion sources are value lexicons (range indexes) that use the codepoint collation. Performance is also impacted based on the number of matches, and it can help to design the interaction between
				<code>search:suggest</code>and the UI so that suggestions are given after a minimum of 3 characters are entered (that is, the lexicon match calls will have at least 3 characters). Again, this is quite data-dependent, so you should try it on a large data set with your own data.</p>
			<p>The output of
				<code>search:suggest</code>is a sequence of query text strings, not a sequence of words. Each query text string can include quoted text, such as phrases. The output of
				<code>search:suggest</code>is appropriate to pass into the first argument of
				<code>search:search</code>, including any quoted phrases. For example, if you have a suggestion that returns multi-word phrases (for example, from range element index values), then the suggestion will quote the phrase.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

let $options :=
&lt;search:options xmlns="http://marklogic.com/appservices/search"&gt;
 &lt;default-suggestion-source&gt;
   &lt;range collation="http://marklogic.com/collation/"
          type="xs:string" facet="true"&gt;
      &lt;element ns="http://marklogic.com/xdmp/apidoc"
               name="function"/&gt;
      &lt;attribute ns="" name="name"/&gt;
   &lt;/range&gt;
 &lt;/default-suggestion-source&gt;
&lt;/search:options&gt;
return
search:suggest("docu", $options)

=&gt; a sequence of strings representing query text:

document-add-collections
document-add-permissions
document-add-properties
document-checkin
document-checkout


</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

let $options :=
&lt;search:options xmlns="http://marklogic.com/appservices/search"&gt;
 &lt;default-suggestion-source&gt;
    &lt;range collation="http://marklogic.com/collation/"
          type="xs:string" facet="true"&gt;
      &lt;element ns="" name="hello"/&gt;
   &lt;/range&gt;
 &lt;/default-suggestion-source&gt;
&lt;/search:options&gt;
return
search:suggest("a", $options)

=&gt;  a sequence of strings representing query text:
"and that"
"and this"



</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:suggest(("ta","foo"),(),5)

=&gt;  a sequence of strings representing query text:

tab
table
tadpole
tag



</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:suggest(("table","foo"),(),(),5,2)

=&gt;  a sequence of strings representing query text:

food
fool
foolhardy
foolish
foolishness



</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

(:
given a document created with the following:

xdmp:document-insert("/test.xml",
&lt;root&gt;
  &lt;my:my-element xmlns:my="my-namespace" shortname="fool"/&gt;
  &lt;my:my-element xmlns:my="my-namespace" shortname="food"/&gt;
  &lt;my:my-element xmlns:my="my-namespace" shortname="foolhardy"/&gt;
  &lt;my:my-element xmlns:my="my-namespace" shortname="foolish"/&gt;
  &lt;my:my-element xmlns:my="my-namespace" shortname="foolishness"/&gt;
  &lt;my:my-element xmlns:my="my-namespace" name="foody"/&gt;
&lt;/root&gt;)
:)
let $options :=
&lt;options xmlns="http://marklogic.com/appservices/search"&gt;
 &lt;constraint name="tag"&gt;
   &lt;range collation="http://marklogic.com/collation/"
          type="xs:string" facet="true"&gt;
      &lt;element ns="my-namespace"
               name="my-element"/&gt;
      &lt;attribute ns="" name="name"/&gt;
   &lt;/range&gt;
 &lt;/constraint&gt;
 &lt;suggestion-source ref="tag"&gt;
   &lt;range collation="http://marklogic.com/collation/"
          type="xs:string" facet="true"&gt;
      &lt;element ns="my-namespace"
               name="my-element"/&gt;
      &lt;attribute ns="" name="shortname"/&gt;
   &lt;/range&gt;
 &lt;/suggestion-source&gt;
&lt;/options&gt;
return
search:suggest("tag:foo", $options)

=&gt;
suggestions to complete tag: from the range index on the
"shortname" attribute (notice "foody" is not in the answer):

tag:food
tag:fool
tag:foolhardy
tag:foolish
tag:foolishness


</example>
	</function>
	<function name="unparse" lib="search" category="Search" bucket="XQuery Library Modules" hidden="false" fullname="search:unparse">
		<summary>This function turns a serialized and annotated
			<code>cts:query</code>(typically from
			<code>search:parse</code>) back into query text according to the specified rules.</summary>
		<params>
			<param name="cts-query" type="schema-element(cts:query)" optional="false">A serialized and annotated
				<code>cts:query</code>, typically the result of a call to
				<a href="#search:parse">
					<code>search:parse</code>
				</a>.</param>
		</params>
		<return>xs:string+</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace search = "http://marklogic.com/appservices/search"
    at "/MarkLogic/appservices/search/search.xqy";

search:unparse(
    search:parse("tag:technology AND format:pdf",
    search:get-default-options()))

=&gt;

"tag:technology AND format:pdf"


</example>
	</function>
	<function name="create-user" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:create-user">
		<summary>Creates a new user in the system database for the context database. Returns the user ID of the created user.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">A unique username. If $user-name is not unique, an error is returned.</param>
			<param name="description" type="xs:string?" optional="false">A description of the user.</param>
			<param name="password" type="xs:string" optional="false">The initial password for this user.</param>
			<param name="role-names" type="xs:string*" optional="false">The roles (if any) assigned to this user. If one of the $role-names names a role that does not exist, an error is returned.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">The default permissions granted to this user.</param>
			<param name="collections" type="xs:string*" optional="false">The URIs for the default collections to which this user has access.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:create-user(
    "Jim",
    "Jim the temp",
    "newtemp",
    "Temporary",
    (xdmp:permission("security", "read")),
    ("http://marklogic.com/dev_modules"))

 (: Creates a new user, named "Jim," with the role, "Temporary."  "Jim"
    is assigned the default permission, security(read), and the default
    collection, "http://marklogic.com/dev_modules". :)

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/create-user</code>
			<br />and, for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="create-user-with-role" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:create-user-with-role">
		<summary>Creates a new user in the system database for the context database. Returns the user ID of the created user. Also creates a role by the same name and assigns the newly-created user to the newly-created role. Parameters that define roles, permissions, and collections are only applied to the new user.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">A unique username. If $user-name is not unique, an error is returned.</param>
			<param name="description" type="xs:string?" optional="false">A description of the user.</param>
			<param name="password" type="xs:string" optional="false">The initial password for this user.</param>
			<param name="role-names" type="xs:string*" optional="false">Additional roles (if any) assigned to this user. If one of the $role-names names a role that does not exist, an error is returned.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">The default permissions granted to this user.</param>
			<param name="collections" type="xs:string*" optional="false">The URIs for the default collections to which this user has access.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:create-user-with-role(
    "Jim",
    "Jim the temp",
    "newtemp",
    "Temporary",
    (xdmp:permission("security", "read"),
     xdmp:permission("security", "update")),
    ("http://marklogic.com/dev_modules"))

(: Creates a new user, named Jim, with the roles, Jim and Temporary.
   Jim is assigned the default permissions, security(read) and security(update),
   and the default collection, "http://marklogic.com/dev_modules". :)


</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/create-user</code>
			<br />
			<code>http://marklogic.com/xdmp/privileges/create-role</code>
			<br />and, for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="user-set-name" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-set-name">
		<summary>Changes the name of the user from $user-name to $new-user-name.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The existing name of the user.</param>
			<param name="new-user-name" type="xs:string" optional="false">The new name of the user.</param>
			<param name="password" type="xs:string" optional="false">The password to set for the user. This can be either the original password for the user or a new password.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-set-name(
    "William",
    "Bill",
    "temp")

(: Changes the username from "Wiiliam" to "Bill" and resets the password to
   "temp". :)


</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-set-name</code>if the currrent user is not $user-name.</privilege>
		<usage>
			<p>If a user with name equal to $user-name is not found, an error is returned.</p>
			<p>If $new-user-name is not unique, an error is returned.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="user-set-password" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-set-password">
		<summary>Changes the password for the user identified by $user-name to $password.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of the user.</param>
			<param name="password" type="xs:string" optional="false">The new password. If $password is the empty string, an error is returned.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-set-password</code>if the currrent user is not $user-name.</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-set-password("Jim", "temp")

(: Changes the password for the user, "Jim," to "temp." :)

</example>
	</function>
	<function name="user-set-description" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-set-description">
		<summary>Changes the description of the user identified by $user-name to $description.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of the user.</param>
			<param name="description" type="xs:string" optional="false">A description of the user.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-set-description(
    "Bill",
    "Senior QA Engineer")

(:  Changes the description of the user, "Bill." :)

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-set-description</code>if the current user is not $user-name.</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="role-set-description" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-set-description">
		<summary>Changes the description of the role identified by $role-name to $description.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of the role.</param>
			<param name="description" type="xs:string" optional="false">A description of the role.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-set-description</code>if the currrent role is not $role-name.</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-set-description(
    "Developer",
    "Developer-level access")

(:  Changes the description of the role, "Developer." :)

</example>
	</function>
	<function name="role-get-description" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-get-description">
		<summary>Returns the description for the specified role.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of the role.</param>
		</params>
		<return>xs:string</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-get-description</code>
		</privilege>
		<usage>
			<p>If a role with name equal to $role-name is not found, an error is returned.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-get-description("Developer")

=&gt; Developer-level access
</example>
	</function>
	<function name="get-role-ids" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:get-role-ids">
		<summary>
			<p>Returns a sequence of unique
				<code>sec:role-id</code>elements that corresponds to the sequence of role names
				<code>$role-names</code>.</p>
			<p>Duplicate names return a single ID.</p>
			<p>If
				<code>$role-names</code>is omitted, returns all of the
				<code>sec:role-id</code>elements in the database.</p>
			<p>If a role name in
				<code>$role-names</code>does not correspond to an existing role, an error is returned.</p>
		</summary>
		<params>
			<param name="role-names" type="xs:string*" optional="true">A sequence of role names. If omitted, returns all of the
				<code>sec:role-id</code>elements in the database.</param>
		</params>
		<return>element(sec:role-id)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/get-role-ids</code>
		</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
   "/MarkLogic/security.xqy";

sec:get-role-ids(("writer", "editor"))

=&gt;

&lt;sec:role-id xmlns:sec="http://marklogic.com/xdmp/security"&gt;6629014463670416824&lt;/sec:role-id&gt;
&lt;sec:role-id xmlns:sec="http://marklogic.com/xdmp/security"&gt;6615337390848046012&lt;/sec:role-id&gt;
</example>
	</function>
	<function name="get-role-names" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:get-role-names">
		<summary>Returns sequence of unique sec:role-name's that corresponds to the sequence of role IDs $role-ids. Duplicate IDs return a single name.</summary>
		<params>
			<param name="role-ids" type="xs:unsignedLong*" optional="false">A sequence of role IDs.</param>
		</params>
		<return>element(sec:role-name)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/get-role-names</code>
		</privilege>
		<usage>
			<p>If a role ID in $role-ids does not correspond to an existing role, an error is returned.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:get-role-names((6629014463670416824,
                     6615337390848046012))
=&gt;

&lt;sec:role-name xmlns:sec="http://marklogic.com/xdmp/security"&gt;editor&lt;/sec:role-name&gt;
&lt;sec:role-name xmlns:sec="http://marklogic.com/xdmp/security"&gt;writer&lt;/sec:role-name&gt;

</example>
	</function>
	<function name="user-set-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-set-roles">
		<summary>Assigns the user with name $user-name to have the roles identified by $role-names. Removes previously assigned roles.
			<br />
			<br />If a user with name equal to $user-name is not found, an error is returned.
			<br />
			<br />If a role name in $role-names does not correspond to an existing role, an error is returned.
			<br />
			<br />If $role-names is the empty sequence, all existing roles for the user are removed.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-names is not a subset of the current user's roles or one of the removed roles is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
			<param name="role-names" type="xs:string*" optional="false">A sequence of role names.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-set-roles("Jim", ("Developer", "Temporary"))

(:  Resets the roles for "Jim" to "Developer" and "Temporary. :)

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-set-roles</code>
			<br />and for role assignment ($role-names not empty sequence):
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="user-add-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-add-roles">
		<summary>
			<p>Adds the roles ($role-names) to the list of roles granted to the user ($user-name).</p>
			<p>If a user with name equal to $user-name is not found, an error is returned.</p>
			<p>If one of the $role-names does not correspond to an existing role, an error is returned.</p>
			<p>If the current user is limited to granting only his/her roles, and $role is not a subset of the current user's roles, then an error is returned.</p>
		</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
			<param name="role-names" type="xs:string*" optional="false">A sequence of role names.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-add-roles("Jim", ("merge", "alert-user"))

(:  Adds the roles, "merge" and "alert-user," to Jim's existing roles. :)

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-add-roles</code>
			<br />and for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="user-remove-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-remove-roles">
		<summary>
			<p>Removes the roles ($role-names) from the list of roles granted to the user ($user-name).</p>
			<p>If a user with name equal to $user-name is not found, an error is returned.</p>
			<p>If one of $role-names does not correspond to an existing role, an error is returned.</p>
			<p>If the current user is limited to granting only his/her roles, and one of $role-names is not a subset of the current user's roles, then an error is returned.</p>
		</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
			<param name="role-names" type="xs:string*" optional="false">A sequence of role names.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-role-from-user</code>
			<br />and for role removal:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-remove-roles("Jim", ("admin", "admin-builtins"))

(: Removes the "admin" and "admin-builtins" roles from the user, "Jim." :)
</example>
	</function>
	<function name="user-get-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-get-roles">
		<summary>Returns a sequence of role names for the roles directly assigned to the user ($user-name). Does not flatten the roles to include "inherited roles."
			<br />
			<br />If a user with name equal to $user-name is not found, an error is returned.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
		</params>
		<return>xs:string*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-get-roles</code>
		</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-get-roles("Jim")

=&gt;

Developer
admin
admin-builtins

</example>
	</function>
	<function name="user-get-description" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-get-description">
		<summary>Returns the user's description. If a user with name equal to $user-name is not found, an error is returned.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
		</params>
		<return>xs:string</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-get-description</code>
			<br />or the current user is the same as the $user-name.</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-get-description("Jim")

=&gt;

Jim the temp

</example>
	</function>
	<function name="remove-user" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:remove-user">
		<summary>Removes the user with name $user-name.
			<br />
			<br />If a user with name equal to $user-name is not found, an error is returned.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:remove-user("Jim")

(: Removes the user, named Jim. :)

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-user</code>
		</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="create-role" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:create-role">
		<summary>Creates a new role in the system database for the context database.
			<br />
			<br />If $role-name is not unique, an error is returned.
			<br />
			<br />If one of the $role-names does not identify a role, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-names is not a subset of the current user's roles, then an error is returned.
			<br />
			<br />Returns the role-id.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of the role to be created.</param>
			<param name="description" type="xs:string?" optional="false">A description of the role to be created.</param>
			<param name="role-names" type="xs:string*" optional="false">A sequence of role names to which the role is assigned.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">The default permissions for the role.</param>
			<param name="collections" type="xs:string*" optional="false">The default collections for the role.</param>
			<param name="compartment" type="xs:string?" optional="true">The compartment to assign to the role.</param>
		</params>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:create-role(
    "Temporary",
    "Temporary worker access",
    ("filesystem-access"),
    (),
    ("testDocument"))

(: Creates a new role, named "Temporary," with the default collection,
   named testDocument. :)

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/create-role</code>
			<br />and for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="role-set-name" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-set-name">
		<summary>Changes the sec:role-name of a role from $role-name to $new-role-name.
			<br />
			<br />If $new-role-name is not unique, an error is returned.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of the role to change.</param>
			<param name="new-role-name" type="xs:string" optional="false">The new name for the role.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-set-name</code>
		</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-set-name("Temporary", "Contractor")

(: Changes the name of the "Temporary" role to "Contractor."  :)

</example>
	</function>
	<function name="role-set-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-set-roles">
		<summary>Assigns roles (named $role-names) to be the set of included roles for the role ($role-name). Removes previously assigned roles.
			<br />
			<br />If a role with name equal to $role-name is not found, an error is returned.
			<br />
			<br />If a role name in $role-names does not correspond to an existing role, an error is returned.
			<br />
			<br />If $role-names is the empty sequence, all included roles for the role are removed.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-names is not a subset of the current user's roles, then an error is returned.
			<br />
			<br /></summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
			<param name="role-names" type="xs:string*" optional="false">A sequence containing the names of roles to assign to $role-name.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-set-roles</code>
			<br />and for role assignment ($role-names not empty sequence):
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-set-roles("Contractor", ("Developer", "alert-internal"))

(: Assigns the "Developer" and "alert-internal" roles to the "Contractor"
   role and removes any other roles previously assigned to "Contractor." :)
</example>
	</function>
	<function name="role-add-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-add-roles">
		<summary>Adds new roles ($new-roles) to the role specified by
			<code>$role-name</code>.
			<br />
			<br />If a role with name equal to $role-name is not found, an error is returned.
			<br />
			<br />If one of $new-roles does not correspond to an existing role, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $new-role is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of the role.</param>
			<param name="new-roles" type="xs:string*" optional="false">The roles to add to the role.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-add-roles</code>
			<br />and for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-add-roles("Contractor", "filesystem-access")

(: Adds the "filesystem-access" role to the "Contractor" role and leaves
   any previously assigned roles intact. :)

</example>
	</function>
	<function name="role-remove-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-remove-roles">
		<summary>Removes the roles ($role-names) from the set of roles included by the role ($role-name).
			<br />
			<br />If a role with name equal to $role-name is not found, an error is returned.
			<br />
			<br />If one of $role-names does not correspond to an existing role, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $old-role is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
			<param name="role-names" type="xs:string*" optional="false">The name of the roles to remove from the role.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-remove-roles</code>
			<br />and for role removal:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-remove-roles("Contractor", ("Developer", "alert-internal"))

(: Removes the "Developer" and "alert-internal" roles from the "Contractor" role. :)
</example>
	</function>
	<function name="remove-role" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:remove-role">
		<summary>Removes the role ($role-name).
			<br />
			<br />If a role with name equal to $role-name is not found, an error is returned.
			<br />
			<br />This function also removes all references to the role (privileges, amps, permissions and users).</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:remove-role("Temporary")

(: Removes the role, named Temporary. :)

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-role</code>
		</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="remove-role-from-users" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:remove-role-from-users">
		<summary>Removes references to the role ($role-name) from all users.
			<br />
			<br />If a role with name equal to $role-name is not found, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-name is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-role-from-users</code>
			<br />and for role removal:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:remove-role-from-users("Contractor")

(: Removes the "Contractor" role from all users. :)
</example>
	</function>
	<function name="remove-role-from-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:remove-role-from-roles">
		<summary>Removes references to the role ($role-name) from all other roles.
			<br />
			<br />If a role with name equal to $role-name is not found, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-name is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-role-from-users</code>
			<br />and for role removal:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:remove-role-from-roles("Developer")

(: Removes the "Developer" role from all other roles. :)

</example>
	</function>
	<function name="remove-role-from-privileges" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:remove-role-from-privileges">
		<summary>Removes references to the role ($role-name) from all privileges.
			<br />
			<br />If a role with name equal to $role-name is not found, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-name is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-role-from-privileges</code>
			<br />and for role removal:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:remove-role-from-privileges("Developer")

(: Removes the "Developer" role from all privileges. :)

</example>
	</function>
	<function name="remove-role-from-amps" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:remove-role-from-amps">
		<summary>Removes references to the role ($role-name) from all amps.
			<br />
			<br />If a role with name equal to $role-name is not found, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-name is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-role-from-amps</code>
			<br />and for role removal:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:remove-role-from-amps("Developer")

(: Removes the "Developer" role from all amps. :)
</example>
	</function>
	<function name="create-privilege" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:create-privilege">
		<summary>Creates a new privilege and returns the new privilege-id.
			<br />
			<br />For execute privileges, the privilege is initially nothing more than a name. Use the
			<code>xdmp:security-assert()</code>function in your code to associate the privilege with a protected operation.
			<br />
			<br />For URI privleges, the
			<code>$action</code>parameter identifies the base URI to be protected. Users must have this privilege to access any of the documents or code under the specified URI.
			<br />
			<br />If $action is not unique, an error is returned.
			<br />
			<br />If $kind is not one of ("execute", "uri") then en error is returned.
			<br />
			<br />If one of the $role-names names a role that does not exist, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-names is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="privilege-name" type="xs:string" optional="false">The name of the privilege to create (unique within security database).</param>
			<param name="action" type="xs:string" optional="false">Action protected by this privilege. For an Execute Privilege, this is usually a URI describing an activity. For a URI Privilege, this is a base URI used to filter database activities with certain document URIs.</param>
			<param name="kind" type="xs:string" optional="false">Either "execute" or "uri".</param>
			<param name="role-names" type="xs:string*" optional="false">The names of the roles which can perform this action.</param>
		</params>
		<return>xs:unsignedLong</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/create-privilege</code>
			<br />and for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:create-privilege("mypriv",
                     "http://marklogic.com/xdmp/privileges/mypriv",
                     "execute",
                     "Developer")

(: Creates an execute privilege, named "mypriv," and assigns it to the
   "Developer" role. :)
</example>
	</function>
	<function name="privilege-set-name" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:privilege-set-name">
		<summary>Changes the sec:privilege-name of a sec:privilege to $new-privilege-name.
			<br />
			<br />If a privilege with the given $action and $kind is not found, an error is returned.
			<br />
			<br />If $new-privilege-name is not unique, an error is returned.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">The action URI for the privilege. If $kind is a URI privilege, then use the URI to protect for the action parameter.</param>
			<param name="kind" type="xs:string" optional="false">Either "execute" or "uri".</param>
			<param name="new-privilege-name" type="xs:string" optional="false">The new name for the privilege.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/privilege-set-name</code>
		</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:privilege-set-name(
    "http://marklogic.com/xdmp/privileges/mypriv",
    "execute",
    "new_name")

(: Renames the execute privilege with the specified action to "new_name." :)
</example>
	</function>
	<function name="remove-privilege" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:remove-privilege">
		<summary>Removes the privilege identified by ($action,$kind).
			<br />
			<br />If a privilege identified by ($action,$kind) is not found, an error is returned.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">The action URI for the privilege. If $kind is a URI privilege, then use the URI to protect for the action parameter.</param>
			<param name="kind" type="xs:string" optional="false">Either "execute" or "uri".</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-privilege</code>
		</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:remove-privilege(
    "http://marklogic.com/xdmp/privileges/mypriv",
    "execute")

(: Removes the execute privilege with the specified action. :)
</example>
	</function>
	<function name="privilege-get-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:privilege-get-roles">
		<summary>Returns a sequence of role names for the roles assigned to the privilege ($action,$kind).
			<br />
			<br />If a privilege with action equal to $action is not found, an error is returned.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">The action URI for the privilege. If $kind is a URI privilege, then use the URI to protect for the action parameter.</param>
			<param name="kind" type="xs:string" optional="false">Either "execute" or "uri".</param>
		</params>
		<return>xs:string*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/privilege-get-roles</code>
		</privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:privilege-get-roles(
    "http://marklogic.com/xdmp/privileges/create-role",
     "execute")
=&gt;

security
</example>
	</function>
	<function name="privilege-set-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:privilege-set-roles">
		<summary>Assigns the privilege ($action,$kind) to have the roles identified by $role-names. Removes the prviously assigned roles.
			<br />
			<br />If a privilege identified by ($action,$kind) is not found, an error is returned.
			<br />
			<br />If a role name in $role-names does not correspond to an existing role, an error is returned.
			<br />
			<br />If $role-names is the empty sequence, all existing roles for the privilege are removed.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-names is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">The action URI for the privilege. If $kind is a URI privilege, then use the URI to protect for the action parameter.</param>
			<param name="kind" type="xs:string" optional="false">Either "execute" or "uri".</param>
			<param name="role-names" type="xs:string*" optional="false">New roles that can perform this action. All previously assigned roles will be removed. If $role-names is the empty sequence, the privilege will have no roles assigned.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/privilege-set-roles</code>
			<br />and for role assignment ($role-names not empty sequence):
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:privilege-set-roles(
    "http://marklogic.com/xdmp/privileges/mypriv",
     "execute", "Contractor")

(: Assigns the privilege with the specified action to the "Contractor" role.
   The privilege is removed from any other roles that had previously been
   assigned the privilege. :)
</example>
	</function>
	<function name="privilege-add-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:privilege-add-roles">
		<summary>Adds the roles ($role-names) to the list of roles assigned to the privilege ($action,$kind).
			<br />
			<br />If a privilege identified by ($action,$kind) is not found, an error is returned.
			<br />
			<br />If one of $role-names does not correspond to an existing role, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">The action URI for the privilege. If $kind is a URI privilege, then use the URI to protect for the action parameter.</param>
			<param name="kind" type="xs:string" optional="false">Either "execute" or "uri".</param>
			<param name="role-names" type="xs:string*" optional="false">Additional roles for the privilege. If $role-names is the empty sequence, the function has no effect.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:privilege-add-roles(
    "http://marklogic.com/xdmp/privileges/unprotected-collections",
    "execute",
    ("Temporary"))

(: Adds the unprotected-collection execute privilege to the Temporary role. :)

</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/privilege-add-roles</code>
			<br />and for role assignment:
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
	</function>
	<function name="privilege-remove-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:privilege-remove-roles">
		<summary>Removes roles ($role-names) from the roles assigned to the privilege ($action,$kind).
			<br />
			<br />If a privilege identified by ($action,$kind) is not found, an error is returned.
			<br />
			<br />If one of $role-names does not correspond to an existing role, an error is returned.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">The action URI for the privilege. If $kind is a URI privilege, then use the URI to protect for the action parameter.</param>
			<param name="kind" type="xs:string" optional="false">Either "execute" or "uri".</param>
			<param name="role-names" type="xs:string*" optional="false">Additional roles for the privilege. If $role-names is the empty sequence, the function has no effect.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/privilege-remove-roles</code>
			<br />and for role removal:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:privilege-remove-roles(
    "http://marklogic.com/xdmp/privileges/mypriv",
    "execute", "Contractor")

(: Removes the specified privilege from the "Contractor" role. :)
</example>
	</function>
	<function name="create-amp" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:create-amp">
		<summary>
			<p>Creates a new amp in the system database for the context database.</p>
			<p>If the tuple ($namespace, $local-name, $document-uri, $database) is not unique, an error is returned.</p>
			<p>If one of the $role-names does not identify a role, an error is returned.</p>
			<p>If the current user is limited to granting only his/her roles, and $role-names is not a subset of the current user's roles, then an error is returned.</p>
			<p>Returns the amp-id.</p>
		</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">Namespace of the function to which the amp applies.</param>
			<param name="local-name" type="xs:string" optional="false">Name of function to which the amp applies.</param>
			<param name="document-uri" type="xs:string" optional="false">URI of the module in which the function is located.</param>
			<param name="database" type="xs:unsignedLong" optional="false">Database ID in which the module is located. If the module is on the filesystem (in the Modules directory), specify
				<code>xs:unsignedLong(0)</code>.</param>
			<param name="role-names" type="xs:string*" optional="false">Roles that should be temporarily assumed while the amp is in effect.</param>
		</params>
		<return>xs:unsignedLong</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/create-amp</code>
			<br />and for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:create-amp(
    "http://marklogic.com/my_modules/myspace",
    "my-amp",
    "/MarkLogic/MyModule.xqy",
    0,
    "Developer")

 (: Creates an amp for the function "my-amp" in the MyModule.xqy module that
    temporarily grants users the "Developer" role. :)
</example>
	</function>
	<function name="amp-set-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:amp-set-roles">
		<summary>Assigns the amp identified by $namespace, $local-name and $document-uri to have the roles identified by $roles-names. Removes previously assigned roles.
			<br />
			<br />If an amp with the given identifiers does not exist, an error is returned.
			<br />
			<br />If a role name in $role-names does not correspond to an existing role, an error is returned.
			<br />
			<br />If $role-names is the empty sequence, all roles assigned to the amp are removed.
			<br />
			<br />If the current user is limited to granting only his/her roles, and $role-names is not a subset of the current user's roles, then an error is returned.</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">Namespace of the function to which the amp applies.</param>
			<param name="local-name" type="xs:string" optional="false">Name of function to which the amp applies.</param>
			<param name="document-uri" type="xs:string" optional="false">URI of the document in which the function is located.</param>
			<param name="database" type="xs:unsignedLong" optional="false">Database ID in which the module is located. If the module is on the filesystem (in the Modules directory), specify
				<code>xs:unsignedLong(0)</code>.</param>
			<param name="role-names" type="xs:string*" optional="false">Roles that should be temporarily assumed while the amp is in effect.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/amp-set-roles</code>
			<br />and for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:amp-set-roles(
    "http://marklogic.com/my_modules/myspace",
    "my-amp",
    "/MarkLogic/MyModule.xqy",
    0,
    ("Developer", "Temporary"))

(: Sets the "Developer" and "Temporary" rolea as the roles granted to the "my-amp" amp.
   Any other roles previously in the list are removed. :)

</example>
	</function>
	<function name="amp-add-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:amp-add-roles">
		<summary>Adds the roles ($role-names) to the list of roles granted to the amp ($namespace, $local-name, $document-uri).</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">Namespace of the function to which the amp applies.</param>
			<param name="local-name" type="xs:string" optional="false">Name of function to which the amp applies.</param>
			<param name="document-uri" type="xs:string" optional="false">URI of the document in which the function is located.</param>
			<param name="database" type="xs:unsignedLong" optional="false">Database ID in which the module is located. If the module is on the filesystem (in the Modules directory), specify
				<code>xs:unsignedLong(0)</code>.</param>
			<param name="role-names" type="xs:string*" optional="false">Roles that should be temporarily assumed while the amp is in effect.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/amp-add-roles</code>
			<br />and for role assignment:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>If an amp with the given identifiers ($namespace, $local-name, $document-uri) is not found, an error is returned.</p>
			<p>If one of $role-names does not correspond to an existing role, an error is returned.</p>
			<p>If the current user is limited to granting only his/her roles, and $role is not a subset of the current user's roles, then an error is returned.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:amp-add-roles(
    "http://marklogic.com/my_modules/myspace",
    "my-amp",
    "/MarkLogic/MyModule.xqy",
    0,
    "Contractor")

(: Adds the "Contractor" role to the list of roles granted to the "my-amp" amp. :)

</example>
	</function>
	<function name="amp-get-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:amp-get-roles">
		<summary>Returns a sequence of role names for the roles directly assigned to the amp ($namespace, $local-name, $document-uri).</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">Namespace of the function to which the amp applies.</param>
			<param name="local-name" type="xs:string" optional="false">Name of function to which the amp applies.</param>
			<param name="document-uri" type="xs:string" optional="false">URI of the document in which the function is located.</param>
			<param name="database" type="xs:unsignedLong" optional="false">Database ID in which the module is located. If the module is on the filesystem (in the Modules directory), specify
				<code>xs:unsignedLong(0)</code>.</param>
		</params>
		<return>xs:string*</return>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/amp-get-roles</code>
			</p>
		</privilege>
		<usage>
			<p>If an amp is not found with the given identifiers, an error is returned.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:amp-get-roles(
    "http://marklogic.com/my_modules/myspace",
    "my-amp",
    "/MarkLogic/MyModule.xqy",
    0)
=&gt;

Contractor
Developer
Temporary

</example>
	</function>
	<function name="role-get-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-get-roles">
		<summary>Returns a sequence of role names for the roles directly assigned to the given role ($role-name).</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>xs:string*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-get-roles</code>
		</privilege>
		<usage>
			<p>If a role with name equal to $role-name is not found, an error is returned.</p>
			<p>If a role is assigned to itself, the sequence returned from
				<code>sec:role-get-roles</code>does not include itself.</p>
			<p>To find all of the roles this role inherits (that is, the roles assigned directly to this role, the roles assigned to those roles, and so on), use the
				<code>xdmp:role-roles</code>built-in function.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
 xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-get-roles("Developer")

=&gt;

filesystem-access
pipeline-execution

</example>
	</function>
	<function name="amp-remove-roles" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:amp-remove-roles">
		<summary>Removes a role ($role-name) from the set of roles included by the amp ($namespace, $local-name, $document-uri).</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">Namespace of the function to which the amp applies.</param>
			<param name="local-name" type="xs:string" optional="false">Name of function to which the amp applies.</param>
			<param name="document-uri" type="xs:string" optional="false">URI of the document in which the function is located.</param>
			<param name="database" type="xs:unsignedLong" optional="false">Database ID in which the module is located. If the module is on the filesystem (in the Modules directory), specify
				<code>xs:unsignedLong(0)</code>.</param>
			<param name="role-names" type="xs:string*" optional="false">Roles that should be temporarily assumed while the amp is in effect.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/amp-remove-roles</code>
			<br />and for role removal:
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-all-roles</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/grant-my-roles</code></privilege>
		<usage>
			<p>If one of $role-names does not correspond to an existing role, an error is returned.</p>
			<p>If an amp idnetified by ($namespace, $local-name, $document-uri) is not found then an error is returned.</p>
			<p>If the current user is limited to granting only his/her roles, and $role-name is not a subset of the current user's roles, then an error is returned.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:amp-remove-roles(
    "http://marklogic.com/my_modules/myspace",
    "my-amp",
    "/MarkLogic/MyModule.xqy",
    0,
    "Developer")

(: Removes the "Developer" role from the list of roles granted to the "my-amp" amp. :)

</example>
	</function>
	<function name="remove-amp" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:remove-amp">
		<summary>Removes the amp ($namespace, $local-name, $document-uri, $database) and returns true after completion.</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">The namespace of the function to which the amp applies.</param>
			<param name="local-name" type="xs:string" optional="false">The name of the function to which the amp applies.</param>
			<param name="document-uri" type="xs:string" optional="false">The URI of the module in which the function is located.</param>
			<param name="database" type="xs:unsignedLong" optional="false">Database ID in which the module is located. If the module is on the filesystem (in the Modules directory), specify
				<code>xs:unsignedLong(0)</code>.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>If an amp ($namespace, $local-name, $document-uri) is not found, an error is returned.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:remove-amp(
    "http://marklogic.com/my_modules/myspace",
    "my-amp",
    "/MarkLogic/MyModule.xqy",
    0)

(: Removes the "my-amp" amp. :)
</example>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/remove-amp</code>
		</privilege>
	</function>
	<function name="amp-doc-collections" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:amp-doc-collections">
		<summary>Returns a sequence of strings corresponding to the collection uri's that amps belong to.</summary>
		<return>xs:string*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:amp-doc-collections()

=&gt;

http://marklogic.com/xdmp/security
http://marklogic.com/xdmp/amps

</example>
	</function>
	<function name="amp-doc-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:amp-doc-permissions">
		<summary>Returns a sequence of permission elements that all newly created amp documents receive.</summary>
		<return>element(sec:permission)*</return>
		<privilege></privilege>
	</function>
	<function name="user-doc-collections" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-doc-collections">
		<summary>Returns a sequence of strings corresponding to the collection uri's that users belong to.</summary>
		<return>xs:string*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-doc-collections()

=&gt;

http://marklogic.com/xdmp/security
http://marklogic.com/xdmp/users


</example>
	</function>
	<function name="user-doc-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-doc-permissions">
		<summary>Returns a sequence of permission elements that all newly created user documents receive.</summary>
		<return>element(sec:permission)*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-doc-permissions()

=&gt;

&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;read&lt;/sec:capability&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;update&lt;/sec:capability&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;insert&lt;/sec:capability&gt;
&lt;/sec:permission&gt;

</example>
	</function>
	<function name="role-doc-collections" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-doc-collections">
		<summary>Returns a sequence of strings corresponding to the collection uri's that roles belong to.</summary>
		<return>xs:string*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-doc-collections()

=&gt;

http://marklogic.com/xdmp/security
http://marklogic.com/xdmp/roles

</example>
	</function>
	<function name="role-doc-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-doc-permissions">
		<summary>Returns a sequence of permission elements that all newly created role documents receive.</summary>
		<return>element(sec:permission)*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-doc-permissions()

=&gt;

&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;read&lt;/sec:capability&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;update&lt;/sec:capability&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;insert&lt;/sec:capability&gt;
&lt;/sec:permission&gt;

</example>
	</function>
	<function name="get-amp" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:get-amp">
		<summary>Returns an sec:amp element corresponding to an amp identified by ($namespace, $local-name, $document-uri). If no such amp is found, an error is returned.</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">Namespace of the function to which the amp applies.</param>
			<param name="local-name" type="xs:string" optional="false">Name of function to which the amp applies.</param>
			<param name="document-uri" type="xs:string" optional="false">URI of the document in which the function is located.</param>
			<param name="database" type="xs:unsignedLong" optional="false">Database ID in which the module is located. If the module is on the filesystem (in the Modules directory), specify
				<code>xs:unsignedLong(0)</code>.</param>
		</params>
		<return>element(sec:amp)?</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:get-amp(
    "http://marklogic.com/xdmp/alert",
    "action-insert",
    "/MarkLogic/alert.xqy",
    0)
=&gt;

&lt;sec:amp xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:amp-id&gt;2840630016131588040&lt;/sec:amp-id&gt;
  &lt;sec:namespace&gt;http://marklogic.com/xdmp/alert&lt;/sec:namespace&gt;
  &lt;sec:local-name&gt;action-insert&lt;/sec:local-name&gt;
  &lt;sec:document-uri&gt;/MarkLogic/alert.xqy&lt;/sec:document-uri&gt;
  &lt;sec:database&gt;0&lt;/sec:database&gt;
  &lt;sec:role-ids&gt;
    &lt;sec:role-id&gt;4235709426772438321&lt;/sec:role-id&gt;
  &lt;/sec:role-ids&gt;
&lt;/sec:amp&gt;

</example>
	</function>
	<function name="get-privilege" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:get-privilege">
		<summary>Returns a sec:privilege element corresponding to a privilege identified by ($action,$kind). If no such privilege is found, an error is returned.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">Action protected by this privilege. For an Execute Privilege, this is usually a URI describing an activity. For a URI Privilege, this is a base URI used to filter database activities with certain document URIs.</param>
			<param name="kind" type="xs:string" optional="false">Either "execute" or "uri".</param>
		</params>
		<return>element(sec:privilege)?</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:get-privilege(
    "http://marklogic.com/xdmp/privileges/admin-module-read",
    "execute")

=&gt;

&lt;sec:privilege xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:privilege-id&gt;17293336516617295309&lt;/sec:privilege-id&gt;
  &lt;sec:privilege-name&gt;admin-module-read&lt;/sec:privilege-name&gt;
  &lt;sec:action&gt;http://marklogic.com/xdmp/privileges/admin-module-read&lt;/sec:action&gt;
  &lt;sec:role-ids&gt;
    &lt;sec:role-id&gt;5444982746628127945&lt;/sec:role-id&gt;
    &lt;sec:role-id&gt;6629014463670416824&lt;/sec:role-id&gt;
  &lt;/sec:role-ids&gt;
  &lt;sec:kind&gt;execute&lt;/sec:kind&gt;
&lt;/sec:privilege&gt;

</example>
	</function>
	<function name="priv-doc-collections" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:priv-doc-collections">
		<summary>Returns a sequence of strings corresponding to the collection uri's that privileges belong to.</summary>
		<return>xs:string*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:priv-doc-collections()

=&gt;

http://marklogic.com/xdmp/security
http://marklogic.com/xdmp/privileges

</example>
	</function>
	<function name="priv-doc-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:priv-doc-permissions">
		<summary>Returns a sequence of permission elements that all newly created privilege documents receive.</summary>
		<return>element(sec:permission)*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:priv-doc-permissions()

=&gt;

&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;read&lt;/sec:capability&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;update&lt;/sec:capability&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
  &lt;sec:capability&gt;insert&lt;/sec:capability&gt;
&lt;/sec:permission&gt;

</example>
	</function>
	<function name="security-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:security-collection">
		<summary>Returns a string corresponding to the uri for the Security collection.</summary>
		<return>xs:string</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:security-collection()

=&gt;

http://marklogic.com/xdmp/security

</example>
	</function>
	<function name="security-namespace" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:security-namespace">
		<summary>Returns a string corresponding to the uri of the security namespace.</summary>
		<return>xs:string</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:security-namespace()

=&gt;

http://marklogic.com/xdmp/security
</example>
	</function>
	<function name="users-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:users-collection">
		<summary>Returns a string corresponding to the uri for the users collection.</summary>
		<return>xs:string</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:users-collection( )

=&gt;

http://marklogic.com/xdmp/users

</example>
	</function>
	<function name="roles-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:roles-collection">
		<summary>Returns a string corresponding to the uri for the roles collection.</summary>
		<return>xs:string</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:roles-collection( )

=&gt;

http://marklogic.com/xdmp/roles

</example>
	</function>
	<function name="privileges-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:privileges-collection">
		<summary>Returns a string corresponding to the uri for the privileges collection.</summary>
		<return>xs:string</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:privileges-collection( )

=&gt;

http://marklogic.com/xdmp/privileges

</example>
	</function>
	<function name="amps-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:amps-collection">
		<summary>Returns a string corresponding to the uri for the amps collection.</summary>
		<return>xs:string</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:amps-collection( )

=&gt;

http://marklogic.com/xdmp/amps

</example>
	</function>
	<function name="collections-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:collections-collection">
		<summary>Returns a string corresponding to the uri for the protected collections collection.</summary>
		<return>xs:string</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:collections-collection( )

=&gt;

http://marklogic.com/xdmp/collections

</example>
	</function>
	<function name="user-set-default-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-set-default-permissions">
		<summary>Sets the default permissions for a user with name $user-name.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of the user.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">New permissions. If the empty sequence is provided, deletes the existing permissions.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-set-default-permissions</code>
		</privilege>
		<usage>
			<p>If a user with name $user-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-set-default-permissions(
   "Jim",
    (xdmp:permission("security", "read"),
     xdmp:permission("security", "update")))

(: Sets the security(read) and security(update) permissions for user, "Jim." :)

</example>
	</function>
	<function name="get-distinct-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:get-distinct-permissions">
		<summary>Returns a sequence of permission elements made up of a concatenation of $output-perms and the distinct permission elements of $input-perms.</summary>
		<params>
			<param name="input-perms" type="element(sec:permission)*" optional="false">The input permissions.</param>
			<param name="output-perms" type="element(sec:permission)*" optional="false">The output permissions. This is typically an empty sequence.</param>
		</params>
		<return>element(sec:permission)*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:get-distinct-permissions(
    (xdmp:permission("security", "read"),
     xdmp:permission("security", "update")),
     ())
=&gt;

&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:capability&gt;update&lt;/sec:capability&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:capability&gt;read&lt;/sec:capability&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
&lt;/sec:permission&gt;

</example>
	</function>
	<function name="role-set-default-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-set-default-permissions">
		<summary>Sets the default permissions for a role with name $role-name.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of the role to which the default permissions are set.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">New permissions. If the empty sequence is provided, deletes the existing permissions.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-set-default-permissions</code>
		</privilege>
		<usage>
			<p>If a role with name $role-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:role-set-default-permissions(
    "Developer",
     (xdmp:permission("security", "read"),
      xdmp:permission("security", "update")))

(: Sets the default permissions for the "Developer" role to security(read) and
   security(update). :)
</example>
	</function>
	<function name="user-get-default-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-get-default-permissions">
		<summary>Returns a sequence of permission elements correspondinig to the user's default permissions.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
		</params>
		<return>element(sec:permission)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-get-default-permission</code>
		</privilege>
		<usage>
			<p>If a user with name $user-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-get-default-permissions("Jim")

=&gt;

&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:capability&gt;update&lt;/sec:capability&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:capability&gt;read&lt;/sec:capability&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
&lt;/sec:permission&gt;

</example>
	</function>
	<function name="role-get-default-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-get-default-permissions">
		<summary>Returns a sequence of permission elements correspondinig to the role's default permissions.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>element(sec:permission)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-get-default-permission</code>
		</privilege>
		<usage>
			<p>If a role with name $role-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-get-default-permissions("Developer")

=&gt;

&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:capability&gt;update&lt;/sec:capability&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:capability&gt;read&lt;/sec:capability&gt;
  &lt;sec:role-id&gt;16363340809666818373&lt;/sec:role-id&gt;
&lt;/sec:permission&gt;

</example>
	</function>
	<function name="user-get-default-collections" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-get-default-collections">
		<summary>Returns a sequence of strings correspondinig to the uri's of the user's default collections.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
		</params>
		<return>xs:string*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-get-default-collections</code>
		</privilege>
		<usage>
			<p>If a user with name $user-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:user-get-default-collections("Jim")

=&gt;

http://marklogic.com/jims_modules
http://marklogic.com/jims_docs

</example>
	</function>
	<function name="role-get-default-collections" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-get-default-collections">
		<summary>Returns a sequence of strings correspondinig to the uri's of the role's default collections.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>xs:string*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-get-default-collections</code>
		</privilege>
		<usage>
			<p>If a role with name $role-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
    "/MarkLogic/security.xqy";

sec:role-get-default-collections("Developer")

=&gt;

http://marklogic.com/dev_modules
http://marklogic.com/dev_docs

</example>
	</function>
	<function name="user-set-default-collections" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-set-default-collections">
		<summary>Sets the default collections of a user with name $user-name to $collections.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
			<param name="collections" type="xs:string*" optional="false">A sequence of collections.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-set-default-collections</code>
		</privilege>
		<usage>
			<p>If a user with name $user-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:user-set-default-collections("Jim",
    ("http://marklogic.com/jim_modules",
     "http://marklogic.com/jim_docs"))

(: Sets the default collections for the user, "Jim," to "http://marklogic.com/jim_modules"
   and "http://marklogic.com/jim_docs". Any other previously set collections are removed.

</example>
	</function>
	<function name="role-set-default-collections" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-set-default-collections">
		<summary>Sets the default collections of a role with name $role-name to $collections.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
			<param name="collections" type="xs:string*" optional="false">A sequence of collections.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-set-default-collections</code>
		</privilege>
		<usage>
			<p>If a role with name $role-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:role-set-default-collections("Developer",
    ("http://marklogic.com/dev_modules",
     "http://marklogic.com/dev_docs"))

(: Sets the default collections for the role, "Developer," to
"http://marklogic.com/dev_modules" and "http://marklogic.com/dev_docs".
 Any other previously set collections are removed.

</example>
	</function>
	<function name="get-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:get-collection">
		<summary>Gets the security document corresponding to a protected collection with uri equal to $uri.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of a collection.</param>
		</params>
		<return>element(sec:collection)</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/unprotect-collection</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/collection-set-permissions</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/collection-add-permissions</code>or
			<br />
			<code>http://marklogic.com/xdmp/privileges/collection-remove-permissions</code></privilege>
		<usage>
			<p>If a protected collection with uri equal to $uri is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:get-collection("http://marklogic.com/cpf/domains")

=&gt;

&lt;sec:collection xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:collection-id&gt;403495114666638078&lt;/sec:collection-id&gt;
  &lt;sec:uri&gt;http://marklogic.com/cpf/domains&lt;/sec:uri&gt;
&lt;/sec:collection&gt;

</example>
	</function>
	<function name="protect-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:protect-collection">
		<summary>Protects a collection $uri with the given permissions ($permissions). Returns the unique id of the protected collection. If the protected collection at the specified URI does not exist, it is created.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of a collection.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Permissions governing the collection.</param>
		</params>
		<return>xs:unsignedLong</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/protect-collection</code>
		</privilege>
		<usage>
			<p>If $uri is empty or can not be cast as an xs:AnyURI, an error is raised.</p>
			<p>If a collection with the same uri is already protected, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:protect-collection("http://marklogic.com/dev_modules",
                       (xdmp:permission("Developer", "read"),
                        xdmp:permission("Developer", "insert")))

(: Users with the "Developer" role can read and insert files in "dev_modules." :)
</example>
	</function>
	<function name="unprotect-collection" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:unprotect-collection">
		<summary>Removes the protection of a collection $uri. This does not remove the collection or any of its documents, but it does remove the protected collection from the security database.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the collection from which to remove protections.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/unprotect-collection</code>
		</privilege>
		<usage>
			<p>If a protected collection with uri equal to $uri is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:unprotect-collection("http://marklogic.com/dev_modules")

(: Removes protection from the "dev_modules" collection. :)

</example>
	</function>
	<function name="collection-set-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:collection-set-permissions">
		<summary>Sets the permissions of a protected collection identified by $uri to $permissions.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of a collection.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">New permissions. If the empty sequence is provided, deletes the existing permissions.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/collection-set-permissions</code>
		</privilege>
		<usage>
			<p>If a protected collection with uri equal to $uri is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:collection-set-permissions("http://marklogic.com/dev_modules",
                               (xdmp:permission("Developer", "read"),
                                xdmp:permission("Developer", "update")))

(: Sets the permissions on "dev_modules" to Developer(read) and Developer(update).
   Any previous permissions on the collection are removed. :)
</example>
	</function>
	<function name="collection-add-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:collection-add-permissions">
		<summary>Add the permissions $permissions to the protected collection identified by $uri.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of a collection.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">New permissions to add to that protected collection. If $permissions is the empty sequence, the function will have no effect.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/collection-add-permissions</code>
		</privilege>
		<usage>
			<p>If a protected collection with uri equal to $uri is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:collection-add-permissions("http://marklogic.com/dev_modules",
                               (xdmp:permission("Developer", "insert")))

(: Adds the Developer(insert) permission to the "dev_modules" collection. :)

</example>
	</function>
	<function name="collection-remove-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:collection-remove-permissions">
		<summary>Removes the permissions $permissions from the protected collection identified by $uri.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of a collection.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Permissions to be removed from that protected collection. If $permissions is the empty sequence, the function will have no effect.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/collection-remove-permissions</code>
		</privilege>
		<usage>
			<p>If a protected collection with uri equal to $uri is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:collection-remove-permissions("http://marklogic.com/dev_modules",
                                  (xdmp:permission("Developer", "update")))

(: Removes the Developer(update) permission from the "dev_modules" collection. :)
</example>
	</function>
	<function name="collection-get-permissions" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:collection-get-permissions">
		<summary>Returns a sequence of permission elements corresponding to the current permissions granted to the protected collection identified by $uri.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of a collection.</param>
		</params>
		<return>element(sec:permission)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/collection-get-permissions</code>
		</privilege>
		<usage>
			<p>If a protected collection with uri equal to $uri is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:collection-get-permissions("http://marklogic.com/dev_modules")

=&gt;

&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:capability&gt;read&lt;/sec:capability&gt;
  &lt;sec:role-id&gt;5444982746628127945&lt;/sec:role-id&gt;
&lt;/sec:permission&gt;
&lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
  &lt;sec:capability&gt;insert&lt;/sec:capability&gt;
  &lt;sec:role-id&gt;5444982746628127945&lt;/sec:role-id&gt;
&lt;/sec:permission&gt;

</example>
	</function>
	<function name="user-privileges" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-privileges">
		<summary>Returns a set of privilege elements corresponding to all privileges that a user has. (roles are flattened to give a complete set of privileges).</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of a user.</param>
		</params>
		<return>element(sec:privilege)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/user-privileges</code>if the current user is not $user-name.</privilege>
		<usage>
			<p>If a user with name equal to $user-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:user-privileges("Jim")

=&gt;

&lt;sec:privilege xmlns:sec="http://marklogic.com/xdmp/security"&gt;
 &lt;sec:privilege-id&gt;12387631775818383068&lt;/sec:privilege-id&gt;
  &lt;sec:privilege-name&gt;xdmp:save&lt;/sec:privilege-name&gt;
  &lt;sec:action&gt;http://marklogic.com/xdmp/privileges/xdmp-save&lt;/sec:action&gt;
  &lt;sec:role-ids&gt;
    &lt;sec:role-id&gt;13749738523688002780&lt;/sec:role-id&gt;
  &lt;/sec:role-ids&gt;
  &lt;sec:kind&gt;execute&lt;/sec:kind&gt;
&lt;/sec:privilege&gt;
(:  ..... and all other privileges assigned to "jim." :)

</example>
	</function>
	<function name="role-privileges" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-privileges">
		<summary>Returns a set of privilege elements corresponding to all privileges that a role has. (Roles are flattened to give a complete set of privileges).</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of a role.</param>
		</params>
		<return>element(sec:privilege)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-privileges</code>if the current role is not $role-name.</privilege>
		<usage>
			<p>If a role with name equal to $role-name is not found, an error is raised.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:role-privileges("Developer")

=&gt;

&lt;sec:privilege xmlns:sec="http://marklogic.com/xdmp/security"&gt;
 &lt;sec:privilege-id&gt;12387631775818383068&lt;/sec:privilege-id&gt;
  &lt;sec:privilege-name&gt;xdmp:save&lt;/sec:privilege-name&gt;
  &lt;sec:action&gt;http://marklogic.com/xdmp/privileges/xdmp-save&lt;/sec:action&gt;
  &lt;sec:role-ids&gt;
    &lt;sec:role-id&gt;13749738523688002780&lt;/sec:role-id&gt;
  &lt;/sec:role-ids&gt;
  &lt;sec:kind&gt;execute&lt;/sec:kind&gt;
&lt;/sec:privilege&gt;
(:  ..... and all other privileges assigned to "Developer." :)
</example>
	</function>
	<function name="security-installed" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:security-installed">
		<summary>Returns fn:true() if security has been installed on the current database. Otherwise, returns false.</summary>
		<params />
		<return>xs:boolean</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:security-installed()

=&gt; true
</example>
	</function>
	<function name="uid-for-name" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:uid-for-name">
		<summary>Returns the uids for the named user or () if no such user exists.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The named user.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:uid-for-name("Jim")

=&gt;

18325468190304151823

</example>
	</function>
	<function name="get-user-names" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:get-user-names">
		<summary>Returns sequence of unique sec:user-name's that corresponds to the sequence of user IDs $user-ids. Duplicate IDs return a single name.</summary>
		<params>
			<param name="user-ids" type="xs:unsignedLong*" optional="false">A sequence of user IDs.</param>
		</params>
		<return>element(sec:user-name)*</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/get-user-names</code>
		</privilege>
		<usage>
			<p>If a user ID in $user-ids does not correspond to an existing user, an error is returned.</p>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
   "/MarkLogic/security.xqy";

sec:get-user-names((18325468190304151823,
                    5673246250406350379,
                    11765239768744971597))

=&gt;

&lt;sec:user-name xmlns:sec="http://marklogic.com/xdmp/security"&gt;Jim&lt;/sec:user-name&gt;
&lt;sec:user-name xmlns:sec="http://marklogic.com/xdmp/security"&gt;Sue&lt;/sec:user-name&gt;
&lt;sec:user-name xmlns:sec="http://marklogic.com/xdmp/security"&gt;Tom&lt;/sec:user-name&gt;

</example>
	</function>
	<function name="set-realm" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:set-realm">
		<summary>Changes the realm of this security database to $realm. If the realm is different from the old value this function also invalidates all the existing digest passwords since they will no longer work with the new realm. Warning: this invalidates all user's digest passwords, including the user running this function and users of the Admin Interface (if the Admin Interface is set to digest authentication, which is the default setting); once a user's digest password is invalidated, that user will no longer be able to log in with digest authentication.</summary>
		<params>
			<param name="realm" type="xs:string" optional="false">The new realm name to which the security database name is changed.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";
import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:set-realm("public")

(: Sets the realm to "public." :)

</example>
	</function>
	<function name="check-admin" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:check-admin">
		<summary>Throws an error if the current user does not have the admin role.</summary>
		<params />
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";

import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:check-admin()

=&gt;  [0.9-ml] SEC-NOADMIN: User does not have admin role.

</example>
	</function>
	<function name="security-version" type="security" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:security-version">
		<summary>Returns the current version of the security database.</summary>
		<params />
		<return>xs:double</return>
		<privilege></privilege>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
(: execute this against the security database :)
xquery version "1.0-ml";

import module namespace sec="http://marklogic.com/xdmp/security" at
     "/MarkLogic/security.xqy";

sec:security-version()

=&gt; 40100

</example>
	</function>
	<function name="get-compartments" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:get-compartments">
		<summary>This function returns a list of all of the compartments.</summary>
		<return>xs:string*</return>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/get-compartments</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  sec:get-compartments()


</example>
	</function>
	<function name="role-get-compartment" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-get-compartment">
		<summary>This function returns the compartment for the specified role.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The name of the role.</param>
		</params>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/role-get-compartment</code>
		</privilege>
		<return>xs:string?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  sec:role-get-compartment("my-compartmented-role")

</example>
	</function>
	<function name="compartment-get-roles" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:compartment-get-roles">
		<summary>This function returns a list of roles in the specifed compartment.</summary>
		<params>
			<param name="compartment-name" type="xs:string" optional="false">The name of the compartment.</param>
		</params>
		<return>element(sec:role)*</return>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/compartment-get-roles</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  sec:compartment-get-roles("my-compartment")

</example>
	</function>
	<function name="validate-permissions" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:validate-permissions">
		<summary>This function throws the SEC_NOPERMCAP exception if a permission has no capability specified and it throws the SEC-NOPERMROLEID exception if there is no role specified in the permission.</summary>
		<params>
			<param name="permissions" type="element(sec:permission)*" optional="false">Zero or more permission elements to check.</param>
		</params>
		<return>node()*</return>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  sec:validate-permissions(xdmp:permission("my-role", "read"))

</example>
	</function>
	<function name="role-exists" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:role-exists">
		<summary>This function returns true if the specified role exists in the security database.</summary>
		<params>
			<param name="role-name" type="xs:string" optional="false">The role name.</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/get-role</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  sec:role-exists("my-role")

</example>
	</function>
	<function name="user-exists" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-exists">
		<summary>This function returns true if the specified user exists in the security database.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The user name.</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/get-user</code>
		</privilege>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  sec:user-exists("my-user")

</example>
	</function>
	<function name="privilege-exists" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:privilege-exists">
		<summary>This function returns true if the specified privilege exists.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">The URI of the privilege.</param>
			<param name="kind" type="xs:string" optional="false">The kind of privilege: "execute" or uri".</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/get-privilege</code>
		</privilege>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: execute this against the security database :)
import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

sec:privilege-exists("http://marklogic.com/xdmp/privileges/get-privilege",
      "execute")


</example>
	</function>
	<function name="amp-exists" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:amp-exists">
		<summary>This function returns true if the specified amp exists in the security database.</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">The namespace for the amped function.</param>
			<param name="local-name" type="xs:string" optional="false">The local-name of the amped function.</param>
			<param name="document-uri" type="xs:string" optional="false">The URI of the module containing the amped function.</param>
			<param name="database" type="xs:unsignedLong" optional="false">The database ID of the module containing the amped function.</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>This function must be executed against the security database.</p>
		</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

   sec:amp-exists("my/namespace/uri", "my-function", "/my/module.xqy",
      xdmp:database("my-database"))

</example>
	</function>
	<function name="user-get-last-password-date" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="true" fullname="sec:user-get-last-password-date">
		<summary>This function returns the time of the most recent password change for the specified user. If the password for the user has not been changed since the upgrade to 4.2, there is no history, so an empty sequence will be returned. If the user does not exist, an exception is thrown.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of the user to check.</param>
		</params>
		<return>xs:dateTime?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  sec:user-get-last-password-date("Jim")

  (: Returns the date and time of the last password change for the user "Jim," or
     an empty sequence if the password has not changed since the upgrade to 4.2. :)

</example>
	</function>
	<function name="user-get-password-extra" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-get-password-extra">
		<summary>This function returns the extra information for the specified user. If the user does not exist, an exception is thrown.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of the user for whom to return the extra information.</param>
		</params>
		<return>element(sec:password-extra)?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  sec:user-get-password-extra("Jim")

  (: Returns the extra information for the user, Jim. :)

</example>
	</function>
	<function name="user-set-password-extra" lib="sec" category="Security-sec" bucket="XQuery Library Modules" hidden="false" fullname="sec:user-set-password-extra">
		<summary>This function sets extra information for the specified user. If the user does not exist, an exception is thrown.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The name of the user for whom to set the extra information.</param>
			<param name="extra" type="element(sec:password-extra)" optional="false">The extra information to be set for the user.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace sec = "http://marklogic.com/xdmp/security"
      at "/MarkLogic/security.xqy";

  let $extra := &lt;sec:password-extra&gt;
                   &lt;p&gt;Change this password in 30 days&lt;/p&gt;
                &lt;/sec:password-extra&gt;

  return sec:user-set-password-extra("Jim", $extra)

  (: Sets the extra information for the user, Jim. :)

</example>
	</function>
	<function name="load" type="spell" lib="spell" category="Spelling Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="spell:load">
		<summary>Add the words from the file specified in $path to the dictionary at $uri. If a document exists with the specified URI, it is replaced with this one. Note that words that are 64 characters or greater will never be returned as suggestions from
			<code>spell:suggest</code>or
			<code>spell:suggest-detailed</code>.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path to a file containing the dictionary.</param>
			<param name="uri" type="xs:string" optional="false">The URI of the dictionary.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>Dictionaries loaded with the
			<code>spell:load</code>function are automatically added to the following collections:
			<ul>
				<li>http://marklogic.com/xdmp/documents</li>
				<li>http://marklogic.com/xdmp/spell</li>
			</ul></usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace spell = "http://marklogic.com/xdmp/spell"
	         at "/MarkLogic/spell.xqy";

  spell:load("c:\dictionaries\spell.xml", "/mySpell/spell.xml")

</example>
	</function>
	<function name="insert" type="spell" lib="spell" category="Spelling Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="spell:insert">
		<summary>Load the words in $dict into the dictionary at $uri. If there is no document at $uri a new one will be created. If there is a document at $uri it will be overwritten.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the dictionary.</param>
			<param name="dict" type="element(spell:dictionary)" optional="false">A dictionary document.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace spell = "http://marklogic.com/xdmp/spell"
	         at "/MarkLogic/spell.xqy";

  spell:insert("/mySpell/special.xml",
     &lt;dictionary xmlns="http://marklogic.com/xdmp/spell"&gt;
          &lt;word&gt;WebDAV&lt;/word&gt;
     &lt;/dictionary&gt; )

  =&gt; Creates a dictionary with only the word "WebDAV"
     at the specifed URI

</example>
	</function>
	<function name="add-word" type="spell" lib="spell" category="Spelling Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="spell:add-word">
		<summary>Add the word $word to the dictionary at $uri. If the word is already in the dictionary (case-sensitive), then this function throws an exception.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the dictionary.</param>
			<param name="word" type="xs:string" optional="false">The word to add.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace spell = "http://marklogic.com/xdmp/spell"
	         at "/MarkLogic/spell.xqy";

  spell:add-word("/mySpell/spell.xml", "WebDAV")

  =&gt; adds the word "WebDAV" to the specifed dictionary

</example>
	</function>
	<function name="remove-word" type="spell" lib="spell" category="Spelling Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="spell:remove-word">
		<summary>Remove the word $word from the dictionary at $uri.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the dictionary.</param>
			<param name="word" type="xs:string" optional="false">The word to remove.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace spell = "http://marklogic.com/xdmp/spell"
	         at "/MarkLogic/spell.xqy";

  spell:remove-word("/mySpell/spell.xml", "Fiat")

  =&gt; removes the word "Fiat" from the specified dictionary

</example>
	</function>
	<function name="make-dictionary" type="spell" lib="spell" category="Spelling Dictionary Management" bucket="XQuery Library Modules" hidden="false" fullname="spell:make-dictionary">
		<summary>Creates a dictionary node from a sequence of words. Use
			<code>spell:load</code>to load the dictionary node into the database as a dictionary.</summary>
		<params>
			<param name="words" type="xs:string*" optional="false">The words from which to construct a dictionary.</param>
		</params>
		<return>element(spell:dictionary)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace spell = "http://marklogic.com/xdmp/spell"
	         at "/MarkLogic/spell.xqy";

  let $words := ("words", "to", "go", "in", "the", "dictionary")
  return
  spell:make-dictionary($words)

  =&gt;
  &lt;dictionary xmlns="http://marklogic.com/xdmp/spell"&gt;
    &lt;word&gt;words&lt;/word&gt;
    &lt;word&gt;to&lt;/word&gt;
    &lt;word&gt;go&lt;/word&gt;
    &lt;word&gt;in&lt;/word&gt;
    &lt;word&gt;the&lt;/word&gt;
    &lt;word&gt;dictionary&lt;/word&gt;
  &lt;/dictionary&gt;


</example>
    <example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace spell = "http://marklogic.com/xdmp/spell"
	         at "/MarkLogic/spell.xqy";

  spell:make-dictionary(cts:words())

  =&gt; A spell:dictionary element containing all the words in the database.
     Use spell:load to load this into the database as a dictionary.
     This example requires a word lexicon on the database.  You can
     construct the sequence of words any way you like.

</example>
	</function>
	<function name="is-correct" type="builtin" lib="spell" category="SpellBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="spell:is-correct">
		<summary>Returns true() if the specified word is spelled correctly, otherwise returns false(). A word is considered to be spelled correctly if it is in the specified dictionary.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URIs of the dictionarys to use.</param>
			<param name="word" type="xs:string" optional="false">The word to check.</param>
		</params>
		<return>xs:boolean</return>
		<usage>The
			<code>spell:is-correct</code>function is a built-in function and does not require the
			<code>import module</code>statement in the XQuery prolog.</usage>
		<example xml:space="preserve">
  spell:is-correct("en-utf8.xml","occasionally")

  =&gt; true()
</example>
		<algorithm />
	</function>
	<function name="suggest" type="builtin" lib="spell" category="SpellBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="spell:suggest">
		<summary>Suggests a list of spellings for a word. Returns a sequence of the most likely spellings for the specified word.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URIs of the dictionarys to use.</param>
			<param name="word" type="xs:string" optional="false">The word for which you get spelling suggestions.</param>
			<param name="options" type="node()?" optional="true">The options node for this suggest operation. The default is (). The node for the spell:suggest options must be in the
				<code>http://marklogic.com/xdmp/spell</code>namespace.
				<p>The
					<code>spell:suggest</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;maximum&gt;</p>
						</dt>
						<dd>Specifies the maximum number of suggestions to be returned. The default is 10.</dd>
						<dt>
							<p>&lt;distance-threshold&gt;</p>
						</dt>
						<dd>Specifies a cut off threshold for suggestions having a distance less than the gven number. The default is 100.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>xs:string*</return>
		<usage>
			<p>The
				<code>spell:suggest</code>function is a built-in function and does not require the
				<code>import module</code>statement in the XQuery prolog.</p>
			<p>The
				<code>spell:suggest</code>function only provides suggestions to words that are less than 64 characters in length; words 64 characters or longer return no suggestions. Also, it removes any dictionary entries that are 64 characters or more, so it will never return a suggestion with greater than 64 characters.</p>
		</usage>
		<example xml:space="preserve">
  spell:suggest("myDictionary.xml","occasionally")

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; occasionally occasional occasion occasions occasion's
     occasioned optionally educationally irrationally
</example>
    <example xml:space="preserve">
  spell:suggest("spell.xml", "albetros")

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; albatross abettors alders alters Albert's Elbert's
     allegros alder's Walters abettor's
</example>
		<algorithm />
	</function>
	<function name="levenshtein-distance" type="builtin" lib="spell" category="SpellBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="spell:levenshtein-distance">
		<summary>Given two strings, returns the Levenshtein distance between those strings. The Levenshtein distance is a measure of how many operations it takes to transform a string into another string, and it is useful in determining if a word is spelled correctly, or in simply comparing how "different" two words are.</summary>
		<params>
			<param name="str1" type="xs:string" optional="false">The first input string.</param>
			<param name="str2" type="xs:string" optional="false">The second input string.</param>
		</params>
		<return>xs:integer?</return>
		<usage>
			<p>The
				<code>spell:levenshtein-distance</code>function is a built-in function and does not require the
				<code>import module</code>statement in the XQuery prolog.</p>
			<p>The
				<code>spell:levenshtein-distance</code>function throws an exception if one of the strings is 64 or more characters in length and the other is at least 1 character in length.</p>
		</usage>
		<example xml:space="preserve">
  spell:levenshtein-distance("albatros","albetros")

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; 1
</example>
    <example xml:space="preserve">
  spell:levenshtein-distance("cat", "cats")

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; 1
</example>
		<algorithm />
	</function>
	<function name="double-metaphone" type="builtin" lib="spell" category="SpellBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="spell:double-metaphone">
		<summary>Given a word returns the two metaphone keys. The primary and secondary metaphone keys which represent the phonetic encoding of two words are returned as a sequence of two strings. Double metaphone is an algorithm based on phonetic sounds useful in providing data to spelling correction suggestions.</summary>
		<params>
			<param name="word" type="xs:string" optional="false">The word for phonetic matching.</param>
		</params>
		<return>xs:string*</return>
		<usage>The
			<code>spell:double-metaphone</code>function is a built-in function and does not require the
			<code>import module</code>statement in the XQuery prolog.</usage>
		<example xml:space="preserve">
  spell:double-metaphone("smith")

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; smo xmt
</example>
    <example xml:space="preserve">
  spell:double-metaphone("jones")

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; jns ans
</example>
		<algorithm />
	</function>
	<function name="suggest-detailed" type="builtin" lib="spell" category="SpellBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="spell:suggest-detailed">
		<summary>Suggests a list of spellings for a word. Returns a sequence of elements describing each suggestion, including the suggested word, the distance, the key distance, the word distance, and the levenshtein distance.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URIs of the dictionarys to use.</param>
			<param name="word" type="xs:string" optional="false">The word for which you get spelling suggestions.</param>
			<param name="options" type="node()?" optional="true">The options node for this suggest operation. The default is (). The node for the
				<code>spell:suggest-detailed</code>options must be in the
				<code>http://marklogic.com/xdmp/spell</code>namespace.
				<p>The
					<code>spell:suggest-detailed</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;maximum&gt;</p>
						</dt>
						<dd>Specifies the maximum number of suggestions to be returned. The default is 10.</dd>
						<dt>
							<p>&lt;distance-threshold&gt;</p>
						</dt>
						<dd>Specifies a cut off threshold for suggestions having a distance less than the gven number. The default is 100.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>spell:suggestion*</return>
		<usage>
			<p>The
				<code>spell:suggest-detailed</code>function is a built-in function and does not require the
				<code>import module</code>statement in the XQuery prolog.</p>
			<p>The
				<code>spell:suggest-detailed</code>function only provides suggestions to words that are less than 64 characters in length; words 64 characters or longer return no suggestions. Also, it removes any dictionary entries that are 64 characters or more, so it will never return a suggestion with greater than 64 characters.</p>
		</usage>
		<example xml:space="preserve">
  spell:suggest-detailed("myDictionary.xml","occasionally")

<br xmlns="http://www.w3.org/1999/xhtml" />
  =&gt; ()
</example>
    <example xml:space="preserve">
  spell:suggest("spell.xml", "albetros")

  =&gt;
&lt;spell:suggestion original="albetros" dictionary="spell.xml"&gt;
  &lt;spell:word
         distance="26"
         key-distance="0"
         word-distance="95"
         levenshtein-distance="2"&gt;
    albatross
  &lt;/spell:word&gt;
&lt;/spell:suggestion&gt;
</example>
		<algorithm />
	</function>
	<function name="load" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:load">
		<summary>Load the file specified in $path to the thesaurus at $uri. Exisiting documents at $uri are overwritten.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path to a file containing thesaurus entries.</param>
			<param name="uri" type="xs:string" optional="false">The URI of a thesaurus document.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>If $path contains XML that does not conform to the thesaurus schema, an error is raised. If $uri contains XML that does not conform to the thesaurus schema (located in
			<code>
				<em>install_dir</em>/Config/thesaurus.xsd</code>), an error is raised.
			<br />
			<br /></usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	thsr="http://marklogic.com/xdmp/thesaurus"
                             at "/MarkLogic/thesaurus.xqy";

  thsr:load("c:\thesaurus\roget.xml", "/myThsrDocs/roget.xml")

</example>
	</function>
	<function name="insert" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:insert">
		<summary>Load the entries in $thsr into the thesaurus at $uri. If there is no document at $uri a new one will be created. If there is a document at $uri it will be overwritten.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of a thesaurus document.</param>
			<param name="thsr" type="element(thsr:thesaurus)" optional="false">A thesaurus document.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>If $uri contains XML that does not conform to the thesaurus schema (located in
			<code>
				<em>install_dir</em>/Config/thesaurus.xsd</code>), an error is raised.
			<br />
			<br />If $thsr contains XML that does not conform to the thesaurus schema, an error is raised.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	thsr="http://marklogic.com/xdmp/thesaurus"
                             at "/MarkLogic/thesaurus.xqy";

  thsr:insert("/myThsrDocs/roget.xml",
               xdmp:get("c:\thesaurus\roget.xml") )

</example>
	</function>
	<function name="set-entry" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:set-entry">
		<summary>Adds the entry $entry to the thesaurus at $uri.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of a thesaurus document.</param>
			<param name="entry" type="element(thsr:entry)" optional="false">An entry to add to the thesaurus.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>set the entry $entry in the thesaurus at $uri. If $entry does not contain a valid entry node, an error will be raised. If an entry matching $entry does not exist in the thesaurus, $entry is added to the thesaurus. If $entry contains XML that does not conform to the thesaurus schema (located in
			<code>
				<em>install_dir</em>/Config/thesaurus.xsd</code>), an error is raised.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	thsr="http://marklogic.com/xdmp/thesaurus"
                             at "/MarkLogic/thesaurus.xqy";

  thsr:set-entry("/myThsrDocs/roget.xml",
   &lt;entry xmlns="http://marklogic.com/xdmp/thesaurus"&gt;
      &lt;term&gt;Car&lt;/term&gt;
      &lt;synonym&gt;
        &lt;term&gt;Ford&lt;/term&gt;
        &lt;part-of-speech&gt;noun&lt;/part-of-speech&gt;
      &lt;/synonym&gt;
      &lt;synonym&gt;
        &lt;term&gt;automobile&lt;/term&gt;
        &lt;part-of-speech&gt;noun&lt;/part-of-speech&gt;
      &lt;/synonym&gt;
      &lt;synonym&gt;
        &lt;term&gt;Fiat&lt;/term&gt;
        &lt;part-of-speech&gt;noun&lt;/part-of-speech&gt;
      &lt;/synonym&gt;
   &lt;/entry&gt;)

</example>
	</function>
	<function name="remove-term" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:remove-term">
		<summary>Removes all entries with term $term from the thesaurus document(s) at $uri.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URI of the thesaurus document(s).</param>
			<param name="term" type="xs:string" optional="false">A term to remove from the thesaurus.</param>
		</params>
		<return>empty-sequence()</return>
		<usage></usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	thsr="http://marklogic.com/xdmp/thesaurus"
                             at "/MarkLogic/thesaurus.xqy";

  thsr:remove-term("/myThsrDocs/roget.xml", "Car")

   =&gt; removes all entries for "Car" from the thesaurus with the
      specified URI


</example>
	</function>
	<function name="remove-entry" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:remove-entry">
		<summary>Removes all entries that exactly match $entry from the thesaurus documents(s) at $uri.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URI of the thesaurus document(s).</param>
			<param name="entry" type="element(thsr:entry)" optional="false">A thesaurus entry.</param>
		</params>
		<return>empty-sequence()</return>
		<usage></usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	thsr="http://marklogic.com/xdmp/thesaurus"
                             at "/MarkLogic/thesaurus.xqy";

   (: removes the second "Car" entry from the
      thesaurus document :)
  thsr:remove-entry("/myThsrDocs/roget.xml",
            thsr:lookup("/myThsrDocs/roget.xml","Car")[2])

</example>
	</function>
	<function name="add-synonym" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:add-synonym">
		<summary>Adds a synonym to the specified thesaurus entry.</summary>
		<params>
			<param name="entry" type="element(thsr:entry)" optional="false">A thesaurus entry.</param>
			<param name="synonym" type="element(thsr:synonym)" optional="false">A synonym to add to a thesaurus entry.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>The synonym and the entry specified must conform to the thesaurus schema and must be namespace-qualified with the "http://marklogic.com/xdmp/thesaurus" namespace.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	thsr="http://marklogic.com/xdmp/thesaurus"
                             at "/MarkLogic/thesaurus.xqy";
  thsr:add-synonym(thsr:lookup("/myThsrDocs/roget.xml",
                               "car")[1],
                 &lt;thsr:synonym&gt;
                    &lt;thsr:term&gt;Alfa Romeo&lt;/thsr:term&gt;
                 &lt;/thsr:synonym&gt;)

</example>
	</function>
	<function name="remove-synonym" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:remove-synonym">
		<summary>Removes synonym $synonym from thesaurus entry $entry.</summary>
		<params>
			<param name="entry" type="element(thsr:entry)" optional="false">A thesaurus entry.</param>
			<param name="synonym" type="element(thsr:synonym)" optional="false">A synonym to add to a thesaurus entry.</param>
		</params>
		<return>empty-sequence()</return>
		<usage></usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	   thsr="http://marklogic.com/xdmp/thesaurus"
                             at "/MarkLogic/thesaurus.xqy";

  thsr:remove-synonym(thsr:lookup("/myThsrDocs/roget.xml",
                                   "car")[1],
                           &lt;thsr:synonym&gt;
                                &lt;thsr:term&gt;Fiat&lt;/thsr:term&gt;
                           &lt;/thsr:synonym&gt;)


</example>
	</function>
	<function name="lookup" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:lookup">
		<summary>Returns all entries for term $term in the thesaurus document(s) at $uri.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URI of the thesaurus document(s).</param>
			<param name="term" type="xs:string" optional="false">A term to lookup in the thesaurus.</param>
		</params>
		<return>element(thsr:entry)*</return>
		<usage></usage>
		<example xml:space="preserve">
   thsr:lookup("/myThsrDocs/thesaurus.xml", "weary")
   =&gt; returns the thesaurus entry for the term "weary"

</example>
	</function>
	<function name="query-lookup" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:query-lookup">
		<summary>Returns a sequence of all entries that are found by looking up terms in the query and/or subqueries of $query in the thesaurus document(s) at $uri.</summary>
		<params>
			<param name="uri" type="xs:string*" optional="false">The URI of the thesaurus document(s).</param>
			<param name="query" type="cts:query" optional="false">A cts:query item from any of the
				<code>cts:*-query</code>functions (
				<code>cts:word-query</code>,
				<code>cts:and-query</code>, etc.).</param>
		</params>
		<return>element(thsr:entry)*</return>
		<usage></usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	   thsr="http://marklogic.com/xdmp/thesaurus"
                           at "/MarkLogic/thesaurus.xqy";

  let $query := cts:word-query("weary")
  return
      thsr:query-lookup("/myThsrDocs/thesaurus.xml",
                        $query)

   =&gt; All entries for the term "weary" in the specified
      thsesaurus document

</example>
	</function>
	<function name="expand" type="thesaurus" lib="thsr" category="Thesaurus" bucket="XQuery Library Modules" hidden="false" fullname="thsr:expand">
		<summary>Returns a query that searches for all the query strings specified in $query and their synonyms as found in $entries.</summary>
		<params>
			<param name="query" type="cts:query" optional="false">A cts:query item from any of the
				<code>cts:*-query</code>functions (
				<code>cts:word-query</code>,
				<code>cts:and-query</code>, and so on). Thesaurus expansion only occurs on an "unwildcarded"
				<code>cts:query</code>; it cannot expand "wildcarded" queries.</param>
			<param name="entries" type="element(thsr:entry)*" optional="false">A sequence of thesaurus entries.</param>
			<param name="new-weight" type="xs:double?" optional="false">A new weight for the relevance ranking. If $new-weight is the empty sequence, then the relevance ranking is inherited from the parent query.</param>
			<param name="min-weight" type="xs:double?" optional="false">A minimum weight for the relevance ranking. If $min-weight is not the empty sequence then only queries with weight less than or equal to $min-weight will be expanded. Otherwise, all queiries are expanded.</param>
			<param name="filter" type="node()*" optional="false">A sequence of node restrictions. These restrictions must be nodes that can be found in a thesaurus entry (for example,
				<code>&lt;thsr:qualifier&gt;birds&lt;/thsr:qualifier&gt;</code>).</param>
		</params>
		<return>cts:query</return>
		<usage></usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace
	   thsr="http://marklogic.com/xdmp/thesaurus"
                           at "/MarkLogic/thesaurus.xqy";

  cts:search(
   doc("/Docs/hamlet.xml")//LINE,
   thsr:expand(
     cts:word-query("weary"),
     thsr:lookup("/myThsrDocs/thesaurus.xml",
     "weary"),
     (),
     (),
     () )
   )

   (: This query returns all of the lines in Shakespeare's
      Hamlet that have the word "weary" or any of the
      synonyms of the word "weary"  :)


</example>
	</function>
	<function name="create-trigger" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:create-trigger">
		<summary>Creates a new trigger in the context database. Returns the trigger ID of the created trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">A unique name. If $trigger-name is not unique, an error is returned.</param>
			<param name="description" type="xs:string?" optional="false">A description of the trigger.</param>
			<param name="event" type="element()" optional="false">The definition of an event that invokes the trigger module. Use
				<code>
					<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
				</code>or
				<code>
					<a href="#trgr:trigger-database-online-event">trgr:trigger-database-online-event</a>
				</code>to construct this element.</param>
			<param name="module" type="element(trgr:module)" optional="false">The module to execute when the triggering event occurs. Use
				<code>
					<a href="#trgr:trigger-module">trgr:trigger-module</a>
				</code>to construct this element.</param>
			<param name="enabled" type="xs:boolean" optional="false">Set to true if the trigger is enabled.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">A sequence of permissions for the trigger. These permissions will determine which roles are permitted to modify the trigger.</param>
			<param name="recursive" type="xs:boolean?" optional="true">Set to true if the trigger should be allowed to trigger itself for recursive changes on the same document. Set to false to prevent the trigger from triggering itself. If this parameter is not present, then its value is true.</param>
			<param name="task-priority" type="xs:string" optional="true">The task priority for post-commit triggers. Either "normal" or "higher". If this parameter is not present, the value is "normal".</param>
		</params>
		<return>xs:unsignedLong</return>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/create-trigger</code>
			</p>
		</privilege>
		<usage>
			<p>Triggers must be created in the triggers database associated with the the content database to which the triggers apply. To determine the triggers database programatically, use
				<code>xdmp:triggers-database</code>in the evaluation context of the content database, or
				<code>xdmp:database</code>with the database name listed as the
				<code>triggers database</code>value in the Admin Interface under Databases &gt;
				<em>content_db_name</em>.</p>
			<p>Triggers are created in the
				<code>http://marklogic.com/xdmp/triggers/</code>directory, with the trigger ID completing the URI. This is the ID returned by
				<code>trgr:create-trigger</code>.</p>
			<p>If a trigger named $trigger-name already exists, the exception
				<code>TRGR-TNEXISTS</code>is raised. You must use
				<code>
					<a href="#trgr:remove-trigger">trgr:remove-trigger</a>
				</code>to delete an existing trigger before recreating it.</p>
			<p>Once a trigger is created, you can view it in the Admin Interface under the content database, in the Triggers Summary page (Databases &gt;
				<em>content_db_name</em>&gt; Triggers). If your trigger does not appear in Triggers Summary,
				<code>trgr:create-trigger</code>was probably evaluated in the wrong database context.</p>
		</usage>
		<example xml:space="preserve">
(: Run in the context of the triggers database of the content database :)
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:create-trigger("myTrigger", "Simple trigger example",
  trgr:trigger-data-event(
      trgr:directory-scope("/myDir/", "1"),
      trgr:document-content("create"),
      trgr:post-commit()),
  trgr:trigger-module(xdmp:database("test"), "/modules/", "log.xqy"),
  fn:true(), xdmp:default-permissions() )

  =&gt; The ID of the newly created trigger. This
     trigger fires whenever a document is created in the
     /myDir/ directory. The action module, /modules/log.xqy,
     is stored in the modules database of the App Server
     against which the content document is created.  When
     the trigger fires, a task to evaluate /modules/log.xqy
     is spawned on the task server queue.

</example>
	</function>
	<function name="trigger-set-name" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-set-name">
		<summary>Changes the name of a trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The current trigger name.</param>
			<param name="new-trigger-name" type="xs:string" optional="false">The new trigger name.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>Changes the name of a trigger from $trigger-name to $new-trigger-name.</p>
			<p>This function must be run in the context of the database containing the trigger whose name is to be changed.</p>
			<p>If no trigger trigger named $trigger-name exists, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: In the context of the database containing the trigger :)
trgr:trigger-set-name("currentName", "newName")

</example>
	</function>
	<function name="trigger-set-description" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-set-description">
		<summary>Sets the description of the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
			<param name="description" type="xs:string" optional="false">The new trigger description.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>This function must be run in the context of the database containing the trigger whose description is to be changed.</p>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-set-description("currentName", "the new description")

</example>
	</function>
	<function name="trigger-enable" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-enable">
		<summary>Enables the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>This function must be run in the context of the database containing the trigger to be enabled. If no trigger named $trigger-name exists, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-enable("the_trigger_name")

</example>
	</function>
	<function name="trigger-disable" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-disable">
		<summary>Disables the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>This function must be run in the context of the database containing the trigger to be disabled. If no trigger named $trigger-name exists, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-disable("the_trigger_name")

</example>
	</function>
	<function name="trigger-set-module" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-set-module">
		<summary>Sets or replaces the action module associated with the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
			<param name="module" type="element(trgr:module)" optional="false">A module definition. Use
				<code>
					<a href="#trgr:trigger-module">trgr:trigger-data-event</a>
				</code>to construct this parameter.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>When $trigger fires, $module is evaluated. Any module previously associated with $trigger is replaced when this function is called.</p>
			<p>This function must be run in the context of the database containing the trigger to be modified.</p>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-set-module(
  "myTrigger",
  trgr:trigger-module(
    xdmp:database("trigger_module_database"),
    "/modules/",
    "the-new-action.xqy") )

  =&gt; Empty sequence. When "myTrigger" fires, "the-new-action.xqy"
    is evaluated.

</example>
	</function>
	<function name="trigger-set-event" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-set-event">
		<summary>Assigns a triggering event to the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
			<param name="event" type="element()" optional="false">An event definition. Use
				<code>
					<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
				</code>or
				<code>
					<a href="#trgr:trigger-database-online-event">trgr:trigger-database-online-event</a>
				</code>to construct this element.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>A trigger event describes the conditions under which the trigger fires. After calling this function, any previous event associated with the trigger is replaced.</p>
			<p>This function must be run in the context of the database containing the trigger to be modified.</p>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-set-event(
  "myTrigger",
  trgr:trigger-data-event(
    trgr:directory-scope("/myDir/", "1"),
    trgr:document-content("create"),
    trgr:post-commit()) )

  =&gt; Empty sequence. The trigger "myTrigger" is set to fire
     whenever a document is created in "/myDir/". The trigger
     module runs after the creating transaction is committed.

</example>
	</function>
	<function name="trigger-set-permissions" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-set-permissions">
		<summary>Sets the permissions that determine which roles are permitted to modify the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">A sequence of permission nodes.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>Any permissions previously associated with the trigger are replaced.</p>
			<p>This function must be run in the context of the database containing the trigger to be modified.</p>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-set-permissions(
  "myTrigger",
  xdmp:default-permissions() )

  =&gt; Empty sequence. The trigger "myTrigger" may be modified
     roles which have the default permissions.

</example>
	</function>
	<function name="trigger-get-permissions" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-get-permissions">
		<summary>Returns the permissions for the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
		</params>
		<return>element(sec:permission)*</return>
		<privilege></privilege>
		<usage>
			<p>The permissions on a trigger determine which roles may modify the trigger. This function must be run in the context of the database containing the trigger to be examined.</p>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-get-permissions("myTrigger")

  =&gt; &lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
       &lt;sec:capability&gt;update&lt;/sec:capability&gt;
       &lt;sec:role-id&gt;6991745490888355329&lt;/sec:role-id&gt;
     &lt;/sec:permission&gt;
     &lt;sec:permission xmlns:sec="http://marklogic.com/xdmp/security"&gt;
       &lt;sec:capability&gt;read&lt;/sec:capability&gt;
       &lt;sec:role-id&gt;6991745490888355329&lt;/sec:role-id&gt;
     &lt;/sec:permission&gt;

</example>
	</function>
	<function name="trigger-add-permissions" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-add-permissions">
		<summary>Adds permissions to the set of permissions on the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">A sequence of permission nodes.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>Any permissions previously associated with the trigger remain intact. This function must be run in the context of the database containing the trigger to be examined.</p>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-add-permissions(
  "myTrigger",
  (xdmp:permission("some-role", "read"),
   xdmp:permission("some-role", "modify"))
)

</example>
	</function>
	<function name="trigger-remove-permissions" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-remove-permissions">
		<summary>Removes a set of permissions from the set of permissions on the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">A sequence of permission nodes.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>This function must be run in the context of the database containing the trigger to be modified.</p>
			<p>Any permissions on
				<code>$trigger-name</code>not listed in
				<code>$permissions</code>are unchanged.</p>
			<p>Any permissions in
				<code>$permissions</code>not associated with
				<code>$trigger-name</code>are ignored.</p>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:trigger-remove-permissions(
    "myTrigger",
    (xdmp:permission("some-role", "modify"))
)

</example>
	</function>
	<function name="get-trigger" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:get-trigger">
		<summary>Returns the XML representation of a trigger with the given name.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
		</params>
		<return>element(trgr:trigger)</return>
		<privilege></privilege>
		<usage>
			<p>This function must be run in the context of the database containing the trigger to be examined. If no trigger with the name $trigger-name exists, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:get-trigger("myTrigger")

  =&gt; &lt;trgr:trigger xmlns:trgr="http://marklogic.com/xdmp/triggers"&gt;
       &lt;trgr:trigger-id&gt;7561204940964272849&lt;/trgr:trigger-id&gt;
       &lt;trgr:trigger-name&gt;myTrigger&lt;/trgr:trigger-name&gt;
       &lt;trgr:description&gt;Simple trigger example&lt;/trgr:description&gt;
       &lt;trgr:data-event&gt;
         &lt;trgr:directory-scope&gt;
           &lt;trgr:uri&gt;/myDir/&lt;/trgr:uri&gt;
           &lt;trgr:depth&gt;1&lt;/trgr:depth&gt;
         &lt;/trgr:directory-scope&gt;
         &lt;trgr:document-content&gt;
           &lt;trgr:update-kind&gt;create&lt;/trgr:update-kind&gt;
         &lt;/trgr:document-content&gt;
         &lt;trgr:when&gt;post-commit&lt;/trgr:when&gt;
       &lt;/trgr:data-event&gt;
       &lt;trgr:module&gt;
         &lt;trgr:database&gt;10570023054829957732&lt;/trgr:database&gt;
         &lt;trgr:root&gt;/modules/&lt;/trgr:root&gt;
         &lt;trgr:path&gt;log.xqy&lt;/trgr:path&gt;
       &lt;/trgr:module&gt;
       &lt;trgr:enabled&gt;true&lt;/trgr:enabled&gt;
       &lt;trgr:recursive&gt;true&lt;/trgr:recursive&gt;
       &lt;trgr:task-priority&gt;normal&lt;/trgr:task-priority&gt;
     &lt;/trgr:trigger&gt;

</example>
	</function>
	<function name="get-trigger-by-id" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:get-trigger-by-id">
		<summary>Returns the XML representation of the trigger with the given trigger id.</summary>
		<params>
			<param name="trigger-id" type="xs:unsignedLong" optional="false">The trigger id.</param>
		</params>
		<return>element(trgr:trigger)</return>
		<usage>
			<p>This function must be run in the context of the database containing the trigger to be examined. If no trigger exists with id $trigger-id, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

(: Run in the context of the database containing the trigger :)
trgr:get-trigger-by-id(7561204940964272849)

  =&gt; &lt;trgr:trigger xmlns:trgr="http://marklogic.com/xdmp/triggers"&gt;
       &lt;trgr:trigger-id&gt;7561204940964272849&lt;/trgr:trigger-id&gt;
       &lt;trgr:trigger-name&gt;myTrigger&lt;/trgr:trigger-name&gt;
       &lt;trgr:description&gt;Simple trigger example&lt;/trgr:description&gt;
       &lt;trgr:data-event&gt;
         &lt;trgr:directory-scope&gt;
           &lt;trgr:uri&gt;/myDir/&lt;/trgr:uri&gt;
           &lt;trgr:depth&gt;1&lt;/trgr:depth&gt;
         &lt;/trgr:directory-scope&gt;
         &lt;trgr:document-content&gt;
           &lt;trgr:update-kind&gt;create&lt;/trgr:update-kind&gt;
         &lt;/trgr:document-content&gt;
         &lt;trgr:when&gt;post-commit&lt;/trgr:when&gt;
       &lt;/trgr:data-event&gt;
       &lt;trgr:module&gt;
         &lt;trgr:database&gt;10570023054829957732&lt;/trgr:database&gt;
         &lt;trgr:root&gt;/modules/&lt;/trgr:root&gt;
         &lt;trgr:path&gt;log.xqy&lt;/trgr:path&gt;
       &lt;/trgr:module&gt;
       &lt;trgr:enabled&gt;true&lt;/trgr:enabled&gt;
       &lt;trgr:recursive&gt;true&lt;/trgr:recursive&gt;
       &lt;trgr:task-priority&gt;normal&lt;/trgr:task-priority&gt;
     &lt;/trgr:trigger&gt;

</example>
	</function>
	<function name="trigger-module" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-module">
		<summary>Returns the XML representation of a trigger module which can be used as the
			<em>module</em>parameter of
			<code>
				<a href="#trgr:create-trigger">trgr:create-trigger</a>
			</code>.</summary>
		<params>
			<param name="database-id" type="xs:unsignedLong" optional="false">A database-id.</param>
			<param name="root" type="xs:string" optional="false">The root path within the database.</param>
			<param name="path" type="xs:string" optional="false">The path to the module relative to $root within the database identified by $database-id.</param>
		</params>
		<return>element(trgr:module)</return>
		<usage></usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-module(
  xdmp:database("Documents"),
  "/modules/",
  "log-create.xqy")

  =&gt; An internal XML representation of the trigger module,
     usable as the module parameter of trgr:create-trigger().

</example>
	</function>
	<function name="trigger-data-event" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-data-event">
		<summary>Returns the XML representation of a triggering eventa, usable as the
			<em>event</em>parameter of
			<code>
				<a href="#trgr:create-trigger">trgr:create-trigger</a>
			</code>.</summary>
		<params>
			<param name="scope" type="element()" optional="false">An event scope, such as is created by
				<code>
					<a href="#trgr:directory-scope">trgr:directory-scope</a>
				</code>,
				<code>
					<a href="#trgr:collection-scope">trgr:collection-scope</a>
				</code>, or
				<code>
					<a href="#trgr:document-scope">trgr:document-scope</a>
				</code>.</param>
			<param name="content" type="element()" optional="false">An event part, such as is created by
				<code>
					<a href="#trgr:document-content">trgr:document-content</a>
				</code>,
				<code>
					<a href="#trgr:property-content">trgr:property-content</a>
				</code>, or
				<code>
					<a href="#trgr:any-property-content">trgr:any-property-content</a>
				</code>.</param>
			<param name="when" type="element(trgr:when)" optional="false">The timing of the trigger execution (pre- or post-commit). Use
				<code>
					<a href="#trgr:post-commit">trgr:post-commit</a>
				</code>or
				<code>
					<a href="#trgr:pre-commit">trgr:pre-commit</a>
				</code>to construct this element.</param>
		</params>
		<return>element(trgr:data-event)</return>
		<usage>
			<p>The
				<em>scope</em>parameter describes the set of documents to which the trigger event applies. The
				<em>content</em>parameter describes the interesting activity within
				<em>scope</em>, such as document creation or document property modification. The
				<em>when</em>parameter describes when the event should be acted on, relative to the triggering transaction.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-data-event(
  trgr:directory-scope("/myDir/", "1"),
  trgr:document-content("create"),
  trgr:post-commit()
)

  =&gt; A trigger event suitable for use with trgr:create-trigger.
     The triggering event occurs at post-commit whenever a document
     is created in the database directory "/myDir/".

</example>
	</function>
	<function name="trigger-database-online-event" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-database-online-event">
		<summary>Returns the XML representation of a database coming online event, usable as the
			<em>event</em>parameter of
			<code>
				<a href="#trgr:create-trigger">trgr:create-trigger</a>
			</code>.</summary>
		<params>
			<param name="user-name" type="xs:string" optional="false">The user used to execute the trigger module.</param>
		</params>
		<return>element(trgr:database-online-event)</return>
		<usage></usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-database-online-event("database-admin")

  =&gt; A trigger event suitable for use with trgr:create-trigger.
     The triggering event occurs whenever a (unspecified) database
     comes online. The trigger module associated with this event
     executes as user "database-admin".

</example>
	</function>
	<function name="document-scope" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:document-scope">
		<summary>Returns the XML representation of a document scope, usable as the scope parameter of a trigger event constructor such as
			<code>
				<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
			</code>.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document uri.</param>
		</params>
		<return>element(trgr:document-scope)</return>
		<usage></usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-data-event(

<strong xmlns="http://www.w3.org/1999/xhtml">trgr:document-scope("/myDir/interesting.xml")</strong>,
  trgr:document-content("modify"),
  trgr:post-commit())

  =&gt; A collection modification trigger event that may
     be used to create a trigger which fires whenever the
     document with URI /myDir/interesting.xml is modified.

</example>
	</function>
	<function name="collection-scope" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:collection-scope">
		<summary>Returns the XML representation of a collection scope, usable as the scope parameter of a trigger event constructor such as
			<code>
				<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
			</code>.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The collection uri.</param>
		</params>
		<return>element(trgr:collection-scope)</return>
		<usage></usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-data-event(

<strong xmlns="http://www.w3.org/1999/xhtml">trgr:collection-scope("/myCollecion/")</strong>,
  trgr:document-content("modify"),
  trgr:post-commit())

  =&gt; A collection modification trigger event
     that can be used to create a trigger which fires
     whenever the /myCollection/ collection is modified.

</example>
	</function>
	<function name="directory-scope" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:directory-scope">
		<summary>Returns the XML representation of a directory scope, usable as the scope parameter of a trigger event constructor such as
			<code>
				<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
			</code>.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The directory uri.</param>
			<param name="depth" type="xs:string" optional="false">The depth of descendants included in the scope. ("1" or "infinity")</param>
		</params>
		<return>element(trgr:directory-scope)</return>
		<usage></usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-data-event(

<strong xmlns="http://www.w3.org/1999/xhtml">trgr:directory-scope("/myDir/", "1")</strong>,
  trgr:document-content("modify"),
  trgr:post-commit())

  =&gt; A directory modification trigger event that may
     be used to create a trigger which fires whenever
     the /myDir/ directory in a database is modified.

</example>
	</function>
	<function name="document-content" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:document-content">
		<summary>Returns the XML representation of a document part of a triggering event, usable as the content parameter of a trigger event constructor such as
			<code>
				<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
			</code>.</summary>
		<params>
			<param name="update-kind" type="xs:string" optional="false">"create", "modify", or "delete"</param>
		</params>
		<return>element(trgr:document-content)</return>
		<usage></usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-data-event(
  trgr:directory-scope("/myDir/", "1"),

<strong xmlns="http://www.w3.org/1999/xhtml">trgr:document-content("modify")</strong>,
  trgr:post-commit())

  =&gt; A directory modification trigger event that can
     be used to create a trigger which fires whenever the
     /myDir/ directory in the database is modified.

</example>
	</function>
	<function name="any-property-content" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:any-property-content">
		<summary>Returns the XML representation of an all-properties part to a triggering event, usable as the content parameter of a trigger event constructor such as
			<code>
				<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
			</code>.</summary>
		<params />
		<return>element(trgr:any-property-content)</return>
		<usage>
			<p>Adding, changing or removing any document property matches this event part.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-data-event(
  trgr:directory-scope("/myDir/", "1"),

<strong xmlns="http://www.w3.org/1999/xhtml">trgr:any-property-content()</strong>,
  trgr:post-commit())

  =&gt; A property modification trigger event that can
     be used to create a trigger which fires whenever any
     property is added, changed or removed on a document
     in the /myDir/ directory.

</example>
	</function>
	<function name="property-content" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:property-content">
		<summary>Returns the XML representation of a property part to a triggering event, usable as the
			<em>content</em>parameter of a trigger event constructor such as
			<code>
				<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
			</code>.</summary>
		<params>
			<param name="property-name" type="xs:QName" optional="false">The QName of the property.</param>
		</params>
		<return>element(trgr:property-content)</return>
		<usage>
			<p>Adding, changing or removing the $property-name document property matches this event part.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-data-event(
  trgr:directory-scope("/myDir/", "1"),

<strong xmlns="http://www.w3.org/1999/xhtml">trgr:property-content(
    fn:qname("", "myInterestingProperty"))</strong>,
  trgr:post-commit())

  =&gt; A property modification trigger event that can
     be used to create a trigger which fires whenever
     the property myInterestingProperty is added, modified
     or removed from a document in /myDir/.

</example>
	</function>
	<function name="pre-commit" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:pre-commit">
		<summary>Returns the XML representation of a pre-commit trigger timing.</summary>
		<return>element(trgr:when)</return>
		<usage>
			<p>Use this function with
				<code>
					<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
				</code>to create a pre-commit trigger event. To learn more about pre-commit triggers, see "Using Triggers to Spawn Actions" in the
				<em>Application Developer's Guide</em>.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:post-commit())
  trgr:trigger-data-event(
    trgr:directory-scope("/myDir/", "1"),
    trgr:document-content("create"),

<strong xmlns="http://www.w3.org/1999/xhtml">trgr:pre-commit()</strong>)

  =&gt; A document modification trigger event that can
     be used to create a trigger which fires whenever
     a document is created in /myDir/. The associated
     trigger module executes before committing the
     firing document creation transaction.

</example>
	</function>
	<function name="post-commit" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:post-commit">
		<summary>Returns the XML representation of a post-commit trigger timing.</summary>
		<return>element(trgr:when)</return>
		<usage>
			<p>Use this function with
				<code>
					<a href="#trgr:trigger-data-event">trgr:trigger-data-event</a>
				</code>to create a post-commit trigger event. To learn more about post-commit triggers, see "Using Triggers to Spawn Actions" in the
				<em>Application Developer's Guide</em>.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:post-commit())
  trgr:trigger-data-event(
    trgr:directory-scope("/myDir/", "1"),
    trgr:document-content("create"),

<strong xmlns="http://www.w3.org/1999/xhtml">trgr:post-commit()</strong>)

  =&gt; A document modification trigger event that can
     be used to create a trigger which fires whenever
     a document is created in /myDir/. The associated
     trigger module executes after committing the
     firing document creation transaction.

</example>
	</function>
	<function name="remove-trigger" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:remove-trigger">
		<summary>Removes the named trigger.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The trigger name.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>This function deletes the specified trigger. You must run this function to remove a trigger before recreating it. If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:remove-trigger("myTrigger")

  =&gt; Empty sequence. Removes the specified trigger from the database.

</example>
	</function>
	<function name="trigger-set-recursive" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-set-recursive">
		<summary>Sets the recursive setting of the identified trigger. When the recursive setting is true, the trigger will trigger itself for recursive changes to the same document.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The current trigger name.</param>
			<param name="recursive" type="xs:boolean" optional="false">The new recursive value for the specified trigger.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-set-recursive("myTrigger", fn:true())

  =&gt; Empty sequence. Sets the named trigger to be recursive.

</example>
	</function>
	<function name="trigger-set-task-priority" type="triggers" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:trigger-set-task-priority">
		<summary>Sets the task priority setting of the identified trigger. The task priority is only applicable to post-commit triggers.</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">The current trigger name.</param>
			<param name="task-priority" type="xs:string" optional="false">The new task priority value for the specified trigger. Either "normal" or "higher".</param>
		</params>
		<return>empty-sequence()</return>
		<privilege></privilege>
		<usage>
			<p>If the named trigger does not exist, the exception
				<code>TRGR-TRIGGERDNE</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
import module namespace trgr="http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

trgr:trigger-set-task-priority("myTrigger", "higher")

  =&gt; Empty sequence. Sets the named trigger to have higher task priority.

</example>
	</function>
	<function name="triggers-change-modules-database" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="false" fullname="trgr:triggers-change-modules-database">
		<summary>This function changes the trigger definitions of each trigger definition in the database that has the database ID $old-db and replaces each database ID with $new-db. This is useful after restoring a triggers database to a different cluster that has different database IDs than the one from which it was backed up.</summary>
		<params>
			<param name="old-db" type="xs:unsignedLong" optional="false">The old database ID.</param>
			<param name="new-db" type="xs:unsignedLong" optional="false">The new database ID.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

(: run this against you triggers database :)
import module namespace trgr = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";

trgr:triggers-change-modules-database(5184170867299910410,
      xdmp:database("Documents") )

=&gt; Empty sequence. Sets all triggers that reference 5184170867299910410
    as their modules database to reference the ID of the Documents database.

</example>
	</function>
	<function name="any-custom-property-content" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:any-custom-property-content">
		<summary>This function....</summary>
		<return>element(trgr:any-custom-property-content)</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="validate-trigger-name" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:validate-trigger-name">
		<summary>This function....</summary>
		<params>
			<param name="trigger-name" type="xs:string" optional="false">Parameter description...</param>
		</params>
		<return>empty()</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

import module namespace triggers = "http://marklogic.com/xdmp/triggers"
   at "/MarkLogic/triggers.xqy";

</example>
	</function>
	<function name="validate-data-event" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:validate-data-event">
		<summary>This function....</summary>
		<params>
			<param name="event" type="element(trgr:data-event)" optional="false">Parameter description...</param>
		</params>
		<return>empty()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="validate-scope" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:validate-scope">
		<summary>This function....</summary>
		<return>element())</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="validate-content" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:validate-content">
		<summary>This function....</summary>
		<return>element())</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="validate-when" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:validate-when">
		<summary>This function....</summary>
		<return>element())</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="validate-database-online-event" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:validate-database-online-event">
		<summary>This function....</summary>
		<params>
			<param name="database-online-event" type="element(trgr:database-online-event)" optional="false">Parameter description...</param>
		</params>
		<return>empty()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="validate-module" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:validate-module">
		<summary>This function....</summary>
		<params>
			<param name="module" type="element(trgr:module)" optional="false">Parameter description...</param>
		</params>
		<return>empty()</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="triggers-uri" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:triggers-uri">
		<summary>This function....</summary>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="get-unique-trigger-id" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:get-unique-trigger-id">
		<summary>This function....</summary>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="triggers-collection" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:triggers-collection">
		<summary>This function....</summary>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="triggers-namespace" lib="trgr" category="Triggers" bucket="XQuery Library Modules" hidden="true" fullname="trgr:triggers-namespace">
		<summary>This function....</summary>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace triggers = "http://marklogic.com/xdmp/triggers"
      at "/MarkLogic/triggers.xqy";


</example>
	</function>
	<function name="url-encode" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:url-encode">
		<summary>Converts plaintext into URL-encoded string.</summary>
		<params>
			<param name="plaintext" type="xs:string" optional="false">Plaintext to be encoded.</param>
			<param name="noSpacePlus" type="xs:boolean?" optional="true">True to encode space as "%20" instead of "+".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:url-encode("Why not?")
  =&gt; "Why+not%3f"
</example>
	</function>
	<function name="url-decode" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:url-decode">
		<summary>Converts URL-encoded string to plaintext.</summary>
		<params>
			<param name="encoded" type="xs:string" optional="false">Encoded text to be decoded.</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:url-decode("Why+not%3f")
  =&gt; "Why not?"
</example>
	</function>
	<function name="login" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:login">
		<summary>
			<p>Logs in a user on an application server that is using application-level authentication and sends a session cookie containing the session ID to the user's browser. Returns true on success, false on failure.</p>
			<p>If the user calling this function has the
				<code>xdmp:login</code>privilege, this function can be called without a password or with the empty sequence as the password. In this case, login will succeed if the specified user exists. Therefore, use the
				<code>xdmp:login</code>privilege carefully, as any user with that privilege will be able to execute code that uses the
				<code>xdmp:login</code>function to log in as any user.</p>
		</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The username of the user to be logged in.</param>
			<param name="password" type="xs:string?" optional="true">The user's password. The password is not needed if the user calling the function has the xdmp:login execute privilege.</param>
			<param name="set-session" type="xs:boolean?" optional="true">A boolean value specifying whether to set a session variable for the login. The default is true. Set to false to not set the session variable to maintain the user logged in.</param>
		</params>
		<return>xs:boolean</return>
		<usage>
			<p>The session exists in the E-node on which it was created; you cannot access that session from a different E-node.</p>
			<p>You can use the
				<code>xdmp:set-session-field</code>function to set a named value in the session and the
				<code>xdmp:get-session-field</code>function to return a value set in a session field. The user session expires when the session reaches its timeout limit. The session cookie remains on the browser until the browser exits or the cookie is explicitly removed by the user.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:login("mark","secret")
  =&gt; true() -- if user "mark" has password "secret"
</example>
    <example xml:space="preserve">
  xdmp:login("username") or xdmp:login("username", ())
  =&gt; true() -- if user calling the function has the
               xdmp:login privilege
</example>
    <example xml:space="preserve">
  xdmp:login("username") or xdmp:login("username", ())
  =&gt; SEC-PRIV exception if the user calling the function does
              not have the xdmp:login privilege
</example>
    <example xml:space="preserve">
  xdmp:login("username")
  =&gt; true() -- if current user has the xdmp:login privilege
</example>
    <example xml:space="preserve">
  xdmp:login("username")
  =&gt; SEC-PRIV exception if current user does not have the
              xdmp:login privilege
</example>
	</function>
	<function name="logout" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:logout">
		<summary>Logs the current user out of the session on the server. The result is that the current user is set to the default user defined in application-level authentication. The session remains on the server until it expires.</summary>
		<params />
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:logout()
  =&gt; ()
</example>
	</function>
	<function name="get-request-field-names" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-field-names">
		<summary>Returns a sequence of the request field names.</summary>
		<params />
		<return>xs:string*</return>
		<example xml:space="preserve">
  xdmp:get-request-field-names()
  =&gt; ("section", "name", ...)
</example>
	</function>
	<function name="get-request-field" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-field">
		<summary>Returns the value of a named request field. If the request field is a
			<code>multipart/form-data</code>type in a POST form, you can use
			<code>xdmp:get-request-field</code>for file upload applications (see the
			<a href="#grf2">second example</a>below).</summary>
		<params>
			<param name="name" type="xs:string" optional="false">Request field name.</param>
			<param name="default" type="xs:string?" optional="true">A default value to return if there is no request field.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  xdmp:get-request-field("index")
  =&gt; "10"
</example>
    <example xml:space="preserve">
<a id="grf2" xmlns="http://www.w3.org/1999/xhtml"></a>
Consider a form.xqy XQuery module with the following content:

  &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;body&gt;
    &lt;form name="test" action="upload.xqy?uid={xdmp:random()}" method="post"
          enctype="multipart/form-data"&gt;
    &lt;p&gt;&lt;label&gt;File to upload:
    &lt;input type="file" class="name" name="upload" size="50"/&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type="submit" value="Upload and Get Results"/&gt;&lt;/p&gt;
    &lt;/form&gt;
    &lt;/body&gt;
  &lt;/html&gt;

Then have an upload.xqy XQuery module as follows:

 let $filename := xdmp:get-request-field-filename("upload")
 let $disposition := fn:concat("attachment; filename=""",$filename,"""")
 let $x := xdmp:add-response-header("Content-Disposition", $disposition)
 let $x:= xdmp:set-response-content-type(
             xdmp:get-request-field-content-type("upload"))
 return
 xdmp:get-request-field("upload")

Execute the form.xqy file, select a file, and click the
"Upload and Get Results" button.  The file you uploaded
will open according to the mime type the browser.  If you
wanted to save it to the database, you could use
xdmp:document-insert to do so.


</example>
	</function>
	<function name="get-request-field-filename" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-field-filename">
		<summary>Returns a list of filenames from a multipart request for the field name specified. Returns an empty sequence for a field that does not exist.</summary>
		<params>
			<param name="field-name" type="xs:string" optional="false">The name of the request field with the multipart request.</param>
		</params>
		<return>xs:string*</return>
		<usage>This function is useful for file upload applications. For an example, see the
			<a href="#grf2">second example in the
				<code>xdmp:get-request-field</code></a>documentation.</usage>
		<example xml:space="preserve">
  (:
     Returns the filename of the files loaded in the
     "upload" input form element.
  :)
  xdmp:get-request-field-filename("upload")
  =&gt; "myfile.doc"
</example>
	</function>
	<function name="get-request-field-content-type" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-field-content-type">
		<summary>This function is used to extract the content type from the request field. It returns a sequence of content types, one for each filename, in the same order as the filenames returned from
			<code>xdmp:get-request-field-filename</code>.</summary>
		<params>
			<param name="field-name" type="xs:string" optional="false">The name of the request field with the multipart request.</param>
		</params>
		<return>xs:string*</return>
		<usage>This function is useful for file upload applications. For an example, see the
			<a href="#grf2">second example in the
				<code>xdmp:get-request-field</code></a>documentation.</usage>
		<example xml:space="preserve">
  (:
     Returns the content type of the files loaded in the
     "upload" input form element.
  :)
  xdmp:get-request-field-content-type("upload")
  =&gt; "application/msword"
</example>
	</function>
	<function name="get-request-header-names" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-header-names">
		<summary>Returns a sequence of request header names.</summary>
		<params />
		<return>xs:string*</return>
		<example xml:space="preserve">
  xdmp:get-request-header-names()
  =&gt; ("A", "B", ...)
</example>
	</function>
	<function type="builtin" lib="xdmp" name="get-request-header" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-header">
		<summary>Returns the value of a named request header.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">Request header name.</param>
			<param name="default" type="xs:string?" optional="true">A default value to return if there is no request header.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  xdmp:get-request-header("A")
  =&gt; "foo"
</example>
	</function>
	<function type="builtin" lib="xdmp" name="get-request-username" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-username">
		<summary>Returns the username from the
			<code>Authorization</code>header of this App Server request.</summary>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:get-request-username()
  =&gt; "fred"
</example>
	</function>
	<function type="builtin" lib="xdmp" name="get-request-method" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-method">
		<summary>Returns the HTTP request method.</summary>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:get-request-method()
  =&gt; "GET"
</example>
	</function>
	<function type="builtin" lib="xdmp" name="get-request-path" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-path">
		<summary>Returns the HTTP request path.</summary>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:get-request-path()
  =&gt; "/example.xqy"
</example>
	</function>
	<function type="builtin" lib="xdmp" name="get-request-url" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-url">
		<summary>Returns the portion of the URL following the host_name:port_number. The output does not include any fragment identifier supplied with the URL (that is, it does not include the # sign or anything following the # sign). Note that when a URL rewriter is used, this function returns the rewritten URL. To get the URL before rewriting occurs, use
			<a href="#xdmp:get-original-url">
				<code>xdmp:get-original-url</code>
			</a>.</summary>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:get-request-url()
  =&gt; "/example.xqy?name=foo&amp;year=2006"
</example>
	</function>
	<function type="builtin" lib="xdmp" name="get-original-url" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-original-url">
		<summary>Returns the portion of the URL following the host_name:port_number. The output does not include any fragment identifier supplied with the URL (that is, it does not include the # sign or anything following the # sign). Note that when a URL rewriter is used, this function returns the URL before rewriting occurs. To get the URL after rewriting occurs, use
			<a href="#xdmp:get-request-url">
				<code>xdmp:get-request-url</code>
			</a>.</summary>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:get-original-url()
  =&gt; "/example.xqy?name=foo&amp;year=2006"
</example>
	</function>
	<function type="builtin" lib="xdmp" name="get-request-port" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-port">
		<summary>Returns the port of the request.</summary>
		<return>xs:integer?</return>
		<example xml:space="preserve">
  xdmp:get-request-port()
  =&gt; 8000
</example>
	</function>
	<function name="get-session-field-names" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-session-field-names">
		<summary>Returns a sequence of the HTTP session field names from the session created by the
			<code>xdmp:login</code>function.</summary>
		<params />
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-get-session-field-names</code>
			</p>
		</privilege>
		<return>xs:string*</return>
		<usage>You can use the
			<code>xdmp:set-session-field</code>function to set a named value in a session and the
			<code>xdmp:get-session-field</code>function to return a value set in a session field.</usage>
		<example xml:space="preserve">
  xdmp:get-session-field-names()
  =&gt; ("user", "role", "action", "index")
</example>
	</function>
	<function name="get-session-field" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-session-field">
		<summary>Returns the value of a named session field from the session created by the
			<code>xdmp:login</code>function.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the session field.</param>
			<param name="default" type="item()*" optional="true">A default value to return if there is no session field.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-get-session-field</code>
			</p>
		</privilege>
		<return>item()*</return>
		<usage>You can use the
			<code>xdmp:set-session-field</code>function to set a named value in a session and the
			<code>xdmp:get-session-field-names</code>function to return the names of the fields in the session.</usage>
		<example xml:space="preserve">
  xdmp:get-session-field("user")
  =&gt; "marklogic"
</example>
	</function>
	<function name="set-session-field" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-session-field">
		<summary>Sets the value of a named session field for the session created by the
			<code>xdmp:login</code>function.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the session field.</param>
			<param name="value" type="item()*" optional="false">The value of the session field.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-session-field</code>
			</p>
		</privilege>
		<return>item()*</return>
		<usage>You can use the
			<code>xdmp:get-session-field-names</code>function to return the names of the fields in the session and the
			<code>xdmp:get-session-field</code>function to return a value set in a session field.</usage>
		<example xml:space="preserve">
  xdmp:set-session-field("user", "marklogic")
  =&gt; "marklogic"
</example>
	</function>
	<function name="get-server-field-names" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-server-field-names">
		<summary>Returns a sequence of the server field names.</summary>
		<params />
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-get-server-field-names</code>
			</p>
		</privilege>
		<return>xs:string*</return>
		<usage>This functions returns the server field names of the fields for which you have privileges to see. Users with the
			<code>admin</code>role have privileges to see all of the server fields. Application Services uses several protected server fields, each having a name that starts with "scope@". Therefore, if you are a user with the
			<code>admin</code>role, you will see all of those fields when you call
			<code>xdmp:get-server-field-names</code>.</usage>
		<example xml:space="preserve">
xdmp:get-server-field-names()
 =&gt;
("name1","name2")


</example>
	</function>
	<function name="get-server-field" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-server-field">
		<summary>Returns the value of a named server field. A server field is created with
			<code>xdmp:set-server-field</code>and stores a name/value pair in memory. The server field is available on the App Server in which it is set on the host in which the App Server runs, via
			<code>xdmp:get-server-field</code>; a server field that is set on one App Server is not available on other App Servers on that host or on the same App Server running on another host. Server fields are commonly used with the system Plugin Framework.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the server field.</param>
			<param name="default" type="item()*" optional="true">A default value to return if there is no server field.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-get-server-field</code>
			</p>
		</privilege>
		<return>item()*</return>
		<example xml:space="preserve">
  xdmp:get-server-field("foo")
  =&gt; "bar"
</example>
	</function>
	<function name="set-server-field" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-server-field">
		<summary>Sets the value of a named server field. A server field is created with
			<code>xdmp:set-server-field</code>and stores a name/value pair in memory. The server field is available on the App Server in which it is set on the host in which the App Server runs, via
			<code>xdmp:get-server-field</code>; a server field that is set on one App Server is not available on other App Servers on that host or on the same App Server running on another host.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the server field.</param>
			<param name="value" type="item()*" optional="false">The value of the server field.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-server-field</code>
			</p>
		</privilege>
		<return>item()*</return>
		<usage>
			<p>If you use a server field with the system Plugin Framework (by placing the
				<code>xdmp:set-server-field</code>code in a main module under the
				<code>Plugins</code>directory on a host), then the server field will be populated for each App Server on the host before the first request against each App Server is run.</p>
			<p>If you set a server field to the empty sequence, it deletes the server field and it will not appear when you run
				<code>xdmp:get-server-field-names</code>.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:set-server-field("foo", "bar")
  =&gt; "bar"
</example>
	</function>
	<function name="set-server-field-privilege" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-server-field-privilege">
		<summary>Sets the privilege of a named server field.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The name of the server field.</param>
			<param name="privilege" type="xs:string?" optional="false">The privilege action URI for the server field.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-server-field-privilege</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>Changing the server field value on a field being used with a plugin will change the behavior of the plugin. Therefore, if you are using a server field in a plugin, it is a good practice to set a privilege on the server field to protect it from malicious or accidental updates.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:set-server-field-privilege("foo", "http://mydomain.com/privileges/foo-server-field")
</example>
	</function>
	<function name="redirect-response" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:redirect-response">
		<summary>Redirects the App Server response to a given location.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The redirect URL.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:redirect-response("http://marklogic.com/howtobuy.xqy")
</example>
	</function>
	<function name="set-response-code" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-response-code">
		<summary>Sets the response code and message.</summary>
		<params>
			<param name="code" type="xs:integer" optional="false">The response code.</param>
			<param name="message" type="xs:string" optional="false">The response message.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:set-response-code(204,"No Content")
</example>
	</function>
	<function name="get-response-code" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-response-code">
		<summary>Returns two nodes, the first containing the HTTP response code and the second containing the HTTP response message.</summary>
		<params />
		<usage>You can use this with an HTTP Server error handler to create custom error pages.</usage>
		<return>item()*</return>
		<example xml:space="preserve">
  xdmp:response-code()
  =&gt; 200
     OK
</example>
	</function>
	<function name="set-response-content-type" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-response-content-type">
		<summary>Sets the response content-type.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The content type.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:set-response-content-type("text/html")
</example>
	</function>
	<function name="set-response-encoding" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-response-encoding">
		<summary>Sets the response encoding.</summary>
		<params>
			<param name="encoding" type="xs:string" optional="false">The desired response encoding.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:set-response-encoding("ISO-8859-1")
</example>
	</function>
	<function name="get-response-encoding" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-response-encoding">
		<summary>Returns the encoding that the response from this server is in.</summary>
		<params />
		<return>xs:string</return>
	</function>
	<function name="set-request-time-limit" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-request-time-limit">
		<summary>Changes the time limit for an actively running request to the specified value. If you do not supply values for the last three parameters, the function sets the time limit for the current request.</summary>
		<params>
			<param name="time-limit" type="xs:unsignedInt" optional="false">The desired time limit, in seconds.</param>
			<param name="hostID" type="xs:unsignedLong?" optional="true">The ID of the host on which the request is running. Typically, you get the ID of a host by executing code similar to:
				<blockquote>
					<code />
					<pre xml:space="preserve">
    xdmp:host("myhost")
</pre>
				</blockquote></param>
			<param name="serverID" type="xs:unsignedLong?" optional="true">The ID of the App Server in which the request is running. Typically, you get the ID of an App Server by executing code similar to:
				<blockquote>
					<code />
					<pre xml:space="preserve">
    xdmp:server("myAppServerName")
</pre>
				</blockquote></param>
			<param name="requestID" type="xs:unsignedLong?" optional="true">The ID of the request. You can access the request IDs in the
				<code>request</code>elements of the
				<code>xdmp:server-status</code>output. You get the request ID by executing code similar to:
				<blockquote>
					<code />
					<pre xml:space="preserve">
    declare namespace status=
        "http://marklogic.com/xdmp/status/server"

    xdmp:server-status( xdmp:host("myhost"),
      xdmp:server("myAppServerName") )//status:request
</pre>
				</blockquote></param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-request-time-limit-any</code>or
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-request-time-limit-my</code></p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:set-request-time-limit(10000)
</example>
	</function>
	<function name="add-response-header" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:add-response-header">
		<summary>Adds an HTTP response header field.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The response header name.</param>
			<param name="value" type="xs:string" optional="false">The value to set for this response header.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-add-response-header</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:add-response-header("meta", "description")
</example>
	</function>
	<function name="uri-is-file" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:uri-is-file">
		<summary>Returns true if a given URI refers to a file which exists on the current application server. Returns false if the file does not exist. Returns the empty sequence if the URI is the empty sequence.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to check. If the URI begins with a "/", it is relative to the root directory of the application server. Otherwise, it is relative to the current request URI.</param>
		</params>
		<return>xs:boolean?</return>
		<example xml:space="preserve">
  xdmp:uri-is-file("apppages/test.xml")
  =&gt; true if test.xml exists in "apppages" sub-directory
  relative to the directory of the file containing the request.
</example>
    <example xml:space="preserve">
  xdmp:uri-is-file("/sub-directory/test.xml")
  =&gt; true if test.xml exists in "sub-directory" relative
  to the root directory of the application server.
</example>
	</function>
	<function name="get-request-client-address" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-client-address">
		<summary>Returns as a string the internet address of the client from which the HTTP server request is issued.
			<p>Returns the empty sequence if it is not called from an HTTP server.</p></summary>
		<params />
		<return>xs:string?</return>
		<usage>Use this function if you need to get the internet protocol (IP) address of the requesting client. For example, you can create an application that contains conditional code based on IP addresses (see the example below).</usage>
		<example xml:space="preserve">
  if (xdmp:get-request-client-address() eq "127.0.0.1")
  then "Submitted from localhost."
  else "Only localhost access is allowed for this application."
</example>
    <example xml:space="preserve">
  xdmp:get-request-client-address()
  =&gt; "127.0.0.1"
</example>
	</function>
	<function name="get-request-protocol" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-protocol">
		<summary>Returns as a string the request protocol (either "http" or "https")
			<p>Returns the empty sequence if it is not called from an HTTP server.</p></summary>
		<params />
		<return>xs:string?</return>
		<usage>Use this function if you need to determine whether the client connection is HTTP or HTTPs.</usage>
		<example xml:space="preserve">
  if (xdmp:get-request-protocol() eq "https")
  then "Submitted via https."
  else "Application requires secure connections only."
</example>
    <example xml:space="preserve">
  xdmp:get-request-protocol()
  =&gt; "https"
</example>
	</function>
	<function name="get-request-client-certificate" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-client-certificate">
		<summary>Returns the PEM encoded client certificate if one was presented.
			<p>Returns the empty sequence if it is not called from an HTTP server, if SSL is not enabled for the HTTP server, or if no certificate is available. A clients will not send its certificate unless the server requests it.</p></summary>
		<params />
		<return>xs:string?</return>
		<usage>Use this function if you need to examine a client's certificate.</usage>
		<example xml:space="preserve">
  for $p in xdmp:get-request-client-certificate()
  return xdmp:x509-certificate-extract($p)
</example>
	</function>
	<function name="get-request-body" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-body">
		<summary>For PUT requests, returns the body of the request. For POST requests, returns the body of the request if it is not of content-type application/x-www-form-urlencoded.
			<p>Returns the empty sequence if it is not called from an application server.</p></summary>
		<params>
			<param name="format" type="xs:string?" optional="true">The format ("xml", "text", or "binary") to interpret the body as. If not supplied, the format associated with the content-type header in mimetypes.xml is used. If no content-type header exists, the default format is "binary".</param>
		</params>
		<return>item()*</return>
		<usage>
			<p>If the content-type of the POST body is application/x-www-form-urlencoded, it is not available here, but instead is available in its decoded form through
				<code>xdmp:get-request-field-names()</code>and
				<code>xdmp:get-request-field()</code>.</p>
			<p>If there is no content-type header in the request, then the request body defaults to application/x-www-form-urlencoded, and therefore
				<code>xdmp:get-request-body</code>will return the empty sequence. If you want to read the request body, then the POST must include a content-type header.</p>
			<p>You can use this function to process certain types of web service SOAP requests with MarkLogic Server.</p>
			<p>The output of an
				<code>xdmp:get-request-body</code>call is typically a document node, so if you want to get the contents of the POST, you should add a
				<code>/node()</code>XPath step to the output. The contents of the document node could be a text node, an element node, or a binary node.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:get-request-body()/node()
  =&gt; "&lt;a&gt;Contents of POST body.&lt;/a&gt;"
</example>
	</function>
	<function name="get-url-rewriter-path" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-url-rewriter-path">
		<summary>Returns the URL of the URL rewriter handler for this application server. An empty string is returned if there is no rewrite handler.</summary>
		<params />
		<return>xs:string</return>
		<usage>
			<p>This function is useful for implementing a rewrite handler where you may want to resolve a location relative to the rewrite handler rather than to the specific request. This may be the case if the rewrite handler is acting as a delegator to known modules.</p>
		</usage>
		<example xml:space="preserve">
  fn:resolve-uri("special-handler.xqy", xdmp:get-url-rewriter-path())
</example>
	</function>
	<function name="can-grant-roles" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:can-grant-roles">
		<summary>Tests whether a user can grant or revoke a set of roles. Raises an error if the session user can not.</summary>
		<params>
			<param name="roles" type="xs:string*" optional="false">A set of role names</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:can-grant-roles(("development", "qa"))
</example>
		<algorithm />
	</function>
	<function name="security-assert" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:security-assert">
		<summary>Tests whether the current user has at least one of a given set of privileges. Raises an error if the user does not have any of the privileges.</summary>
		<params>
			<param name="privileges" type="xs:string*" optional="false">The set of privilege URIs. These are the action URIs for the privileges, not the names of the privileges.</param>
			<param name="kind" type="xs:string" optional="false">The kind of privileges (either "execute" or "uri").</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xdmp:security-assert("http://my-function/function-foo", "execute")
</example>
		<algorithm />
	</function>
	<function name="has-privilege" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:has-privilege">
		<summary>Tests whether the current user has at least one of a given set of privileges. Returns true if they do, false otherwise.</summary>
		<params>
			<param name="privileges" type="xs:string*" optional="false">The set of privilege URIs. These are the URIs for the privileges, not the names of the privileges.</param>
			<param name="kind" type="xs:string" optional="false">The kind of privileges (either "execute" or "uri").</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
xdmp:has-privilege("http://myprivs/function-foo", "execute")
  =&gt; true if the current user has the execute privilege on a
     privilege with the URI "http://myprivs/function-foo"
</example>
		<algorithm />
	</function>
	<function name="user-roles" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:user-roles">
		<summary>Returns all roles assigned to a user, including roles directly assigned to the user and roles inherited by other roles.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The user name.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<privilege>http://marklogic.com/xdmp/privileges/xdmp-user-roles</privilege>
		<example xml:space="preserve">
  xdmp:user-roles("ian")
  =&gt;(2349872340, 432987324)
</example>
		<algorithm />
	</function>
	<function name="role-roles" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:role-roles">
		<summary>Returns the set of all roles inherited by a given role, including roles directly assigned to the role and roles inherited from other roles.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The role name.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<privilege>http://marklogic.com/xdmp/privileges/xdmp-role-roles</privilege>
		<example xml:space="preserve">
  xdmp:role-roles("vp")
  =&gt;(2349872340, 432987324)
</example>
		<algorithm />
	</function>
	<function name="privilege-roles" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:privilege-roles">
		<summary>Returns the set of all roles that have a given privilege.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">The privilege action.</param>
			<param name="kind" type="xs:string" optional="false">The privilege kind.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<privilege>http://marklogic.com/xdmp/privileges/xdmp-privilege-roles</privilege>
		<example xml:space="preserve">
  xdmp:privilege-roles(
         "http://marklogic.com/privileges/delete-all",
         "execute")
  =&gt;(2349872340, 432987324)
</example>
		<algorithm />
	</function>
	<function name="amp-roles" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:amp-roles">
		<summary>Returns the set of all roles assigned to an amp, including roles directly assigned to the amp and roles inherited by other roles.</summary>
		<params>
			<param name="namespace-uri" type="xs:string" optional="false">The amped function namespace URI.</param>
			<param name="localname" type="xs:string" optional="false">The amped function localname.</param>
			<param name="document-uri" type="xs:string" optional="false">The amped function module URI.</param>
			<param name="database-id" type="xs:unsignedLong" optional="false">The database ID containing the module.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<privilege>http://marklogic.com/xdmp/privileges/xdmp-amp-roles</privilege>
		<example xml:space="preserve">
  xdmp:amp-roles("http://marklogic.com",
                 "read-docs",
                 "/app/docs.xqy",
                 239487239487)
  =&gt;(2349872340, 432987324)
</example>
		<algorithm />
	</function>
	<function name="document-get-collections" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-get-collections">
		<summary>Returns the collections to which a given document belongs.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  xdmp:document-get-collections("chapter5.xml")
  =&gt;("http://marklogic.com/all-books",
        "http://marklogic.com/xml-books")
</example>
		<algorithm />
	</function>
	<function name="document-get-permissions" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-get-permissions">
		<summary>Returns the permissions to a given document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
		</params>
		<return>element()*</return>
		<example xml:space="preserve">
  xdmp:document-get-permissions("chapter5.xml")
  =&gt;(&lt;sec:permission&gt;
          &lt;sec:capability&gt;read&lt;/sec:capability&gt;
          &lt;sec:role-id&gt;324978243&lt;/sec:role-id&gt;
        &lt;/sec:permission&gt;,
        &lt;sec:permission&gt;
          &lt;sec:capability&gt;read&lt;/sec:capability&gt;
          &lt;sec:role-id&gt;32493478578243&lt;/sec:role-id&gt;
        &lt;/sec:permission&gt;,
        &lt;sec:permission&gt;
          &lt;sec:capability&gt;update&lt;/sec:capability&gt;
          &lt;sec:role-id&gt;32493478578243&lt;/sec:role-id&gt;
        &lt;/sec:permission&gt;)
</example>
		<algorithm />
	</function>
	<function name="default-permissions" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:default-permissions">
		<summary>Returns the permissions any new document would get if the current user were to insert a document without specifying the default permissions.</summary>
		<params>
			<param name="uri" type="xs:string" optional="true">The document URI to get parent directory.</param>
		</params>
		<return>element()*</return>
		<example xml:space="preserve">
  xdmp:default-permissions("http://example.com/content/foo.xml")
  =&gt;(&lt;sec:permission&gt;
          &lt;sec:capability&gt;read&lt;/sec:capability&gt;
          &lt;sec:role-id&gt;324978243&lt;/sec:role-id&gt;
        &lt;/sec:permission&gt;,
        &lt;sec:permission&gt;
          &lt;sec:capability&gt;read&lt;/sec:capability&gt;
          &lt;sec:role-id&gt;32493478578243&lt;/sec:role-id&gt;
        &lt;/sec:permission&gt;,
        &lt;sec:permission&gt;
          &lt;sec:capability&gt;update&lt;/sec:capability&gt;
          &lt;sec:role-id&gt;32493478578243&lt;/sec:role-id&gt;
        &lt;/sec:permission&gt;)
</example>
		<algorithm />
	</function>
	<function name="default-collections" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:default-collections">
		<summary>Returns the collections any new document would get if the current user were to insert a document without specifying the collections.</summary>
		<params>
			<param name="uri" type="xs:string" optional="true">The document URI to get parent directory.</param>
		</params>
		<return>element()*</return>
		<example xml:space="preserve">
  xdmp:default-collections()
  =&gt;("http://example.com/docs",
        "http://example.com/manuals")
</example>
		<algorithm />
	</function>
	<function name="get-current-user" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-current-user">
		<summary>Returns the name of the current user.</summary>
		<params />
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:get-current-user()
  =&gt;"ian"
</example>
		<algorithm />
	</function>
	<function name="get-request-user" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-request-user">
		<summary>Returns the id of the current user.</summary>
		<params />
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:get-request-user()
  =&gt;23987236
</example>
		<algorithm />
	</function>
	<function name="get-current-roles" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-current-roles">
		<summary>Returns all the current roles, both assigned and inherited by the current user and any received from amps.</summary>
		<params />
		<return>xs:unsignedLong*</return>
		<privilege>http://marklogic.com/xdmp/privileges/xdmp-get-current-roles</privilege>
		<example xml:space="preserve">
  xdmp:get-current-roles()
  =&gt;(2349872340, 432987324)
</example>
		<algorithm />
	</function>
	<function name="permission" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:permission">
		<summary>Returns a permission element in the security namespace corresponding to the named role and capability given.</summary>
		<params>
			<param name="role" type="xs:string" optional="false">A role name.</param>
			<param name="capability" type="xs:string" optional="false">A capability (read, update, insert, or execute).</param>
		</params>
		<return>element()</return>
		<example xml:space="preserve">
  xdmp:permission("development", "read")
  =&gt;&lt;sec:permission&gt;
          &lt;sec:capability&gt;read&lt;/sec:capability&gt;
          &lt;sec:role-id&gt;32497824353&lt;/sec:role-id&gt;
       &lt;/sec:permission&gt;
</example>
		<algorithm />
	</function>
	<function name="user" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:user">
		<summary>Returns the user ID for the specified user name. Unlike the security library module function
			<code>sec:uid-for-name</code>, this function can be evaluted against any database and does not need to be evaluated directly against the security database. It returns the user ID from the security database configured for the database in which the App Server evaluates against.</summary>
		<params>
			<param name="user" type="xs:string" optional="false">A user name.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
  xdmp:user("sylvester")
  =&gt; 239871567325
</example>
		<algorithm />
	</function>
	<function name="role" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:role">
		<summary>Returns the role ID for the specified role name. Unlike the security library module function
			<code>sec:uid-for-name</code>, this function can be evaluted against any database and does not need to be evaluated directly against the security database. It returns the role ID from the security database configured for the database in which the App Server evaluates against.</summary>
		<params>
			<param name="role" type="xs:string" optional="false">A role name.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
  xdmp:role("editor")
  =&gt; 2392349873545
</example>
		<algorithm />
	</function>
	<function name="privilege" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:privilege">
		<summary>Returns the privilege ID for the specified privilege name. Unlike the security library module function
			<code>sec:uid-for-name</code>, this function can be evaluted against any database and does not need to be evaluated directly against the security database. It returns the privilege ID from the security database configured for the database in which the App Server evaluates against.</summary>
		<params>
			<param name="action" type="xs:string" optional="false">A privilege action.</param>
			<param name="kind" type="xs:string" optional="false">A privilege kind: "execute" or "URI".</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
  xdmp:privilege("http://my-app/test","execute")
  =&gt; 2392349873545
</example>
		<algorithm />
	</function>
	<function name="amp" type="builtin" lib="xdmp" category="Security" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:amp">
		<summary>Returns the amp ID for the specified amp. Unlike the security library module function
			<code>sec:uid-for-name</code>, this function can be evaluted against any database and does not need to be evaluated directly against the security database. It returns the amp ID from the security database configured for the database in which the App Server evaluates against.</summary>
		<params>
			<param name="namespace" type="xs:string" optional="false">A function namespace.</param>
			<param name="localname" type="xs:string" optional="false">A function localname.</param>
			<param name="module-uri" type="xs:string" optional="false">The module URI for the amp.</param>
			<param name="database" type="xs:unsignedLong" optional="false">The ID of the database in which the module to which this amp refers is stored. If the module is on the filesystem under the
				<code>Modules</code>directory, then specify 0 for the database ID.</param>
		</params>
		<return>xs:integer</return>
		<example xml:space="preserve">
  xdmp:amp("http://my-app/test","my-func","/modules/my-module.xqy",
            xdmp:modules-database())
  =&gt; 2392349873545
</example>
    <example xml:space="preserve">
  xdmp:amp("http://marklogic.com/xdmp/security", "amp-add-roles",
         "/MarkLogic/security.xqy", 0)
  =&gt; 3548369234520018804
</example>
		<algorithm />
	</function>
	<function name="host-status" type="builtin" lib="xdmp" category="Server Monitoring" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:host-status">
		<summary>Returns the status of a host.</summary>
		<params>
			<param name="host-id" type="xs:unsignedLong" optional="false">A host ID.</param>
		</params>
		<return>element(host-status)</return>
		<usage schema="host-status.xsd">
			<p>The information returned from
				<code>xdmp:host-status</code>is always computed on the host specified in the
				<code>$host-id</code>parameter, even if the call is evaluated on an App Server running on a different host. That is, when the API call is issued, MarkLogic Server communicates with the specified host for the its status and returns the staus from the perspective of the specified host (not from the perspective of the host in which the XQuery API is evaluated).</p>
		</usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/status</code>
		</privilege>
		<example xml:space="preserve">
xdmp:host-status(xdmp:host("raymond.marklogic.com"))
=&gt;
&lt;host-status xmlns="http://marklogic.com/xdmp/status/host"&gt;
  &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
  &lt;host-name&gt;raymond.marklogic.com&lt;/host-name&gt;
  &lt;group-id&gt;18323836549784872587&lt;/group-id&gt;
  &lt;current-time&gt;2007-02-16T18:50:43.422-08:00&lt;/current-time&gt;
  &lt;bind-port&gt;7999&lt;/bind-port&gt;
  &lt;connect-port&gt;7999&lt;/connect-port&gt;
  &lt;last-startup&gt;2007-02-16T18:39:00.642-08:00&lt;/last-startup&gt;
  &lt;version&gt;3.2-20070214&lt;/version&gt;
  &lt;architecture&gt;i686&lt;/architecture&gt;
  &lt;license-key&gt;ABC-123-XYZ&lt;/license-key&gt;
  &lt;licensee&gt;Raymond - MarkLogic&lt;/licensee&gt;
  &lt;license-key-expires&gt;2007-04-14T00:00:00-08:00&lt;/license-key-expires&gt;
  &lt;license-key-cpus&gt;2&lt;/license-key-cpus&gt;
  &lt;license-key-cores&gt;4&lt;/license-key-cores&gt;
  &lt;license-key-size&gt;0&lt;/license-key-size&gt;
  &lt;license-key-options&gt;
    &lt;license-key-option&gt;conversion&lt;/license-key-option&gt;
    &lt;license-key-option&gt;failover&lt;/license-key-option&gt;
    &lt;license-key-option&gt;French&lt;/license-key-option&gt;
    &lt;license-key-option&gt;German&lt;/license-key-option&gt;
    &lt;license-key-option&gt;Italian&lt;/license-key-option&gt;
    &lt;license-key-option&gt;Spanish&lt;/license-key-option&gt;
    &lt;license-key-option&gt;Russian&lt;/license-key-option&gt;
    &lt;license-key-option&gt;Arabic&lt;/license-key-option&gt;
    &lt;license-key-option&gt;Simplified Chinese&lt;/license-key-option&gt;
    &lt;license-key-option&gt;English&lt;/license-key-option&gt;
  &lt;/license-key-options&gt;
  &lt;pre-release-expires&gt;2007-05-15T05:08:59-08:00&lt;/pre-release-expires&gt;
  &lt;accepted-version&gt;3.2-20070214&lt;/accepted-version&gt;
  &lt;accepted-agreement&gt;development&lt;/accepted-agreement&gt;
  &lt;accepted-licensee&gt;Raymond - MarkLogic&lt;/accepted-licensee&gt;
  &lt;edition&gt;Enterprise&lt;/edition&gt;
  &lt;cpus&gt;1&lt;/cpus&gt;
  &lt;cores&gt;1&lt;/cores&gt;
  &lt;host-size&gt;197&lt;/host-size&gt;
  &lt;log-device-space&gt;3592&lt;/log-device-space&gt;
  &lt;data-dir-space&gt;3592&lt;/data-dir-space&gt;
  &lt;config-file-timestamps&gt;
    &lt;groups-timestamp&gt;1978290846354&lt;/groups-timestamp&gt;
    &lt;hosts-timestamp&gt;354793208466&lt;/hosts-timestamp&gt;
    &lt;databases-timestamp&gt;1995470715538&lt;/databases-timestamp&gt;
    &lt;assignments-timestamp&gt;1832261958290&lt;/assignments-timestamp&gt;
    &lt;tokenizer-timestamp&gt;0&lt;/tokenizer-timestamp&gt;
    &lt;mimetypes-timestamp&gt;0&lt;/mimetypes-timestamp&gt;
  &lt;/config-file-timestamps&gt;
  &lt;http-servers&gt;
    &lt;http-server&gt;
      &lt;http-server-id&gt;15847393982828089978&lt;/http-server-id&gt;
      &lt;port&gt;9032&lt;/port&gt;
      &lt;webDAV&gt;true&lt;/webDAV&gt;
    &lt;/http-server&gt;
    &lt;http-server&gt;
      &lt;http-server-id&gt;17360064376275143119&lt;/http-server-id&gt;
      &lt;port&gt;8000&lt;/port&gt;
      &lt;webDAV&gt;false&lt;/webDAV&gt;
    &lt;/http-server&gt;
    &lt;http-server&gt;
      &lt;http-server-id&gt;4492507232107144149&lt;/http-server-id&gt;
      &lt;port&gt;8001&lt;/port&gt;
      &lt;webDAV&gt;false&lt;/webDAV&gt;
    &lt;/http-server&gt;
  &lt;/http-servers&gt;
  &lt;xdbc-servers&gt;
    &lt;xdbc-server&gt;
      &lt;xdbc-server-id&gt;4057681084273905496&lt;/xdbc-server-id&gt;
      &lt;port&gt;8021&lt;/port&gt;
    &lt;/xdbc-server&gt;
    &lt;xdbc-server&gt;
      &lt;xdbc-server-id&gt;6086706739056900422&lt;/xdbc-server-id&gt;
      &lt;port&gt;8050&lt;/port&gt;
    &lt;/xdbc-server&gt;
  &lt;/xdbc-servers&gt;
  &lt;task-server&gt;
    &lt;task-server-id&gt;10441203546898933382&lt;/task-server-id&gt;
  &lt;/task-server&gt;
  &lt;assignments&gt;
    &lt;assignment&gt;
      &lt;forest-name&gt;bill&lt;/forest-name&gt;
      &lt;forest-id&gt;11413686728343849399&lt;/forest-id&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
    &lt;/assignment&gt;
    &lt;assignment&gt;
      &lt;forest-name&gt;Security&lt;/forest-name&gt;
      &lt;forest-id&gt;11436840116662532973&lt;/forest-id&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
    &lt;/assignment&gt;
    &lt;assignment&gt;
      &lt;forest-name&gt;Triggers&lt;/forest-name&gt;
      &lt;forest-id&gt;6800799099781840925&lt;/forest-id&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
    &lt;/assignment&gt;
    &lt;assignment&gt;
      &lt;forest-name&gt;Documents&lt;/forest-name&gt;
      &lt;forest-id&gt;12434840716430044697&lt;/forest-id&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
    &lt;/assignment&gt;
    &lt;assignment&gt;
      &lt;forest-name&gt;test&lt;/forest-name&gt;
      &lt;forest-id&gt;8050247748004050993&lt;/forest-id&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
    &lt;/assignment&gt;
    &lt;assignment&gt;
      &lt;forest-name&gt;Modules&lt;/forest-name&gt;
      &lt;forest-id&gt;2413699485643173169&lt;/forest-id&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
    &lt;/assignment&gt;
    &lt;assignment&gt;
      &lt;forest-name&gt;Schemas&lt;/forest-name&gt;
      &lt;forest-id&gt;6668879474270284963&lt;/forest-id&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
    &lt;/assignment&gt;
  &lt;/assignments&gt;
  &lt;hosts&gt;
    &lt;host&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
      &lt;host-name&gt;raymond.marklogic.com&lt;/host-name&gt;
      &lt;connect-port&gt;7999&lt;/connect-port&gt;
      &lt;online&gt;true&lt;/online&gt;
      &lt;secure&gt;true&lt;/online&gt;
    &lt;/host&gt;
  &lt;/hosts&gt;
  &lt;backup-jobs/&gt;
  &lt;restore-jobs/&gt;
&lt;/host-status&gt;
</example>
		<algorithm />
	</function>
	<function name="cache-status" type="builtin" lib="xdmp" category="Server Monitoring" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:cache-status">
		<summary>Returns the status of the caches.</summary>
		<params />
		<return>element(cache-status)</return>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/status</code>
		</privilege>
		<example xml:space="preserve">
xdmp:host-status()
=&gt;
&lt;cache-status xmlns="http://marklogic.com/xdmp/status/cache"&gt;
  &lt;compressed-tree-cache-partitions&gt;
    &lt;compressed-tree-cache-partition&gt;
      &lt;partition-size&gt;32&lt;/partition-size&gt;
      &lt;partition-table&gt;53.9&lt;/partition-table&gt;
      &lt;partition-used&gt;46.2&lt;/partition-used&gt;
      &lt;partition-free&gt;53&lt;/partition-free&gt;
      &lt;partition-overhead&gt;0.8&lt;/partition-overhead&gt;
    &lt;/compressed-tree-cache-partition&gt;
  &lt;/compressed-tree-cache-partitions&gt;
  &lt;expanded-tree-cache-partitions&gt;
    &lt;expanded-tree-cache-partition&gt;
      &lt;partition-size&gt;32&lt;/partition-size&gt;
      &lt;partition-table&gt;81.2&lt;/partition-table&gt;
      &lt;partition-busy&gt;0&lt;/partition-busy&gt;
      &lt;partition-used&gt;89.7&lt;/partition-used&gt;
      &lt;partition-free&gt;6.2&lt;/partition-free&gt;
      &lt;partition-overhead&gt;4.1&lt;/partition-overhead&gt;
    &lt;/expanded-tree-cache-partition&gt;
  &lt;/expanded-tree-cache-partitions&gt;
  &lt;list-cache-partitions&gt;
    &lt;list-cache-partition&gt;
      &lt;partition-size&gt;32&lt;/partition-size&gt;
      &lt;partition-table&gt;0.1&lt;/partition-table&gt;
      &lt;partition-busy&gt;0&lt;/partition-busy&gt;
      &lt;partition-used&gt;0.1&lt;/partition-used&gt;
      &lt;partition-free&gt;99.9&lt;/partition-free&gt;
      &lt;partition-overhead&gt;0&lt;/partition-overhead&gt;
    &lt;/list-cache-partition&gt;
  &lt;/list-cache-partitions&gt;
&lt;/cache-status&gt;
</example>
		<algorithm />
	</function>
	<function name="forest-status" type="builtin" lib="xdmp" category="Server Monitoring" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-status">
		<summary>Returns the status of a forest.</summary>
		<params>
			<param name="forest-id" type="xs:unsignedLong" optional="false">A forest ID.</param>
		</params>
		<return>element(forest-status)</return>
		<usage schema="forest-status.xsd"></usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/status</code>
		</privilege>
		<example xml:space="preserve">
xdmp:forest-status(xdmp:forest("Documents"))
=&gt;
&lt;forest-status xmlns="http://marklogic.com/xdmp/status/forest"&gt;
  &lt;forest-id&gt;12434840716430044697&lt;/forest-id&gt;
  &lt;forest-name&gt;Documents&lt;/forest-name&gt;
  &lt;state&gt;open&lt;/state&gt;
  &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
  &lt;database-id&gt;2634450243966805432&lt;/database-id&gt;
  &lt;last-state-change&gt;2007-02-16T18:39:31.267-08:00&lt;/last-state-change&gt;
  &lt;journals-size&gt;57&lt;/journals-size&gt;
  &lt;stands&gt;
    &lt;stand&gt;
      &lt;stand-id&gt;15174447282968484759&lt;/stand-id&gt;
      &lt;path&gt;c:\Program Files\MarkLogic\Data\Forests\Documents\00000016&lt;/path&gt;
      &lt;stand-kind&gt;Active&lt;/stand-kind&gt;
      &lt;label-version&gt;50397184&lt;/label-version&gt;
      &lt;disk-size&gt;11&lt;/disk-size&gt;
      &lt;memory-size&gt;1&lt;/memory-size&gt;
      &lt;list-cache-hits&gt;158&lt;/list-cache-hits&gt;
      &lt;list-cache-misses&gt;105&lt;/list-cache-misses&gt;
      &lt;list-cache-hit-rate&gt;0&lt;/list-cache-hit-rate&gt;
      &lt;list-cache-miss-rate&gt;0&lt;/list-cache-miss-rate&gt;
      &lt;compressed-tree-cache-hits&gt;0&lt;/compressed-tree-cache-hits&gt;
      &lt;compressed-tree-cache-misses&gt;0&lt;/compressed-tree-cache-misses&gt;
      &lt;compressed-tree-cache-hit-rate&gt;0&lt;/compressed-tree-cache-hit-rate&gt;
      &lt;compressed-tree-cache-miss-rate&gt;0&lt;/compressed-tree-cache-miss-rate&gt;
    &lt;/stand&gt;
  &lt;/stands&gt;
  &lt;current-time&gt;2007-02-16T18:44:06.154-08:00&lt;/current-time&gt;
  &lt;merges/&gt;
  &lt;reindexing&gt;false&lt;/reindexing&gt;
  &lt;device-space&gt;3592&lt;/device-space&gt;
  &lt;backups/&gt;
  &lt;transaction-coordinators/&gt;
  &lt;transaction-participants/&gt;
&lt;/forest-status&gt;
</example>
		<algorithm />
	</function>
	<function name="server-status" type="builtin" lib="xdmp" category="Server Monitoring" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:server-status">
		<summary>Returns the status of an app-server on a host.</summary>
		<params>
			<param name="host-id" type="xs:unsignedLong" optional="false">A host ID.</param>
			<param name="server-id" type="xs:unsignedLong" optional="false">A server ID (HTTP, XDBC, webDAV, or Task).</param>
		</params>
		<return>element(server-status)</return>
		<usage schema="server-status.xsd"></usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/status</code>
		</privilege>
		<example xml:space="preserve">
xdmp:server-status(xdmp:host(),xdmp:server("Admin"))
=&gt;

&lt;server-status xmlns="http://marklogic.com/xdmp/status/server"&gt;
  &lt;server-id&gt;4492507232107144149&lt;/server-id&gt;
  &lt;server-name&gt;Admin&lt;/server-name&gt;
  &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
  &lt;server-kind&gt;http-server&lt;/server-kind&gt;
  &lt;port&gt;8009&lt;/port&gt;
  &lt;root&gt;Admin\&lt;/root&gt;
  &lt;modules&gt;0&lt;/modules&gt;
  &lt;database&gt;5496769417926491762&lt;/database&gt;
  &lt;last-login&gt;9823948029384029384&lt;/last-login&gt;
  &lt;display-last-login&gt;true&lt;/display-last-login&gt;
  &lt;backlog&gt;256&lt;/backlog&gt;
  &lt;threads&gt;2&lt;/threads&gt;
  &lt;max-threads&gt;32&lt;/max-threads&gt;
  &lt;request-timeout&gt;30&lt;/request-timeout&gt;
  &lt;keep-alive-timeout&gt;5&lt;/keep-alive-timeout&gt;
  &lt;session-timeout&gt;3600&lt;/session-timeout&gt;
  &lt;max-time-limit&gt;3600&lt;/max-time-limit&gt;
  &lt;default-time-limit&gt;600&lt;/default-time-limit&gt;
  &lt;authentication&gt;basic&lt;/authentication&gt;
  &lt;default-user&gt;8216129598321388485&lt;/default-user&gt;
  &lt;privilege&gt;0&lt;/privilege&gt;
  &lt;default-xquery-version&gt;1.0-ml&lt;/default-xquery-version&gt;
  &lt;current-time&gt;2007-03-29T14:43:00.819-07:00&lt;/current-time&gt;
  &lt;request-statuses&gt;
    &lt;request-status&gt;
      &lt;request-id&gt;15629296310429871822&lt;/request-id&gt;
      &lt;server-id&gt;4492507232107144149&lt;/server-id&gt;
      &lt;host-id&gt;13264574555735898770&lt;/host-id&gt;
      &lt;canceled&gt;false&lt;/canceled&gt;
      &lt;modules&gt;0&lt;/modules&gt;
      &lt;database&gt;5496769417926491762&lt;/database&gt;
      &lt;root&gt;Admin\&lt;/root&gt;
      &lt;request-kind&gt;invoke&lt;/request-kind&gt;
      &lt;request-text&gt;/cluster-status.xqy&lt;/request-text&gt;
      &lt;update&gt;false&lt;/update&gt;
      &lt;start-time&gt;2007-03-29T14:42:52.905-07:00&lt;/start-time&gt;
      &lt;user&gt;8216129598321388485&lt;/user&gt;
      &lt;client-address&gt;127.0.0.1&lt;/client-address&gt;
      &lt;trigger-depth&gt;0&lt;/trigger-depth&gt;
      &lt;expanded-tree-cache-hits&gt;0&lt;/expanded-tree-cache-hits&gt;
      &lt;expanded-tree-cache-misses&gt;0&lt;/expanded-tree-cache-misses&gt;
      &lt;request-state&gt;running&lt;/request-state&gt;
      &lt;profiling-allowed&gt;false&lt;/profiling-allowed&gt;
      &lt;profiling-enabled&gt;false&lt;/profiling-enabled&gt;
      &lt;debugging-allowed&gt;false&lt;/debugging-allowed&gt;
      &lt;debugging-status&gt;detached&lt;/debugging-status&gt;
    &lt;/request-status&gt;
  &lt;/request-statuses&gt;
  &lt;request-rate&gt;0.0639857&lt;/request-rate&gt;
  &lt;expanded-tree-cache-hits&gt;759&lt;/expanded-tree-cache-hits&gt;
  &lt;expanded-tree-cache-misses&gt;185&lt;/expanded-tree-cache-misses&gt;
  &lt;expanded-tree-cache-hit-rate&gt;0.272918&lt;/expanded-tree-cache-hit-rate&gt;
  &lt;expanded-tree-cache-miss-rate&gt;0&lt;/expanded-tree-cache-miss-rate&gt;
  &lt;fs-program-cache-hits&gt;9&lt;/fs-program-cache-hits&gt;
  &lt;fs-program-cache-misses&gt;40&lt;/fs-program-cache-misses&gt;
  &lt;db-program-cache-hits&gt;0&lt;/db-program-cache-hits&gt;
  &lt;db-program-cache-misses&gt;0&lt;/db-program-cache-misses&gt;
  &lt;env-program-cache-hits&gt;0&lt;/env-program-cache-hits&gt;
  &lt;env-program-cache-misses&gt;0&lt;/env-program-cache-misses&gt;
  &lt;fs-main-module-seq-cache-hits&gt;0&lt;/fs-main-module-seq-cache-hits&gt;
  &lt;fs-main-module-seq-cache-misses&gt;19&lt;/fs-main-module-seq-cache-misses&gt;
  &lt;db-main-module-seq-cache-hits&gt;0&lt;/db-main-module-seq-cache-hits&gt;
  &lt;db-main-module-seq-cache-misses&gt;0&lt;/db-main-module-seq-cache-misses&gt;
  &lt;fs-lib-module-cache-hits&gt;412&lt;/fs-lib-module-cache-hits&gt;
  &lt;fs-lib-module-cache-misses&gt;23&lt;/fs-lib-module-cache-misses&gt;
  &lt;db-lib-module-cache-hits&gt;0&lt;/db-lib-module-cache-hits&gt;
  &lt;db-lib-module-cache-misses&gt;0&lt;/db-lib-module-cache-misses&gt;
&lt;/server-status&gt;
</example>
		<algorithm />
	</function>
	<function name="forest-counts" type="builtin" lib="xdmp" category="Server Monitoring" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-counts">
		<summary>Returns detailed forest statistics for a given forest. This built-in may require significantly more processing time than
			<code>xdmp:forest-status</code>.</summary>
		<params>
			<param name="forest-id" type="xs:unsignedLong" optional="false">A forest ID.</param>
			<param name="show-elements" type="xs:string*" optional="true">The names of a elements to be returned (the element names are listed in the Usage Notes below). Only the top-level elements that show counts are allowed (for example,
				<code>stands-counts</code>or
				<code>document-count</code>). The function will only perform the computations necessary to return the nodes specified. If this parameter is not specified, then all statistics are calculated and returned for the forest. For each element name, you can specify a trailing * for wildcard matching. Specifying a * with no other text forces all calculations and returns all of the nodes.</param>
		</params>
		<return>element(forest-counts)</return>
		<usage schema="forest-status.xsd"></usage>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/counts</code>
			</p>
		</privilege>
		<example xml:space="preserve">
xdmp:forest-counts(xdmp:forest("Documents"))
=&gt;
&lt;forest-counts xmlns="http://marklogic.com/xdmp/status/forest"&gt;
  &lt;forest-id&gt;12434840716430044697&lt;/forest-id&gt;
  &lt;current-time&gt;2007-02-16T19:00:00.708-08:00&lt;/current-time&gt;
  &lt;stands-counts&gt;
    &lt;stand-counts&gt;
      &lt;stand-id&gt;15174447282968484759&lt;/stand-id&gt;
      &lt;path&gt;c:\Program Files\MarkLogic\Data\Forests\Documents\00000016&lt;/path&gt;
      &lt;active-fragment-count&gt;146&lt;/active-fragment-count&gt;
      &lt;nascent-fragment-count&gt;0&lt;/nascent-fragment-count&gt;
      &lt;deleted-fragment-count&gt;0&lt;/deleted-fragment-count&gt;
    &lt;/stand-counts&gt;
  &lt;/stands-counts&gt;
  &lt;document-count&gt;67&lt;/document-count&gt;
  &lt;directory-count&gt;3&lt;/directory-count&gt;
&lt;/forest-counts&gt;

</example>
    <example xml:space="preserve">
(: only calculate the document count :)
xdmp:forest-counts(xdmp:forest("Documents"), ("document-count"))
=&gt;
&lt;forest-counts xmlns="http://marklogic.com/xdmp/status/forest"&gt;
  &lt;forest-id&gt;11656884323633926637&lt;/forest-id&gt;
  &lt;forest-name&gt;Documents&lt;/forest-name&gt;
  &lt;current-time&gt;2008-03-18T16:22:34.082-07:00&lt;/current-time&gt;
  &lt;document-count&gt;1070&lt;/document-count&gt;
&lt;/forest-counts&gt;


</example>
    <example xml:space="preserve">
(: force everything to be calculated :)
xdmp:forest-counts(xdmp:forest("Documents"), "*")
=&gt;
 the full output of xdmp:forest-counts


</example>
    <example xml:space="preserve">
(: show the counts of everything that needs to be reindexed  :)
xdmp:forest-counts(xdmp:forest("Documents"), "reindex*")
=&gt;
&lt;forest-counts xmlns="http://marklogic.com/xdmp/status/forest"&gt;
  &lt;forest-id&gt;11656884323633926637&lt;/forest-id&gt;
  &lt;forest-name&gt;Documents&lt;/forest-name&gt;
  &lt;current-time&gt;2008-03-18T18:07:47.57-07:00&lt;/current-time&gt;
  &lt;reindex-refragment-fragment-count&gt;0&lt;/reindex-refragment-fragment-count&gt;
  &lt;reindex-refragment-rate&gt;0&lt;/reindex-refragment-rate&gt;
  &lt;reindex-fragment-count&gt;0&lt;/reindex-fragment-count&gt;
  ......
  ..... all of the other reindex* elements
  ......
&lt;/forest-counts&gt;


</example>
		<algorithm />
	</function>
	<function name="request-status" type="builtin" lib="xdmp" category="Server Monitoring" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:request-status">
		<summary>
			<p>Returns the status of a running request. If the request ID is that of the calling request, then no special permission is required. If the ID is for another request, then the calling request needs
				<code>http://marklogic.com/xdmp/privileges/status</code>permission.</p>
			<p>The result of this builtin is exactly equivalent to
				<code>xdmp:server-status(xdmp:host(), xdmp:server())//*:request-status[*:request-id = $req]</code>, where
				<code>$req</code>is the ID of the request you are interested in.</p>
			<p>In the 3.2 release this builtin is not cluster-aware, the first argument (host ID) must be the same as the value returned by
				<code>xdmp:host()</code>. If you wish to obtain the status of a request running on a remote host, use the code snippet above to obtain the request status using
				<code>xdmp:server-status()</code>.</p>
		</summary>
		<params>
			<param name="host-id" type="xs:unsignedLong" optional="false">A host ID. Must be the ID of the local host.</param>
			<param name="server-id" type="xs:unsignedLong" optional="false">A server ID (HTTP, XDBC, webDAV, or Task).</param>
			<param name="request-id" type="xs:unsignedLong" optional="false">A request ID.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/status</privilege>
		<return>element(request-status)</return>
		<usage schema="server-status.xsd"></usage>
		<example xml:space="preserve">

xdmp:request-status(xdmp:host(), xdmp:server(), xdmp:request())
=&gt;
&lt;request-status xmlns="http://marklogic.com/xdmp/status/server"&gt;
  &lt;request-id&gt;6421977735636900809&lt;/request-id&gt;
  &lt;server-id&gt;6693979901326946703&lt;/server-id&gt;
  &lt;host-id&gt;2612493919508853477&lt;/host-id&gt;
  &lt;canceled&gt;false&lt;/canceled&gt;
  &lt;modules&gt;0&lt;/modules&gt;
  &lt;database&gt;5184170867299910410&lt;/database&gt;
  &lt;root&gt;c:/ml-danny\&lt;/root&gt;
  &lt;request-kind&gt;invoke&lt;/request-kind&gt;
  &lt;request-text&gt;/cq/eval.xqy?iefix.txt&lt;/request-text&gt;
  &lt;update&gt;false&lt;/update&gt;
  &lt;start-time&gt;2008-06-09T16:08:43.681-07:00&lt;/start-time&gt;
  &lt;time-limit&gt;600&lt;/time-limit&gt;
  &lt;max-time-limit&gt;1440&lt;/max-time-limit&gt;
  &lt;user&gt;893641342095093063&lt;/user&gt;
  &lt;client-address&gt;127.0.0.1&lt;/client-address&gt;
  &lt;trigger-depth&gt;0&lt;/trigger-depth&gt;
  &lt;expanded-tree-cache-hits&gt;0&lt;/expanded-tree-cache-hits&gt;
  &lt;expanded-tree-cache-misses&gt;0&lt;/expanded-tree-cache-misses&gt;
  &lt;request-state&gt;running&lt;/request-state&gt;
  &lt;profiling-allowed&gt;true&lt;/profiling-allowed&gt;
  &lt;profiling-enabled&gt;false&lt;/profiling-enabled&gt;
  &lt;debugging-allowed&gt;true&lt;/debugging-allowed&gt;
  &lt;debugging-status&gt;detached&lt;/debugging-status&gt;
&lt;/request-status&gt;


</example>
		<algorithm />
	</function>
	<function name="foreign-cluster-status" type="builtin" lib="xdmp" category="Server Monitoring" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:foreign-cluster-status">
		<summary>Returns the status of a foreign cluster from a host's point of view.</summary>
		<params>
			<param name="host-id" type="xs:unsignedLong" optional="false">A host ID.</param>
			<param name="foreign-cluster-id" type="xs:unsignedLong" optional="false">A foreign cluster ID.</param>
		</params>
		<return>element(foreign-cluster-status)</return>
		<usage schema="foreign-cluster-status.xsd"></usage>
		<privilege>
			<code>http://marklogic.com/xdmp/privileges/status</code>
		</privilege>
		<example xml:space="preserve">
xdmp:foreign-cluster-status(xdmp:host(),xdmp:foreign-cluster("SanFrancisco"))
=&gt;

&lt;foreign-cluster-status xmlns="http://marklogic.com/xdmp/status/foreign-cluster"&gt;
&lt;/foreign-cluster-status&gt;
</example>
		<algorithm />
	</function>
	<function name="forest-backup" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-backup">
		<summary>Backs up forest data files.</summary>
		<params>
			<param name="forestID" type="unsignedLong" optional="false">A forest ID.</param>
			<param name="pathname" type="xs:string" optional="false">A forest backup pathname. If the directory does not exist, it is created when you run this function. The filesystem permissions must be such that the directory is writable by the operating system user under which MarkLogic Server is running. The directory cannot be the MarkLogic Server install directory or the MarkLogic Server data directory.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-forest-backup</code>
			</p>
		</privilege>
		<usage>
			<p>Reindexing will stop while a backup or restore is in progress.</p>
		</usage>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:forest-backup(11183608861595735720,"/backups/Data/Forests/Documents")
</example>
	</function>
	<function name="forest-restore" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-restore">
		<summary>Restores forest data files. Restarts the forest to complete the restoration.</summary>
		<params>
			<param name="forestID" type="unsignedLong" optional="false">A forest ID.</param>
			<param name="pathname" type="xs:string" optional="false">A forest backup pathname.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-forest-restore</code>
			</p>
		</privilege>
		<usage>
			<p>Reindexing will stop while a backup or restore is in progress.</p>
		</usage>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:forest-restore(11183608861595735720,"/backups/Data/Forests/Documents")
</example>
	</function>
	<function name="forest-clear" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-clear">
		<summary>Clears forest data files.</summary>
		<params>
			<param name="forestIDs" type="unsignedLong*" optional="false">The IDs of the forests to clear. If a forest has replica forests, the replicas are cleared as well.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-forest-clear</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:forest-clear(11183608861595735720)
</example>
	</function>
	<function name="forest-restart" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-restart">
		<summary>Restarts a forest. If multiple forest IDs are specified, the restarts occur in parallel.</summary>
		<params>
			<param name="forestIDs" type="unsignedLong*" optional="false">A forest ID.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-forest-restart</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:forest-restart((11183608861595735720,29382837261839278))
</example>
	</function>
	<function name="forest-rollback" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:forest-rollback">
		<summary>Rolls forests back to a previous point in time, marking any fragment newer than the specified timestamp as deleted. Also, any fragments that were created before the specified timestamp and deleted after will be rolled back (un-deleted).</summary>
		<params>
			<param name="forestIDs" type="unsignedLong*" optional="false">A sequence of forest IDs.</param>
			<param name="timestamp" type="unsignedLong" optional="false">The system timestamp to which you want to roll back.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-forest-rollback</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>If the timestamp specified is greater than the current system timestamp (that is, greater than the value of
				<code>xdmp:request-timestamp()</code>), then an exception is thrown.</p>
			<p>If the specified timestamp is less than (earlier) then the the oldest timestamp in the specified forest(s), then an exception is thrown.</p>
			<p>You should not have any updates occurring on a forest while it is being rolled back; the best practice is for the forest to be quiesced during a rollback operation.</p>
			<p>If you have failover replication configured for a forest, the replica forest(s) will be rolled back at the same time as the specified forest(s).</p>
			<p>If MarkLogic Server restarts during a rollback operation, the rollback will complete when the forest comes back online.</p>
			<p>You can only roll back a forest that is in the "Open" state.</p>
			<p>The
				<code>updates-allowed</code>setting must be set to
				<code>all</code>in order to successfully roll a forest back to a previous timestamp.</p>
			<p>As part of the
				<code>xdmp:forest-rollback</code>operation, the specified forest(s) are restarted.</p>
			<p>As a consequence of the forest(s) restarting, if the forest is a failover forest and it is failed over to another host, the system will attempt to mount the forest on the original host (that is, it will un-failover the forest).</p>
			<p>If you perform an
				<code>xdmp:forest-rollback</code>operation on a forest attached to the context database or any of its auxilliary databases (the security, modules, or triggers databases for that database), then the rollback is performed asyncronously in the background, and any exceptions that occur will not be reported back to the program; in this case, if an exception occurs it might be reported to the
				<code>ErrorLog.txt</code>file. Additionally, because the rollback of forests in the context database (or in its auxilliary databases) is run asyncronously, there might be a small delay between when the rollback is issued and when the forest is restarted, and the rollback state is not reflected until the forest restart is completed. Therefore, it is best practice to call
				<code>xdmp:forest-rollback</code>against forests not attached to the context database.</p>
			<p>After an
				<code>xdmp:forest-clear</code>operation on a forest, you will no longer be able to roll that forest back (because the forest clear deletes all of the stands in the forest).</p>
			<p>The forest rollback operation cannot be undone (except by restoring from backup); that is, after rolling a forest back to a point in time, you cannot roll the forest "forward" to where you started.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:forest-rollback(11183608861595735720, 12345623)
</example>
    <example xml:space="preserve">
   (:
   Run this against a different database context then
   the my-db database.
   :)
  xdmp:forest-rollback(
     xdmp:database-forests(xdmp:database("my-db")), 12345623)
</example>
	</function>
	<function name="database-backup-validate" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-backup-validate">
		<summary>Validates that the specified list of forests can be backed up to the backup data directory. Optionally verifies that the list of forests can enable journal archiving to the journal archive directory with the specified lag limit. Returns a database backup set node.</summary>
		<params>
			<param name="forestIDs" type="unsignedLong*" optional="false">A sequence of forest IDs.</param>
			<param name="pathname" type="xs:string" optional="false">A backup data directory pathname.</param>
			<param name="include-replicas" type="xs:boolean?" optional="true">Whether or not to include replica forests</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether or not to enable journal archiving</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path to where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 15.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-backup-validate</code>
			</p>
		</privilege>
		<return>element()</return>
		<example xml:space="preserve">
  xdmp:database-backup-validate((11183608861595735720,898513504988507762),
    "/backups/Data", fn:false(), fn:true())
  =&gt;
&lt;bp:backup-plan
   xsi:schemaLocation="http://marklogic.com/xdmp/backup-plan backup-plan.xsd"
   xmlns:bp="http://marklogic.com/xdmp/backup-plan"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance";&gt;
  &lt;bp:forest&gt;
    &lt;bp:forest-name&gt;Documents&lt;/bp:forest-name&gt;
    &lt;bp:forest-id&gt;9157142760003704384&lt;/bp:forest-id&gt;
    &lt;bp:forest-status&gt;okay&lt;/bp:forest-status&gt;
    &lt;bp:directory-path&gt;/tmp&lt;/bp:directory-path&gt;
    &lt;bp:directory-status&gt;okay&lt;/bp:directory-status&gt;
    &lt;bp:action&gt;backup&lt;/bp:action&gt;
    &lt;bp:journal-archiving&gt;true&lt;/bp:journal-archiving&gt;
    &lt;bp:journal-archive-path&gt;/tmp&lt;/bp:journal-archive-path&gt;
    &lt;bp:journal-archive-path-status&gt;okay&lt;/bp:journal-archive-path-status&gt;
    &lt;bp:journal-archive-lag-limit&gt;15&lt;/bp:journal-archive-lag-limit&gt;
    &lt;bp:journal-archive-lag-limit-status&gt;okay&lt;/bp:journal-archive-lag-limit-status&gt;
  &lt;/bp:forest&gt;
&lt;/bp:backup-plan&gt;
</example>
	</function>
	<function name="database-backup" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-backup">
		<summary>Starts an asynchronous backup of the specified list of forests to the backup data directory. Optionally starts journal archiving of the specified list of forests to the specified journal archive directory. Returns a job ID that uniquely identifies the backup task.</summary>
		<params>
			<param name="forestIDs" type="unsignedLong*" optional="false">A sequence of forest IDs.</param>
			<param name="pathname" type="xs:string" optional="false">A backup data directory pathname. The directory must exist and be writable by the operating system user under which MarkLogic Server is running. The directory cannot be the MarkLogic Server install directory or the MarkLogic Server data directory.</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether or not to enable journal archiving. Defaults to
				<code>false</code>.</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path to where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 15.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-backup</code>
			</p>
		</privilege>
		<usage>
			<p>You cannot restore to a read-only forest.</p>
			<p>Reindexing will stop while a backup or restore is in progress.</p>
			<p>The backup directory must exist on each host that has a forest specified in the database backup call (that is, the d-nodes in which the forests being backed up are hosted).</p>
			<p>If enabling journal archiving, all forest must belong to the same database.</p>
		</usage>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:database-backup((11183608861595735720,898513504988507762),
    "/backups/Data")
  =&gt; 33030877979801813489
</example>
    <example xml:space="preserve">
  xdmp:database-backup(xdmp:database-forests(xdmp:database("Documents")),
    "/backups/Data", fn:true(), "/backups/JournalArchiving", 15)
  =&gt; 437302857479804813287
</example>
	</function>
	<function name="start-journal-archiving" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:start-journal-archiving">
		<summary>Starts journal archiving to the specified list of forests.</summary>
		<params>
			<param name="forestIDs" type="unsignedInt*" optional="false">A sequence of forest IDs.</param>
			<param name="journal-archive-path" type="xs:string" optional="false">Path to where archived journals are stored. Defaults to the backup data directory.</param>
			<param name="lag-limit" type="xs:unsignedLong" optional="true">Maximum difference in seconds that the archived journal can lag behind its forest's active journal. Defaults to 15.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-start-journal-archiving</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:start-journal-archiving(xdmp:forest("Documents"),"/backups/Data",500)
</example>
	</function>
	<function name="stop-journal-archiving" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:stop-journal-archiving">
		<summary>Stops journal archiving to the specified list of forests.</summary>
		<params>
			<param name="forestIDs" type="unsignedLong" optional="false">A sequence of forest IDs.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-stop-journal-archiving</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:stop-journal-archiving(xdmp:forest("Documents"))
</example>
	</function>
	<function name="database-backup-status" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-backup-status">
		<summary>Checks the status of the outstanding backup job with the specified job ID. Returns a database backup status node defined in the
			<code>job-status.xsd</code>schema.</summary>
		<params>
			<param name="jobid" type="unsignedLong" optional="false">A backup job ID.</param>
			<param name="hostid" type="unsignedLong" optional="true">The ID of the host that the backup was started on.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-backup-status</code>
			</p>
		</privilege>
		<return>element()</return>
		<usage schema="job-status.xsd" element-name="job-status"></usage>
		<example xml:space="preserve">
xdmp:database-backup-status(33030877979801813489, 16529920850295602277)
=&gt;
&lt;job:job-status xsi:schemaLocation="http://marklogic.com/xdmp/job-status
   job-status.xsd" xmlns:job="http://marklogic.com/xdmp/job-status"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;job:forest&gt;
    &lt;job:forest-name&gt;Documents&lt;/job:forest-name&gt;
    &lt;job:forest-id&gt;9157142760003704384&lt;/job:forest-id&gt;
    &lt;job:status&gt;in-progress&lt;/job:status&gt;
    &lt;job:journal-archiving&gt;true&lt;/job:journal-archiving&gt;
    &lt;job:journal-archive-path&gt;/backup/JournalArchive&lt;/job:journal-archive-path&gt;
    &lt;job:journal-archive-lag-limit&gt;15&lt;/job:journal-archive-lag-limit&gt;
  &lt;/job:forest&gt;
&lt;/job:job-status&gt;
</example>
	</function>
	<function name="database-backup-cancel" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-backup-cancel">
		<summary>Cancels an outstanding backup job with the specified job ID, returning true if the cancel operation is successful, false if the cancel operation is not successful.</summary>
		<params>
			<param name="jobid" type="unsignedLong" optional="false">A backup job ID.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-backup-cancel</code>
			</p>
		</privilege>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xdmp:database-backup-cancel(33030877979801813489)
  =&gt; true
</example>
	</function>
	<function name="database-restore-validate" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-restore-validate">
		<summary>Validates that the specified list of forests can be restored from the backup data directory. Returns a database restore set node.</summary>
		<params>
			<param name="forestIDs" type="unsignedLong*" optional="false">A sequence of forest IDs.</param>
			<param name="pathname" type="xs:string" optional="false">A backup data directory pathname.</param>
			<param name="restoreToTime" type="xs:dateTime?" optional="true">The date and time to restore the forest data to.</param>
			<param name="include-replicas" type="xs:boolean?" optional="true">Whether to include replica forests</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether to restore from archived journals. Defaults to false.</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path to where archived journals are stored. Defaults to the backup data directory.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-restore-validate</code>
			</p>
		</privilege>
		<return>element()</return>
		<example xml:space="preserve">
  xdmp:database-restore-validate((11183608861595735720,898513504988507762),
    "/backups/Data")
  =&gt; ..database restore set node
</example>
	</function>
	<function name="database-restore" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-restore">
		<summary>Starts an asynchronous restore of the specified list of forests from the backup data directory. Returns a job ID that uniquely identifies the restore task.</summary>
		<params>
			<param name="forestIDs" type="unsignedLong*" optional="false">A sequence of forest IDs.</param>
			<param name="pathname" type="xs:string" optional="false">A backup data directory pathname.</param>
			<param name="restoreToTime" type="xs:dateTime?" optional="true">The date and time to restore the forest data to.</param>
			<param name="journal-archiving" type="xs:boolean?" optional="true">Whether to restore from archived journals. Defaults to false.</param>
			<param name="journal-archive-path" type="xs:string?" optional="true">Path to where archived journals are stored. Defaults to the backup data directory.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-restore</code>
			</p>
		</privilege>
		<usage>
			<p>Reindexing will stop while a backup or restore is in progress.</p>
		</usage>
		<return>xs:unsignedLong</return>
		<example xml:space="preserve">
  xdmp:database-restore((11183608861595735720,898513504988507762),
    "/backups/Data")
  =&gt; 33030877979801813489
</example>
	</function>
	<function name="database-restore-status" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-restore-status">
		<summary>Checks the status of the outstanding restore job with the specified job ID. Returns a database restore status node.</summary>
		<params>
			<param name="jobid" type="unsignedLong" optional="false">A restore job ID.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-restore-status</code>
			</p>
		</privilege>
		<return>element()</return>
		<example xml:space="preserve">
xdmp:database-restore-status(33030877979801813489)
=&gt;
&lt;job:job-status xsi:schemaLocation="http://marklogic.com/xdmp/job-status
   job-status.xsd" xmlns:job="http://marklogic.com/xdmp/job-status"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;job:forest&gt;
    &lt;job:forest-name&gt;docapp&lt;/job:forest-name&gt;
    &lt;job:forest-id&gt;7521617173471751251&lt;/job:forest-id&gt;
    &lt;job:status&gt;in-progress&lt;/job:status&gt;
    &lt;job:restore-to-time&gt;2011-07-12T13:08:00-07:00&lt;/job:restore-to-time&gt;
    &lt;job:journal-archiving&gt;true&lt;/job:journal-archiving&gt;
    &lt;job:journal-archive-path&gt;/space/backup/20110711-3&lt;/job:journal-archive-path&gt;
    &lt;job:safe-restore-to-time&gt;2011-07-12T13:08:00-07:00&lt;/job:safe-restore-to-time&gt;
    &lt;job:journal-archive-lag-limit&gt;15&lt;/job:journal-archive-lag-limit&gt;
  &lt;/job:forest&gt;
&lt;/job:job-status&gt;
</example>
	</function>
	<function name="database-restore-cancel" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-restore-cancel">
		<summary>Cancels an outstanding restore job with the specified job ID, returning true if the cancel operation is successful, false if the cancel operation is not successful.</summary>
		<params>
			<param name="jobid" type="unsignedLong" optional="false">A restore job ID.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-restore-cancel</code>
			</p>
		</privilege>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xdmp:database-restore-cancel(33030877979801813489)
  =&gt; true
</example>
	</function>
	<function name="shutdown" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:shutdown">
		<summary>Shutdown servers on hosts.</summary>
		<params>
			<param name="hostIDs" type="unsignedLong*" optional="false">A sequence of host IDs, or empty sequence for the local host.</param>
			<param name="reason" type="xs:string" optional="false">Prepositional phrase describing the reason to shutdown.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-shutdown</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:shutdown((), "for software upgrade")
</example>
	</function>
	<function name="restart" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:restart">
		<summary>Restart servers on hosts.</summary>
		<params>
			<param name="hostIDs" type="unsignedLong*" optional="false">A sequence of host IDs, or empty sequence for the local host.</param>
			<param name="reason" type="xs:string" optional="false">Prepositional phrase describing the reason to restart.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-restart</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:restart((), "to reload server.xml")
</example>
	</function>
	<function name="filesystem-directory" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:filesystem-directory">
		<summary>Performs a directory listing of the given file pathname.</summary>
		<params>
			<param name="pathname" type="xs:string" optional="false">Pathname of the directory to be listed.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-filesystem-directory</code>
			</p>
		</privilege>
		<return>element(dir:directory)</return>
		<usage>
			<p>The user under which MarkLogic Server is running must have permissions to read the specified directory. For example, on Windows systems, MarkLogic Server typically runs as the SYSTEM user, and therefore the SYSTEM user must have permissions to read the directory (even a mapped network drive directory). Similarly, on UNIX systems, MarkLogic Server typically runs as the daemon user, and that user needs to have read permission to the specified directory. If the user in which MarkLogic Server runs does not have the needed permissions, then a an error such as SVC-DIROPEN or SVC-FILOPEN is thrown when you attempt to call
				<code>xdmp:filesystem-directory</code>.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:filesystem-directory("/etc")
  =&gt; ..directory listing node
</example>
	</function>
	<function name="filesystem-file" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:filesystem-file">
		<summary>Reads a file from the filesystem. The file at the specified path must be UTF-8 encoded.</summary>
		<params>
			<param name="pathname" type="xs:string" optional="false">Pathname of the file to be read.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-filesystem-file</code>
			</p>
		</privilege>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:filesystem-file("/etc/motd")
  =&gt; contents of /etc/motd
</example>
	</function>
	<function name="filesystem-file-length" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:filesystem-file-length">
		<summary>Reads the length of a file from the filesystem. It returns empty sequence if the file doesn't exist.</summary>
		<params>
			<param name="pathname" type="xs:string" optional="false">Pathname of the file to be read.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-filesystem-file-length</code>
			</p>
		</privilege>
		<return>xs:unsignedLong?</return>
		<example xml:space="preserve">
  xdmp:filesystem-file-length("/testdata1/a.jpg")
  =&gt; length of /testdata1/a.jpg
</example>
	</function>
	<function name="filesystem-file-exists" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:filesystem-file-exists">
		<summary>Return true if a file exists; otherwise false.</summary>
		<params>
			<param name="pathname" type="xs:string" optional="false">Pathname of the file.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-filesystem-file-exists</code>
			</p>
		</privilege>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xdmp:filesystem-file-exists("/testdata1/a.jpg")
  =&gt; true
</example>
	</function>
	<function name="castable-as" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:castable-as">
		<summary>Returns true if a value is castable. This is similar to the "castable as" XQuery predicate, except that the type is determined at runtime.</summary>
		<params>
			<param name="namespace-uri" type="xs:string" optional="false">The namespace URI of the type.</param>
			<param name="local-name" type="xs:string" optional="false">The local-name of the type.</param>
			<param name="item" type="item()" optional="false">The item to be cast.</param>
		</params>
		<return>xs:boolean</return>
		<example xml:space="preserve">
  xdmp:castable-as(
    "http://www.w3.org/2001/XMLSchema",
    "integer",
    "12")
    =&gt; true()
</example>
	</function>
	<function name="merge-cancel" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:merge-cancel">
		<summary>Cancel the merge with the specified merge ID on a forest with the specified forest ID.</summary>
		<params>
			<param name="forest-ID" type="xs:unsignedLong" optional="false">A forest ID.</param>
			<param name="merge-ID" type="xs:unsignedLong" optional="false">A merge ID, which is available from the output of
				<code>xdmp:forest-status</code>.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/request-my-requests</code>or
				<code>http://marklogic.com/xdmp/privileges/request-any-requests</code></p>
		</privilege>
		<usage>To cancel a merge on a database, find all of the forests in the database and use
			<code>xdmp:merge-cancel</code>on each forest.</usage>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:merge-cancel(98394839084390843,3838938902783)
   =&gt; ()
</example>
	</function>
	<function name="request-cancel" type="builtin" lib="xdmp" category="Server Monitoring" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:request-cancel">
		<summary>Cancel the request with the given host, server, and request IDs.</summary>
		<params>
			<param name="hostID" type="xs:unsignedLong" optional="false">The ID of the host on which the request is running. Typically, you get the ID of a host by executing code similar to:
				<blockquote>
					<code />
					<pre xml:space="preserve">
    xdmp:host("myhost")
</pre>
				</blockquote></param>
			<param name="serverID" type="xs:unsignedLong" optional="false">The ID of the App Server in which the request is running. Typically, you get the ID of an App Server by executing code similar to:
				<blockquote>
					<code />
					<pre xml:space="preserve">
    xdmp:server("myAppServerName")
</pre>
				</blockquote></param>
			<param name="requestID" type="xs:unsignedLong" optional="false">The ID of the request. You can access the request IDs in the
				<code>request</code>elements of the
				<code>xdmp:server-status</code>output. You get the request ID by executing code similar to:
				<blockquote>
					<code />
					<pre xml:space="preserve">
    declare namespace status=
        "http://marklogic.com/xdmp/status/server"

    xdmp:server-status( xdmp:host("myhost"),
      xdmp:server("myAppServerName") )//status:request
</pre>
				</blockquote></param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-request-cancel</code>and
				<code>http://marklogic.com/xdmp/privileges/cancel-any-request</code>or
				<code>http://marklogic.com/xdmp/privileges/cancel-my-requests</code></p>
		</privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>To find out the status of the request after it has been canceled, you can call
				<code>xdmp:server-status</code>, which has information about each request active or being canceled on the server. Once a request has completed canceling, it will no longer appear in the output of
				<code>xdmp:server-status</code>.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:request-cancel(xdmp:host("myhost"),
                      xdmp:server("myAppServerName"),
	             98394839084390843)
   =&gt; ()
</example>
	</function>
	<function name="database-backup-purge" type="builtin" lib="xdmp" category="AdminBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:database-backup-purge">
		<summary>Purge old backups from a directory.</summary>
		<params>
			<param name="dir" type="xs:string" optional="false">The directory under which to look for backups.</param>
			<param name="keep-num-backups" type="xs:unsignedInt" optional="false">The maximum number of old backups to keep.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-database-backup-purge</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
	</function>
	<function name="get-orphaned-binaries" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-orphaned-binaries">
		<summary>Returns a sequence of the IDs of all orphaned large binaries in a given forest.</summary>
		<params>
			<param name="id" type="xs:unsignedLong" optional="false">A forest ID.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-get-orphaned-binaries</code>
			</p>
		</privilege>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:get-orphaned-binaries(8456374036761185098)
    =&gt; 1236374036761185456
1236378936761185098
1256374036761185951
</example>
	</function>
	<function name="remove-orphaned-binary" type="builtin" lib="xdmp" category="Extension" subcategory="MarkLogic Server" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:remove-orphaned-binary">
		<summary>Remove an orphaned large binary</summary>
		<params>
			<param name="forestID" type="xs:unsignedLong" optional="false">A forest ID.</param>
			<param name="binaryID" type="xs:unsignedLong" optional="false">The ID of an orphaned large binary.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-remove-orphaned-binary</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xdmp:remove-orphaned-binary(8456374036761185098, 1236374036761185456)
</example>
	</function>
	<function name="lock-for-update" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:lock-for-update">
		<summary>Acquires an intent exclusive lock on a URI.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI to be locked for update.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>Note that this is not a document lock, this is a lock that the system normally acquires automatically during an update transaction. Without
				<code>xdmp:lock-for-update</code>, the URI lock is lazily acquired when it is needed.</p>
			<p>When you add
				<code>xdmp:lock-for-update</code>to an XQuery or XSLT program that performs an update, the URI lock is acquired as soon as this function is called. If an update first calls
				<code>xdmp:lock-for-update</code>, and if another transaction is updating that same URI, then it will retry when the
				<code>xdmp:lock-for-update</code>call is made. If you do not call
				<code>xdmp:lock-for-update</code>, then the update transaction might have to do some extra work before it attempts to acquire the URI lock, and if another transaction has the URI lock, then it will have to retry and repeat that work before attempting to lock the URI again (possibly repeating this process if the lock is still not available). In these situations, calling
				<code>xdmp:lock-for-update</code>early in the update code can reduce overall contention in the system.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:lock-for-update("/example.xml")
</example>
		<algorithm />
	</function>
	<function name="save" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:save">
		<summary>Serializes a node as text and saves it to a file. The node can be any node, including a document node, an element node, a text node, or a binary node.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The output file pathname. The path can be fully qualifed or relative. Relative pathnames are resolved from the directory in which MarkLogic Server is installed.</param>
			<param name="node" type="node()" optional="false">The node to be serialized.</param>
			<param name="options" type="node()?" optional="true">The options node for this save operation. The default value is (). The node for the xdmp:save options must be in the
				<code>xdmp:save</code>namespace.
				<p>The
					<code>xdmp:save</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;output-encoding&gt;</p>
						</dt>
						<dd>Specifies the encoding to use when saving the document.</dd>
						<dt>
							<p>&lt;output-sgml-character-entities&gt;</p>
						</dt>
						<dd>Specifies if character entities should be output upon serialization of the XML. Valid values are
							<code>normal</code>,
							<code>none</code>,
							<code>math</code>, and
							<code>pub</code>. By default (that is, if this option is not specified), no SGML entities are serialized on output, unless the App Server is configured to output SGML character entities.</dd>
						<dt>
							<p>&lt;method&gt;</p>
						</dt>
						<dd>Valid values are
							<code>xml</code>,
							<code>html</code>,
							<code>xhtml</code>, and
							<code>text</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;cdata-section-elements&gt;</p>
						</dt>
						<dd>A list of QNames to output as CDATA sections. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;encoding&gt;</p>
						</dt>
						<dd>The encoding. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;use-character-maps&gt;</p>
						</dt>
						<dd>Valid values are
							<code>xdmp:sgml-entities-normal</code>,
							<code>xdmp:sgml-entities-math</code>, and
							<code>xdmp:sgml-entities-pub</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;media-type&gt;</p>
						</dt>
						<dd>A mimetype representing a media type. For example,
							<code>text/plain</code>or
							<code>text/xml</code>(or other valid mimetypes). This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;byte-order-mark&gt;</p>
						</dt>
						<dd>Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;indent&gt;</p>
						</dt>
						<dd>Specifies if typed XML (that is, XML for which there is an in-scope schema) should be pretty-printed (indented). Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;indent-untyped&gt;</p>
						</dt>
						<dd>Specifies if untyped XML (that is, XML for which there is no in-scope schema) should be pretty-printed (indented). Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;include-content-type&gt;</p>
						</dt>
						<dd>Include the content-type declaration when serializing the node. Valid values are
							<code>yes</code>or
							<code>no</code>.</dd>
						<dt>
							<p>&lt;escape-uri-attributes&gt;</p>
						</dt>
						<dd>Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;doctype-public&gt;</p>
						</dt>
						<dd>A public identifier, which is the public identifier to use on the emitted DOCTYPE. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;doctype-system&gt;</p>
						</dt>
						<dd>A system identifier, which is the system identifier to use on the emitted DOCTYPE. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;omit-xml-declaration&gt;</p>
						</dt>
						<dd>Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;standalone&gt;</p>
						</dt>
						<dd>Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;normalization-form&gt;</p>
						</dt>
						<dd>Valid values are
							<code>NFC</code>,
							<code>NFD</code>, and
							<code>NFKD</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
						<dt>
							<p>&lt;default-attributes&gt;</p>
						</dt>
						<dd>Specifies whether attributes defaulted with a schema should be included in the serialization. Valid values are
							<code>yes</code>or
							<code>no</code>. This is like the corresponding part of both the XSLT
							<a href="http://www.w3.org/TR/xslt20/#serialization">
								<code>xsl:output</code>
							</a>instruction and the MarkLogic XQuery
							<code>xdmp:output</code>prolog statement.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-save</code>
			</p>
		</privilege>
		<example xml:space="preserve">
  (: serialize an XML document in the database to a file on disk :)
  let $mynode := doc("/mydocs/example.xml")
  return
  xdmp:save("example.xml", $mynode)
</example>
    <example xml:space="preserve">
  (: save a text file :)
  let $text := text { "hello" }
  return
  xdmp:save("hello.txt", $text)
</example>
    <example xml:space="preserve">
  (: save a pdf stored in the database to disk,
     explicitly specifying the output encoding :)
  let $pdf := doc("/mydocs/stuff.pdf")
  return
  xdmp:save("mystuff.pdf", $pdf,
    &lt;options xmlns="xdmp:save"&gt;
      &lt;output-encoding&gt;utf-8&lt;/output-encoding&gt;
    &lt;/options&gt;)
</example>
		<algorithm />
	</function>
	<function name="document-load" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-load">
		<summary>Inserts a new document with the specified URI. If a document already exists at the URI, the function replaces the content in the existing document as an update operation.</summary>
		<params>
			<param name="location" type="xs:string" optional="false">The location of the input document. If the scheme of the location is HTTP (that is, if the string starts with "http://"), then the document is requested over HTTP. If the scheme is file (that is, if the string starts with "file://"), then the document is requested over file protocol from the local filesystem. Otherwise, the document is fetched from the local filesystem. On the filesystem, the path can be fully qualifed or relative. Relative pathnames are resolved from the directory in which MarkLogic Server is installed.</param>
			<param name="options" type="node()?" optional="true">The options node for this load operation. The default value is (). The node for the xdmp:document-load options must be in the
				<code>xdmp:document-load</code>namespace. This parameter can also include option elements in the
				<code>xdmp:http</code>namespace for the HTTP parameters.
				<p>The
					<code>xdmp:document-load</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;uri&gt;</p>
						</dt>
						<dd>The URI of the document to be loaded. If omitted, then the location is used for the URI.</dd>
						<dt>
							<p>&lt;permissions&gt;</p>
						</dt>
						<dd>Security permission elements corresponding to the permissions for the document. If not supplied, the current user's default permissions are applied. The default value used for $permissions can be obtained by calling
							<code>xdmp:default-permissions()</code>. A document that is created by a non-admin user (that is, by any user who does not have the
							<code>admin</code>role) must have at least one update permission, otherwise the creation will throw an
							<code>XDMP-MUSTHAVEUPDATE</code>exception.</dd>
						<dt>
							<p>&lt;collections&gt;</p>
						</dt>
						<dd>The collection URIs for collections to which this document belongs. If not supplied, the document is added to the current user's default collections (the collections returned from
							<code>xdmp:default-collections()</code>). For each collection that is protected, the user must have permissions to update that collection or have the
							<code>any-collection</code>privilege. For each unprotected collection, the user must have the
							<code>unprotected-collections</code>privilege. The
							<code>&lt;collections&gt;</code>element consists of one or more
							<code>&lt;collection&gt;</code>child elements. For example:
							<pre xml:space="preserve">
    &lt;collections&gt;
      &lt;collection&gt;myCollection1&lt;/collection&gt;
      &lt;collection&gt;myCollection2&lt;/collection&gt;
    &lt;/collections&gt;
</pre></dd>
						<dt>
							<p>&lt;quality&gt;</p>
						</dt>
						<dd>The quality of this document. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</dd>
						<dt>
							<p>&lt;default-namespace&gt;</p>
						</dt>
						<dd>The namespace to use if there is no namespace at the root node of the document. The default value is "".</dd>
						<dt>
							<p>&lt;repair&gt;</p>
						</dt>
						<dd>A value of
							<code>full</code>specifies that malformed XML content be repaired. A value of
							<code>none</code>specifies that malformed XML content is rejected. If no repair option is explicitly specified, the default is implicitly specified by the XQuery version of the caller. In XQuery
							<code>1.0</code>and
							<code>1.0-ml</code>the default is
							<code>none</code>. In XQuery
							<code>0.9-ml</code>the default is
							<code>full</code>. This option has no effect on binary or text documents.</dd>
						<dt>
							<p>&lt;format&gt;</p>
						</dt>
						<dd>A value of
							<code>text</code>specifies to get the document as a text document, regardless of the URI specified. A value of
							<code>binary</code>specifies to get the document as a binary document, regardless of the URI specified. A value of
							<code>xml</code>specifies to get the document as an XML document, regardless of the URI specified.</dd>
						<dt>
							<p>&lt;default-language&gt;</p>
						</dt>
						<dd>The language to specify in an
							<code>xml:lang</code>attribute on the root element node if the root element node does not already have an
							<code>xml:lang</code>attribute. If
							<code>default-language</code>is not specified, then nothing is added to the root element node.</dd>
						<dt>
							<p>&lt;forests&gt;</p>
						</dt>
						<dd>Specifies the ID of the forest in which this document is inserted. Each forest ID is in a &lt;forest&gt; child element and is of type
							<code>xs:unsignedLong</code>. If the document already exists in the database, it will remain in its existing forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the document is inserted into one of the specifed forests. If the document already exists and the forest in which it is stored is set to delete-only, then you must specify the forest IDs to include one or more forests that allow updates, otherwise an exception is thrown.</dd>
						<dt>
							<p>&lt;encoding&gt;</p>
						</dt>
						<dd>Specifies the encoding to use when reading the document into MarkLogic Server. Supported values include
							<code>UTF-8</code>,
							<code>ISO-8859-1</code>, as well as many other popular encodings. See the
							<em>Search Developer's Guide</em>for a list of character set encodings by language. All encodings will be translated into UTF-8 from the specified encoding. The string specifed for the
							<code>encoding</code>option will be matched to an encoding name according to the Unicode Charset Alias Matching rules (
							<a href="http://www.unicode.org/reports/tr22/#Charset_Alias_Matching">http://www.unicode.org/reports/tr22/#Charset_Alias_Matching</a>). An automatic encoding detector will be used if the value
							<code>auto</code>is specified. If no encoding can be detected, the encoding defaults to UTF-8. If no encoding option is specified and you are using a path with an
							<code>http://</code>scheme, the encoding defaults to the encoding specified in the http header (if an encoding header is specified), otherwise it defaults to UTF-8.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>When selecting documents over HTTP (where the
				<code>$location</code>parameter begins with
				<code>http://</code>), the response from the webserver is loaded into the database, regardless of what the headers returned from the webserver indicate. For example, if the webserver returns a 404 (file not found), then the response page that says "file not found" is loaded into the database. If you want to examine the headers before loading the document, use
				<code>xdmp:http-get</code>(combined with
				<code>xdmp:document-insert</code>) instead, as
				<code>xdmp:http-get</code>allows you to examine the headers returned from the HTTP server.</p>
		</usage>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-document-load</code>
			</p>
			<p>If a new document is inserted, you also need the
				<code>unprotected-uri</code>privilege (only if the URI is not protected), the
				<code>any-uri</code>privilege, or an appropriate URI privilege.</p>
			<p>If adding an unprotected collection to a document, the
				<code>unprotected-collections</code>privilege (
				<code>http://marklogic.com/xdmp/privileges/unprotected-collections</code>) is needed; if adding a protected collection, the user must have either permissions to update the collection or the
				<code>any-collection</code>privilege (
				<code>http://marklogic.com/xdmp/privileges/any-collection</code>).</p>
		</privilege>
		<example xml:space="preserve">
xdmp:document-load("c:\myFile.xml",
    &lt;options xmlns="xdmp:document-load"&gt;
      &lt;uri&gt;/documents/myFile.xml&lt;/uri&gt;
      &lt;repair&gt;none&lt;/repair&gt;
      &lt;permissions&gt;{xdmp:default-permissions()}&lt;/permissions&gt;
    &lt;/options&gt;)

=&gt; Loads the document with a URI "/documents/myFile.xml"
   and does not perform tag repair during the load.


</example>
    <example xml:space="preserve">
xdmp:document-load("http://myCompany.com/file.xml",
    &lt;options xmlns="xdmp:document-load"
             xmlns:http="xdmp:http"&gt;
      &lt;uri&gt;/documents/myFile.xml&lt;/uri&gt;
      &lt;repair&gt;none&lt;/repair&gt;
      &lt;permissions&gt;{xdmp:default-permissions()}&lt;/permissions&gt;
      &lt;format&gt;xml&lt;/format&gt;
      &lt;http:authentication&gt;
          &lt;http:username&gt;user&lt;/http:username&gt;
          &lt;http:password&gt;pass&lt;/http:password&gt;
      &lt;/http:authentication&gt;
    &lt;/options&gt;)

=&gt; Loads the document with a URI "/documents/myFile.xml"
   from the server http://myCompany.com, sending the
   credentials user/pass. Tag repair is not performed
   during the load, and the document is loaded as xml.


</example>
    <example xml:space="preserve">
xdmp:document-load("c:\myFile.xml",
    &lt;options xmlns="xdmp:document-load"&gt;
       &lt;uri&gt;/documents/myFile.xml&lt;/uri&gt;
       &lt;permissions&gt;{xdmp:default-permissions()}&lt;/permissions&gt;
       &lt;collections&gt;
          &lt;collection&gt;myCollection1&lt;/collection&gt;
	  &lt;collection&gt;myCollection2&lt;/collection&gt;
       &lt;/collections&gt;
       &lt;repair&gt;full&lt;/repair&gt;
       &lt;forests&gt;
         &lt;forest&gt;{xdmp:forest("myForest")}&lt;/forest&gt;
       &lt;/forests&gt;
    &lt;/options&gt; )

=&gt; Loads the document with a URI "/documents/myFile.xml"
   performing tag repair during the load, adding the
   document to the "myCollection1" and "myCollection2"
   collections, and loading the document into the forest
   named "myForest".


</example>
	</function>
	<function name="load" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:load">
		<summary>[DEPRECATED: use
			<a href="#xdmp:document-load">
				<code>xdmp:document-load</code>
			</a>instead] Inserts a new document from the XML file at $path if a document with the specified URI does not already exist. Otherwise, the function replaces the content in the existing document as an update operation.</summary>
		<params>
			<param name="path" type="xs:string" optional="false">The path to the input file. The path can be fully qualifed or relative. Relative pathnames are resolved from the directory in which MarkLogic Server is installed.</param>
			<param name="uri" type="xs:string?" optional="true">The URI of the document to be loaded. If omitted, then the pathname is used.</param>
			<param name="permissions" type="element(sec:permission)*" optional="true">Security permission elements corresponding to the permissions for the document. If not supplied, the current user's default permissions are applied. The default value used for $permissions can be obtained by calling xdmp:default-permissions(). To specify no permissions, enter the empty sequence ().</param>
			<param name="collections" type="xs:string*" optional="true">The collection URIs for collections to which this document belongs. If not supplied, the document is added to the current user's default collections. The default value used for $collections can be obtained by calling xdmp:default-collections(). To specify no collections, enter the empty sequence ().</param>
			<param name="quality" type="xs:int?" optional="true">The quality of this document. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</param>
			<param name="default-namespace" type="xs:string?" optional="true">If $default-namespace is specified and the root node of the loaded document does not explicitly specify a namespace, $default-namespace will be applied to the root node. The default value for $default-namespace is "".</param>
			<param name="options" type="xs:string*" optional="true">The options for loading this document. The default value is ().
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>"repair-full"</dt>
						<dd>Specifies that malformed XML content be repaired during loading. This option has no effect on binary or text documents.</dd>
						<dt>"repair-none"</dt>
						<dd>Specifies that malformed XML content be rejected during loading. This option has no effect on binary or text documents.</dd>
						<dt>"format-text"</dt>
						<dd>Specifies to load the document as a text document, regardless of the URI specified.</dd>
						<dt>"format-binary"</dt>
						<dd>Specifies to load the document as a binary document, regardless of the URI specified.</dd>
						<dt>"format-xml"</dt>
						<dd>Specifies to load the document as an XML document, regardless of the URI specified.</dd>
						<dt>"lang=en"</dt>
						<dd>Specifies that the document is in english.</dd>
					</dl>
				</blockquote></param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Specifies the ID of the forest in which this document is inserted. If the document already exists in the database, it will remain in its existing forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the document is inserted into one of the specifed forests.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-load</code>
			</p>
			<p>If a new document is inserted, you also need the
				<code>unprotected-uri</code>privilege (only if the URI is not protected), the
				<code>any-uri</code>privilege, or an appropriate URI privilege.</p>
		</privilege>
		<usage>
			<p>If no format is specified in $options, it is specified by the document content type specified by the extension of the document URI. The mimetype extensions and corresponding content types are set in the Admin Interface.</p>
			<p>If neither "repair-full" nor "repair-none" is present, the default is specified by the XQuery version of the caller. In XQuery version
				<code>1.0</code>and
				<code>1.0-ml</code>the default is "repair-none". In XQuery version
				<code>0.9-ml</code>the default is "repair-full".</p>
		</usage>
		<example xml:space="preserve">
  xdmp:load("/home/test/example.xml", "/example.xml",
            (xdmp:permission("editor", "read"),
             xdmp:permission("editor", "update")),
            "http://examples.com",
            10,"http://www.marklogic.com/default")
</example>
    <example xml:space="preserve">
  xdmp:load("/home/test/example.xml",
	    "/example.xml",
            xdmp:default-permissions(),
            xdmp:default-collections(),
            0,
	    "",
	    "repair-none")
</example>
		<algorithm />
	</function>
	<function name="document-insert" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-insert">
		<summary>Inserts a new document into the database if a document with the specified URI does not already exist. If a document already exists at the specified URI, the function replaces the content of the existing document with the specified content (the
			<code>$root</code>parameter) as an update operation. In addition to replacing the content,
			<code>xdmp:document-insert</code>replaces any permissions, collections, and quality with the ones specified (or with the default values for these parameters, if not explicitly specified). Also, if a properties document exists at the same URI, that properties document (including any content it contains) is preserved.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to be inserted.</param>
			<param name="root" type="node()" optional="false">The root node. The root node can be one of XML format, binary (BLOB) format, or text (CLOB) format.</param>
			<param name="permissions" type="element(sec:permission)*" optional="true">Security permission elements corresponding to the permissions for the document. If not supplied, the current user's default permissions are applied. The default value used for $permissions can be obtained by calling xdmp:default-permissions(). A document that is created by a non-admin user (that is, by any user who does not have the
				<code>admin</code>role) must have at least one update permission, otherwise the creation will throw an
				<code>XDMP-MUSTHAVEUPDATE</code>exception.</param>
			<param name="collections" type="xs:string*" optional="true">The collection URIs for collections to which this document belongs. If not supplied, the document is added to the current user's default collections. For each collection that is protected, the user must have permissions to update that collection or have the
				<code>any-collection</code>privilege. For each unprotected collection, the user must have the
				<code>unprotected-collections</code>privilege. The default value used for $collections can be obtained by calling
				<code>xdmp:default-collections()</code>.</param>
			<param name="quality" type="xs:int?" optional="true">The quality of this document. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Specifies the ID of the forest in which this document is inserted. If the document already exists in the database and if $forest-ids is not specified, it will remain in its existing forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the document is inserted into one of the specifed forests. If the document exists and the forest in which it is stored is set to delete-only, then you must set $forest-ids to include one or more forests that allow updates, otherwise an exception is thrown.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<p>If a new document is inserted, the
				<code>unprotected-uri</code>privilege (only if the URI is not protected), the
				<code>any-uri</code>privilege, or an appropriate URI privilege is also needed. If adding an unprotected collection to a document, the
				<code>unprotected-collections</code>privilege is needed; if adding a protected collection, the user must have either permissions to update the collection or the
				<code>any-collection</code>privilege.</p>
		</privilege>
		<example xml:space="preserve">
  xdmp:document-insert(
         "/example.xml", &lt;a&gt;aaa&lt;/a&gt;,
            (xdmp:permission("editor", "read"),
             xdmp:permission("editor", "update")),
         "http://examples.com")
</example>
    <example xml:space="preserve">
  xdmp:document-insert(
         "/example.xml",
	 &lt;a&gt;aaa&lt;/a&gt;,
         xdmp:default-permissions(),
         xdmp:default-collections(),
	 10)
</example>
    <example xml:space="preserve">
(:
   Specify the forest IDs to move a delete-only document
   from one forest to another (assuming at least one of
   the forests allows updates).
:)
  xdmp:document-insert(
         "/example.xml",
	 &lt;root&gt;new content here&lt;/root&gt;, (), (), 0,
	 xdmp:database-forests(xdmp:database()) )
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";
(: create a text document :)
xdmp:document-insert("/text-doc.txt",
   text { "This is a text document." } )


</example>
	</function>
	<function name="directory-create" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:directory-create">
		<summary>Creates a directory. If security is enabled, the document permissions and collections are set to the given parameters, if supplied. Otherwise, the current user's default permissions and/or collections are applied. If the beginning of the the document URI is protected, the user must have access to that URI privilege. If the directory URI does not end with a '/' one is added. If the directory already exists, then an XDMP-DIREXISTS exception is thrown.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the directory to be inserted.</param>
			<param name="permissions" type="element(sec:permission)*" optional="true">Security permission elements corresponding to the permissions for the document.</param>
			<param name="collections" type="xs:string*" optional="true">The collections to which the new directory belongs.</param>
			<param name="quality" type="xs:int?" optional="true">The quality of this document. A positive value increases the relevance score of the document in text search functions. The converse is true for a negative value. The default value is 0.</param>
			<param name="forest-ids" type="xs:unsignedLong*" optional="true">Specifies the ID of the forest in which this directory is created. If the directory already exists in the database and if $forest-ids is not specified, it will remain in its existing forest. If no such forest exists or if no such forest is attached to the context database, an error is raised. If multiple forests are specified, the directory is created in one of the specifed forests.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xdmp:directory-create("http://marklogic.com/a/",
            (xdmp:permission("development", "update"),
             xdmp:permission("qa", "read")),
             "http://marklogic.com/directories")

=&gt; Creates a directory named "http://marklogic.com/a/",
   which has the parent directory "http://marklogic.com/".
   The directory is created with the specified permissions,
   and is added to the "http://marklogic.com/directories"
   collection.

</example>
    <example xml:space="preserve">
xdmp:directory-create("/dir/myDirectory/")

=&gt; Creates a directory named "/dir/myDirectory/",
   which has the parent directory "/dir/", which
   in turn has parent directory "/". If
   directory creation is set to automatic in
   the database configuration, this example creates
   all three directories ("/", "/dir/", and
    "/dir/myDirectory/").

</example>
		<algorithm />
	</function>
	<function name="document-delete" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-delete">
		<summary>Deletes a document from the database.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to be deleted.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>The
				<code>xdmp:document-delete</code>function deletes a document and all of its properties, except the directory property; it does not delete a directory with the same URI as the document being deleted. To delete a directory, use the
				<code>xdmp:directory-delete</code>function.</p>
			<p>If a document does not exist at the specified URI,
				<code>xdmp:document-delete</code>returns an error.</p>
		</usage>
		<example xml:space="preserve">
xdmp:document-delete("example.xml")
</example>
	</function>
	<function name="directory-delete" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:directory-delete">
		<summary>Deletes a directory and all of its child and descendant documents and directories from the database.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the directory to be deleted.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>If you delete a directory, the directory and all of its children and descendants (recursively) are deleted, including all child documents and directories. A child document or directory of a given directory is one whose URI begins with the same string as the directory URI.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:directory-delete("http://example.com/")
</example>
		<algorithm />
	</function>
	<function name="collection-delete" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:collection-delete">
		<summary>Deletes from the database every document in a collection. If there are no documents in the specified collection, then nothing is deleted, and
			<code>xdmp:collection-delete</code>still returns the empty sequence.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the collection to be deleted.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:collection-delete("collection-uri")
</example>
		<algorithm />
	</function>
	<function name="node-replace" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:node-replace">
		<summary>Replaces a node.</summary>
		<params>
			<param name="old" type="node()" optional="false">The old node, to be replaced.</param>
			<param name="new" type="node()" optional="false">The new node.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>Attribute nodes cannot be replaced by non-attribute nodes. Non-attribute nodes cannot be replaced by attribute nodes. Element nodes cannot have document node children. Document nodes cannot have multiple element node children.</usage>
		<example xml:space="preserve">
  xdmp:document-insert("/example.xml",
    &lt;a&gt;&lt;b&gt;bbb&lt;/b&gt;&lt;/a&gt;);
  xdmp:node-replace(doc("/example.xml")/a/b, &lt;c&gt;ccc&lt;/c&gt;);
  doc("/example.xml")
 =&gt;
  &lt;a&gt;&lt;c&gt;ccc&lt;/c&gt;&lt;/a&gt;
</example>
    <example xml:space="preserve">
(: This example shows how to update the root
   node of a text format document.  Start by
   creating a text document.     :)

xdmp:document-insert("/mydir/doc.txt",
text{"This is a line of text."} ) ;

(: Update the text node of the text document
   by appending another line of text to the
   text node.  Note that the text node is the
   root node of a text document.     :)

xdmp:node-replace(doc("/mydir/doc.txt")/text() ,
text{ concat(doc("/mydir/doc.txt")/text(), "
This is another line of text.") } ) ;

doc("/mydir/doc.txt")
=&gt;
This is a line of text.
This is another line of text.


</example>
		<algorithm />
	</function>
	<function name="node-delete" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:node-delete">
		<summary>Deletes a node from the database. On-the-fly constructed nodes cannot be deleted.</summary>
		<params>
			<param name="old" type="node()" optional="false">The node to be deleted.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-insert("/example.xml",
    &lt;a&gt;&lt;b&gt;bbb&lt;/b&gt;&lt;/a&gt;);
  xdmp:node-delete(doc("/example.xml")/a/b);
  doc("/example.xml")
 =&gt;
  &lt;a/&gt;
</example>
		<algorithm />
	</function>
	<function name="node-insert-before" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:node-insert-before">
		<summary>Adds an immediately preceding sibling to a node.</summary>
		<params>
			<param name="sibling" type="node()" optional="false">The sibling node to be preceded by the new node.</param>
			<param name="new" type="node()" optional="false">The new node to be inserted.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>Attribute nodes cannot be preceded by non-attribute nodes. Non-attribute nodes cannot be preceded by attribute nodes. Element nodes cannot have document node children. Document nodes cannot have multiple element node children. On-the-fly constructed nodes cannot be updated.</usage>
		<example xml:space="preserve">
  xdmp:document-insert("/example.xml",
    &lt;a&gt;&lt;b&gt;bbb&lt;/b&gt;&lt;/a&gt;);
  xdmp:node-insert-before(doc("/example.xml")/a/b,
    &lt;c&gt;ccc&lt;/c&gt;);
  doc("/example.xml")
 =&gt;
  &lt;a&gt;&lt;c&gt;ccc&lt;/c&gt;&lt;b&gt;bbb&lt;/b&gt;&lt;/a&gt;
</example>
		<algorithm />
	</function>
	<function name="node-insert-after" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:node-insert-after">
		<summary>Adds an immediately following sibling to a node.</summary>
		<params>
			<param name="sibling" type="node()" optional="false">The sibling node to be followed by the new node.</param>
			<param name="new" type="node()" optional="false">The new node to be inserted.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>Attribute nodes cannot be followed by non-attribute nodes. Non-attribute nodes cannot be followed by attribute nodes. Element nodes cannot have document node children. Document nodes cannot have multiple element node children. On-the-fly constructed nodes cannot be updated.</usage>
		<example xml:space="preserve">
  xdmp:document-insert("/example.xml",
    &lt;a&gt;&lt;b&gt;bbb&lt;/b&gt;&lt;/a&gt;);
  xdmp:node-insert-after(doc("/example.xml")/a/b,
    &lt;c&gt;ccc&lt;/c&gt;);
  doc("/example.xml")
 =&gt;
  &lt;a&gt;&lt;b&gt;bbb&lt;/b&gt;&lt;c&gt;ccc&lt;/c&gt;&lt;/a&gt;
</example>
		<algorithm />
	</function>
	<function name="node-insert-child" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:node-insert-child">
		<summary>Adds a new last child to a node. Only element nodes and document nodes can have children. Element nodes cannot have document node children. Document nodes cannot have multiple element node children. On-the-fly constructed nodes cannot be updated. The parameters must specify individual nodes and not node sets.</summary>
		<params>
			<param name="parent" type="node()" optional="false">The parent node which will have a new child node.</param>
			<param name="new" type="node()" optional="false">The new child node to be inserted.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-insert("/example.xml",
    &lt;a/&gt;);
  xdmp:node-insert-child(doc("/example.xml")/a,
    &lt;b&gt;bbb&lt;/b&gt;);
  doc("/example.xml")
 =&gt;
  &lt;a&gt;&lt;b&gt;bbb&lt;/b&gt;&lt;/a&gt;
</example>
    <example xml:space="preserve">
  xdmp:document-insert("/example.xml", &lt;a/&gt;);
  xdmp:node-insert-child(doc("/example.xml")/a,
    attribute b { "bbb" });
  doc("/example.xml")
 =&gt;
  &lt;a b="bbb"/&gt;
</example>
		<algorithm />
	</function>
	<function name="document-add-collections" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-add-collections">
		<summary>Adds the named document to the given collections. For each collection that is protected, the user must have permissions to update that collection or have the
			<code>any-collection</code>privilege. For each unprotected collection, the user must have the
			<code>unprotected-collections</code>privilege.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
			<param name="collections" type="xs:string*" optional="false">A set of collection URIs.</param>
		</params>
		<return>empty-sequence()</return>
		<privilege>
			<p>If adding an unprotected collection to a document, the
				<code>unprotected-collections</code>privilege (
				<code>http://marklogic.com/xdmp/privileges/unprotected-collections</code>) is needed; if adding a protected collection, the user must have either permissions to update the collection or the
				<code>any-collection</code>privilege (
				<code>http://marklogic.com/xdmp/privileges/any-collection</code>).</p>
		</privilege>
		<example xml:space="preserve">
  xdmp:document-add-collections(
    "/example.xml",
    ("http://examples.com", "http://marklogic.com"))
</example>
		<algorithm />
	</function>
	<function name="document-remove-collections" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-remove-collections">
		<summary>Removes the named document from the given collections. For each collection that is protected, the user must have permissions to update that collection or have the
			<code>any-collection</code>privilege. For each unprotected collection, the user must have the
			<code>unprotected-collections</code>privilege.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
			<param name="collections" type="xs:string*" optional="false">A set of collection URIs.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-remove-collections(
    "/example.xml",
    ("http://examples.com", "http://marklogic.com"))
</example>
		<algorithm />
	</function>
	<function name="document-set-collections" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-set-collections">
		<summary>Sets the named document to belong to the given collections, replacing any previously set collections on the named document. To preserve existing collections, use
			<code>xdmp:document-add-collections</code>. For each collection that is protected, the user must have permissions to update that collection or have the
			<code>any-collection</code>privilege. For each unprotected collection, the user must have the
			<code>unprotected-collections</code>privilege.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
			<param name="collections" type="xs:string*" optional="false">A set of collection URIs.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-set-collections(
    "/example.xml",
    ("http://examples.com", "http://marklogic.com"))
</example>
		<algorithm />
	</function>
	<function name="document-add-permissions" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-add-permissions">
		<summary>Adds the given permissions to the given document or directory. The user must have update or insert permissions on the document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Permission elements.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-add-permissions(
    "/example.xml",
    (xdmp:permission("development", "update"),
     xdmp:permission("qa", "read")))
</example>
		<algorithm />
	</function>
	<function name="document-remove-permissions" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-remove-permissions">
		<summary>Removes the given permissions from the named document or directory. The user must have update permissions on the document or directory.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Permission elements.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-remove-permissions(
    "/example.xml",
    (xdmp:permission("development", "update"),
     xdmp:permission("qa", "read")))
</example>
		<algorithm />
	</function>
	<function name="document-set-permissions" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-set-permissions">
		<summary>Sets the permissions on the named document (or directory) to the given permissions, replacing any permissions previously set on the document (or directory). To preserve any existing permissions, use
			<code>xdmp:document-add-permissions</code>. The user must have update permissions on the document or directory.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI.</param>
			<param name="permissions" type="element(sec:permission)*" optional="false">Permission elements.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-set-permissions(
    "/example.xml",
    (xdmp:permission("development", "update"),
     xdmp:permission("qa", "read")))
</example>
		<algorithm />
	</function>
	<function name="document-set-quality" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-set-quality">
		<summary>Sets the quality of the document with the given URI. If the quality of the document is positive, the relevance score of the document is increased in text search functions. The converse is true for "negative" quality.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document to which you are setting the quality.</param>
			<param name="quality" type="xs:int" optional="false">The quality to which to set the document.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-set-quality(
    "http://www.marklogic.com/test.xml",10)
  =&gt; ()
</example>
		<algorithm />
	</function>
	<function name="merge" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:merge">
		<summary>Starts merging the forests of the database, subject to specified options.</summary>
		<params>
			<param name="options" type="node()?" optional="true">The options node for this merge. The default value is (). The node for the xdmp:merge options must be in the
				<code>xdmp:merge</code>namespace.
				<p>The
					<code>xdmp:merge</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;merge-timestamp&gt;</p>
						</dt>
						<dd>Fragments with a timestamp of this or newer are not garbage collected during this merge</dd>
						<dt>
							<p>&lt;merge-max-size&gt;</p>
						</dt>
						<dd>The maximum allowable size, in megabytes, of a resultant stand</dd>
						<dt>
							<p>&lt;merge-priority&gt;</p>
						</dt>
						<dd>The CPU scheduler priority for the merge ("normal" or "lower")</dd>
						<dt>
							<p>&lt;single-stand&gt;</p>
						</dt>
						<dd>If any forests in the database have a single stand and this parameter is false, do not merge them. The default is
							<code>true</code>.</dd>
						<dt>
							<p>&lt;forests&gt;</p>
						</dt>
						<dd>Specifies the IDs of the forests in which to perform merges. Each forest ID is in the &lt;forest&gt; child element and is of type
							<code>xs:unsignedLong</code>.</dd>
					</dl>
				</blockquote></param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-merge</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:merge(&lt;options xmlns="xdmp:merge"&gt;
               &lt;merge-max-size&gt;500&lt;/merge-max-size&gt;
               &lt;merge-timestamp&gt;8273&lt;/merge-timestamp&gt;
               &lt;single-stand&gt;false&lt;/single-stand&gt;
               &lt;forests&gt;
                 &lt;forest&gt;{xdmp:forest("my-forest")}&lt;/forest&gt;
                 &lt;forest&gt;{xdmp:forest("my-other-forest")}&lt;/forest&gt;
               &lt;/forests&gt;
	     &lt;/options&gt;)
   =&gt; ()
   Performs a merge on my-forest and my-other-forest.  If a stand
   created by this merge would be greater than 500 megabytes, the merge
   will be limited and not all stands will be merged (as many as can be
   merged under 500 MB will be merged).  If my-forest or my-other-forest
   have only one stand, they will not be merged.  Any fragments with
   timestamp 8273 or newer will not be garbage collected.
</example>
		<algorithm />
	</function>
	<function name="merging" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:merging">
		<summary>Returns the forest IDs of any currently merging database forests.</summary>
		<params />
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-merging</code>
			</p>
		</privilege>
		<return>xs:unsignedLong*</return>
		<example xml:space="preserve">
  xdmp:merging()
   =&gt; 23487234872334
</example>
		<algorithm />
	</function>
	<function name="lock-acquire" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:lock-acquire">
		<summary>Acquire a lock on a document or directory for an extended amount of time. Locks restrict updates to a document or directory to the user who acquires the lock.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document or directory to be locked.</param>
			<param name="scope" type="xs:string?" optional="true">The lock scope ("exclusive" or "shared"). The default is "exclusive".</param>
			<param name="depth" type="xs:string?" optional="true">The lock depth ("0" or "infinity"). "0" locks the URI only, and "infinity" locks the URI (the document or directory) and all of its children. The default is "0".</param>
			<param name="owner" type="item()?" optional="true">Alternate description of the lock owner. If not specified or if specified as the empty sequence ( () ), then the owner is the user name of the user requesting the lock.</param>
			<param name="timeout" type="xs:unsignedLong?" optional="true">Requested lock timeout in seconds. If not specified or if specified as the empty sequence ( () ) or if specified as 0, then the timeout is infinite.</param>
		</params>
		<return>empty-sequence()</return>
		<usage>
			<p>If you lock a directory specifying a depth of "infinity", the directory and all of it children (all documents and directories with a URI started with the locked directory) are locked. You will not be able to add any children to the directory until the lock is released.</p>
			<p>When a user locks a URI, it is locked to other users, but not to the user who locked it. For example, if the user
				<em>sam</em>locks the URI
				<code>/home/sam.xml</code>by issuing the statement
				<code>xdmp:lock-acquire("/home/sam.xml")</code>, the user
				<em>sam</em>can still issue update commands to the document at that URI, but other users (for example, the user
				<em>josh</em>) will get an exception if they try to update the document.</p>
			<p>If you attempt to acquire a lock on a document that already has a lock, the XDMP-LOCKCONFLICT exception is thrown.</p>
			<p>If you attempt to update a document that is locked by another user, the XDMP-LOCKED exception is thrown.</p>
		</usage>
		<example xml:space="preserve">
xquery version "1.0-ml";
declare namespace DAV="DAV:";

xdmp:lock-acquire("/example.xml",
           "exclusive",
           "0",
           &lt;DAV:href&gt;http://example.com/~user&lt;/DAV:href&gt;,
           xs:unsignedLong(120))
=&gt; ()
</example>
	</function>
	<function name="lock-release" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:lock-release">
		<summary>Unlock a document or directory. Releases the lock created with
			<code>xdmp:lock-acquire</code>.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document or directory to be unlocked.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:lock-release("/example.xml")
  =&gt; ()
</example>
		<algorithm />
	</function>
	<function name="document-set-properties" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-set-properties">
		<summary>Sets the properties of a document to the given sequence of elements, replacing any properties that already exist on the document. To preserve existing document properties, use
			<code>xdmp:document-add-properties</code>. Each element QName is the property name and the element value is the property value. Modifying properties requires update permissions on a document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="props" type="element()*" optional="false">The properties to set. Replaces any properties already set on the document.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-set-properties(
         "example.xml",
         (&lt;priority&gt;1&lt;/priority&gt;,
          &lt;status&gt;unedited&lt;/status&gt;))
  =&gt; ()
</example>
		<algorithm />
	</function>
	<function name="document-add-properties" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-add-properties">
		<summary>Adds a sequence of properties to the properties of a document.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document.</param>
			<param name="props" type="element()*" optional="false">The properties to add.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-add-properties(
         "example.xml",
         (&lt;priority&gt;1&lt;/priority&gt;,
          &lt;status&gt;unedited&lt;/status&gt;))
  =&gt; ()
</example>
		<algorithm />
	</function>
	<function name="document-remove-properties" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-remove-properties">
		<summary>Removes a sequence of properties from the properties of a document. If properties with the QNames given do not exist, nothing is done.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The URI of the document whose properties are being updated.</param>
			<param name="property-names" type="xs:QName*" optional="false">The properties to remove.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:document-remove-properties(
         "example.xml",
         (fn:QName("", "priority"),
          fn:QName("", "status")))
  =&gt; ()
</example>
		<algorithm />
	</function>
	<function name="document-set-property" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-set-property">
		<summary>Sets a property on a document. If any properties with the same property QName exist, they are replaced with the new property. If no properties exist with the same QName, the new property is added.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI for the property setting.</param>
			<param name="prop" type="element()" optional="false">The property to set.</param>
		</params>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
xdmp:document-set-property(
  "http://marklogic.com/a/example.xml",
  &lt;priority xmlns="http://example.com"&gt;5&lt;/priority&gt;)

</example>
		<algorithm />
	</function>
	<function name="document-assign" type="builtin" lib="xdmp" category="UpdateBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-assign">
		<summary>Assign a document URI to a forest index, using the same algorithm as
			<code>xdmp:document-insert</code>. The return value will be a positive integer from 1 to
			<code>$forest-count</code>. This function does not insert or update the document; instead, it returns the index of the forest to which the document URI would be assigned if it were inserted as a new document. In order to match the document to the correct forest, use the list of forest-IDs as returned by
			<code>xdmp:database-forests</code>. If the document already exists, this function may not return the correct forest for the document. In this case,
			<code>xdmp:document-forest</code>will return the correct forest.</summary>
		<params>
			<param name="uri" type="xs:string" optional="false">The document URI to assign.</param>
			<param name="forest-count" type="xs:positiveInteger" optional="false">Specifies the number of forests from which this document may be assigned.</param>
		</params>
		<return>xs:positiveInteger</return>
		<example xml:space="preserve">
  xdmp:document-assign("document-1.xml", 2)
   =&gt; 1
</example>
    <example xml:space="preserve">
  xdmp:document-assign("document-2.xml", 2)
   =&gt; 2
</example>
    <example xml:space="preserve">
  let $forests := xdmp:database-forests(xdmp:database())
  let $index := xdmp:document-assign("document-1.xml", count($forests))
  return $forests[$index]
   =&gt; 17618760155059123769
</example>
	</function>
	<function name="get-transaction-mode" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:get-transaction-mode">
		<summary>Retrieve the transaction mode for the current session. Returns one of "auto", "update", or "query".</summary>
		<params />
		<privilege></privilege>
		<return>xs:string</return>
		<usage>The transaction mode for the session may not be the same as the transaction mode for the current transaction. The mode of a transaction is fixed when the transaction is created.</usage>
		<example xml:space="preserve">
  declare option xdmp:transaction-mode "update";
  xdmp:get-transaction-mode()

  =&gt; "update"
</example>
    <example xml:space="preserve">
  declare option xdmp:transaction-mode "update";

  xdmp:set-transaction-mode("query"),
  xdmp:get-transaction-mode()

  =&gt; "query". Changing the transaction mode during
     execution does not affect the current transaction,
     but still changes the transaction mode of the
     current session.
</example>
	</function>
	<function name="set-transaction-mode" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-transaction-mode">
		<summary>Set the transaction mode for the current session. Calling this function has no effect on existing transactions.</summary>
		<params>
			<param name="value" type="xs:string" optional="false">The new transaction mode. Must be one of "auto", "query", or "update".</param>
		</params>
		<privilege></privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>The mode a transaction runs under is fixed when the transaction is created. Calling
				<code>xdmp:set-transaction-mode</code>during a query does not affect the current transaction.</p>
			<p>The transaction mode defaults to "auto". To change the mode, you may either call
				<code>xdmp:set-transaction-mode</code>or use the
				<code>xdmp:transaction-mode</code>option.</p>
			<p>Use the
				<code>xdmp:transaction-mode</code>option to set the transaction mode before a transaction exists. Use
				<code>xdmp:set-transaction-mode</code>to set the mode during execution.</p>
		</usage>
		<example xml:space="preserve">
  declare option xdmp:transaction-mode "update";

  (: this transaction runs in update mode, due to the option :)
  xdmp:set-transaction-mode("query"),
  xdmp:document-insert("/docs/mydoc.xml", &lt;myData/&gt;),
  xdmp:commit();

  (: but this new transaction runs in query mode :)
  xdmp:get-transaction-mode(),
  fn:doc("/docs/mydoc.xml")

  =&gt; "query"
     &lt;myData/&gt;
</example>
	</function>
	<function name="transaction" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:transaction">
		<summary>Returns the transaction id for the current, or transaction id's for all transactions with the given name.</summary>
		<params>
			<param name="txn-name" type="xs:string" optional="false">An optional transaction name.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">An optional host id, for retrieving the transaction id of a named remote transaction.</param>
		</params>
		<return>xs:unsignedLong*</return>
		<usage>
			<p>When called with no parameters, this function returns the transaction id of the current transaction on the local host. When called with a
				<em>txn-name</em>, the transaction id for the named local or remote transaction(s) is returned.</p>
			<p>Transaction names need not be unique. This function will return multiple transaction id's if more than one transaction matches the parameters.</p>
			<p>To retrieve the transaction id of a named remote transaction, supply a
				<em>host-id</em>. If
				<em>host-id</em>is unknown or MarkLogic Server is not online on that host, an exception is raised.</p>
			<p>If no matching transaction exists, an empty sequence is returned.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:transaction("myNamedTransaction")
  =&gt; The transaction id for "myNamedTransaction" on the local host.
</example>
    <example xml:space="preserve">
  xdmp:transaction("myNamedTransaction", xdmp:host("some-host.marklogic.com"))
  =&gt; The transaction id for "myNamedTransaction" on the remote host
  some-host.marklogic.com.
</example>
	</function>
	<function name="set-transaction-name" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-transaction-name">
		<summary>Set the name of a local or remote transaction.</summary>
		<params>
			<param name="name" type="xs:string" optional="false">The new name.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">An optional host id. If omitted, the local App Server host is assumed. If a host id is given, then a transaction id must also be given.</param>
			<param name="txn-id" type="xs:unsignedLong" optional="false">An optional transaction ID. If omitted, the current transaction is assumed. If a transaction id is given, then a host id must also be given.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-transaction-name-my</code>
			</p>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-transaction-name-any</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>If the transaction already has a name, it is overwritten with the new name.</p>
			<p>If the specified transaction does not exist,
				<code>XDMP-NOTXN</code>is raised.</p>
			<p>If
				<em>host-id</em>is not found or MarkLogic Server is not available on that host, the exception
				<code>XDMP-HOSTOFFLINE</code>is raised.</p>
		</usage>
		<example xml:space="preserve"></example>
    <example xml:space="preserve">
  xdmp:set-transaction-name("myTransaction")
  =&gt; Set the name of the current transaction in the current local session
     to "myTransaction".
</example>
    <example xml:space="preserve">
  xdmp:set-transaction-name("myTransaction", $txn-id,
                            xdmp:host("some-host.marklogic.com"))
  =&gt; Set the name of the given transaction on the remote host
    some-host.marklogic.com to "myTransaction".
</example>
	</function>
	<function name="set-transaction-time-limit" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:set-transaction-time-limit">
		<summary>Set the transaction time limit for a local or remote transaction. Defaults to the configured request timeout.</summary>
		<params>
			<param name="time-limit" type="xs:unsignedInt" optional="false">The desired time limit, in seconds.</param>
			<param name="host-id" type="xs:unsignedLong" optional="false">A host id.</param>
			<param name="txn-id" type="xs:unsignedLong" optional="false">The transaction ID.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-transaction-time-limit-my</code>
			</p>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-set-transaction-time-limit-any</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>The transaction time limit determines how long the transaction may run before being automatically aborted. If you set the time limit to a limit less than the elapsed time of the current transaction, the transaction may abort immediately.</p>
			<p>The default (and maximum) transaction time limit is the request time limit configured for the server that creates the transaction. For information on configuring the request time limit, see the Administrator's Guide, or
				<code>
					<a href="Admin Library#admin:appserver-set-request-timeout">admin:appserver-set-request-timeout</a>
				</code>.</p>
			<p>If you attempt to set the transaction time limit to a value greater than the configured request time limit, the exception
				<code>XDMP-TIMELIMIT</code>is raised.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:set-transaction-time-limit(10)
  =&gt; Empty. The time limit of the current transaction on the
     local host is set to 10 seconds.
</example>
    <example xml:space="preserve">
  xdmp:set-transaction-time-limit(10, xdmp:host(), $some-txn-id)
  =&gt; Empty. The time limit of the given transaction on the local
     host is set to 10 seconds.
</example>
	</function>
	<function name="commit" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:commit">
		<summary>Commit the current transaction to the database.</summary>
		<params />
		<privilege></privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>Transactions running in "update" or "query" transaction mode must be explicitly committed, using this function.
				<code>xdmp:commit</code>is a no-op in "auto" transaction mode (the default) because auto-commit transactions automatically commit at the end of every statement.</p>
			<p>When you call
				<code>xdmp:commit</code>, the transaction is marked for commit, but commit does not actually happen until the end of the currently executing statement.</p>
			<p>This function is equivalent to calling
				<code>
					<a href="#xdmp:transaction-commit">xdmp:transaction-commit</a>
				</code>for the current host and transaction:
				<code>xdmp:transaction-commit(xdmp:host(), xdmp:transaction())</code>.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:set-transaction-mode("update"),
  xdmp:document-insert("/docs/mydoc.xml", &lt;myData/&gt;),
  xdmp:commit()

  =&gt; Empty. The current transaction is marked ready to be committed.
     When the commit completes, the document is visible in the database,
     and the transaction ends.
</example>
	</function>
	<function name="rollback" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:rollback">
		<summary>Roll back the current transaction.</summary>
		<params />
		<privilege></privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>When a transaction is rolled back, the current statement immediately terminates, updates made by any statement in the transaction are discarded, and the transaction terminates.</p>
			<p>Transactions running in "update" or "query" transaction mode should be explicitly rolled back, using this function. Failure to explicitly commit or roll back such a transaction leaves the transaction open until transaction timeout, thus unnecessarily holding resources and locks, potentially blocking other transactions.</p>
			<p>Transactions running in "auto" transaction mode may also use this function, to roll back a transaction without raising an error.</p>
			<p>The result of a statement terminated with
				<code>xdmp:rollback</code>is always the empty sequence.</p>
			<p>This function is equivalent to calling
				<code>
					<a href="#xdmp:transaction-rollback">xdmp:transaction-rollback</a>
				</code>for the current host and transaction:
				<code>xdmp:transaction-rollback(xdmp:host(), xdmp:transaction())</code>.</p>
		</usage>
		<example xml:space="preserve">
  (: multi-statement transaction :)
  declare option xdmp:transaction-mode "update";

  xdmp:document-insert("/docs/first.xml", &lt;first/&gt;);
  xdmp:document-insert("/docs/second.xml", &lt;second/&gt;);
  xdmp:rollback();

  =&gt; Empty. The transaction is rolled back. The documents are
     not added to the database. The transaction ends.
</example>
	</function>
	<function name="transaction-commit" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:transaction-commit">
		<summary>Explicitly commit a transaction running on a named host.</summary>
		<params>
			<param name="host-id" type="xs:unsignedLong" optional="false">A host id.</param>
			<param name="txn-id" type="xs:unsignedLong" optional="false">The transaction ID.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/complete-my-transactions</code>
			</p>
			<p>
				<code>http://marklogic.com/xdmp/privileges/complete-any-transactions</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>Use this function to explicitly commit a remote transaction running in "update" or "query" transaction mode. You typically will not use this function for transactions running in "auto" transaction mode because the server commits such transactions automatically, at the end of every statement.</p>
			<p>When you call
				<code>xdmp:transaction-commit</code>, the transaction is marked for commit. The commit occurs at the end of the current executing statement. The transaction ends at that point.</p>
			<p>If the named host or transaction does not exist, an error is raised.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:transaction-commit(xdmp:host("some-host.marklogic.com"), $some-txn-id)

  =&gt; Empty. The given transaction is marked ready to be committed.
</example>
	</function>
	<function name="transaction-rollback" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:transaction-rollback">
		<summary>Explicitly roll back a transaction running on a named host.</summary>
		<params>
			<param name="host-id" type="xs:unsignedLong" optional="false">A host id.</param>
			<param name="txn-id" type="xs:unsignedLong" optional="false">The transaction ID.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xdmp-transaction-complete</code>
			</p>
		</privilege>
		<return>empty-sequence()</return>
		<usage>
			<p>Use this function to explicitly roll back a remote transaction running in "update" or "query" transaction mode. See
				<code>
					<a href="#xdmp:rollback">xdmp:rollback</a>
				</code>for more information.</p>
			<p>Any statement executing under the remote transaction is halted immediately.</p>
			<p>If the named host or transaction does not exist, an error is raised.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:transaction-rollback(xdmp:host("some-host.marklogic.com"), $some-txn-id)

  =&gt; Empty. The given transaction is rolled back and all
     modifications made by the transaction are discarded.
</example>
	</function>
	<function name="xa-complete" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:xa-complete">
		<summary>Completes (commits or rolls back) a prepared XA transaction.</summary>
		<params>
			<param name="forestID" type="unsignedLong" optional="false">A forest ID.</param>
			<param name="txn-id" type="xs:unsignedLong" optional="false">The transaction ID.</param>
			<param name="commit" type="xs:boolean" optional="false">Whether to commit or rollback. A value of true means commit.</param>
			<param name="remember" type="xs:boolean" optional="false">Whether to remember the completion until explicitly forgotten.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/complete-my-transactions</code>
			</p>
			<p>
				<code>http://marklogic.com/xdmp/privileges/complete-any-transactions</code>
			</p>
		</privilege>
		<usage>
			<p>You should usually let the Transaction Manager handle commit or rollback of global transactions. This function is made available for unusual circumstances in which you need to heuristically complete the MarkLogic branch of a global XA transaction. For example, if contact with the Transaction Manager is lost for a long time.</p>
		</usage>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:xa-complete($forest-id, $txn-id, fn:true(), fn:true())
  =&gt; Empty. The given transaction is committed and the
     outcome is remembered.

  xdmp:xa-complete($forest-id, $txn-id, fn:false(), fn:true())
  =&gt; Empty. The given transaction is rolled back and the
     outcome is remembered.
</example>
	</function>
	<function name="xa-forget" type="builtin" lib="xdmp" category="TransactionBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:xa-forget">
		<summary>Forgets a remembered completed XA transaction.</summary>
		<params>
			<param name="forestID" type="unsignedLong" optional="false">The forest ID of the coordinating forest.</param>
			<param name="txn-id" type="xs:unsignedLong" optional="false">The ID of a MarkLogic transaction that is part of a global XA transaction.</param>
		</params>
		<privilege>
			<p>
				<code>http://marklogic.com/xdmp/privileges/xa-forget</code>
			</p>
		</privilege>
		<usage>
			<p>Once a global transaction is prepared, it is remembered only by the coordinating forest. Supply the coordinating forest's ID to this function. Use xdmp:host-status and xdmp:forest-status to discover the coordinating forest.</p>
		</usage>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
  xdmp:xa-forget($forest-id, $txn-id)

  =&gt; Empty. The given transaction is forgotten and can no longer
     be recovered.
</example>
	</function>
	<function name="crypt" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:crypt">
		<summary>Calculates the password hash for the given password and salt.</summary>
		<params>
			<param name="password" type="xs:string" optional="false">String to be hashed.</param>
			<param name="salt" type="xs:string" optional="false">Salt to avoid 1:1 mapping from passwords to hashes. Only the first 8 characters of the salt are significant; any characters beyond the eighth are ignored.</param>
		</params>
		<return>xs:string</return>
		<usage>
			<p>You typically use the username as the salt, which ensures that no two hash values will be the same, even if different users have the same password.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:crypt("123abc","admin")
  =&gt; "arQEnpM6JHR8vY4n3e5gr0"
</example>
	</function>
	<function name="document-filter" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:document-filter">
		<summary>Filters a wide variety of document formats, extracting metadata and text, and returning XHTML. The extracted text has very little formatting, and is typically used for search, classificiation, or other text processing.</summary>
		<params>
			<param name="doc" type="node()" optional="false">Document to filter, as binary node().</param>
		</params>
		<return>node()</return>
		<usage>
			<p>Document metadata is returned in XHTML
				<code>meta</code>elements. The document title is in the
				<code>title</code>element. The format of the document is returned as a MIME media type in a
				<code>meta</code>element with the name "content-type". Metadata values with recognized date formats are converted to ISO8601.</p>
			<p>If the document has metadata but no text, like an audio or video document, the XHTML will have a
				<code>head</code>element but no
				<code>body</code>element.</p>
		</usage>
		<example xml:space="preserve">
xdmp:document-filter(doc("wordperfect.wpd"))

=&gt; Filters the wordperfect.wpd document to XHTML.
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

xdmp:document-filter(
 xdmp:http-get("http://www.marklogic.com/images/logo.gif")[2])
=&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;meta name="content-type" content="image/gif"/&gt;
    &lt;meta name="filter-capabilities" content="none"/&gt;
    &lt;meta name="size" content="2199"/&gt;
  &lt;/head&gt;
&lt;/html&gt;


</example>
	</function>
	<function name="email" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:email">
		<summary>Send an email in an XQuery program. A valid SMTP Relay must be configured in the Groups page of the Admin Interface for the email to be sent. The format of the email message must be an XML file that complies with the schema files listed below.</summary>
		<params>
			<param name="message" type="node()" optional="false">An XML representation of an email message to send. The message must comply with the XML schemas defined in the following schema files:
				<ul>
					<li>
						<code>
							<em>install_dir</em>/Config/email-xml.xsd</code>
					</li>
					<li>
						<code>
							<em>install_dir</em>/Config/rfc822.xsd</code>
					</li>
				</ul>where
				<code>
					<em>install_dir</em>
				</code>is the directory in which MarkLogic Server is installed.</param>
		</params>
		<privilege>http://marklogic.com/xdmp/privileges/xdmp-email</privilege>
		<return>empty-sequence()</return>
		<example xml:space="preserve">
This example demonstrates sending a message with
HTML content.

xdmp:email(
&lt;em:Message
 xmlns:em="URN:ietf:params:email-xml:"
 xmlns:rf="URN:ietf:params:rfc822:"&gt;
  &lt;rf:subject&gt;Sample HTML Email&lt;/rf:subject&gt;
  &lt;rf:from&gt;
    &lt;em:Address&gt;
      &lt;em:name&gt;MarkLogic&lt;/em:name&gt;
      &lt;em:adrs&gt;marklogic@yourdomain&lt;/em:adrs&gt;
    &lt;/em:Address&gt;
  &lt;/rf:from&gt;
  &lt;rf:to&gt;
    &lt;em:Address&gt;
      &lt;em:name&gt;System Administrator&lt;/em:name&gt;
      &lt;em:adrs&gt;admin@yourdomain&lt;/em:adrs&gt;
    &lt;/em:Address&gt;
  &lt;/rf:to&gt;
  &lt;em:content&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;
        &lt;title&gt;Test HTML message&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Test HTML message&lt;/h1&gt;
        &lt;p&gt;Here is a simple paragraph&lt;/p&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/em:content&gt;
&lt;/em:Message&gt;)


</example>
    <example xml:space="preserve">
This example demonstrate sending a message with
plain text content.

xdmp:email(
&lt;em:Message
 xmlns:em="URN:ietf:params:email-xml:"
 xmlns:rf="URN:ietf:params:rfc822:"&gt;
  &lt;rf:subject&gt;Sample Plain Text Email&lt;/rf:subject&gt;
  &lt;rf:from&gt;
    &lt;em:Address&gt;
      &lt;em:name&gt;MarkLogic&lt;/em:name&gt;
      &lt;em:adrs&gt;marklogic@yourdomain&lt;/em:adrs&gt;
    &lt;/em:Address&gt;
  &lt;/rf:from&gt;
  &lt;rf:to&gt;
    &lt;em:Address&gt;
      &lt;em:name&gt;System Administrator&lt;/em:name&gt;
      &lt;em:adrs&gt;admin@yourdomain&lt;/em:adrs&gt;
    &lt;/em:Address&gt;
  &lt;/rf:to&gt;
  &lt;em:content xml:space="preserve"&gt;
This is a sample email with a plain text body.
&lt;/em:content&gt;
&lt;/em:Message&gt;)


</example>
    <example xml:space="preserve">
This example demonstrates sending a message with
attachments.

let $newline := "&amp;#13;&amp;#10;"
let $boundary := concat("blah", xdmp:random())
let $content-type := concat("multipart/mixed; boundary=",$boundary)
let $attachment1 := xs:base64Binary(doc("/space/binaries/testdata1/Bon-Jovi.jpeg"))
let $attachment2 := xs:base64Binary(doc("/space/binaries/testdata1/logo.gif"))
let $content := concat(
  "--",$boundary,$newline,
  $newline,
  "This is a test email with two images attached.", $newline,
  "--",$boundary,$newline,
  "Content-Type: image/jpeg", $newline,
  "Content-Disposition: attachment; filename=Bon-Jovi.jpeg", $newline,
  "Content-Transfer-Encoding: base64", $newline,
  $newline,
  $attachment1, $newline,
  "--",$boundary,$newline,
  "Content-Type: image/gif", $newline,
  "Content-Disposition: attachment; filename=logo.gif", $newline,
  "Content-Transfer-Encoding: base64", $newline,
  $newline,
  $attachment2, $newline,
  "--",$boundary,"--", $newline)

return
  xdmp:email(
  &lt;em:Message
    xmlns:em="URN:ietf:params:email-xml:"
    xmlns:rf="URN:ietf:params:rfc822:"&gt;
    &lt;rf:subject&gt;Sample Email&lt;/rf:subject&gt;
    &lt;rf:from&gt;
      &lt;em:Address&gt;
        &lt;em:name&gt;MarkLogic&lt;/em:name&gt;
        &lt;em:adrs&gt;marklogic@yourdomain&lt;/em:adrs&gt;
      &lt;/em:Address&gt;
    &lt;/rf:from&gt;
    &lt;rf:to&gt;
      &lt;em:name&gt;System Administrator&lt;/em:name&gt;
      &lt;em:adrs&gt;admin@yourdomain&lt;/em:adrs&gt;
    &lt;/rf:to&gt;
    &lt;rf:content-type&gt;{$content-type}&lt;/rf:content-type&gt;
    &lt;em:content xml:space="preserve"&gt;
      {$content}
    &lt;/em:content&gt;
  &lt;/em:Message&gt;)


</example>
	</function>
	<function name="word-convert" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:word-convert">
		<summary>Converts a Microsoft Word document to XHTML. Returns several nodes, including a parts node, the converted document xml node, and any other document parts (for example, css files and images). The first node is the parts node, which contains a manefest of all of the parts generated as result of the conversion. Does not convert Microsoft Office 2007 documents.</summary>
		<params>
			<param name="doc" type="node()" optional="false">Microsoft Word document to convert to HTML, as binary node().</param>
			<param name="filename" type="xs:string" optional="false">The root for the name of the converted files and directories. If the specified filename includes an extension, then the extension is appended to the root with an underscore. The directory for other parts of the conversion (images, for example) has the string "_parts" appended to the root. For example, if you specify a filename of "myFile.doc", the generated names will be "myFile_doc.xhtml" for the xml node and "myFile_doc_parts" for the directory containing the any other parts generated by the conversion (images, css files, and so on).</param>
			<param name="options" type="node()?" optional="true">Options element for this conversion. The options element must be in the
				<code>xdmp:word-convert</code>namespace. The default value is (). In addition to the options shown below, you can specify
				<code>xdmp:tidy</code>options by entering the tidy option elements in the
				<code>xdmp:tidy</code>namespace.
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;tidy&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to run tidy on the document and
							<code>false</code>not to run tidy. If you run tidy, you can also specify any
							<a href="#xdmp:tidy">xdmp:tidy options</a>. Any tidy option elements must be in the
							<code>xdmp:tidy</code>namespace.</dd>
						<dt>
							<p>&lt;compact&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to produce "compact" HTML, that is, without style information. The default is
							<code>false</code>.</dd>
						<dt>
							<p>Sample Options Node:</p>
						</dt>
						<dd>The following is a sample options node which specifies that tidy is used to clean the generated html and specifies to use the tidy "clean" option for the conversion:
							<pre xml:space="preserve">
&lt;options xmlns="xdmp:word-convert"
         xmlns:tidy="xdmp:tidy"&gt;
  &lt;tidy&gt;true&lt;/tidy&gt;
  &lt;tidy:clean&gt;yes&lt;/tidy:clean&gt;
&lt;/options&gt;
</pre></dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()*</return>
		<usage>The convert functions return several nodes. The first node is a manifest containing the various parts of the conversion. Typically there will be an xml part, a css part, and some image parts. Each part is returned as a separate node in the order shown in the manifest.
			<p>Therefore, given the following manifest:</p>
			<pre xml:space="preserve">
&lt;parts&gt;
  &lt;part&gt;myFile_doc.xhtml&lt;/part&gt;
  &lt;part&gt;myFile_doc_parts/conv.css&lt;/part&gt;
  &lt;part&gt;myFile_doc_parts/toc.xml&lt;/part&gt;
&lt;/parts&gt;
</pre>
			<p>the first node of the returned query is the manifest, the second is the "myFile_doc.xhtml" node, the third is the "myFile_doc_parts/conv.css" node, and the fourth is the myFile_doc_parts/toc.xml node.</p></usage>
		<example xml:space="preserve">
let $results := xdmp:word-convert(
                         xdmp:document-get("myFile.doc"),
                         "myFile.doc" ),
    $manifest := $results[1]
return
$results[2 to last()]

=&gt; all of the converted nodes
</example>
	</function>
	<function name="excel-convert" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:excel-convert">
		<summary>Converts a Microsoft Excel document to XHTML. Returns several nodes, including a parts node, the converted document xml node, and any other document parts (for example, css files and images). The first node is the parts node, which contains a manefest of all of the parts generated as result of the conversion. Does not convert Microsoft Office 2007 documents.</summary>
		<params>
			<param name="doc" type="node()" optional="false">Microsoft Office Excel document to convert to HTML, as binary node().</param>
			<param name="filename" type="xs:string" optional="false">The root for the name of the converted files and directories. If the specified filename includes an extension, then the extension is appended to the root with an underscore. The directory for other parts of the conversion (images, for example) has the string "_parts" appended to the root. For example, if you specify a filename of "myFile.xls", the generated names will be "myFile_xls.xhtml" for the xml node and "myFile_xls_parts" for the directory containing the any other parts generated by the conversion (images, css files, and so on).</param>
			<param name="options" type="node()?" optional="true">Options element for this conversion. The options element must be in the
				<code>xdmp:excel-convert</code>namespace. The default value is (). In addition to the options shown below, you can specify
				<code>xdmp:tidy</code>options by entering the tidy option elements in the
				<code>xdmp:tidy</code>namespace.
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;tidy&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to run tidy on the document and
							<code>false</code>not to run tidy. If you run tidy, you can also specify an
							<a href="#xdmp:tidy">xdmp:tidy options node</a>.</dd>
						<dt>
							<p>&lt;sheetID&gt;</p>
						</dt>
						<dd>An integer specifying which sheet of the input Excel document to convert. If this option is not set, all sheets are converted.</dd>
						<dt>
							<p>&lt;compact&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to produce "compact" HTML, that is, without style information. The default is
							<code>false</code>.</dd>
						<dt>
							<p>&lt;print-area-only&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to convert only the print area of the sheet.</dd>
						<dt>
							<p>&lt;sheet-by-sheet&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to produce one document for each sheet. The default is
							<code>false</code>.</dd>
						<dt>
							<p>Sample Options Node:</p>
						</dt>
						<dd>The following is a sample options node which specifies that tidy is used to clean the generated html, specifies to use the tidy "clean" option, and specifies to only convert sheet 2 of the document:
							<pre xml:space="preserve">
&lt;options xmlns="xdmp:excel-convert"
         xmlns:tidy="xdmp:tidy"&gt;
  &lt;tidy&gt;true&lt;/tidy&gt;
  &lt;tidy:clean&gt;yes&lt;/tidy:clean&gt;
  &lt;sheetID&gt;2&lt;/sheetID&gt;
&lt;/options&gt;
</pre></dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()*</return>
		<usage>The convert functions return several nodes. The first node is a manifest containing the various parts of the conversion. Typically there will be an xml part, a css part, and some image parts. Each part is returned as a separate node in the order shown in the manifest.
			<p>Therefore, given the following manifest:</p>
			<pre xml:space="preserve">
&lt;parts&gt;
  &lt;part&gt;myFile_xls.xhtml&lt;/part&gt;
  &lt;part&gt;myFile_xls_parts/conv.css&lt;/part&gt;
  &lt;part&gt;myFile_xls_parts/toc.xml&lt;/part&gt;
&lt;/parts&gt;
</pre>
			<p>the first node of the returned query is the manifest, the second is the "myFile_xls.xhtml" node, the third is the "myFile_xls_parts/conv.css" node, and the fourth is the myFile_xls_parts/toc.xml node.</p></usage>
		<example xml:space="preserve">
let $results := xdmp:excel-convert(
                         xdmp:document-get("myFile.xls"),
                         "myFile.xls" ),
    $manifest := $results[1]
return
$results[2 to last()]

=&gt; all of the converted nodes
</example>
	</function>
	<function name="powerpoint-convert" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:powerpoint-convert">
		<summary>Converts a Microsoft Powerpoint document to XHTML. Returns several nodes, including a parts node, the converted document xml node, and any other document parts (for example, css files and images). The first node is the parts node, which contains a manefest of all of the parts generated as result of the conversion. Does not convert Microsoft Office 2007 documents.</summary>
		<params>
			<param name="doc" type="node()" optional="false">Microsoft Powerpoint document to convert to HTML, as binary node().</param>
			<param name="filename" type="xs:string" optional="false">The root for the name of the converted files and directories. If the specified filename includes an extension, then the extension is appended to the root with an underscore. The directory for other parts of the conversion (images, for example) has the string "_parts" appended to the root. For example, if you specify a filename of "myFile.ppt", the generated names will be "myFile_ppt.xhtml" for the xml node and "myFile_ppt_parts" for the directory containing the any other parts generated by the conversion (images, css files, and so on).</param>
			<param name="options" type="node()?" optional="true">Options element for this conversion. The options element must be in the
				<code>xdmp:powerpoint-convert</code>namespace. The default value is (). In addition to the options shown below, you can specify
				<code>xdmp:tidy</code>options by entering the tidy option elements in the
				<code>xdmp:tidy</code>namespace.
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;tidy&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to run tidy on the document and
							<code>false</code>not to run tidy. If you run tidy, you can also specify an
							<a href="#xdmp:tidy">xdmp:tidy options node</a>.</dd>
						<dt>
							<p>&lt;compact&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to produce "compact" HTML, that is, without style information. The default is
							<code>false</code>.</dd>
						<dt>
							<p>&lt;slideID&gt;</p>
						</dt>
						<dd>An integer specifying which slide of the input Powerpoint document to convert. If this option is not set, all slides are converted.</dd>
						<dt>
							<p>&lt;slide-by-slide&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to produce one document for each slide. The default is
							<code>false</code>.</dd>
						<dt>
							<p>&lt;speaker-notes&gt;</p>
						</dt>
						<dd>Specify
							<code>true</code>to include speaker notes in the output. The default is
							<code>false</code>.</dd>
						<dt>
							<p>Sample Options Node:</p>
						</dt>
						<dd>The following is a sample options node which specifies that tidy is used to clean the generated html, specifies to use the tidy "clean" option, and specifies to only convert the second slide of the document:
							<pre xml:space="preserve">
&lt;options xmlns="xdmp:powerpoint-convert"
         xmlns:tidy="xdmp:tidy"&gt;
  &lt;tidy&gt;true&lt;/tidy&gt;
  &lt;tidy:clean&gt;yes&lt;/tidy:clean&gt;
  &lt;slideID&gt;2&lt;/slideID&gt;
&lt;/options&gt;
</pre></dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()*</return>
		<usage>The convert functions return several nodes. The first node is a manifest containing the various parts of the conversion. Typically there will be an xml part, a css part, and some image parts. Each part is returned as a separate node in the order shown in the manifest.
			<p>Therefore, given the following manifest:</p>
			<pre xml:space="preserve">
&lt;parts&gt;
  &lt;part&gt;myFile_ppt.xhtml&lt;/part&gt;
  &lt;part&gt;myFile_ppt_parts/conv.css&lt;/part&gt;
  &lt;part&gt;myFile_ppt_parts/toc.xml&lt;/part&gt;
&lt;/parts&gt;
</pre>
			<p>the first node of the returned query is the manifest, the second is the "myFile_ppt.xhtml" node, the third is the "myFile_ppt_parts/conv.css" node, and the fourth is the myFile_ppt_parts/toc.xml node.</p></usage>
		<example xml:space="preserve">
let $results := xdmp:powerpoint-convert(
                         xdmp:document-get("myFile.ppt"),
                         "myFile.ppt" ),
    $manifest := $results[1]
return
$results[2 to last()]

=&gt; all of the converted nodes
</example>
	</function>
	<function name="to-json" type="builtin" lib="xdmp" category="Extension" subcategory="JSON" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:to-json">
		<summary>Returns a string representing a JSON serialization of a given item sequence.</summary>
		<params>
			<param name="item" type="item()*" optional="false">The item sequence whose JSON serialization is returned.</param>
		</params>
		<return>xs:string</return>
		<usage>
			<p>XML nodes are serialized to JSON strings.</p>
			<p>JSON has no serialization for infinity, not a number, and negative 0, therefore if you try and serialize INF, -INF, NaN, or -0 as JSON, an exception is thrown. If you want to represent these values in some way in your serialized JSON, then you can catch the exception (with a try/catch, for example) and provide your own value for it.</p>
			<p>XQuery maps (
				<code>map:map</code>types) serialize to JSON name-value pairs.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:to-json(("a",fn:false()))
   =&gt; ["a", false]
</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

xdmp:to-json(
    xdmp:from-json('
        { "a":111 }
     ')
)

=&gt;

{"a":111}
</example>
	</function>
	<function name="from-json" type="builtin" lib="xdmp" category="Extension" subcategory="JSON" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:from-json">
		<summary>Parses a string as JSON, returning an item sequence.</summary>
		<params>
			<param name="arg" type="xs:string" optional="false">JSON input to be parsed.</param>
		</params>
		<return>item()*</return>
		<usage>
			<p>JSON objects are parsed as maps.</p>
			<p>The JSON null value is represented as the empty sequence.</p>
			<p>Nested arrays in JSON are flattened out.</p>
			<p>Any codepoints in the JSON string that aren't allowed in XML are rejected and an error is thrown.</p>
		</usage>
		<example xml:space="preserve">
  xdmp:from-json('["a", false]')
  =&gt; ("a", fn:false())

</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

let $json :=
  '[{"some-key":45683}, "this is a string", 123]'
return
xdmp:from-json($json)

=&gt;

map:map(
 &lt;map:map xmlns:xs="http://www.w3.org/2001/XMLSchema"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:map="http://marklogic.com/xdmp/map"&gt;
   &lt;map:entry key="some-key"&gt;
     &lt;map:value xsi:type="xs:integer"&gt;45683&lt;/map:value&gt;
   &lt;/map:entry&gt;
 &lt;/map:map&gt;)
this is a string
123

Note that what is shown above is the serialization of the XQuery items.
You can also use some or all of the items in the XQuery data model.
For example, consider the following, which adds to the map based on the
other values:

xquery version "1.0-ml";
let $json :=
  '[{"some-key":45683}, "this is a string", 123]'
let $items := xdmp:from-json($json)
let $put := map:put($items[1], xs:string($items[3]), $items[2])
return
$items[1]

(: returns the following map:
map:map(
 &lt;map:map xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:map="http://marklogic.com/xdmp/map"&gt;
    &lt;map:entry key="123"&gt;
       &lt;map:value xsi:type="xs:string"&gt;this is a string&lt;/map:value&gt;
    &lt;/map:entry&gt;
    &lt;map:entry key="some-key"&gt;
      &lt;map:value xsi:type="xs:integer"&gt;45683&lt;/map:value&gt;
    &lt;/map:entry&gt;
 &lt;/map:map&gt;)
:)

In the above query, the first item ($items[1]) returned from the
xdmp:from-json call is a map, and the map is then modified, and then
the modified map is returned.
</example>
	</function>
	<function name="zip-manifest" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:zip-manifest">
		<summary>Return a manifest for this zip file. The manifest contains information about what is in the zip file. The form of the manifest is:
			<pre xml:space="preserve">
  &lt;parts xmlns="xdmp:zip"&gt;
    &lt;part uncompressed-size="[size]" compressed-size="[size]"
          encrypted="[true/false]"&gt;path1&lt;/part&gt;
    &lt;part uncompressed-size="[size]" compressed-size="[size]"
          encrypted="[true/false]"&gt;path2&lt;/part&gt;
    ...more parts
  &lt;/parts&gt;
</pre>Each &lt;part&gt; is a file within the zip. The attributes specify the uncompressed size for the file, the compressed size for that file, whether or not the file is encrypted, and the last-modified timestamp. Note that MarkLogic cannot exctract encrypted files, attempting to do so will cause an error. Also note that due to a limitation in the zip file format, the last-modified time has a granularity of two seconds (e.g. 10:22:33 becomes 10:22:32).</summary>
		<params>
			<param name="zipfile" type="binary()" optional="false">The zip document binary node.</param>
		</params>
		<return>node()</return>
		<example xml:space="preserve">
xdmp:zip-manifest($myzip)
=&gt;
&lt;parts&gt;
  &lt;part uncompressed-size="89246" compressed-size="4538"
        encrypted="no" last-modified="2009-03-20T03:30:32"&gt;
    docProps/app.xml
  &lt;/part&gt;
  &lt;part uncompressed-size="2896" compressed-size="634"
        encrypted="no" last-modified="2009-03-23T19:30:32"&gt;
    word/fontTable.xml
  &lt;/part&gt;
  &lt;part uncompressed-size="139914" compressed-size="12418"
        encrypted="yes" last-modified="2009-03-23T15:30:32"&gt;
    word/styles.xml
  &lt;/part&gt;
&lt;/parts&gt;


</example>
		<algorithm />
	</function>
	<function name="zip-get" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:zip-get">
		<summary>Get a named file from a zip document. Unzips and returns the file in memory as a document node (for XML formats), a text node (for text formats), or a binary node (for binary formats). The format is determined either by the mimetype from the file name or by the
			<code>format</code>option.</summary>
		<params>
			<param name="zipfile" type="binary()" optional="false">The zip file.</param>
			<param name="name" type="xs:string" optional="false">The path to the zip file as shown in the zip manifest.</param>
			<param name="options" type="node()?" optional="true">The options node for gitting this zip file. The default value is (). The node for the xdmp:zip-get options must be in the
				<code>xdmp:zip-get</code>namespace.
				<p>The
					<code>xdmp:zip-get</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;default-namespace&gt;</p>
						</dt>
						<dd>The namespace to use if there is no namespace at the root node of the document. The default value is "".</dd>
						<dt>
							<p>&lt;repair&gt;</p>
						</dt>
						<dd>A value of
							<code>full</code>specifies that malformed XML content be repaired. A value of
							<code>none</code>specifies that malformed XML content is rejected. If no repair option is explicitly specified, the default is implicitly specified by the XQuery version of the caller. In XQuery
							<code>1.0</code>and
							<code>1.0-ml</code>the default is
							<code>none</code>. In XQuery
							<code>0.9-ml</code>the default is
							<code>full</code>. This option has no effect on binary or text documents.</dd>
						<dt>
							<p>&lt;format&gt;</p>
						</dt>
						<dd>A value of
							<code>text</code>specifies to get the document as a text document, regardless of the URI specified. A value of
							<code>binary</code>specifies to get the document as a binary document, regardless of the URI specified. A value of
							<code>xml</code>specifies to get the document as an XML document, regardless of the URI specified.</dd>
						<dt>
							<p>&lt;default-language&gt;</p>
						</dt>
						<dd>The language to specify in an
							<code>xml:lang</code>attribute on the root element node if the root element node does not already have an
							<code>xml:lang</code>attribute. If
							<code>default-language</code>is not specified, then nothing is added to the root element node.</dd>
						<dt>
							<p>&lt;encoding&gt;</p>
						</dt>
						<dd>Specifies the encoding to use when reading the document into MarkLogic Server. Supported values include
							<code>UTF-8</code>and
							<code>ISO-8859-1</code>. All encodings will be translated into UTF-8 from the specified encoding. The string specifed for the
							<code>encoding</code>option will be matched to an encoding name according to the Unicode Charset Alias Matching rules (
							<a href="http://www.unicode.org/reports/tr22/#Charset_Alias_Matching">http://www.unicode.org/reports/tr22/#Charset_Alias_Matching</a>). An automatic encoding detector will be used if the value
							<code>auto</code>is specified. If no encoding can be detected, the encoding defaults to UTF-8. If no encoding option is specified, the encoding defaults to the encoding specified in the http header (if using with one of the http functions, for example,
							<code>xdmp:http-get</code>), otherwise it defaults to UTF-8; any encoding http headers are ignored if there is any value specified for the
							<code>encoding</code>option.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()+</return>
		<usage>
			<p>The name of the document you are extracting will determine the default format in which the document is extracted, based on the mimetype settings. For example, if you are extracting a document with the name
				<code>myDocument.xmlfile</code>, it will by default extract that document as a text document (because it is an unknown mimetype, and unknown mimetypes default to text format). If you know this is an XML document, then specify a
				<code>format</code>of
				<code>xml</code>in the
				<code>options</code>node (see the
				<a href="#zipget3">third example</a>below).</p>
		</usage>
		<example xml:space="preserve">
xdmp:zip-get(doc("/zip/tmp.zip"), "files/myxmlfile.xml")

=&gt; the "files/myxmlfile.xml" node from the "/zip/tmp.zip" zip file


</example>
    <example xml:space="preserve">
(: unzip all of the files in the zip archive :)
xquery version "1.0-ml";
declare namespace zip="xdmp:zip";

for $x in xdmp:zip-manifest(doc("/zip/tmp.zip"))//zip:part/text()
return
xdmp:zip-get(doc("/zip/tmp.zip"), $x)

=&gt; a sequence of all of the unzipped nodes in the "/zip/tmp.zip" zip file


</example>
    <example xml:space="preserve">
xdmp:zip-get(doc("/zip/tmp.zip"), "myDocument.xmlfile",
	&lt;options xmlns="xdmp:zip-get"&gt;
	  &lt;format&gt;xml&lt;/format&gt;
	&lt;/options&gt;)

=&gt; the "myDocument.xmlfile" node from the "/zip/tmp.zip"
   zip file, as an XML document


</example>
		<algorithm />
	</function>
	<function name="zip-create" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:zip-create">
		<summary>Create a zip file from a list of nodes.</summary>
		<params>
			<param name="manifest" type="node()" optional="false">The zip manifest, which must be in the
				<code>xdmp:zip</code>namespace and conform to the
				<code>zip.xsd</code>schema, located in the
				<code>
					<em>marklogic-dir</em>/Schemas</code>directory. The manifest has the following basic form:
				<blockquote>
					<pre xml:space="preserve">
    &lt;parts xmlns="xdmp:zip"&gt;
      &lt;part last-modified="2009-03-23T19:30:32"&gt;path1&lt;/part&gt;
      &lt;part&gt;path2&lt;/part&gt;
      ...more parts
    &lt;/parts&gt;
</pre>
				</blockquote>Any of the size or encrypted attributes in the manifest are ignored for
				<code>xdmp:zip-create</code>. Attributes other than uncompressed-size, compressed-size, encrypted, and last-modified will throw an error. If the last-modified attribute is specified, that date and time will be set for the part. Otherwise, if the node for the part comes from a database that tracks the last modified time of a document, that date and time will be used. The current date and time will be used if no other value is available. Due to a limitation in the zip file format, the time has a granularity of two seconds (e.g. 10:22:33 becomes 10:22:32).</param>
			<param name="nodes" type="node()+" optional="false">The nodes that you want to zip up. The nodes correspond to
				<code>part</code>elements in the manifest, where the first node corresponds to the first
				<code>part</code>element specified, the second node to the second
				<code>part</code>element, and so on. Specifying a different number of &lt;part&gt; elements than nodes will result in an error.</param>
		</params>
		<return>binary()</return>
		<usage>
			<p>While you can create a zip file of encrypted content,
				<code>xdmp:zip-create</code>does not have the capability to encrypt the content to be zipped.</p>
			<p>The
				<code>&lt;part&gt;</code>elements in the manifest should contain relative paths so the zip file can be unpacked into its own directory; do not start the path with a forward slash or a backslash.</p>
			<p>To support creating Open Container Format archives for the EPUB format,
				<code>xdmp:zip-create</code>will not compress the first part if it is named "mimetype".</p>
		</usage>
		<example xml:space="preserve">
let $zip := xdmp:zip-create(
               &lt;parts xmlns="xdmp:zip"&gt;
                 &lt;part&gt;mydoc.xml&lt;/part&gt;
	        &lt;part&gt;mypicture.jpg&lt;/part&gt;
	        &lt;/parts&gt;,
	       (doc("/mydoc.xml"), doc("/mypicture.jpg")))
return
xdmp:save("c:/tmp/myzip.zip", $zip,
     &lt;options xmlns="xdmp:save"&gt;
        &lt;encoding&gt;utf8&lt;/encoding&gt;
     &lt;/options&gt;)

=&gt; Creates a zip archive that includes the documents "/mydoc.xml"
   and "/mypicture.jpg", then saves that to the filesystem.


</example>
    <example xml:space="preserve">
(: the "mimetype" file will not be compressed to support
   the EPUB format :)
let $zip := xdmp:zip-create(
               &lt;parts xmlns="xdmp:zip"&gt;
                 &lt;part&gt;mimetype&lt;/part&gt;
	        &lt;part&gt;META-INF/container.xml&lt;/part&gt;
	        &lt;part&gt;OEBPS/content.opf&lt;/part&gt;
	        &lt;part&gt;OEBPS/content.pdf&lt;/part&gt;
	        &lt;/parts&gt;,
	       (document { "application/epub+zip" },
                 doc("/my-doc/container.xml"),
                 doc("/my-doc/content.opf"),
                 doc("/my-doc/content.pdf")
                 ))
return
xdmp:save("c:/tmp/mydoc.epub", $zip,
     &lt;options xmlns="xdmp:save"&gt;
        &lt;encoding&gt;utf8&lt;/encoding&gt;
     &lt;/options&gt;)

=&gt; Creates a zip archive that meets the OCF specification,
   then saves that to the filesystem.


</example>
	</function>
	<function name="gzip" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:gzip">
		<summary>Create a gzip node from a node.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node that you want to gzip up.</param>
		</params>
		<return>binary()</return>
		<example xml:space="preserve">
let $gzip := xdmp:gzip(doc("/mydoc.xml"))
return
xdmp:save("c:/tmp/myzip.gz", $gzip)

=&gt; Creates a gzip node from the document "/mydoc.xml", then
   saves that to the filesystem.


</example>
	</function>
	<function name="gunzip" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:gunzip">
		<summary>Get a node from a gzip node. Gunzips and returns the file in memory as a document node (for XML formats), a text node (for text formats), or a binary node (for binary formats). The format is determined by the
			<code>format</code>option.</summary>
		<params>
			<param name="gzipnode" type="binary()" optional="false">The gzip node.</param>
			<param name="options" type="node()?" optional="false">The options node for gunzipping this gzip node. The node for the xdmp:gunzip options must be in the
				<code>xdmp:zip-get</code>namespace.
				<p>The
					<code>xdmp:gunzip</code>options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;default-namespace&gt;</p>
						</dt>
						<dd>The namespace to use if there is no namespace at the root node of the document. The default value is "".</dd>
						<dt>
							<p>&lt;repair&gt;</p>
						</dt>
						<dd>A value of
							<code>full</code>specifies that malformed XML content be repaired. A value of
							<code>none</code>specifies that malformed XML content is rejected. If no repair option is explicitly specified, the default is implicitly specified by the XQuery version of the caller. In XQuery
							<code>1.0</code>and
							<code>1.0-ml</code>the default is
							<code>none</code>. In XQuery
							<code>0.9-ml</code>the default is
							<code>full</code>. This option has no effect on binary or text documents.</dd>
						<dt>
							<p>&lt;format&gt;</p>
						</dt>
						<dd>A value of
							<code>text</code>specifies to get the document as a text document, regardless of the URI specified. A value of
							<code>binary</code>specifies to get the document as a binary document, regardless of the URI specified. A value of
							<code>xml</code>specifies to get the document as an XML document, regardless of the URI specified.</dd>
						<dt>
							<p>&lt;default-language&gt;</p>
						</dt>
						<dd>The language to specify in an
							<code>xml:lang</code>attribute on the root element node if the root element node does not already have an
							<code>xml:lang</code>attribute. If
							<code>default-language</code>is not specified, then nothing is added to the root element node.</dd>
						<dt>
							<p>&lt;encoding&gt;</p>
						</dt>
						<dd>Specifies the encoding to use when reading the document into MarkLogic Server. Supported values include
							<code>UTF-8</code>and
							<code>ISO-8859-1</code>. All encodings will be translated into UTF-8 from the specified encoding. The string specified for the
							<code>encoding</code>option will be matched to an encoding name according to the Unicode Charset Alias Matching rules (
							<a href="http://www.unicode.org/reports/tr22/#Charset_Alias_Matching">http: //www.unicode.org/reports/tr22/#Charset_Alias_Matching</a>). An automatic encoding detector will be used if the value
							<code>auto</code>is specified. If no encoding can be detected, the encoding defaults to UTF-8. If no encoding option is specified, the encoding defaults to the encoding specified in the http header (if using with one of the http functions, for example,
							<code>xdmp:http-get</code>), otherwise it defaults to UTF-8; any encoding http headers are ignored if there is any value specified for the
							<code>encoding</code>option.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()+</return>
		<usage>
			<p>You must tell the format of the node after gunzipping. You need to specify a
				<code>format</code>in the
				<code>options</code>node</p>
		</usage>
		<example xml:space="preserve">
xdmp:gunzip(doc("/gzip/tmp.gz"),
  &lt;options xmlns="xdmp:zip-get"&gt;
    &lt;format&gt;xml&lt;/format&gt;
  &lt;/options&gt;)

=&gt; the gunzip node from the "/gzip/tmp.gz" gzip node


</example>
		<algorithm />
	</function>
	<function name="x509-certificate-extract" type="builtin" lib="xdmp" category="AppServerBuiltins" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:x509-certificate-extract">
		<summary>Returns the XML representation of the specified X.509 certificate.</summary>
		<params>
			<param name="cert" type="xs:string" optional="false">The PEM encoded certificate.</param>
		</params>
		<return>An XML representation of the certificate.</return>
		<example xml:space="preserve">
xquery version "1.0-ml";

let $cert := "-----BEGIN CERTIFICATE-----
MIID4DCCA0mgAwIBAgIJAIp4RM8+Lkr3MA0GCSqGSIb3DQEBBQUAMIGnMQswCQYD
VQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTETMBEGA1UEBxMKU2FuIENhcmxv
czETMBEGA1UEChMKTWFyayBMb2dpYzEUMBIGA1UECxMLRW5naW5lZXJpbmcxHjAc
BgNVBAMTFUNlcnRpZmljYXRlIEF1dGhvcml0eTEjMCEGCSqGSIb3DQEJARYUd2Zl
aWNrQG1hcmtsb2dpYy5jb20wHhcNMDgxMjAzMDEyNzQ5WhcNMDkxMjAzMDEyNzQ5
WjCBpzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEzARBgNVBAcT
ClNhbiBDYXJsb3MxEzARBgNVBAoTCk1hcmsgTG9naWMxFDASBgNVBAsTC0VuZ2lu
ZWVyaW5nMR4wHAYDVQQDExVDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxIzAhBgkqhkiG
9w0BCQEWFHdmZWlja0BtYXJrbG9naWMuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GN
ADCBiQKBgQDnauIbA33nIH8IpiUyWA9sB/X3d8DU8cKbEes1dk6xX3mFfMWja56D
vkPFaX9/voSbeG1E92d2Y518xvjgoR8okf2rkDI35nqA9ejcuC0wg0tXuh5OSVfr
UpzVSwbCy55fweaVzkKC2TZXgOy5JeNbw+i/UohTLW2TPwQ4rpynPwIDAQABo4IB
EDCCAQwwHQYDVR0OBBYEFLY2z4PX7fWY47gRhGpVJBIJpufYMIHcBgNVHSMEgdQw
gdGAFLY2z4PX7fWY47gRhGpVJBIJpufYoYGtpIGqMIGnMQswCQYDVQQGEwJVUzET
MBEGA1UECBMKQ2FsaWZvcm5pYTETMBEGA1UEBxMKU2FuIENhcmxvczETMBEGA1UE
ChMKTWFyayBMb2dpYzEUMBIGA1UECxMLRW5naW5lZXJpbmcxHjAcBgNVBAMTFUNl
cnRpZmljYXRlIEF1dGhvcml0eTEjMCEGCSqGSIb3DQEJARYUd2ZlaWNrQG1hcmts
b2dpYy5jb22CCQCKeETPPi5K9zAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUA
A4GBAA8/lJQK6NmHFvP85LS3Sdfnd9D9opDeehqv4LfoFWxHMiKsxSA7hrYRs6u9
qQxCED54UfB1+kjs2GrM4H1uWeeHADdUKDRVHcivCVqWP4GUD2r0upKj8C3UD46V
aNHLW0yW7Anf4DMBsfhvKfIopBDoP6NPbDith5RtmM98N8xn
-----END CERTIFICATE-----"

return xdmp:x509-certificate-extract($cert)

=&gt;

&lt;cert&gt;
  &lt;version&gt;2&lt;/version&gt;
  &lt;serialNumber&gt;8A7844CF3E2E4AF7&lt;/serialNumber&gt;
  &lt;signatureType&gt;sha1WithRSAEncryption&lt;/signatureType&gt;
  &lt;issuer&gt;
    &lt;countryName&gt;US&lt;/countryName&gt;
    &lt;stateOrProvinceName&gt;California&lt;/stateOrProvinceName&gt;
    &lt;localityName&gt;San Carlos&lt;/localityName&gt;
    &lt;organizationName&gt;MarkLogic&lt;/organizationName&gt;
    &lt;organizationalUnitName&gt;Engineering&lt;/organizationalUnitName&gt;
    &lt;commonName&gt;Certificate Authority&lt;/commonName&gt;
    &lt;emailAddress&gt;me@marklogic.com&lt;/emailAddress&gt;
  &lt;/issuer&gt;
  &lt;validity&gt;
    &lt;notBefore&gt;2008-12-03T01:27:49Z&lt;/notBefore&gt;
    &lt;notAfter&gt;2009-12-03T01:27:49Z&lt;/notAfter&gt;
  &lt;/validity&gt;
  &lt;subject&gt;
    &lt;countryName&gt;US&lt;/countryName&gt;
    &lt;stateOrProvinceName&gt;California&lt;/stateOrProvinceName&gt;
    &lt;localityName&gt;San Carlos&lt;/localityName&gt;
    &lt;organizationName&gt;MarkLogic&lt;/organizationName&gt;
    &lt;organizationalUnitName&gt;Engineering&lt;/organizationalUnitName&gt;
    &lt;commonName&gt;Certificate Authority&lt;/commonName&gt;
    &lt;emailAddress&gt;me@marklogic.com&lt;/emailAddress&gt;
  &lt;/subject&gt;
  &lt;publicKey&gt;-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDnauIbA33nIH8IpiUyWA9sB/X3
d8DU8cKbEes1dk6xX3mFfMWja56DvkPFaX9/voSbeG1E92d2Y518xvjgoR8okf2r
kDI35nqA9ejcuC0wg0tXuh5OSVfrUpzVSwbCy55fweaVzkKC2TZXgOy5JeNbw+i/
UohTLW2TPwQ4rpynPwIDAQAB
-----END PUBLIC KEY-----
&lt;/publicKey&gt;
  &lt;v3ext&gt;
    &lt;subjectKeyIdentifier critical="false"&gt;B6:36:CF:83:D7:ED:F5:98:E3:B8:11:84:6A:55:24:12:09:A6:E7:D8&lt;/subjectKeyIdentifier&gt;
    &lt;authorityKeyIdentifier critical="false"&gt;keyid:B6:36:CF:83:D7:ED:F5:98:E3:B8:11:84:6A:55:24:12:09:A6:E7:D8
DirName:/C=US/ST=California/L=San Carlos/O=MarkLogic/OU=Engineering/CN=Certificate Authority/emailAddress=me@marklogic.com
serial:8A:78:44:CF:3E:2E:4A:F7
&lt;/authorityKeyIdentifier&gt;
    &lt;basicConstraints critical="false"&gt;CA:TRUE&lt;/basicConstraints&gt;
  &lt;/v3ext&gt;
&lt;/cert&gt;


</example>
		<algorithm />
	</function>
	<function name="md5" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:md5">
		<summary>Calculates the md5 hash of the given argument.</summary>
		<params>
			<param name="data" type="item()" optional="false">Data to be hashed. Must be xs:string or a binary node.</param>
			<param name="encoding" type="xs:string" optional="true">Encoding format for the output string, must be "hex" for hexadecimal or "base64". Default is "hex".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:md5("foo")
  =&gt; "acbd18db4cc2f85cedef654fccc4a4d8"

</example>
    <example xml:space="preserve">
  xdmp:md5("foo", "base64")
  =&gt; "rL0Y20zC+Fzt72VPzMSk2A=="

</example>
	</function>
	<function name="hmac-md5" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:hmac-md5">
		<summary>Calculates the Hash-based Message Authentication Code (HMAC) using the md5 hash function of the given secret key and message arguments.</summary>
		<params>
			<param name="secretkey" type="item()" optional="false">The secret key. Must be xs:string or a binary node.</param>
			<param name="message" type="item()" optional="false">Message to be authenticated. Must be xs:string or a binary node.</param>
			<param name="encoding" type="xs:string" optional="true">Encoding format for the output string, must be "hex" for hexadecimal or "base64". Default is "hex".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:hmac-md5("foo", "bar")
  =&gt; "0c7a250281315ab863549f66cd8a3a53"

</example>
    <example xml:space="preserve">
  xdmp:hmac-md5("foo", "bar", "base64")
  =&gt; "DHolAoExWrhjVJ9mzYo6Uw=="

</example>
	</function>
	<function name="sha1" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:sha1">
		<summary>Calculates the SHA1 hash of the given argument.</summary>
		<params>
			<param name="data" type="item()" optional="false">Data to be hashed. Must be xs:string or a binary node.</param>
			<param name="encoding" type="xs:string" optional="true">Encoding format for the output string, must be "hex" for hexadecimal or "base64". Default is "hex".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:sha1("foo")
  =&gt; "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"

</example>
    <example xml:space="preserve">
  xdmp:sha1("foo", "base64")
  =&gt; "C+7Hteo/D9vJXQ3UfzxbwnXaijM="

</example>
	</function>
	<function name="hmac-sha1" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:hmac-sha1">
		<summary>Calculates the Hash-based Message Authentication Code (HMAC) using the SHA1 hash function of the given secret key and message arguments.</summary>
		<params>
			<param name="secretkey" type="item()" optional="false">The secret key. Must be xs:string or a binary node.</param>
			<param name="message" type="xs:string" optional="false">Message to be authenticated.</param>
			<param name="encoding" type="xs:string" optional="true">Encoding format for the output string, must be "hex" for hexadecimal or "base64". Default is "hex".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:hmac-sha1("foo", "bar")
  =&gt; "46b4ec586117154dacd49d664e5d63fdc88efb51"

</example>
    <example xml:space="preserve">
  xdmp:hmac-sha1("foo", "bar", "base64")
  =&gt; "RrTsWGEXFU2s1J1mTl1j/ciO+1E="

</example>
	</function>
	<function name="sha256" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:sha256">
		<summary>Calculates the SHA256 hash of the given argument.</summary>
		<params>
			<param name="data" type="item()" optional="false">Data to be hashed. Must be xs:string or a binary node.</param>
			<param name="encoding" type="xs:string" optional="true">Encoding format for the output string, must be "hex" for hexadecimal or "base64". Default is "hex".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:sha256("foo")
  =&gt; "2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"

</example>
    <example xml:space="preserve">
  xdmp:sha256("foo", "base64")
  =&gt; "LCa0a2j/xo/5m0U8HTBBNBNCLXBkg7+g+YpeiGJm564="

</example>
	</function>
	<function name="hmac-sha256" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:hmac-sha256">
		<summary>Calculates the Hash-based Message Authentication Code (HMAC) using the SHA256 hash function of the given secret key and message arguments.</summary>
		<params>
			<param name="secretkey" type="item()" optional="false">The secret key. Must be xs:string or a binary node.</param>
			<param name="message" type="item()" optional="false">Message to be authenticated. Must be xs:string or a binary node.</param>
			<param name="encoding" type="xs:string" optional="true">Encoding format for the output string, must be "hex" for hexadecimal or "base64". Default is "hex".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:hmac-sha256("foo", "bar")
  =&gt; "f9320baf0249169e73850cd6156ded0106e2bb6ad8cab01b7bbbebe6d1065317"

</example>
    <example xml:space="preserve">
  xdmp:hmac-sha256("foo", "bar", "base64")
  =&gt; "+TILrwJJFp5zhQzWFW3tAQbiu2rYyrAbe7vr5tEGUxc="

</example>
	</function>
	<function name="sha512" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:sha512">
		<summary>Calculates the SHA512 hash of the given argument.</summary>
		<params>
			<param name="data" type="item()" optional="false">Data to be hashed. Must be xs:string or a binary node.</param>
			<param name="encoding" type="xs:string" optional="true">Encoding format for the output string, must be "hex" for hexadecimal or "base64". Default is "hex".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:sha512("foo")
  =&gt; "f7fbba6e0636f890e56fbbf3283e524c6fa3204ae298382d624741d0dc6638326e\
      282c41be5e4254d8820772c5518a2c5a8c0c7f7eda19594a7eb539453e1ed7"

</example>
    <example xml:space="preserve">
  xdmp:sha512("foo", "base64")
  =&gt; "9/u6bgY2+JDlb7vzKD5STG+jIErimDgtYkdB0NxmODJuKCxBvl5CVNiCB3LFUYos\
      WowMf37aGVlKfrU5RT4e1w=="

</example>
	</function>
	<function name="hmac-sha512" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:hmac-sha512">
		<summary>Calculates the Hash-based Message Authentication Code (HMAC) using the SHA512 hash function of the given secret key and message arguments.</summary>
		<params>
			<param name="secretkey" type="item()" optional="false">The secret key. Must be xs:string or a binary node.</param>
			<param name="message" type="item()" optional="false">Message to be authenticated. Must be xs:string or a binary node.</param>
			<param name="encoding" type="xs:string" optional="true">Encoding format for the output string, must be "hex" for hexadecimal or "base64". Default is "hex".</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xdmp:hmac-sha512("foo", "bar")
  =&gt; "114682914c5d017dfe59fdc804118b56a3a652a0b8870759cf9e792ed7426b08197076\
      bf7d01640b1b0684df79e4b67e37485669e8ce98dbab60445f0db94fce"

</example>
    <example xml:space="preserve">
  xdmp:hmac-sha512("foo", "bar", "base64")
  =&gt; "EUaCkUxdAX3+Wf3IBBGLVqOmUqC4hwdZz555LtdCawgZcHa/fQFkCxsGhN955LZ\
      +N0hWaejOmNurYERfDblPzg=="

</example>
	</function>
	<function name="pdf-convert" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:pdf-convert">
		<summary>Converts a PDF file to XHTML. Returns several nodes, including a parts node, the converted document xml node, and any other document parts (for example, css files and images). The first node is the parts node, which contains a manefest of all of the parts generated as result of the conversion.</summary>
		<params>
			<param name="doc" type="node()" optional="false">PDF document to convert to HTML, as a binary node().</param>
			<param name="filename" type="xs:string" optional="false">The root for the name of the converted files and directories. If the specified filename includes an extension, then the extension is appended to the root with an underscore. The directory for other parts of the conversion (images, for example) has the string "_parts" appended to the root. For example, if you specify a filename of "myFile.pdf", the generated names will be "myFile_pdf.xhtml" for the xml node and "myFile_pdf_parts" for the directory containing the any other parts generated by the conversion (images, css files, and so on).</param>
			<param name="options" type="node()?" optional="true">Options element for this conversion. The options element must be in the
				<code>xdmp:pdf-convert</code>namespace. The default value is (). In addition to the options shown below, you can specify
				<code>xdmp:tidy</code>options by entering the tidy option elements in the
				<code>xdmp:tidy</code>namespace.
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>
							<p>&lt;tidy&gt;</p>
						</dt>
						<dd>Default value:
							<code>true</code>
							<br />
							<br />Specify
							<code>true</code>to run tidy on the document and
							<code>false</code>not to run tidy. If you run tidy, you can also specify any
							<a href="xdmp:tidy">xdmp:tidy options</a>. Any tidy option elements must be in the
							<code>xdmp:tidy</code>namespace.</dd>
						<dt>
							<p>&lt;config&gt;</p>
						</dt>
						<dd>The configuration file for the conversion. You can specify an absolute path or a relative path. The relative path is relative to the
							<code>&lt;install_dir&gt;/Converters/cvtpdf</code>directory. The default configuration file is named
							<code>PDFtoHTML.cfg</code>; it produces a single reflowed XHTML document with CSS styling. Setting this parameter may override the remaining options.</dd>
						<dt>
							<p>&lt;page-by-page&gt;</p>
						</dt>
						<dd>Default value:
							<code>false</code>
							<br />
							<br />Specify
							<code>true</code>to select a different default configuration file that produces one XHTML document per page with absolute positioning. The default paged configuration file is named
							<code>PDFtoXHTML_pages.cfg</code>If a specific configuration file is selected with the
							<code>config</code>option, the
							<code>page-by-page</code>option has no effect.</dd>
						<dt>
							<p>&lt;page-start-id&gt;</p>
						</dt>
						<dd>Default value:
							<code>0</code>
							<br />
							<br />The index of the first page to convert. Page indices start at zero.</dd>
						<dt>
							<p>&lt;page-end-id&gt;</p>
						</dt>
						<dd>Default value:
							<code>-1</code>
							<br />
							<br />The index of the last page to convert. Page indices start at zero. The default is -1, meaning to convert through the last page of the document.</dd>
						<dt>
							<p>&lt;synth-bookmarks&gt;</p>
						</dt>
						<dd>Default value:
							<code>true</code>
							<br />
							<br />Enable/disable converter's internal font-based TOC inferences.</dd>
						<dt>
							<p>&lt;image-output&gt;</p>
						</dt>
						<dd>Default value:
							<code>true</code>
							<br />
							<br />Enable/disable extraction and conversion of images.</dd>
						<dt>
							<p>&lt;text-output&gt;</p>
						</dt>
						<dd>Default value:
							<code>true</code>
							<br />
							<br />Enable/disable extraction of text.</dd>
						<dt>
							<p>&lt;zones&gt;</p>
						</dt>
						<dd>Default value:
							<code>false</code>
							<br />
							<br />Enable/disable zone controls. Using
							<code>true</code>produces better results when the PDF is annotated; using
							<code>false</code>produces better results in non-annotated tables.</dd>
						<dt>
							<p>&lt;ignore-text&gt;</p>
						</dt>
						<dd>Default value:
							<code>true</code>
							<br />
							<br />Enable/disable extraction of text from images. Documents consisting of scanned pages can only have text extracted if this parameter is set to
							<code>true</code>; however, diagrams with embedded text labels may be less palatable. For page-by-page conversion, the problem with reflowing of text and graphical elements within a diagram giving poor results is not such a problem, and the value of
							<code>false</code>will probably be the better choice.</dd>
						<dt>
							<p>&lt;remove-overprint&gt;</p>
						</dt>
						<dd>Default value:
							<code>false</code>
							<br />
							<br />Enable/disable removal of text overlays. Setting this parameter to
							<code>true</code>can sometimes clean up messy results stemming from reflowing of text that was not visible in the original PDF because it was covered by something else.</dd>
						<dt>
							<p>&lt;illustrations&gt;</p>
						</dt>
						<dd>Default value:
							<code>true</code>
							<br />
							<br />Enable/disable extraction of illustrations. Setting this parameter to
							<code>false</code>can sometimes clean up messy results stemming from minor and unnecessary graphical ornaments.</dd>
						<dt>
							<p>&lt;image-quality&gt;</p>
						</dt>
						<dd>Default value:
							<code>75</code>
							<br />
							<br />Determines the quality of extracted and converted images: smaller values mean smaller image sizes (in bytes) but lossier rendering. The maximum is 100.</dd>
						<dt>
							<p>&lt;page-start&gt;</p>
						</dt>
						<dd>Default value:
							<code />
							<br />
							<br />Boilerplate text inserted at the start of every page. Any XML markup must be escaped. For example:
							<code>&amp;lt;p&gt;PAGE START&amp;lt/p&gt;</code></dd>
						<dt>
							<p>&lt;page-end&gt;</p>
						</dt>
						<dd>Default value:
							<code />
							<br />
							<br />Boilerplate text inserted at the end of every page. XML markup must be escaped.</dd>
						<dt>
							<p>&lt;document-start&gt;</p>
						</dt>
						<dd>Default value:
							<code />
							<br />
							<br />Boilerplate text inserted at the start of every document. XML markup must be escaped.</dd>
						<dt>
							<p>&lt;document-end&gt;</p>
						</dt>
						<dd>Default value:
							<code />
							<br />
							<br />Boilerplate text inserted at the end of every document. XML markup must be escaped.</dd>
						<dt>
							<p>&lt;password&gt;</p>
						</dt>
						<dd>Default value:
							<code />
							<br />
							<br />The password required to open a password-protected PDF.</dd>
						<dt>
							<p>Sample Options Node:</p>
						</dt>
						<dd>The following is a sample options node which specifies that tidy is used to clean the generated html, specifies to use the tidy "clean" option, and specifies a particular configuration file to use for the conversion:
							<pre xml:space="preserve">
&lt;options xmlns="xdmp:pdf-convert"
         xmlns:tidy="xdmp:tidy"&gt;
  &lt;tidy&gt;true&lt;/tidy&gt;
  &lt;tidy:clean&gt;yes&lt;/tidy:clean&gt;
  &lt;config&gt;c:\myConfigFile.cfg&lt;/config&gt;
&lt;/options&gt;
</pre></dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()*</return>
		<usage>The convert functions return several nodes. The first node is a manifest containing the various parts of the conversion. Typically there will be an xml part, a css part, and some image parts. Each part is returned as a separate node in the order shown in the manifest.
			<p>Therefore, given the following manifest:</p>
			<pre xml:space="preserve">
&lt;parts&gt;
  &lt;part&gt;myFile_pdf.xhtml&lt;/part&gt;
  &lt;part&gt;myFile_pdf_parts/conv.css&lt;/part&gt;
  &lt;part&gt;myFile_pdf_parts/toc.xml&lt;/part&gt;
&lt;/parts&gt;
</pre>
			<p>the first node of the returned query is the manifest, the second is the "myFile_pdf.xhtml" node, the third is the "myFile_pdf_parts/conv.css" node, and the fourth is the myFile_pdf_parts/toc.xml node.</p></usage>
		<example xml:space="preserve">
let $results := xdmp:pdf-convert(
                         xdmp:document-get("myFile.pdf"),
                         "myFile.pdf" ),
    $manifest := $results[1]
return
$results[2 to last()]

=&gt; all of the converted nodes
</example>
	</function>
	<function name="tidy" type="builtin" lib="xdmp" category="Document Conversion" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:tidy">
		<summary>Run tidy on the specified html document to convert the document to well-formed and clean XHTML. Returns two nodes: the first is a status node indicating any errors or warning from tidy, and the second is an html node containing the cleaned xhtml.</summary>
		<params>
			<param name="doc" type="xs:string" optional="false">A string representing the the html document you want to tidy.</param>
			<param name="options" type="node()?" optional="true">The options nodes for this operation. The node for the tidy options must be in the
				<code>xdmp:tidy</code>namespace. The default value is (). The options are based on the open source HTML Tidy configuration options, available at
				<a href="http://tidy.sourceforge.net/docs/quickref.html" target="_blank">http://tidy.sourceforge.net/docs/quickref.html</a>. Most of the tidy options are available through
				<code>xdmp:tidy</code>with the following exceptions:
				<ul>
					<li>The character encoding for the output is always UTF-8.</li>
					<li>The filesystem options which allow you to specify where to save output are not supported (although there are many ways to achieve this through functions such as
						<code>xdmp:save</code>).</li>
					<li>The output is always XHTML.</li>
					<li>Entities except for the built-in HTML entities will be always be output in numeric form.</li>
				</ul>
				<p>Options include:</p>
				<blockquote>
					<dl>
						<dt>
							<h4>HTML, XHTML, and XML Options</h4>
							<p>&lt;add-xml-decl&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should add the XML declaration when outputting XML or XHTML. Note that if the input already includes an
							<code>&lt;?xml ... ?&gt;</code>declaration then this option will be ignored.</dd>
						<dt>
							<p>&lt;add-xml-space&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should add
							<code>xml:space="preserve"</code>to elements such as &lt;PRE&gt;, &lt;STYLE&gt; and &lt;SCRIPT&gt; when generating XML. This is needed if the whitespace in such elements is to be parsed appropriately without having access to the DTD.</dd>
						<dt>
							<p>&lt;alt-text&gt;</p>
						</dt>
						<dd>Default Value: n/a
							<br />
							<br />
							<br />Description: This option specifies the default "alt=" text Tidy uses for &lt;IMG&gt; attributes. This feature is dangerous as it suppresses further accessibility warnings. You are responsible for making your documents accessible to people who can not see the images!</dd>
						<dt>
							<p>&lt;assume-xml-procins&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should change the parsing of processing instructions to require ?&gt; as the terminator rather than &gt;. This option is automatically set if the input is in XML.</dd>
						<dt>
							<p>&lt;bare&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should strip Microsoft specific HTML from Word 2000 documents, and output spaces rather than non-breaking spaces where they exist in the input.</dd>
						<dt>
							<p>&lt;clean&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should strip out surplus presentational tags and attributes replacing them by style rules and structural markup as appropriate. It works well on the HTML saved by Microsoft Office products.</dd>
						<dt>
							<p>&lt;css-prefix&gt;</p>
						</dt>
						<dd>Default Value: n/a
							<br />
							<br />Description: This option specifies the prefix that Tidy uses for styles rules. By default, "c" will be used.</dd>
						<dt>
							<p>&lt;doctype&gt;</p>
						</dt>
						<dd>Default Value:
							<code>auto</code>
							<br />
							<br />Possible Values:
							<code>auto</code>,
							<code>omit</code>,
							<code>strict</code>,
							<code>loose</code>,
							<code>transitional</code>, or user-specified fpi string
							<br />
							<br />Description: This option specifies the DOCTYPE declaration generated by Tidy. If set to
							<code>omit</code>the output won't contain a DOCTYPE declaration. If set to
							<code>auto</code>(the default) Tidy will use an educated guess based upon the contents of the document. If set to
							<code>strict</code>, Tidy will set the DOCTYPE to the strict DTD. If set to
							<code>loose</code>, the DOCTYPE is set to the loose (transitional) DTD. Alternatively, you can supply a string for the formal public identifier (FPI). For example:
							<br />
							<br />
							<code>doctype: "-//ACME//DTD HTML 3.14159//EN"</code>
							<br />
							<br />If you specify the FPI for an XHTML document, Tidy will set the system identifier to the empty string. Tidy leaves the DOCTYPE for generic XML documents unchanged. Specifying a doctype of
							<code>omit</code>implies that the numeric-entities option is set to
							<code>yes</code>.</dd>
						<dt>
							<p>&lt;drop-empty-paras&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should discard empty paragraphs. If set to no, empty paragraphs are replaced by a pair of &lt;BR&gt; elements as HTML4 precludes empty paragraphs.</dd>
						<dt>
							<p>&lt;drop-font-tags&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should discard &lt;FONT&gt; and &lt;CENTER&gt; tags without creating the corresponding style rules. This option can be set independently of the clean option.</dd>
						<dt>
							<p>&lt;drop-proprietary-attributes&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should strip out proprietary attributes, such as MS data binding attributes.</dd>
						<dt>
							<p>&lt;enclose-block-text&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should insert a &lt;P&gt; element to enclose any text it finds in any element that allows mixed content for HTML transitional but not HTML strict.</dd>
						<dt>
							<p>&lt;enclose-text&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should enclose any text it finds in the body element within a &lt;P&gt; element. This is useful when you want to take existing HTML and use it with a style sheet.</dd>
						<dt>
							<p>&lt;escape-cdata&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should convert &lt;![CDATA[]]&gt; sections to normal text.</dd>
						<dt>
							<p>&lt;fix-backslash&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should replace backslash characters "\" in URLs by forward slashes "/".</dd>
						<dt>
							<p>&lt;fix-bad-comments&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should replace unexpected hyphens with "=" characters when it comes across adjacent hyphens. The default is yes. This option is provided for users of Cold Fusion which uses the comment syntax: &lt;!--- ---&gt;</dd>
						<dt>
							<p>&lt;fix-uri&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should check attribute values that carry URIs for illegal characters and if such are found, escape them as HTML 4 recommends.</dd>
						<dt>
							<p>&lt;hide-comments&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should print out comments.</dd>
						<dt>
							<p>&lt;hide-endtags&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should omit optional end-tags when generating the pretty printed markup. This option is ignored if you are outputting to XML.</dd>
						<dt>
							<p>&lt;indent-cdata&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should indent &lt;![CDATA[]]&gt; sections.</dd>
						<dt>
							<p>&lt;input-xml&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should use the XML parser rather than the error correcting HTML parser.</dd>
						<dt>
							<p>&lt;join-classes&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should combine class names to generate a single new class name, if multiple class assignments are detected on an element.</dd>
						<dt>
							<p>&lt;join-styles&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should combine styles to generate a single new style, if multiple style values are detected on an element.</dd>
						<dt>
							<p>&lt;literal-attributes&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should ensure that whitespace characters within attribute values are passed through unchanged.</dd>
						<dt>
							<p>&lt;logical-emphasis&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should replace any occurrence of &lt;I&gt; by &lt;EM&gt; and any occurrence of &lt;B&gt; by &lt;STRONG&gt;. In both cases, the attributes are preserved unchanged. This option can be set independently of the clean and drop-font-tags options.</dd>
						<dt>
							<p>&lt;lower-literals&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should convert the value of an attribute that takes a list of predefined values to lower case. This is required for XHTML documents.</dd>
						<dt>
							<p>&lt;merge-divs&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: Can be used to modify behavior of setting the
							<code>clean</code>option to
							<code>yes</code>. This option specifies if Tidy should merge nested &lt;div&gt; such as
							<code>&lt;div&gt;&lt;div&gt;...&lt;/div&gt;&lt;/div&gt;</code>.</dd>
						<dt>
							<p>&lt;ncr&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should allow numeric character references.</dd>
						<dt>
							<p>&lt;new-blocklevel-tags&gt;</p>
						</dt>
						<dd>Default Value: none
							<br />
							<br />Description: This option specifies new block-level tags. This option takes a space or comma separated list of tag names. Unless you declare new tags, Tidy will refuse to generate a tidied file if the input includes previously unknown tags. Note you can't change the content model for elements such as &lt;TABLE&gt;, &lt;UL&gt;, &lt;OL&gt; and &lt;DL&gt;.</dd>
						<dt>
							<p>&lt;new-empty-tags&gt;</p>
						</dt>
						<dd>Default Value: none
							<br />
							<br />Description: This option specifies new empty inline tags. This option takes a space or comma separated list of tag names. Unless you declare new tags, Tidy will refuse to generate a tidied file if the input includes previously unknown tags. Remember to also declare empty tags as either inline or blocklevel.</dd>
						<dt>
							<p>&lt;new-inline-tags&gt;</p>
						</dt>
						<dd>Default Value: none
							<br />
							<br />Description: This option specifies new non-empty inline tags. This option takes a space or comma separated list of tag names. Unless you declare new tags, Tidy will refuse to generate a tidied file if the input includes previously unknown tags.</dd>
						<dt>
							<p>&lt;new-pre-tags&gt;</p>
						</dt>
						<dd>Default Value: none
							<br />
							<br />Description: This option specifies new tags that are to be processed in exactly the same way as HTML's &lt;PRE&gt; element. This option takes a space or comma separated list of tag names. Unless you declare new tags, Tidy will refuse to generate a tidied file if the input includes previously unknown tags. Note you can not as yet add new CDATA elements (similar to &lt;SCRIPT&gt;).</dd>
						<dt>
							<p>&lt;numeric-entities&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should output entities other than the built-in HTML entities (&amp;, &lt;, &gt; and ") in the numeric rather than the named entity form.</dd>
						<dt>
							<p>&lt;output-html&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should generate pretty printed output, writing it as HTML.</dd>
						<dt>
							<p>&lt;output-xhtml&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should generate pretty printed output, writing it as extensible HTML. This option causes Tidy to set the DOCTYPE and default namespace as appropriate to XHTML. If a DOCTYPE or namespace is given they will checked for consistency with the content of the document. In the case of an inconsistency, the corrected values will appear in the output. For XHTML, entities can be written as named or numeric entities according to the setting of the
							<code>numeric-entities</code>option. The original case of tags and attributes will be preserved, regardless of other options.</dd>
						<dt>
							<p>&lt;output-xml&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should pretty print output, writing it as well-formed XML. Any entities not defined in XML 1.0 will be written as numeric entities to allow them to be parsed by a XML parser. The original case of tags and attributes will be preserved, regardless of other options.</dd>
						<dt>
							<p>&lt;quote-ampersand&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should output unadorned &amp; characters as &amp;#38;.</dd>
						<dt>
							<p>&lt;quote-marks&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should output " characters as " as is preferred by some editing environments. The apostrophe character ' is written out as &amp;#39; since many web browsers don't yet support &amp;#39;.</dd>
						<dt>
							<p>&lt;quote-nbsp&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should output non-breaking space characters as entities, rather than as the Unicode character value 160 (decimal).</dd>
						<dt>
							<p>&lt;repeated-attributes&gt;</p>
						</dt>
						<dd>Default Value:
							<code>keep-last</code>
							<br />
							<br />Possible Values:
							<code>keep-first</code>,
							<code>keep-last</code>
							<br />
							<br />Description: This option specifies if Tidy should keep the first or last attribute, if an attribute is repeated (for example, if a tag has has two
							<code>align</code>attributes.</dd>
						<dt>
							<p>&lt;replace-color&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should replace numeric values in color attributes by HTML/XHTML color names where defined, e.g. replace "#ffffff" with "white".</dd>
						<dt>
							<p>&lt;show-body-only&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should print only the contents of the body tag as an HTML fragment. Useful for incorporating existing whole pages as a portion of another page.</dd>
						<dt>
							<p>&lt;uppercase-attributes&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should output attribute names in upper case. The default is no, which results in lower case attribute names, except for XML input, where the original case is preserved.</dd>
						<dt>
							<p>&lt;uppercase-tags&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should output tag names in upper case. The default is no, which results in lower case tag names, except for XML input, where the original case is preserved.</dd>
						<dt>
							<p>&lt;word-2000&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should go to great pains to strip out all the surplus stuff Microsoft Word 2000 inserts when you save Word documents as "Web pages". Doesn't handle embedded images or VML.</dd>
						<dt>
							<h4>Diagnostic Options</h4>
							<p>&lt;accessibility-check&gt;</p>
						</dt>
						<dd>Default Value: 0
							<br />
							<br />Possible Values: 0, 1, 2, or 3
							<br />
							<br />Description: This option specifies what level of accessibility checking, if any, that Tidy should do. Level 0 is equivalent to Tidy Classic's accessibility checking. For more information on Tidy's accessibility checking, see the web site for the
							<a href="http://www.aprompt.ca/Tidy/accessibilitychecks.html">Adaptive Technology Resource Centre at the University of Toronto</a>.</dd>
						<dt>
							<p>&lt;show-errors&gt;</p>
						</dt>
						<dd>Default Value:
							<code>6</code>
							<br />
							<br />Possible Values: Any integer.
							<br />
							<br />Description: This option specifies the number Tidy uses to determine if further errors should be shown. If set to 0, then no errors are shown.</dd>
						<dt>
							<p>&lt;show-warnings&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should suppress warnings. This is useful when a few errors are hidden between many warning messages.</dd>
						<dt>
							<h4>Pretty Print Options</h4>
							<p>&lt;break-before-br&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should output a line break before each &lt;BR&gt; element.</dd>
						<dt>
							<p>&lt;indent&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Possible Values:
							<code>no</code>,
							<code>yes</code>,
							<code>auto</code>
							<br />
							<br />Description: This option specifies if Tidy should indent block-level tags. If set to
							<code>auto</code>, this option causes Tidy to decide whether or not to indent the content of tags such as TITLE, H1-H6, LI, TD, TD, or P depending on whether or not the content includes a block-level element. You are advised to avoid setting indent to
							<code>yes</code>as this can expose layout bugs in some browsers.</dd>
						<dt>
							<p>&lt;indent-attributes&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should begin each attribute on a new line.</dd>
						<dt>
							<p>&lt;indent-spaces&gt;</p>
						</dt>
						<dd>Default Value:
							<code>2</code>
							<br />
							<br />Possible Values: Any integer.
							<br />
							<br />Description: This option specifies the number of spaces Tidy uses to indent content, when indentation is enabled.</dd>
						<dt>
							<p>&lt;markup&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should generate a pretty printed version of the markup. Note that Tidy won't generate a pretty printed version if it finds significant errors (see force-output).</dd>
						<dt>
							<p>&lt;punctuation-wrap&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should line wrap after some Unicode or Chinese punctuation characters.</dd>
						<dt>
							<p>&lt;split&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should create a sequence of slides from the input, splitting the markup prior to each successive &lt;H2&gt;. The slides are written to "slide001.html", "slide002.html" etc.</dd>
						<dt>
							<p>&lt;tab-size&gt;</p>
						</dt>
						<dd>Default Value: 8
							<br />
							<br />Possible Values: Any integer.
							<br />
							<br />Description: This option specifies the number of columns that Tidy uses between successive tab stops. It is used to map tabs to spaces when reading the input. Tidy never outputs tabs.</dd>
						<dt>
							<p>&lt;vertical-space&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should add some empty lines for readability.</dd>
						<dt>
							<p>&lt;wrap&gt;</p>
						</dt>
						<dd>Default Value: 68
							<br />
							<br />Possible Values: Any integer.
							<br />
							<br />Description: This option specifies the right margin Tidy uses for line wrapping. Tidy tries to wrap lines so that they do not exceed this length. Set wrap to zero if you want to disable line wrapping.</dd>
						<dt>
							<p>&lt;wrap-asp&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should line wrap text contained within ASP pseudo elements, which look as follows:
							<br />
							<code>&lt;% ... %&gt;</code>.</dd>
						<dt>
							<p>&lt;wrap-attributes&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should line wrap attribute values, for easier editing. This option can be set independently of wrap-script-literals.</dd>
						<dt>
							<p>&lt;wrap-jste&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should line wrap text contained within JSTE pseudo elements, which look as follows:
							<br />
							<code>&lt;# ... #&gt;</code>.</dd>
						<dt>
							<p>&lt;wrap-php&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should line wrap text contained within PHP pseudo elements, which look as follows:
							<br />
							<code>&lt;?php ... ?&gt;</code>.</dd>
						<dt>
							<p>&lt;wrap-script-literals&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should line wrap string literals that appear in script attributes. Tidy wraps long script string literals by inserting a backslash character before the line break.</dd>
						<dt>
							<p>&lt;wrap-sections&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should line wrap text contained within
							<code>&lt;![ ... ]&gt;</code>section tags.</dd>
						<dt>
							<h4>Miscellaneous Options</h4>
							<p>&lt;force-output&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should produce output even if errors are encountered. Use this option with care - if Tidy reports an error, this means Tidy was not able to, or is not sure how to, fix the error, so the resulting output may not be what you expect.</dd>
						<dt>
							<p>&lt;keep-time&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should keep the original modification time of files that Tidy modifies in place. The default is no. Setting the option to yes allows you to tidy files without causing these files to be uploaded to a web server when using a tool such as SiteCopy. Note this feature is not supported on some platforms.</dd>
						<dt>
							<p>&lt;quiet&gt;</p>
						</dt>
						<dd>Default Value:
							<code>no</code>
							<br />
							<br />Description: This option specifies if Tidy should output the summary of the numbers of errors and warnings, or the welcome or informational messages.</dd>
						<dt>
							<p>&lt;tidy-mark&gt;</p>
						</dt>
						<dd>Default Value:
							<code>yes</code>
							<br />
							<br />Description: This option specifies if Tidy should add a meta element to the document head to indicate that the document has been tidied. Tidy won't add a meta element if one is already present.</dd>
					</dl>
				</blockquote></param>
		</params>
		<return>node()+</return>
		<example xml:space="preserve">
let $html := "
&lt;htm&gt;
 &lt;h1&gt;This is a heading 1
 &lt;p&gt;This is paragraph tag
"
return
xdmp:tidy($html, &lt;options xmlns="xdmp:tidy"&gt;
                 &lt;/options&gt;)

=&gt; a tidy-status node with any errors and warnings and
   an html node containing the clean and well-formed XHTML.


</example>
    <example xml:space="preserve">
xquery version "1.0-ml";

xdmp:tidy(
 xdmp:document-get("c:/tmp/test.html",
   &lt;options xmlns="xdmp:document-get"&gt;
     &lt;format&gt;text&lt;/format&gt;
    &lt;/options&gt;))[2]
=&gt;
The html document from the filesystem converted to xhtml
</example>
	</function>
	<function name="user-last-login" type="builtin" lib="xdmp" category="Extension" subcategory="Extension" hidden="false" bucket="MarkLogic Built-In Functions" fullname="xdmp:user-last-login">
		<summary>Returns the last-login node for the specified user ID. If no user ID is specified, then the current user is assumed. If no last-login database is specified in the App Server configuration, then the empty sequence is returned.</summary>
		<params>
			<param name="user" type="xs:unsignedLong" optional="false">A user ID.</param>
		</params>
		<return>element(last-login)?</return>
		<example xml:space="preserve">
  xdmp:user-last-login(xdmp:user("sylvester"))
  =&gt;
  &lt;last-login xmlns="http://marklogic.com/xdmp/last-login"&gt;
    &lt;user-id&gt;1134406269933351074&lt;/user-id&gt;
    &lt;last-successful-login&gt;2008-03-19T15:41:08&lt;/last-successful-login&gt;
    &lt;last-unsuccessful-login&gt;2008-03-19T15:40:45&lt;/last-unsuccessful-login&gt;
    &lt;number-unsuccessful-logins&gt;0&lt;/number-unsuccessful-logins&gt;
    &lt;display-last-login&gt;true&lt;/display-last-login&gt;
  &lt;/last-login&gt;
</example>
		<algorithm />
	</function>
	<function name="clean" type="xhtml" lib="xhtml" category="XHTML Conversion" bucket="CPF Functions" hidden="false" fullname="xhtml:clean">
		<summary>Clean up the XHTML: pruning empty spans, consolidating adjacent spans, etc.</summary>
		<params>
			<param name="doc" type="node()?" optional="false">The source XHTML.</param>
		</params>
		<return>node()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace xhtml = "http://marklogic.com/cpf/xhtml"
	         at "/MarkLogic/conversion/xhtml.xqy";

  xhtml:clean(fn:doc("my.xhtml"))

</example>
	</function>
	<function name="restructure" type="xhtml" lib="xhtml" category="XHTML Conversion" bucket="CPF Functions" hidden="false" fullname="xhtml:restructure">
		<summary>Turn an XHTML with flat structure into one with div structure based on the header elements.</summary>
		<params>
			<param name="doc" type="node()?" optional="false">The source XHTML.</param>
		</params>
		<return>node()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  declare default element namespace "http://www.w3.org/1999/xhtml";

  import module namespace xhtml = "http://marklogic.com/cpf/xhtml"
	         at "/MarkLogic/conversion/xhtml.xqy";

  let $unstructured :=
     &lt;html&gt;
       &lt;head&gt;&lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;
       &lt;body&gt;
          &lt;h1&gt;First section&lt;/h1&gt;
          &lt;p&gt;First paragraph.&lt;/p&gt;
          &lt;p&gt;Second paragraph.&lt;/p&gt;
          &lt;h2&gt;Subheader&lt;/h2&gt;
          &lt;p&gt;Sub paragraph.&lt;/p&gt;
          &lt;h1&gt;Second section&lt;/h1&gt;
          &lt;p&gt;Last paragraph.&lt;/p&gt;
       &lt;/body&gt;
     &lt;/html&gt;
  return xhtml:restructure( $unstructured )

  Returns:
    &lt;html&gt;
      &lt;head&gt;&lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
         &lt;div class="mlsection1"&gt;
           &lt;h1&gt;First section&lt;/h1&gt;
           &lt;p&gt;First paragraph.&lt;/p&gt;
           &lt;p&gt;Second paragraph.&lt;/p&gt;
           &lt;div class="mlsection2"&gt;
             &lt;h2&gt;Subheader&lt;/h2&gt;
             &lt;p&gt;Sub paragraph.&lt;/p&gt;
           &lt;/div&gt;
         &lt;/div&gt;
         &lt;div class="mlsection1"&gt;
           &lt;h1&gt;Second section&lt;/h1&gt;
           &lt;p&gt;Last paragraph.&lt;/p&gt;
         &lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;

</example>
	</function>
	<function name="add-lists" type="xhtml" lib="xhtml" category="XHTML Conversion" bucket="CPF Functions" hidden="false" fullname="xhtml:add-lists">
		<summary>Infer numbered or bulleted lists and insert appropriate markup. Restructuring first is highly recommended to improve both accuracy and performance. This function also assumes that indentation styling is already present on the paragraphs in the original input.</summary>
		<params>
			<param name="doc" type="node()?" optional="false">The source XHTML.</param>
		</params>
		<return>node()?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  declare default element namespace "http://www.w3.org/1999/xhtml";

  import module namespace xhtml = "http://marklogic.com/cpf/xhtml"
	         at "/MarkLogic/conversion/xhtml.xqy";

  let $raw :=
     &lt;html&gt;
       &lt;head&gt;&lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;
       &lt;body&gt;
          &lt;div class="mlsection1"&gt;
            &lt;h1&gt;Section header&lt;/h1&gt;
            &lt;p&gt;1. First paragraph.&lt;/p&gt;
            &lt;p&gt;2. Second paragraph.&lt;/p&gt;
            &lt;p&gt;a. Sub-topic 1.&lt;/p&gt;
            &lt;p&gt;b. Sub-topic 1.&lt;/p&gt;
            &lt;p&gt;3. Third paragraph&lt;/p&gt;
            &lt;div class="mlsection2"&gt;
              &lt;h2&gt;Subheader&lt;/h2&gt;
              &lt;p&gt;1. Sub paragraph.&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
       &lt;/body&gt;
     &lt;/html&gt;
  return xhtml:add-lists( $raw )

  Returns:
     &lt;html&gt;
       &lt;head&gt;&lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;
       &lt;body&gt;
          &lt;div class="mlsection1"&gt;
            &lt;h1&gt;Section header&lt;/h1&gt;
            &lt;ol style="list-style-type: none; margin-left: 0pt"&gt;
              &lt;li&gt;1. First paragraph.&lt;/li&gt;
              &lt;li&gt;2. Second paragraph.&lt;/li&gt;
              &lt;ol style="list-style-type: none; margin-left: 0pt"&gt;
                &lt;li&gt;a. Sub-topic 1.&lt;/li&gt;
                &lt;li&gt;b. Sub-topic 1.&lt;/li&gt;
              &lt;/ol&gt;
              &lt;li&gt;3. Third paragraph&lt;/li&gt;
            &lt;/ol&gt;
            &lt;div class="mlsection2"&gt;
              &lt;h2&gt;Subheader&lt;/h2&gt;
              &lt;p&gt;1. Sub paragraph.&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
       &lt;/body&gt;
     &lt;/html&gt;

</example>
	</function>
	<function name="link-expand" lib="xinc" category="Modular Documents" subcategory="XInclude" bucket="XQuery Library Modules" hidden="false" fullname="xinc:link-expand">
		<summary>This function performs a single level expansion of a single XInclude reference. XInclude references in the referenced node will not be expanded.</summary>
		<params>
			<param name="context" type="node()" optional="false">The root node containing the XInclude reference, which is used for the interpretation of relative links with empty href attributes.</param>
			<param name="ref" type="element(xi:include)" optional="false">An XInclude include element.</param>
		</params>
		<return>node()*</return>
		<usage>Since this function only performs a single-level expansion of a single reference, applications will typically call node-expand instead.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace xinc = "http://marklogic.com/xinclude"
	         at "/MarkLogic/xinclude/xinclude.xqy";

  declare namespace xi="http://www.w3.org/2001/XInclude";

  let $root := fn:doc("http://example.org/mydoc.xml")
  return xinc:link-expand( $root, $root/section[1]/xi:include[1] )

</example>
	</function>
	<function name="node-expand" lib="xinc" category="Modular Documents" subcategory="XInclude" bucket="XQuery Library Modules" hidden="false" fullname="xinc:node-expand">
		<summary>This function recursively examines the node for XInclude references and expands them, following the rules of the XInclude specification. The result is a node in which all the XInclude references have been resolved, or an error if there were unresolvable references with no fallback specifications.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node to expand.</param>
		</params>
		<return>node()</return>
		<usage>URI references are resolved against the current database.</usage>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace xinc = "http://marklogic.com/xinclude"
	         at "/MarkLogic/xinclude/xinclude.xqy";

  xinc:node-expand( fn:doc("http://example.org/mydoc.xml") )

</example>
	</function>
	<function name="link-references" lib="xinc" category="Modular Documents" subcategory="XInclude" bucket="XQuery Library Modules" hidden="false" fullname="xinc:link-references">
		<summary>This function returns a list of all the distinct URIs of documents referenced (either directly or indirectly) in the expansion of the node.</summary>
		<params>
			<param name="node" type="node()" optional="false">The node containing XInclude references.</param>
		</params>
		<return>xs:string*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";
  import module namespace xinc = "http://marklogic.com/xinclude"
	         at "/MarkLogic/xinclude/xinclude.xqy";

  xinc:link-references(fn:doc("http://example.org/mydoc.xml"))

</example>
	</function>
	<function name="parse-xpointer" lib="xp" category="Modular Documents" subcategory="XPointer" bucket="XQuery Library Modules" hidden="true" fullname="xp:parse-xpointer">
		<summary>This function....</summary>
		<params>
			<param name="xpointer" type="xs:string" optional="false">Parameter description...</param>
		</params>
		<return>element(xp:part)*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace xp = "http://marklogic.com/xdmp/xpointer"
      at "/MarkLogic/xpointer.xqy";


</example>
	</function>
	<function name="path-from-element-scheme" lib="xp" category="Modular Documents" subcategory="XPointer" bucket="XQuery Library Modules" hidden="true" fullname="xp:path-from-element-scheme">
		<summary>This function....</summary>
		<params>
			<param name="part" type="xs:string" optional="false">Parameter description...</param>
		</params>
		<return>xs:string</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace xp = "http://marklogic.com/xdmp/xpointer"
      at "/MarkLogic/xpointer.xqy";


</example>
	</function>
	<function name="alt-path-from-element-scheme" lib="xp" category="Modular Documents" subcategory="XPointer" bucket="XQuery Library Modules" hidden="true" fullname="xp:alt-path-from-element-scheme">
		<summary>This function....</summary>
		<params>
			<param name="part" type="xs:string" optional="false">Parameter description...</param>
		</params>
		<return>xs:string?</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace xp = "http://marklogic.com/xdmp/xpointer"
      at "/MarkLogic/xpointer.xqy";


</example>
	</function>
	<function name="do-dereference" lib="xp" category="Modular Documents" subcategory="XPointer" bucket="XQuery Library Modules" hidden="true" fullname="xp:do-dereference">
		<summary>This function....</summary>
		<params>
			<param name="context" type="node()" optional="false">Parameter description...</param>
			<param name="path" type="xs:string" optional="false">Parameter description...</param>
			<param name="ns-bindings" type="xs:string*" optional="false">Parameter description...</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml";

  import module namespace xp = "http://marklogic.com/xdmp/xpointer"
      at "/MarkLogic/xpointer.xqy";


</example>
	</function>
	<function name="dereference" lib="xp" category="Modular Documents" subcategory="XPointer" bucket="XQuery Library Modules" hidden="false" fullname="xp:dereference">
		<summary>This function resolves an XPointer in the context of a particular node.</summary>
		<params>
			<param name="context" type="node()" optional="false">The node against which the XPointer evaluates.</param>
			<param name="xpointer" type="xs:string" optional="false">An XPointer.</param>
		</params>
		<return>node()*</return>
		<example xml:space="preserve">
  xquery version "1.0-ml"
  import module namespace xp = "http://marklogic.com/xinclude/xpointer"
	         at "/MarkLogic/xinclude/xpointer.xqy";

  let $node :=
     &lt;root xmlns="http://marklogic.com/myns"&gt;
       &lt;this&gt;
         This is text before the referenced element.
         &lt;that&gt;The referenced element.&lt;/that&gt;
         This is text after the referenced element.
       &lt;/this&gt;
     &lt;/root&gt;
  return
     xp:dereference($node,
        "xmlns(ns=http://marklogic.com/myns) xpath(//ns:this/ns:that)")

===&gt; &lt;that xmlns="http://marklogic.com/myns"&gt;The referenced element.&lt;/that&gt;


</example>
	</function>
</functions>
