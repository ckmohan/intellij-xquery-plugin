{
  classHeader="header.txt"
  parserClass="uk.co.overstory.parser.GrammarParser"
  stubParserClass="org.intellij.grammar.parser.GrammarParserUtil"

  implements="uk.co.overstory.xquery.psi.XqyCompositeElement"
  extends="uk.co.overstory.xquery.psi.impl.XqyCompositeElementImpl"

  psiClassPrefix="Xqy"
  psiImplClassSuffix="Impl"
  psiPackage="uk.co.overstory.xquery.psi"
  psiImplPackage="uk.co.overstory.xquery.psi.impl"

  elementTypeHolderClass="uk.co.overstory.xquery.psi.XqyTypes"
  elementTypePrefix="XQY_"
  elementTypeClass="uk.co.overstory.xquery.psi.XqyCompositeElementType"
  tokenTypeClass="uk.co.overstory.xquery.psi.XqyTokenType"

  // tokens
  CDATA_START="<![CDATA["
  CDATA_END="]>"
  OP_BIND=":="
  APOST="'"
  DBL_QUOTE="\""
  EQUAL="="
  NOT_EQUAL="!="
  LESS_EQUAL="<="
  GREATER_EQUAL=">="
  DOC_BEFORE="<<"
  DOC_AFTER=">>"
  VERT_BAR="|"
  QMARK="?"
  PLUS_SIGN="+"
  MINUS_SIGN="-"
  STAR="*"
  HASH="#"
  SEMICOLON=";"
  COLON=":"
  UNDERSCORE="_"
  LEFT_PAREN="("
  RIGHT_PAREN=")"
  LEFT_BRACE="{"
  RIGHT_BRACE="}"
  LEFT_BRACKET="["
  RIGHT_BRACKET="]"
  LT="<"
  GT=">"
  END_TAG_START="</"
  EMPTY_TAG_END="/>"
  DOLLAR="$"
  AMP="&"
  COMMA=","
  DOT="."
  DOTDOT=".."
  AXIS="::"
  SLASH="/"
  SLASH_SLASH="//"
  PRAGMA_START="(#"
  PRAGMA_END="#)"
  DBL_LEFT_BRACE="{{"
  DBL_RIGHT_BRACE="}}"
  XML_COMMENT_START="<!--"
  XML_COMMENT_END="-->"
  PI_START="<?"
  PI_END="?>"
  CHAR_REF_START="&#"
  CHAR_HEX_REF_START="&#x"

  implements("rule|attr")="uk.co.overstory.xquery.psi.XqyNamedElement"
  extends("rule|attr")="uk.co.overstory.xquery.psi.impl.XqyNamedElementImpl"
  mixin("reference_or_token")="uk.co.overstory.xquery.psi.impl.XqyRefOrTokenImpl"
  mixin("string_literal_expression")="uk.co.overstory.xquery.psi.impl.XqyStringImpl"
  implements("paren_.*expression")="uk.co.overstory.xquery.psi.XqyParenthesized"
}


XQuery   ::= Module EOF
Module   ::= VersionDecl? ( LibraryModule | MainModuleSequence )
VersionDecl
         ::= 'xquery' 'version' StringLiteral ( 'encoding' StringLiteral )? Separator

MainModuleSequence ::= MainModule ( ';' VersionDecl? MainModule)* ';'?

MainModule
         ::= Prolog QueryBody
LibraryModule
         ::= ModuleDecl Prolog
ModuleDecl
         ::= 'module' 'namespace' NCName '=' URILiteral Separator
Prolog   ::= ( ( DefaultNamespaceDecl | Setter | NamespaceDecl | Import ) Separator )* ( ( VarDecl | FunctionDecl | OptionDecl ) Separator )*
Setter   ::= BoundarySpaceDecl
           | DefaultCollationDecl
           | BaseURIDecl
           | ConstructionDecl
           | OrderingModeDecl
           | EmptyOrderDecl
           | CopyNamespacesDecl
Import   ::= SchemaImport
           | ModuleImport
           | ImportStylesheetDecl
Separator
         ::= ';'
NamespaceDecl
         ::= 'declare' 'namespace' NCName '=' URILiteral
BoundarySpaceDecl
         ::= 'declare' 'boundary-space' ( 'preserve' | 'strip' )
DefaultNamespaceDecl
         ::= 'declare' 'default' ( 'element' | 'function' ) 'namespace' URILiteral

ImportStylesheetDecl ::= 'import' 'stylesheet' 'at' StringLiteral

OptionDecl
         ::= 'declare' 'option' QName StringLiteral
OrderingModeDecl
         ::= 'declare' 'ordering' ( 'ordered' | 'unordered' )
EmptyOrderDecl
         ::= 'declare' 'default' 'order' 'empty' ( 'greatest' | 'least' )
CopyNamespacesDecl
         ::= 'declare' 'copy-namespaces' PreserveMode ',' InheritMode
PreserveMode
         ::= 'preserve'
           | 'no-preserve'
InheritMode
         ::= 'inherit'
           | 'no-inherit'
DefaultCollationDecl
         ::= 'declare' 'default' 'collation' URILiteral
BaseURIDecl
         ::= 'declare' 'base-uri' URILiteral
SchemaImport
         ::= 'import' 'schema' SchemaPrefix? URILiteral ( 'at' URILiteral ( ',' URILiteral )* )?
SchemaPrefix
         ::= 'namespace' NCName '='
           | 'default' 'element' 'namespace'
ModuleImport
         ::= 'import' 'module' ( 'namespace' NCName '=' )? URILiteral ( 'at' URILiteral ( ',' URILiteral )* )?
VarDecl  ::= 'declare' 'private'? 'variable' '$' QName TypeDeclaration? ( ':=' ExprSingle | 'external' )
ConstructionDecl
         ::= 'declare' 'construction' ( 'strip' | 'preserve' )
FunctionDecl
         ::= 'declare' 'private'? 'function' FunctionName '(' ParamList? ')' ( 'as' SequenceType )? ( EnclosedExpr | 'external' )
ParamList
         ::= Param ( ',' Param )*
Param    ::= '$' QName TypeDeclaration?
EnclosedExpr
         ::= '{' Expr '}'
QueryBody
         ::= Expr
Expr     ::= ExprSingle ( ',' ExprSingle )*
ExprSingle
         ::= FLWORExpr
           | QuantifiedExpr
           | TypeswitchExpr
           | IfExpr
           | OrExpr
           | TryCatchExpr

TryCatchExpr ::= 'try' EnclosedExpr 'catch' '(' '$' VarName ')' EnclosedExprExtended
EnclosedExprExtended ::= '{' Expr? '}'

FLWORExpr
         ::= ( ForClause | LetClause )+ WhereClause? OrderByClause? 'return' ExprSingle
ForClause
         ::= 'for' '$' VarName TypeDeclaration? PositionalVar? 'in' ExprSingle ( ',' '$' VarName TypeDeclaration? PositionalVar? 'in' ExprSingle )*
PositionalVar
         ::= 'at' '$' VarName
LetClause
         ::= 'let' '$' VarName TypeDeclaration? ':=' ExprSingle ( ',' '$' VarName TypeDeclaration? ':=' ExprSingle )*
WhereClause
         ::= 'where' ExprSingle
OrderByClause
         ::= ( 'order' 'by' | 'stable' 'order' 'by' ) OrderSpecList
OrderSpecList
         ::= OrderSpec ( ',' OrderSpec )*
OrderSpec
         ::= ExprSingle OrderModifier
OrderModifier
         ::= ( 'ascending' | 'descending' )? ( 'empty' ( 'greatest' | 'least' ) )? ( 'collation' URILiteral )?
QuantifiedExpr
         ::= ( 'some' | 'every' ) '$' VarName TypeDeclaration? 'in' ExprSingle ( ',' '$' VarName TypeDeclaration? 'in' ExprSingle )* 'satisfies' ExprSingle
TypeswitchExpr
         ::= 'typeswitch' '(' Expr ')' CaseClause+ 'default' ( '$' VarName )? 'return' ExprSingle
CaseClause
         ::= 'case' ( '$' VarName 'as' )? SequenceType 'return' ExprSingle
IfExpr   ::= 'if' '(' Expr ')' 'then' ExprSingle 'else' ExprSingle
OrExpr   ::= AndExpr ( 'or' AndExpr )*
AndExpr  ::= ComparisonExpr ( 'and' ComparisonExpr )*
ComparisonExpr
         ::= RangeExpr ( ( ValueComp | GeneralComp | NodeComp ) RangeExpr )?
RangeExpr
         ::= AdditiveExpr ( 'to' AdditiveExpr )?
AdditiveExpr
         ::= MultiplicativeExpr ( ( '+' | '-' ) MultiplicativeExpr )*
MultiplicativeExpr
         ::= UnionExpr ( ( '*' | 'div' | 'idiv' | 'mod' ) UnionExpr )*
UnionExpr
         ::= IntersectExceptExpr ( ( 'union' | '|' ) IntersectExceptExpr )*
IntersectExceptExpr
         ::= InstanceofExpr ( ( 'intersect' | 'except' ) InstanceofExpr )*
InstanceofExpr
         ::= TreatExpr ( 'instance' 'of' SequenceType )?
TreatExpr
         ::= CastableExpr ( 'treat' 'as' SequenceType )?
CastableExpr
         ::= CastExpr ( 'castable' 'as' SingleType )?
CastExpr ::= UnaryExpr ( 'cast' 'as' SingleType )?
UnaryExpr
         ::= ( '-' | '+' )* ValueExpr
ValueExpr
         ::= ValidateExpr
           | PathExpr
           | ExtensionExpr
GeneralComp
         ::= '='
           | '!='
           | '<'
           | '<='
           | '>'
           | '>='
ValueComp
         ::= 'eq'
           | 'ne'
           | 'lt'
           | 'le'
           | 'gt'
           | 'ge'
NodeComp ::= 'is'
           | '<<'
           | '>>'
ValidateExpr
         ::= 'validate' ('as' QName | ValidationMode)? 'full'? '{' Expr '}'
ValidationMode
         ::= 'lax'
           | 'strict'
ExtensionExpr
         ::= Pragma+ '{' Expr? '}'
Pragma   ::= '(#' S? QName ( S PragmaContents )? '#)'
          /* ws: explicit */
PathExpr ::= '/' ( RelativePathExpr '/' )
           | '//' RelativePathExpr
           | RelativePathExpr
RelativePathExpr
         ::= StepExpr ( ( '/' | '//' ) StepExpr )*
StepExpr ::= FilterExpr
           | AxisStep
AxisStep ::= ( ReverseStep | ForwardStep ) PredicateList
ForwardStep
         ::= ForwardAxis NodeTest
           | AbbrevForwardStep
ForwardAxis
         ::= 'child' '::'
           | 'descendant' '::'
           | 'attribute' '::'
           | 'namespace' '::'
           | 'self' '::'
           | 'property' '::'
           | 'descendant-or-self' '::'
           | 'following-sibling' '::'
           | 'following' '::'
AbbrevForwardStep
         ::= '@'? NodeTest
ReverseStep
         ::= ReverseAxis NodeTest
           | AbbrevReverseStep
ReverseAxis
         ::= 'parent' '::'
           | 'ancestor' '::'
           | 'preceding-sibling' '::'
           | 'preceding' '::'
           | 'ancestor-or-self' '::'

AbbrevReverseStep
         ::= '..'
NodeTest ::= KindTest
           | NameTest
NameTest ::= QName
           | Wildcard
FilterExpr
         ::= PrimaryExpr PredicateList
PredicateList
         ::= Predicate*
Predicate
         ::= '[' Expr ']'
PrimaryExpr
         ::= Literal
           | VarRef
           | ParenthesizedExpr
           | ContextItemExpr
           | FunctionCall
           | OrderedExpr
           | UnorderedExpr
           | Constructor
Literal  ::= NumericLiteral
           | StringLiteral
NumericLiteral
         ::= IntegerLiteral
           | DecimalLiteral
           | DoubleLiteral
VarRef   ::= '$' VarName
VarName  ::= QName
ParenthesizedExpr
         ::= '(' Expr? ')'
ContextItemExpr
         ::= '.'
OrderedExpr
         ::= 'ordered' '{' Expr '}'
UnorderedExpr
         ::= 'unordered' '{' Expr '}'
FunctionCall
         ::= FunctionName '(' ( ExprSingle ( ',' ExprSingle )* )? ')'
Constructor
         ::= DirectConstructor
           | ComputedConstructor
DirectConstructor
         ::= DirElemConstructor
           | DirCommentConstructor
           | DirPIConstructor
DirElemConstructor
         ::= '<' QName DirAttributeList ( '/>' | '>' DirElemContent* '</' QName S? '>' )
          /* ws: explicit */
DirAttributeList
         ::= ( S ( QName S? '=' S? DirAttributeValue )? )*
          /* ws: explicit */
DirAttributeValue
         ::= "\"" ( EscapeQuot | QuotAttrValueContent )* "\""
           | "'" ( EscapeApos | AposAttrValueContent )* "'"
          /* ws: explicit */
QuotAttrValueContent
         ::= QuotAttrContentChar
           | CommonContent
AposAttrValueContent
         ::= AposAttrContentChar
           | CommonContent
DirElemContent
         ::= DirectConstructor
           | CDataSection
           | CommonContent
           | ElementContentChar
CommonContent
         ::= PredefinedEntityRef
           | CharRef
           | '{{'
           | '}}'
           | EnclosedExpr
DirCommentConstructor
         ::= '<!--' DirCommentContents '-->'
          /* ws: explicit */
DirPIConstructor
         ::= '<?' PITarget ( S DirPIContents )? '?>'
          /* ws: explicit */
ComputedConstructor
         ::= CompDocConstructor
           | CompElemConstructor
           | CompAttrConstructor
           | CompTextConstructor
           | CompCommentConstructor
           | CompPIConstructor
           | CompBinaryConstructor
           | CompNamespaceConstructor

CompBinaryConstructor ::= 'binary' EnclosedExprExtended
CompNamespaceConstructor ::= 'namespace' ( QName | '{' Expr '}' ) EnclosedExprExtended

CompDocConstructor
         ::= 'document' '{' Expr '}'
CompElemConstructor
         ::= 'element' ( QName | '{' Expr '}' ) '{' ContentExpr? '}'
ContentExpr
         ::= Expr
CompAttrConstructor
         ::= 'attribute' ( QName | '{' Expr '}' ) '{' Expr? '}'
CompTextConstructor
         ::= 'text' EnclosedExprExtended
CompCommentConstructor
         ::= 'comment' '{' Expr '}'
CompPIConstructor
         ::= 'processing-instruction' ( NCName | '{' Expr '}' ) '{' Expr? '}'
//SingleType
//         ::= AtomicType ('?'|'*'^OccurrenceIndicator)?
SingleType
         ::= AtomicType OccurrenceIndicator?
TypeDeclaration
         ::= 'as' SequenceType
SequenceType
         ::= 'empty-sequence' '(' ')'
           | ItemType OccurrenceIndicator?
//OccurrenceIndicator
//         ::= '?'
//           | '*'^OccurrenceIndicator
//           | '+'^OccurrenceIndicator
OccurrenceIndicator
         ::= '?' | '*' | '+'
ItemType ::= KindTest
           | 'item' '(' ')'
           | AtomicType
AtomicType
         ::= QName
KindTest ::= DocumentTest
           | ElementTest
           | AttributeTest
           | SchemaElementTest
           | SchemaAttributeTest
           | PITest
           | CommentTest
           | TextTest
           | AnyKindTest
           | BinaryTest
BinaryTest
         ::= 'binary' '(' ')'
AnyKindTest
         ::= 'node' '(' ')'
DocumentTest
         ::= 'document-node' '(' ( ElementTest | SchemaElementTest )? ')'
TextTest ::= 'text' '(' ')'
CommentTest
         ::= 'comment' '(' ')'
PITest   ::= 'processing-instruction' '(' ( NCName | StringLiteral )? ')'
AttributeTest
         ::= 'attribute' '(' ( AttribNameOrWildcard ( ',' TypeName )? )? ')'
AttribNameOrWildcard
         ::= AttributeName
           | '*'
SchemaAttributeTest
         ::= 'schema-attribute' '(' AttributeDeclaration ')'
AttributeDeclaration
         ::= AttributeName
ElementTest
         ::= 'element' '(' ( ElementNameOrWildcard ( ',' TypeName '?'? )? )? ')'
ElementNameOrWildcard
         ::= ElementName
           | '*'
SchemaElementTest
         ::= 'schema-element' '(' ElementDeclaration ')'
ElementDeclaration
         ::= ElementName
AttributeName
         ::= QName
ElementName
         ::= QName
TypeName ::= QName
URILiteral ::= StringLiteral
QName    ::= FunctionName
           | 'attribute'
           | 'namespace'
           | 'binary'
           | 'comment'
           | 'document-node'
           | 'element'
           | 'empty-sequence'
           | 'if'
           | 'item'
           | 'node'
           | 'processing-instruction'
           | 'schema-attribute'
           | 'schema-element'
           | 'text'
           | 'typeswitch'
FunctionName ::= 'ancestor'
           | 'ancestor-or-self'
           | 'and'
           | 'ascending'
           | 'case'
           | 'cast'
           | 'castable'
           | 'catch'
           | 'child'
           | 'collation'
           | 'declare'
           | 'default'
           | 'descendant'
           | 'descendant-or-self'
           | 'descending'
           | 'div'
           | 'document'
           | 'else'
           | 'empty'
           | 'eq'
           | 'every'
           | 'except'
           | 'following'
           | 'following-sibling'
           | 'for'
           | 'ge'
           | 'gt'
           | 'idiv'
           | 'import'
           | 'instance'
           | 'intersect'
           | 'is'
           | 'le'
           | 'let'
           | 'lt'
           | 'mod'
           | 'module'
           | 'ne'
           | 'or'
           | 'order'
           | 'ordered'
           | 'parent'
           | 'preceding'
           | 'preceding-sibling'
           | 'property'
           | 'return'
           | 'satisfies'
           | 'self'
           | 'some'
           | 'stable'
           | 'to'
           | 'treat'
           | 'try'
           | 'union'
           | 'unordered'
           | 'validate'
           | 'where'
           | 'xquery'
           | QName | Token
//           | QName^Token
NCName   ::= 'and'
           | 'ascending'
           | 'case'
           | 'cast'
           | 'castable'
           | 'collation'
           | 'default'
           | 'descending'
           | 'div'
           | 'else'
           | 'empty'
           | 'eq'
           | 'except'
           | 'for'
           | 'ge'
           | 'gt'
           | 'idiv'
           | 'instance'
           | 'intersect'
           | 'is'
           | 'le'
           | 'let'
           | 'lt'
           | 'mod'
           | 'ne'
           | 'or'
           | 'order'
           | 'return'
           | 'satisfies'
           | 'stable'
           | 'to'
           | 'treat'
           | 'union'
           | 'where'
           | NCName | Token
//           | NCName^Token
Whitespace
         ::= ( S | WS | Comment )*
//         ::= ( S^WS | Comment )*
          /* ws: definition */
Comment  ::= '(:' ( CommentContents | Comment )* ':)'
          /* ws: explicit */

//<?TOKENS?>

DirCommentContents
         ::= ( ( Char - '-' ) | '-' ( Char - '-' ) )*
          /* ws: explicit */
StringLiteral
         ::= "\"" ( PredefinedEntityRef | CharRef | EscapeQuot | ( !"\"" | !"&" ) )* "\""
           | "'" ( PredefinedEntityRef | CharRef | EscapeApos | ( !"'" | !'&' )  )* "'"
          /* ws: explicit */
PredefinedEntityRef
         ::= '&' [A-Za-z]+ ';'
          /* ws: explicit */
EscapeQuot
         ::= "\"\""
EscapeApos
         ::= "''"
NameChar ::= Letter
           | Digit
           | '.'
           | '-'
           | '_'
           | ':'
           | CombiningChar
           | Extender
CharRef  ::= '&#' Digits ';'
           | '&#x' (Digits | Hex)+ ';'

/*
Digit    ::= [#x0030-#x0039]
           | [#x0660-#x0669]
           | [#x06F0-#x06F9]
           | [#x0966-#x096F]
           | [#x09E6-#x09EF]
           | [#x0A66-#x0A6F]
           | [#x0AE6-#x0AEF]
           | [#x0B66-#x0B6F]
           | [#x0BE7-#x0BEF]
           | [#x0C66-#x0C6F]
           | [#x0CE6-#x0CEF]
           | [#x0D66-#x0D6F]
           | [#x0E50-#x0E59]
           | [#x0ED0-#x0ED9]
           | [#x0F20-#x0F29]
*/
Extender ::= #x00B7
           | #x02D0
           | #x02D1
           | #x0387
           | #x0640
           | #x0E46
           | #x0EC6
           | #x3005
           | [#x3031-#x3035]
           | [#x309D-#x309E]
           | [#x30FC-#x30FE]
NCName   ::= NCNameStartChar NCNameChar*
NCNameChar
         ::= NameChar - ':'
NCNameStartChar
         ::= Letter
           | '_'
QName    ::= PrefixedName
           | UnprefixedName
PrefixedName
         ::= Prefix ':' LocalPart
UnprefixedName
         ::= LocalPart
Prefix   ::= NCName
LocalPart
         ::= NCName
PITarget ::= NCName
PragmaContents
         ::= ( !'#' | '#'+ !'#' )* '#'* & '#'
DirPIContents
         ::= ( !'?' | '?'+ ( !'?' | !'>' ) )* '?'* & '?'
CDataSection
         ::= '<![CDATA[' ( !']' | ']' !']' | ']' ']'+ !']' )* ']'+ ']>'
Wildcard ::= NCName ':' '*'
           | '*' ( ':' NCName )?
EOF      ::= 0x0000
NonNCNameChar ::= '$' | ( Char - NCNameChar )
NonNCNameChar
          \\ IntegerLiteral DecimalLiteral DoubleLiteral QName^Token NCName^Token 'ancestor' 'ancestor-or-self' 'and' 'as' 'ascending' 'at' 'attribute' 'namespace' 'base-uri' 'binary' 'boundary-space' 'by' 'case' 'cast' 'castable' 'catch' 'child' 'collation' 'comment' 'construction' 'copy-namespaces' 'declare' 'default' 'descendant' 'descendant-or-self' 'descending' 'div' 'document' 'document-node' 'element' 'else' 'empty' 'empty-sequence' 'encoding' 'eq' 'every' 'except' 'external' 'following' 'following-sibling' 'for' 'function' 'private' 'ge' 'greatest' 'gt' 'full' 'idiv' 'if' 'import' 'in' 'inherit' 'instance' 'intersect' 'is' 'item' 'lax' 'le' 'least' 'let' 'lt' 'mod' 'module' 'namespace' 'ne' 'node' 'no-inherit' 'no-preserve' 'of' 'option' 'or' 'order' 'ordered' 'ordering' 'parent' 'preceding' 'preceding-sibling' 'preserve' 'processing-instruction' 'property' 'return' 'satisfies' 'schema' 'stylesheet' 'schema-attribute' 'schema-element' 'self' 'some' 'stable' 'strict' 'strip' 'text' 'then' 'to' 'treat' 'try' 'typeswitch' 'union' 'unordered' 'validate' 'variable' 'version' 'where' 'xquery'
'+'       << '+'^OccurrenceIndicator
'*'       << '*'^OccurrenceIndicator Wildcard
QName^Token
          << 'ancestor' 'ancestor-or-self' 'and' 'ascending' 'attribute' 'binary' 'catch' 'try' 'namespace' 'case' 'cast' 'castable' 'child' 'collation' 'comment' 'declare' 'default' 'descendant' 'descendant-or-self' 'descending' 'div' 'document' 'document-node' 'element' 'else' 'empty' 'empty-sequence' 'eq' 'every' 'except' 'following' 'following-sibling' 'for' 'ge' 'gt' 'idiv' 'if' 'import' 'instance' 'intersect' 'is' 'item' 'le' 'let' 'lt' 'mod' 'module' 'ne' 'node' 'or' 'order' 'ordered' 'parent' 'preceding' 'preceding-sibling' 'processing-instruction' 'property' 'return' 'satisfies' 'schema-attribute' 'schema-element' 'self' 'some' 'stable' 'text' 'to' 'treat' 'typeswitch' 'union' 'unordered' 'validate' 'where' 'xquery'
NCName^Token
          << 'and' 'ascending' 'case' 'cast' 'castable' 'collation' 'default' 'descending' 'div' 'else' 'empty' 'eq' 'except' 'for' 'ge' 'gt' 'idiv' 'instance' 'intersect' 'is' 'le' 'let' 'lt' 'mod' 'ne' 'or' 'order' 'return' 'satisfies' 'stable' 'to' 'treat' 'union' 'where'