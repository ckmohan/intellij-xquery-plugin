Grammar-Kit plugin

** THIS IS A WORK IN PROGRESS **

1.0
Adds support for a custom variant of BNF grammar files such as:
- Highlighting
- Completion
- Navigation
- Refactorings: inline rule, introduce rule
- Intentions: flip choice branches

including:
- PsiBuilder-based PEG parser and PSI hierarchy generation


General usage instructions
1. Create grammar *.bnf file, see Grammar.bnf in the plugin code.
2. Generate parser/ElementTypes/PSI classes (Ctrl-Shift-G)
3. Add lexer, parser definition & plugin.xml
4. Mix-in resolve and other non-trivial functionality to PSI
5. Tune the grammar, regenerate code. Repeat if needed.
You've just build a custom language plugin (Approx. 1 day)


Quick documentation:

See http://en.wikipedia.org/wiki/Parsing_expression_grammar for basic syntax.
Use ::= for ? symbol.
You can also use [ .. ] for optional sequences and { | | } for choices as these
variants are popular in real-world grammars.
Note that Grammar-Kit source code is the main example of Grammar-Kit application.
The grammar for BNF parser and PSI generation can be found here:
https://github.com/JetBrains/Grammar-Kit/blob/master/grammars/Grammar.bnf

Basic syntax is extended with global and rule attributes that control code generation.
Attributes are specified by the list of name=value pairs enclosed in { .. }.
Rule attributes are placed right after its definition, they override global ones.
Global attributes can specify a rule name pattern to apply to: name("pattern")=value.
This way you can keep grammar clean.
Rule modifiers:
1. private: PSI node will not be generated for this rule. Rules are public by default.
2. external: not generated. Used for generated and handwritten code integration.
3. left: left-associativity support. PSI node for this rule will enclose the one to the left.
4. inner: left-injection. PSI node for this rule will be injected into the one to the left.
5. meta: meta grammar support. Meta rules work in conjunction with external expressions.
You can combine modifiers. "inner" should only be used together with "left".
Note that "private left" = "private left inner".

Meta rules & external expressions:
External expression << ... >> is simply an inline variant of external rule.
They can also be used to include meta rule with arguments.
For example:
  meta comma_separated_list ::= <<param>> ( ',' <<param>> ) *
  option_list ::= <<comma_separated_list (OPTION1 | OPTION2 | OPTION3)>>
External rule expression syntax is the same as a body of external expression:
  external manually_parsed_rule ::= methodName param1 param2 ...
Rule references in parameter list are implemented as GeneratedParserUtilBase.Parser instances.

Tokens:
Tokens should appear in grammar file as is. All conflicts can be resolved by quotation.
If there is an attribute with the same value as single-quoted or double-quoted token
then the corresponding IElementType constant will be generated and matched against
otherwise the token will be matched by text.
Text-matched tokens can span more than one real token returned by lexer.
External expressions and external rules interpret double- and single-quoted strings differently.
Generally anything that appears in an external expression after rule or method name is treated
as parameter and passed "as is" except single-quoted strings. They are unquoted first.
This helps passing qualified enum constants, java expressions, etc.

Error recovery:
1. "pin" attribute (value: number or pattern string) makes partially matched rule match
if the specified prefix is matched. This attribute tunes the parser to handle incomplete rules.
2. "recoverUntil" attribute (value: predicate rule) matches any number of tokens after the rule
matching completes with any result. This attribute helps parser recover when unmatched token
sequence is encountered.

Generated parser structure:
For each rule and every its sub-expression in a grammar a static method is generated.
Sub-expression methods are named rule_name_K_L_.. where the (K, L, .. ) list describes the position
of this sub-expression in an enclosing rule. Avoid naming your rules this way.
Generator can split parser code into several classes for better support of large grammars.
For simple cases parser will consists of several generated classes and GeneratedParserUtilBase
class which is generated (copied from Grammar-Kit actually) the first time generator is run.
This class contains error recovery and reporting code as well as completion functionality for
parser-based completion provider. It also contains basic token matching code.
Each external rule must be implemented the same way as generated i.e. by static method.
Global "stubParser" attribute should specify a GeneratedParserUtilBase subclass which contains
all such implementations. They will be imported by "import static .*" directive by all generated parsers.

Lexer:
Currently JFlex-based or any other lexer must be provided separately, you can use _BnfLexer.flex as a base.
IElementType constants generated by parser generator have to be recognized and returned by the lexer.
